DC-Build-Header: theano 0.9.0+dfsg-2 / 2018-05-02 12:32:03 +0000
DC-Task: type:rebuild-binarch-only source:theano version:0.9.0+dfsg-2 chroot:unstable esttime:19227 logfile:/tmp/theano_0.9.0+dfsg-2_unstable_clang60.log modes:clang60:binarch-only
DC-Sbuild-call: su user42 -c 'sbuild -n --arch-any --apt-update -d unstable -v  --chroot-setup-commands=/tmp/clang60 theano_0.9.0+dfsg-2'
sbuild (Debian sbuild) 0.73.0 (23 Dec 2016) on ip-172-31-10-206.eu-central-1.compute.internal

+==============================================================================+
| theano 0.9.0+dfsg-2 (amd64)                  Wed, 02 May 2018 12:32:03 +0000 |
+==============================================================================+

Package: theano
Version: 0.9.0+dfsg-2
Source Version: 0.9.0+dfsg-2
Distribution: unstable
Machine Architecture: amd64
Host Architecture: amd64
Build Architecture: amd64
Build Type: any

I: NOTICE: Log filtering will replace 'var/run/schroot/mount/unstable-amd64-sbuild-3cab53e2-0e2e-4e57-b08b-da1fdd6297d6' with '<<CHROOT>>'

+------------------------------------------------------------------------------+
| Chroot Setup Commands                                                        |
+------------------------------------------------------------------------------+


/tmp/clang60
------------

+ echo 'Entering customization script...'
Entering customization script...
+ CLANG_VERSION=6.0
+ echo 'Install of clang-6.0'
Install of clang-6.0
+ apt-get update
Get:1 http://127.0.0.1:9999/debian unstable InRelease [242 kB]
Get:2 http://127.0.0.1:9999/debian unstable/main Sources.diff/Index [27.9 kB]
Get:3 http://127.0.0.1:9999/debian unstable/main amd64 Packages.diff/Index [27.9 kB]
Get:4 http://127.0.0.1:9999/debian unstable/main Sources 2018-05-02-0830.09.pdiff [16.2 kB]
Get:4 http://127.0.0.1:9999/debian unstable/main Sources 2018-05-02-0830.09.pdiff [16.2 kB]
Get:5 http://127.0.0.1:9999/debian unstable/main amd64 Packages 2018-05-02-0830.09.pdiff [1781 B]
Get:5 http://127.0.0.1:9999/debian unstable/main amd64 Packages 2018-05-02-0830.09.pdiff [1781 B]
Get:6 http://127.0.0.1:9999/debian unstable/main Translation-en [6016 kB]
Fetched 6332 kB in 2s (3598 kB/s)
Reading package lists...
+ apt-get install --yes --no-install-recommends --force-yes clang-6.0
Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  lib32gcc1 lib32stdc++6 libbsd0 libc6-i386 libclang-common-6.0-dev
  libclang1-6.0 libedit2 libjsoncpp1 libllvm6.0 libncurses5 libobjc-7-dev
  libobjc4
Suggested packages:
  gnustep gnustep-devel clang-6.0-doc
Recommended packages:
  llvm-6.0-dev python libomp-dev libgpm2
The following NEW packages will be installed:
  clang-6.0 lib32gcc1 lib32stdc++6 libbsd0 libc6-i386 libclang-common-6.0-dev
  libclang1-6.0 libedit2 libjsoncpp1 libllvm6.0 libncurses5 libobjc-7-dev
  libobjc4
0 upgraded, 13 newly installed, 0 to remove and 0 not upgraded.
Need to get 37.7 MB of archives.
After this operation, 187 MB of additional disk space will be used.
Get:1 http://127.0.0.1:9999/debian unstable/main amd64 libjsoncpp1 amd64 1.7.4-3 [75.6 kB]
Get:2 http://127.0.0.1:9999/debian unstable/main amd64 libbsd0 amd64 0.8.7-1 [92.1 kB]
Get:3 http://127.0.0.1:9999/debian unstable/main amd64 libncurses5 amd64 6.1+20180210-2 [95.7 kB]
Get:4 http://127.0.0.1:9999/debian unstable/main amd64 libedit2 amd64 3.1-20170329-1 [85.2 kB]
Get:5 http://127.0.0.1:9999/debian unstable/main amd64 libllvm6.0 amd64 1:6.0-3 [14.5 MB]
Get:6 http://127.0.0.1:9999/debian unstable/main amd64 libobjc4 amd64 8-20180425-1 [52.4 kB]
Get:7 http://127.0.0.1:9999/debian unstable/main amd64 libobjc-7-dev amd64 7.3.0-17 [204 kB]
Get:8 http://127.0.0.1:9999/debian unstable/main amd64 libc6-i386 amd64 2.27-3 [2855 kB]
Get:9 http://127.0.0.1:9999/debian unstable/main amd64 lib32gcc1 amd64 1:8-20180425-1 [47.8 kB]
Get:10 http://127.0.0.1:9999/debian unstable/main amd64 lib32stdc++6 amd64 8-20180425-1 [406 kB]
Get:11 http://127.0.0.1:9999/debian unstable/main amd64 libclang-common-6.0-dev amd64 1:6.0-3 [3102 kB]
Get:12 http://127.0.0.1:9999/debian unstable/main amd64 libclang1-6.0 amd64 1:6.0-3 [6995 kB]
Get:13 http://127.0.0.1:9999/debian unstable/main amd64 clang-6.0 amd64 1:6.0-3 [9175 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 37.7 MB in 0s (98.2 MB/s)
Selecting previously unselected package libjsoncpp1:amd64.
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 10022 files and directories currently installed.)
Preparing to unpack .../00-libjsoncpp1_1.7.4-3_amd64.deb ...
Unpacking libjsoncpp1:amd64 (1.7.4-3) ...
Selecting previously unselected package libbsd0:amd64.
Preparing to unpack .../01-libbsd0_0.8.7-1_amd64.deb ...
Unpacking libbsd0:amd64 (0.8.7-1) ...
Selecting previously unselected package libncurses5:amd64.
Preparing to unpack .../02-libncurses5_6.1+20180210-2_amd64.deb ...
Unpacking libncurses5:amd64 (6.1+20180210-2) ...
Selecting previously unselected package libedit2:amd64.
Preparing to unpack .../03-libedit2_3.1-20170329-1_amd64.deb ...
Unpacking libedit2:amd64 (3.1-20170329-1) ...
Selecting previously unselected package libllvm6.0:amd64.
Preparing to unpack .../04-libllvm6.0_1%3a6.0-3_amd64.deb ...
Unpacking libllvm6.0:amd64 (1:6.0-3) ...
Selecting previously unselected package libobjc4:amd64.
Preparing to unpack .../05-libobjc4_8-20180425-1_amd64.deb ...
Unpacking libobjc4:amd64 (8-20180425-1) ...
Selecting previously unselected package libobjc-7-dev:amd64.
Preparing to unpack .../06-libobjc-7-dev_7.3.0-17_amd64.deb ...
Unpacking libobjc-7-dev:amd64 (7.3.0-17) ...
Selecting previously unselected package libc6-i386.
Preparing to unpack .../07-libc6-i386_2.27-3_amd64.deb ...
Unpacking libc6-i386 (2.27-3) ...
Selecting previously unselected package lib32gcc1.
Preparing to unpack .../08-lib32gcc1_1%3a8-20180425-1_amd64.deb ...
Unpacking lib32gcc1 (1:8-20180425-1) ...
Selecting previously unselected package lib32stdc++6.
Preparing to unpack .../09-lib32stdc++6_8-20180425-1_amd64.deb ...
Unpacking lib32stdc++6 (8-20180425-1) ...
Selecting previously unselected package libclang-common-6.0-dev.
Preparing to unpack .../10-libclang-common-6.0-dev_1%3a6.0-3_amd64.deb ...
Unpacking libclang-common-6.0-dev (1:6.0-3) ...
Selecting previously unselected package libclang1-6.0:amd64.
Preparing to unpack .../11-libclang1-6.0_1%3a6.0-3_amd64.deb ...
Unpacking libclang1-6.0:amd64 (1:6.0-3) ...
Selecting previously unselected package clang-6.0.
Preparing to unpack .../12-clang-6.0_1%3a6.0-3_amd64.deb ...
Unpacking clang-6.0 (1:6.0-3) ...
Setting up libncurses5:amd64 (6.1+20180210-2) ...
Setting up libobjc4:amd64 (8-20180425-1) ...
Setting up libc6-i386 (2.27-3) ...
Setting up libbsd0:amd64 (0.8.7-1) ...
Setting up libobjc-7-dev:amd64 (7.3.0-17) ...
Processing triggers for libc-bin (2.27-3) ...
Setting up lib32gcc1 (1:8-20180425-1) ...
Setting up libjsoncpp1:amd64 (1.7.4-3) ...
Setting up libedit2:amd64 (3.1-20170329-1) ...
Setting up libllvm6.0:amd64 (1:6.0-3) ...
Setting up libclang1-6.0:amd64 (1:6.0-3) ...
Setting up lib32stdc++6 (8-20180425-1) ...
Setting up libclang-common-6.0-dev (1:6.0-3) ...
Setting up clang-6.0 (1:6.0-3) ...
Processing triggers for libc-bin (2.27-3) ...
W: --force-yes is deprecated, use one of the options starting with --allow instead.
+ echo 'Replace gcc, g++ & cpp by clang'
Replace gcc, g++ & cpp by clang
+ VERSIONS='4.6 4.7 4.8 4.9 5 6 7 8'
+ cd /usr/bin
+ for VERSION in $VERSIONS
+ rm -f g++-4.6 gcc-4.6 cpp-4.6 gcc
+ ln -s clang++-6.0 g++-4.6
+ ln -s clang-6.0 gcc-4.6
+ ln -s clang-6.0 cpp-4.6
+ ln -s clang-6.0 gcc
+ echo 'gcc-4.6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.7 gcc-4.7 cpp-4.7 gcc
+ ln -s clang++-6.0 g++-4.7
+ ln -s clang-6.0 gcc-4.7
+ ln -s clang-6.0 cpp-4.7
+ ln -s clang-6.0 gcc
+ echo 'gcc-4.7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.8 gcc-4.8 cpp-4.8 gcc
+ ln -s clang++-6.0 g++-4.8
+ ln -s clang-6.0 gcc-4.8
+ ln -s clang-6.0 cpp-4.8
+ ln -s clang-6.0 gcc
+ echo 'gcc-4.8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.9 gcc-4.9 cpp-4.9 gcc
+ ln -s clang++-6.0 g++-4.9
+ ln -s clang-6.0 gcc-4.9
+ ln -s clang-6.0 cpp-4.9
+ ln -s clang-6.0 gcc
+ echo 'gcc-4.9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-5 gcc-5 cpp-5 gcc
+ ln -s clang++-6.0 g++-5
+ ln -s clang-6.0 gcc-5
+ ln -s clang-6.0 cpp-5
+ ln -s clang-6.0 gcc
+ echo 'gcc-5 hold'
+ dpkg --set-selections
+ echo 'g++-5 hold'
+ dpkg --set-selections
+ for VERSION in $VERSIONS
+ rm -f g++-6 gcc-6 cpp-6 gcc
+ ln -s clang++-6.0 g++-6
+ ln -s clang-6.0 gcc-6
+ ln -s clang-6.0 cpp-6
+ ln -s clang-6.0 gcc
+ echo 'gcc-6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-7 gcc-7 cpp-7 gcc
+ ln -s clang++-6.0 g++-7
+ ln -s clang-6.0 gcc-7
+ ln -s clang-6.0 cpp-7
+ ln -s clang-6.0 gcc
+ echo 'gcc-7 hold'
+ dpkg --set-selections
+ echo 'g++-7 hold'
+ dpkg --set-selections
+ for VERSION in $VERSIONS
+ rm -f g++-8 gcc-8 cpp-8 gcc
+ ln -s clang++-6.0 g++-8
+ ln -s clang-6.0 gcc-8
+ ln -s clang-6.0 cpp-8
+ ln -s clang-6.0 gcc
+ echo 'gcc-8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ cd -
/build/theano-TWeCMb
+ echo 'Check if gcc, g++ & cpp are actually clang'
Check if gcc, g++ & cpp are actually clang
+ gcc --version
+ grep clang
+ cpp --version
+ grep clang
+ g++ --version
+ grep clang

I: Finished running '/tmp/clang60'.

Finished processing commands.
--------------------------------------------------------------------------------

+------------------------------------------------------------------------------+
| Update chroot                                                                |
+------------------------------------------------------------------------------+

Hit:1 http://127.0.0.1:9999/debian unstable InRelease
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
Calculating upgrade...
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.

+------------------------------------------------------------------------------+
| Fetch source files                                                           |
+------------------------------------------------------------------------------+


Check APT
---------

Checking available source versions...

Download source files with APT
------------------------------

Reading package lists...
NOTICE: 'theano' packaging is maintained in the 'Git' version control system at:
https://anonscm.debian.org/git/debian-science/packages/theano.git
Please use:
git clone https://anonscm.debian.org/git/debian-science/packages/theano.git
to retrieve the latest (possibly unreleased) updates to the package.
Need to get 13.4 MB of source archives.
Get:1 http://127.0.0.1:9999/debian unstable/main theano 0.9.0+dfsg-2 (dsc) [2879 B]
Get:2 http://127.0.0.1:9999/debian unstable/main theano 0.9.0+dfsg-2 (tar) [13.3 MB]
Get:3 http://127.0.0.1:9999/debian unstable/main theano 0.9.0+dfsg-2 (diff) [93.2 kB]
Fetched 13.4 MB in 0s (42.7 MB/s)
Download complete and in download only mode
I: NOTICE: Log filtering will replace 'build/theano-TWeCMb/theano-0.9.0+dfsg' with '<<PKGBUILDDIR>>'
I: NOTICE: Log filtering will replace 'build/theano-TWeCMb' with '<<BUILDDIR>>'

+------------------------------------------------------------------------------+
| Install build-essential                                                      |
+------------------------------------------------------------------------------+


Setup apt archive
-----------------

Merged Build-Depends: build-essential, fakeroot
Filtered Build-Depends: build-essential, fakeroot
dpkg-deb: building package 'sbuild-build-depends-core-dummy' in '/<<BUILDDIR>>/resolver-lglNiI/apt_archive/sbuild-build-depends-core-dummy.deb'.
dpkg-scanpackages: warning: Packages in archive but missing from override file:
dpkg-scanpackages: warning:   sbuild-build-depends-core-dummy
dpkg-scanpackages: info: Wrote 1 entries to output Packages file.
Ign:1 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ InRelease
Get:2 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ Release [957 B]
Ign:3 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ Release.gpg
Get:4 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ Sources [349 B]
Get:5 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ Packages [432 B]
Fetched 1738 B in 0s (0 B/s)
Reading package lists...
Reading package lists...

Install core build dependencies (apt-based resolver)
----------------------------------------------------

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following NEW packages will be installed:
  sbuild-build-depends-core-dummy
0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.
Need to get 856 B of archives.
After this operation, 0 B of additional disk space will be used.
Get:1 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ sbuild-build-depends-core-dummy 0.invalid.0 [856 B]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 856 B in 0s (0 B/s)
Selecting previously unselected package sbuild-build-depends-core-dummy.
(Reading database ... 10771 files and directories currently installed.)
Preparing to unpack .../sbuild-build-depends-core-dummy_0.invalid.0_amd64.deb ...
Unpacking sbuild-build-depends-core-dummy (0.invalid.0) ...
Setting up sbuild-build-depends-core-dummy (0.invalid.0) ...

+------------------------------------------------------------------------------+
| Check architectures                                                          |
+------------------------------------------------------------------------------+

Arch check ok (amd64 included in amd64 arm64 i386 ppc64el s390x hurd-i386 kfreebsd-amd64 kfreebsd-i386 ppc64 sh4 sparc64 x32 all)

+------------------------------------------------------------------------------+
| Install package build dependencies                                           |
+------------------------------------------------------------------------------+


Setup apt archive
-----------------

Merged Build-Depends: debhelper (>= 10), dh-python, python-dev, python3-dev, python-setuptools, python3-setuptools, python-six, python3-six, libblas-dev, python-numpy, python3-numpy, python-scipy, python3-scipy, python-nose, python3-nose, python-nose-parameterized, python3-nose-parameterized, python3-sphinx, python3-sphinx-rtd-theme, python3-pygments, dvipng, texlive-latex-extra, rdfind, symlinks, node-browserify-lite, node-uglify, node-pegjs, node-lodash-compat, libjs-d3
Filtered Build-Depends: debhelper (>= 10), dh-python, python-dev, python3-dev, python-setuptools, python3-setuptools, python-six, python3-six, libblas-dev, python-numpy, python3-numpy, python-scipy, python3-scipy, python-nose, python3-nose, python-nose-parameterized, python3-nose-parameterized, python3-sphinx, python3-sphinx-rtd-theme, python3-pygments, dvipng, texlive-latex-extra, rdfind, symlinks, node-browserify-lite, node-uglify, node-pegjs, node-lodash-compat, libjs-d3
dpkg-deb: building package 'sbuild-build-depends-theano-dummy' in '/<<BUILDDIR>>/resolver-lglNiI/apt_archive/sbuild-build-depends-theano-dummy.deb'.
dpkg-scanpackages: warning: Packages in archive but missing from override file:
dpkg-scanpackages: warning:   sbuild-build-depends-core-dummy sbuild-build-depends-theano-dummy
dpkg-scanpackages: info: Wrote 2 entries to output Packages file.
Ign:1 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ InRelease
Get:2 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ Release [963 B]
Ign:3 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ Release.gpg
Get:4 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ Sources [663 B]
Get:5 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ Packages [750 B]
Fetched 2376 B in 0s (0 B/s)
Reading package lists...
Reading package lists...

Install theano build dependencies (apt-based resolver)
------------------------------------------------------

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  autoconf automake autopoint autotools-dev bsdmainutils ca-certificates
  debhelper dh-autoreconf dh-python dh-strip-nondeterminism docutils-common
  dvipng file fontconfig-config fonts-dejavu-core fonts-font-awesome
  fonts-lato fonts-lmodern gettext gettext-base ghostscript groff-base
  intltool-debian libarchive-zip-perl libavahi-client3 libavahi-common-data
  libavahi-common3 libblas-dev libblas3 libc-ares2 libcairo2 libcroco3
  libcups2 libcupsimage2 libdbus-1-3 libexpat1 libexpat1-dev
  libfile-stripnondeterminism-perl libfontconfig1 libfreetype6 libgd3
  libgfortran4 libglib2.0-0 libgraphite2-3 libgs9 libgs9-common
  libgssapi-krb5-2 libharfbuzz-icu0 libharfbuzz0b libhttp-parser2.8 libice6
  libicu57 libidn11 libijs-0.35 libjbig0 libjbig2dec0 libjpeg62-turbo libjs-d3
  libjs-jquery libjs-modernizr libjs-sphinxdoc libjs-underscore libk5crypto3
  libkeyutils1 libkpathsea6 libkrb5-3 libkrb5support0 liblapack3 liblcms2-2
  libmagic-mgc libmagic1 libmpdec2 libncursesw6 libnghttp2-14 libopenjp2-7
  libpaper-utils libpaper1 libpipeline1 libpixman-1-0 libpng16-16 libpotrace0
  libptexenc1 libpython-dev libpython-stdlib libpython2.7 libpython2.7-dev
  libpython2.7-minimal libpython2.7-stdlib libpython3-dev libpython3-stdlib
  libpython3.6 libpython3.6-dev libpython3.6-minimal libpython3.6-stdlib
  libreadline7 libsigsegv2 libsm6 libsqlite3-0 libssl1.1 libsynctex2
  libtexlua52 libtexlua53 libtexluajit2 libtiff5 libtimedate-perl libtool
  libuv1 libwebp6 libx11-6 libx11-data libxau6 libxaw7 libxcb-render0
  libxcb-shm0 libxcb1 libxdmcp6 libxext6 libxi6 libxml2 libxmu6 libxpm4
  libxrender1 libxt6 libzzip-0-13 lsb-base m4 man-db mime-support
  node-ansi-regex node-ansi-styles node-browserify-lite node-camelcase
  node-cliui node-clone node-color-convert node-color-name node-cross-spawn
  node-decamelize node-defaults node-execa node-find-up node-get-caller-file
  node-get-stream node-invert-kv node-is-stream node-isexe node-lcid
  node-locate-path node-lodash-compat node-lru-cache node-mem node-mimic-fn
  node-npm-run-path node-os-locale node-p-finally node-p-limit node-p-locate
  node-path-exists node-pegjs node-pend node-pseudomap node-require-directory
  node-require-main-filename node-set-blocking node-shebang-command
  node-shebang-regex node-signal-exit node-string-width node-strip-ansi
  node-strip-eof node-uglify node-wcwidth.js node-which node-which-module
  node-wrap-ansi node-y18n node-yallist node-yargs node-yargs-parser nodejs
  openssl po-debconf poppler-data preview-latex-style python
  python-babel-localedata python-decorator python-dev python-minimal
  python-nose python-nose-parameterized python-numpy python-pkg-resources
  python-scipy python-setuptools python-six python2.7 python2.7-dev
  python2.7-minimal python3 python3-alabaster python3-babel python3-certifi
  python3-chardet python3-decorator python3-dev python3-distutils
  python3-docutils python3-idna python3-imagesize python3-jinja2
  python3-lib2to3 python3-markupsafe python3-minimal python3-nose
  python3-nose-parameterized python3-numpy python3-packaging
  python3-pkg-resources python3-pygments python3-pyparsing python3-requests
  python3-roman python3-scipy python3-setuptools python3-six python3-sphinx
  python3-sphinx-rtd-theme python3-tz python3-urllib3 python3.6 python3.6-dev
  python3.6-minimal rdfind readline-common sgml-base sphinx-common
  sphinx-rtd-theme-common symlinks t1utils tex-common texlive-base
  texlive-binaries texlive-latex-base texlive-latex-extra
  texlive-latex-recommended texlive-pictures tzdata ucf x11-common xdg-utils
  xml-core
Suggested packages:
  autoconf-archive gnu-standards autoconf-doc wamerican | wordlist whois
  vacation dh-make dwz gettext-doc libasprintf-dev libgettextpo-dev
  ghostscript-x groff liblapack-doc cups-common libgd-tools krb5-doc krb5-user
  liblcms2-utils libtool-doc gfortran | fortran95-compiler gcj-jdk m4-doc
  apparmor less www-browser node-acorn node-uglify-to-browserify
  libmail-box-perl poppler-utils fonts-japanese-mincho | fonts-ipafont-mincho
  fonts-japanese-gothic | fonts-ipafont-gothic fonts-arphic-ukai
  fonts-arphic-uming fonts-nanum python-doc python-tk python-coverage
  python-nose-doc python-nose-parameterized-doc gfortran python-numpy-dbg
  python-numpy-doc python-scipy-doc python-setuptools-doc python2.7-doc
  binfmt-support python3-doc python3-tk python3-venv docutils-doc
  fonts-linuxlibertine | ttf-linux-libertine texlive-lang-french
  python-jinja2-doc python3-numpy-dbg ttf-bitstream-vera python-pyparsing-doc
  python3-cryptography python3-openssl python3-socks libjs-mathjax
  texlive-fonts-recommended texlive-generic-extra latexmk imagemagick-6.q16
  sphinx-doc python3.6-venv python3.6-doc readline-doc sgml-base-doc perl-tk
  xpdf-reader | pdf-viewer texlive-latex-base-doc python-pygments icc-profiles
  libfile-which-perl libspreadsheet-parseexcel-perl texlive-latex-extra-doc
  texlive-latex-recommended-doc texlive-pstricks dot2tex prerex ruby-tcltk
  | libtcltk-ruby texlive-pictures-doc vprerex
Recommended packages:
  curl | wget | lynx gsfonts libcupsfilters1 dbus libarchive-cpio-perl
  libglib2.0-data shared-mime-info xdg-user-dirs fonts-droid-fallback
  javascript-common krb5-locales libgpm2 libltdl-dev node-source-map
  nodejs-doc libmail-sendmail-perl python-pil python3-pil lmodern
  texlive-fonts-recommended texlive-plain-generic ruby | ruby-interpreter tk
  libfile-mimeinfo-perl libnet-dbus-perl libx11-protocol-perl x11-utils
  x11-xserver-utils
The following NEW packages will be installed:
  autoconf automake autopoint autotools-dev bsdmainutils ca-certificates
  debhelper dh-autoreconf dh-python dh-strip-nondeterminism docutils-common
  dvipng file fontconfig-config fonts-dejavu-core fonts-font-awesome
  fonts-lato fonts-lmodern gettext gettext-base ghostscript groff-base
  intltool-debian libarchive-zip-perl libavahi-client3 libavahi-common-data
  libavahi-common3 libblas-dev libblas3 libc-ares2 libcairo2 libcroco3
  libcups2 libcupsimage2 libdbus-1-3 libexpat1 libexpat1-dev
  libfile-stripnondeterminism-perl libfontconfig1 libfreetype6 libgd3
  libgfortran4 libglib2.0-0 libgraphite2-3 libgs9 libgs9-common
  libgssapi-krb5-2 libharfbuzz-icu0 libharfbuzz0b libhttp-parser2.8 libice6
  libicu57 libidn11 libijs-0.35 libjbig0 libjbig2dec0 libjpeg62-turbo libjs-d3
  libjs-jquery libjs-modernizr libjs-sphinxdoc libjs-underscore libk5crypto3
  libkeyutils1 libkpathsea6 libkrb5-3 libkrb5support0 liblapack3 liblcms2-2
  libmagic-mgc libmagic1 libmpdec2 libncursesw6 libnghttp2-14 libopenjp2-7
  libpaper-utils libpaper1 libpipeline1 libpixman-1-0 libpng16-16 libpotrace0
  libptexenc1 libpython-dev libpython-stdlib libpython2.7 libpython2.7-dev
  libpython2.7-minimal libpython2.7-stdlib libpython3-dev libpython3-stdlib
  libpython3.6 libpython3.6-dev libpython3.6-minimal libpython3.6-stdlib
  libreadline7 libsigsegv2 libsm6 libsqlite3-0 libssl1.1 libsynctex2
  libtexlua52 libtexlua53 libtexluajit2 libtiff5 libtimedate-perl libtool
  libuv1 libwebp6 libx11-6 libx11-data libxau6 libxaw7 libxcb-render0
  libxcb-shm0 libxcb1 libxdmcp6 libxext6 libxi6 libxml2 libxmu6 libxpm4
  libxrender1 libxt6 libzzip-0-13 lsb-base m4 man-db mime-support
  node-ansi-regex node-ansi-styles node-browserify-lite node-camelcase
  node-cliui node-clone node-color-convert node-color-name node-cross-spawn
  node-decamelize node-defaults node-execa node-find-up node-get-caller-file
  node-get-stream node-invert-kv node-is-stream node-isexe node-lcid
  node-locate-path node-lodash-compat node-lru-cache node-mem node-mimic-fn
  node-npm-run-path node-os-locale node-p-finally node-p-limit node-p-locate
  node-path-exists node-pegjs node-pend node-pseudomap node-require-directory
  node-require-main-filename node-set-blocking node-shebang-command
  node-shebang-regex node-signal-exit node-string-width node-strip-ansi
  node-strip-eof node-uglify node-wcwidth.js node-which node-which-module
  node-wrap-ansi node-y18n node-yallist node-yargs node-yargs-parser nodejs
  openssl po-debconf poppler-data preview-latex-style python
  python-babel-localedata python-decorator python-dev python-minimal
  python-nose python-nose-parameterized python-numpy python-pkg-resources
  python-scipy python-setuptools python-six python2.7 python2.7-dev
  python2.7-minimal python3 python3-alabaster python3-babel python3-certifi
  python3-chardet python3-decorator python3-dev python3-distutils
  python3-docutils python3-idna python3-imagesize python3-jinja2
  python3-lib2to3 python3-markupsafe python3-minimal python3-nose
  python3-nose-parameterized python3-numpy python3-packaging
  python3-pkg-resources python3-pygments python3-pyparsing python3-requests
  python3-roman python3-scipy python3-setuptools python3-six python3-sphinx
  python3-sphinx-rtd-theme python3-tz python3-urllib3 python3.6 python3.6-dev
  python3.6-minimal rdfind readline-common sbuild-build-depends-theano-dummy
  sgml-base sphinx-common sphinx-rtd-theme-common symlinks t1utils tex-common
  texlive-base texlive-binaries texlive-latex-base texlive-latex-extra
  texlive-latex-recommended texlive-pictures tzdata ucf x11-common xdg-utils
  xml-core
0 upgraded, 253 newly installed, 0 to remove and 0 not upgraded.
Need to get 234 MB of archives.
After this operation, 716 MB of additional disk space will be used.
Get:1 copy:/<<BUILDDIR>>/resolver-lglNiI/apt_archive ./ sbuild-build-depends-theano-dummy 0.invalid.0 [1032 B]
Get:2 http://127.0.0.1:9999/debian unstable/main amd64 bsdmainutils amd64 11.1.2 [190 kB]
Get:3 http://127.0.0.1:9999/debian unstable/main amd64 groff-base amd64 1.22.3-10 [1176 kB]
Get:4 http://127.0.0.1:9999/debian unstable/main amd64 libpipeline1 amd64 1.5.0-1 [29.0 kB]
Get:5 http://127.0.0.1:9999/debian unstable/main amd64 man-db amd64 2.8.3-2 [1180 kB]
Get:6 http://127.0.0.1:9999/debian unstable/main amd64 libpython2.7-minimal amd64 2.7.15-1 [393 kB]
Get:7 http://127.0.0.1:9999/debian unstable/main amd64 python2.7-minimal amd64 2.7.15-1 [1353 kB]
Get:8 http://127.0.0.1:9999/debian unstable/main amd64 python-minimal amd64 2.7.15~rc1-1 [41.1 kB]
Get:9 http://127.0.0.1:9999/debian unstable/main amd64 mime-support all 3.60 [36.7 kB]
Get:10 http://127.0.0.1:9999/debian unstable/main amd64 libexpat1 amd64 2.2.5-3 [96.8 kB]
Get:11 http://127.0.0.1:9999/debian unstable/main amd64 libncursesw6 amd64 6.1+20180210-2 [131 kB]
Get:12 http://127.0.0.1:9999/debian unstable/main amd64 readline-common all 7.0-3 [70.4 kB]
Get:13 http://127.0.0.1:9999/debian unstable/main amd64 libreadline7 amd64 7.0-3+b1 [151 kB]
Get:14 http://127.0.0.1:9999/debian unstable/main amd64 libsqlite3-0 amd64 3.23.1-1 [603 kB]
Get:15 http://127.0.0.1:9999/debian unstable/main amd64 libssl1.1 amd64 1.1.0h-2 [1352 kB]
Get:16 http://127.0.0.1:9999/debian unstable/main amd64 libpython2.7-stdlib amd64 2.7.15-1 [1912 kB]
Get:17 http://127.0.0.1:9999/debian unstable/main amd64 python2.7 amd64 2.7.15-1 [298 kB]
Get:18 http://127.0.0.1:9999/debian unstable/main amd64 libpython-stdlib amd64 2.7.15~rc1-1 [20.5 kB]
Get:19 http://127.0.0.1:9999/debian unstable/main amd64 python amd64 2.7.15~rc1-1 [155 kB]
Get:20 http://127.0.0.1:9999/debian unstable/main amd64 fonts-lato all 2.0-2 [2698 kB]
Get:21 http://127.0.0.1:9999/debian unstable/main amd64 poppler-data all 0.4.9-2 [1473 kB]
Get:22 http://127.0.0.1:9999/debian unstable/main amd64 libpython3.6-minimal amd64 3.6.5-5 [572 kB]
Get:23 http://127.0.0.1:9999/debian unstable/main amd64 python3.6-minimal amd64 3.6.5-5 [1728 kB]
Get:24 http://127.0.0.1:9999/debian unstable/main amd64 python3-minimal amd64 3.6.5-3 [36.2 kB]
Get:25 http://127.0.0.1:9999/debian unstable/main amd64 libmpdec2 amd64 2.4.2-2 [87.2 kB]
Get:26 http://127.0.0.1:9999/debian unstable/main amd64 libpython3.6-stdlib amd64 3.6.5-5 [1730 kB]
Get:27 http://127.0.0.1:9999/debian unstable/main amd64 python3.6 amd64 3.6.5-5 [229 kB]
Get:28 http://127.0.0.1:9999/debian unstable/main amd64 libpython3-stdlib amd64 3.6.5-3 [19.7 kB]
Get:29 http://127.0.0.1:9999/debian unstable/main amd64 python3 amd64 3.6.5-3 [24.1 kB]
Get:30 http://127.0.0.1:9999/debian unstable/main amd64 sgml-base all 1.29 [14.8 kB]
Get:31 http://127.0.0.1:9999/debian unstable/main amd64 ucf all 3.0038 [67.8 kB]
Get:32 http://127.0.0.1:9999/debian unstable/main amd64 tex-common all 6.09 [53.2 kB]
Get:33 http://127.0.0.1:9999/debian unstable/main amd64 tzdata all 2018d-1 [252 kB]
Get:34 http://127.0.0.1:9999/debian unstable/main amd64 libmagic-mgc amd64 1:5.33-2 [234 kB]
Get:35 http://127.0.0.1:9999/debian unstable/main amd64 libmagic1 amd64 1:5.33-2 [113 kB]
Get:36 http://127.0.0.1:9999/debian unstable/main amd64 file amd64 1:5.33-2 [65.6 kB]
Get:37 http://127.0.0.1:9999/debian unstable/main amd64 gettext-base amd64 0.19.8.1-6 [122 kB]
Get:38 http://127.0.0.1:9999/debian unstable/main amd64 libsigsegv2 amd64 2.12-2 [32.8 kB]
Get:39 http://127.0.0.1:9999/debian unstable/main amd64 m4 amd64 1.4.18-1 [202 kB]
Get:40 http://127.0.0.1:9999/debian unstable/main amd64 autoconf all 2.69-11 [341 kB]
Get:41 http://127.0.0.1:9999/debian unstable/main amd64 autotools-dev all 20180224.1 [77.0 kB]
Get:42 http://127.0.0.1:9999/debian unstable/main amd64 automake all 1:1.15.1-3.1 [736 kB]
Get:43 http://127.0.0.1:9999/debian unstable/main amd64 autopoint all 0.19.8.1-6 [434 kB]
Get:44 http://127.0.0.1:9999/debian unstable/main amd64 openssl amd64 1.1.0h-2 [744 kB]
Get:45 http://127.0.0.1:9999/debian unstable/main amd64 ca-certificates all 20180409 [161 kB]
Get:46 http://127.0.0.1:9999/debian unstable/main amd64 libtool all 2.4.6-2.1 [547 kB]
Get:47 http://127.0.0.1:9999/debian unstable/main amd64 dh-autoreconf all 17 [16.5 kB]
Get:48 http://127.0.0.1:9999/debian unstable/main amd64 libarchive-zip-perl all 1.60-1 [95.6 kB]
Get:49 http://127.0.0.1:9999/debian unstable/main amd64 libfile-stripnondeterminism-perl all 0.041-1 [19.9 kB]
Get:50 http://127.0.0.1:9999/debian unstable/main amd64 libtimedate-perl all 2.3000-2 [42.2 kB]
Get:51 http://127.0.0.1:9999/debian unstable/main amd64 dh-strip-nondeterminism all 0.041-1 [12.0 kB]
Get:52 http://127.0.0.1:9999/debian unstable/main amd64 libglib2.0-0 amd64 2.56.1-2 [2928 kB]
Get:53 http://127.0.0.1:9999/debian unstable/main amd64 libicu57 amd64 57.1-9 [7698 kB]
Get:54 http://127.0.0.1:9999/debian unstable/main amd64 libxml2 amd64 2.9.4+dfsg1-6.1 [725 kB]
Get:55 http://127.0.0.1:9999/debian unstable/main amd64 libcroco3 amd64 0.6.12-2 [144 kB]
Get:56 http://127.0.0.1:9999/debian unstable/main amd64 gettext amd64 0.19.8.1-6 [1302 kB]
Get:57 http://127.0.0.1:9999/debian unstable/main amd64 intltool-debian all 0.35.0+20060710.4 [26.3 kB]
Get:58 http://127.0.0.1:9999/debian unstable/main amd64 po-debconf all 1.0.20 [247 kB]
Get:59 http://127.0.0.1:9999/debian unstable/main amd64 debhelper all 11.2.1 [1013 kB]
Get:60 http://127.0.0.1:9999/debian unstable/main amd64 dh-python all 3.20180326 [93.2 kB]
Get:61 http://127.0.0.1:9999/debian unstable/main amd64 xml-core all 0.18 [23.4 kB]
Get:62 http://127.0.0.1:9999/debian unstable/main amd64 docutils-common all 0.14+dfsg-3 [204 kB]
Get:63 http://127.0.0.1:9999/debian unstable/main amd64 libpng16-16 amd64 1.6.34-1 [287 kB]
Get:64 http://127.0.0.1:9999/debian unstable/main amd64 libfreetype6 amd64 2.8.1-2 [461 kB]
Get:65 http://127.0.0.1:9999/debian unstable/main amd64 fonts-dejavu-core all 2.37-1 [1068 kB]
Get:66 http://127.0.0.1:9999/debian unstable/main amd64 fontconfig-config all 2.13.0-4 [280 kB]
Get:67 http://127.0.0.1:9999/debian unstable/main amd64 libfontconfig1 amd64 2.13.0-4 [343 kB]
Get:68 http://127.0.0.1:9999/debian unstable/main amd64 libjpeg62-turbo amd64 1:1.5.2-2+b1 [134 kB]
Get:69 http://127.0.0.1:9999/debian unstable/main amd64 libjbig0 amd64 2.1-3.1+b2 [31.0 kB]
Get:70 http://127.0.0.1:9999/debian unstable/main amd64 libtiff5 amd64 4.0.9-5 [246 kB]
Get:71 http://127.0.0.1:9999/debian unstable/main amd64 libwebp6 amd64 0.6.1-2 [263 kB]
Get:72 http://127.0.0.1:9999/debian unstable/main amd64 libxau6 amd64 1:1.0.8-1+b2 [19.9 kB]
Get:73 http://127.0.0.1:9999/debian unstable/main amd64 libxdmcp6 amd64 1:1.1.2-3 [26.3 kB]
Get:74 http://127.0.0.1:9999/debian unstable/main amd64 libxcb1 amd64 1.13-1 [136 kB]
Get:75 http://127.0.0.1:9999/debian unstable/main amd64 libx11-data all 2:1.6.5-1 [292 kB]
Get:76 http://127.0.0.1:9999/debian unstable/main amd64 libx11-6 amd64 2:1.6.5-1 [749 kB]
Get:77 http://127.0.0.1:9999/debian unstable/main amd64 libxpm4 amd64 1:3.5.12-1 [49.1 kB]
Get:78 http://127.0.0.1:9999/debian unstable/main amd64 libgd3 amd64 2.2.5-4 [136 kB]
Get:79 http://127.0.0.1:9999/debian unstable/main amd64 libkpathsea6 amd64 2018.20180416.47457-2 [165 kB]
Get:80 http://127.0.0.1:9999/debian unstable/main amd64 libptexenc1 amd64 2018.20180416.47457-2 [58.7 kB]
Get:81 http://127.0.0.1:9999/debian unstable/main amd64 libsynctex2 amd64 2018.20180416.47457-2 [78.5 kB]
Get:82 http://127.0.0.1:9999/debian unstable/main amd64 libtexlua52 amd64 2018.20180416.47457-2 [112 kB]
Get:83 http://127.0.0.1:9999/debian unstable/main amd64 libtexlua53 amd64 2018.20180416.47457-2 [125 kB]
Get:84 http://127.0.0.1:9999/debian unstable/main amd64 libtexluajit2 amd64 2018.20180416.47457-2 [255 kB]
Get:85 http://127.0.0.1:9999/debian unstable/main amd64 t1utils amd64 1.41-2 [62.0 kB]
Get:86 http://127.0.0.1:9999/debian unstable/main amd64 libpixman-1-0 amd64 0.34.0-2 [529 kB]
Get:87 http://127.0.0.1:9999/debian unstable/main amd64 libxcb-render0 amd64 1.13-1 [108 kB]
Get:88 http://127.0.0.1:9999/debian unstable/main amd64 libxcb-shm0 amd64 1.13-1 [98.3 kB]
Get:89 http://127.0.0.1:9999/debian unstable/main amd64 libxext6 amd64 2:1.3.3-1+b2 [52.5 kB]
Get:90 http://127.0.0.1:9999/debian unstable/main amd64 libxrender1 amd64 1:0.9.10-1 [33.0 kB]
Get:91 http://127.0.0.1:9999/debian unstable/main amd64 libcairo2 amd64 1.15.10-3 [664 kB]
Get:92 http://127.0.0.1:9999/debian unstable/main amd64 libgraphite2-3 amd64 1.3.11-2 [85.2 kB]
Get:93 http://127.0.0.1:9999/debian unstable/main amd64 libavahi-common-data amd64 0.7-4 [122 kB]
Get:94 http://127.0.0.1:9999/debian unstable/main amd64 libavahi-common3 amd64 0.7-4 [54.4 kB]
Get:95 http://127.0.0.1:9999/debian unstable/main amd64 libdbus-1-3 amd64 1.12.8-1 [209 kB]
Get:96 http://127.0.0.1:9999/debian unstable/main amd64 libavahi-client3 amd64 0.7-4 [57.8 kB]
Get:97 http://127.0.0.1:9999/debian unstable/main amd64 libkeyutils1 amd64 1.5.9-9.2 [12.9 kB]
Get:98 http://127.0.0.1:9999/debian unstable/main amd64 libkrb5support0 amd64 1.16-2 [62.8 kB]
Get:99 http://127.0.0.1:9999/debian unstable/main amd64 libk5crypto3 amd64 1.16-2 [121 kB]
Get:100 http://127.0.0.1:9999/debian unstable/main amd64 libkrb5-3 amd64 1.16-2 [316 kB]
Get:101 http://127.0.0.1:9999/debian unstable/main amd64 libgssapi-krb5-2 amd64 1.16-2 [158 kB]
Get:102 http://127.0.0.1:9999/debian unstable/main amd64 libcups2 amd64 2.2.7-3 [320 kB]
Get:103 http://127.0.0.1:9999/debian unstable/main amd64 libcupsimage2 amd64 2.2.7-3 [130 kB]
Get:104 http://127.0.0.1:9999/debian unstable/main amd64 libidn11 amd64 1.33-2.2 [116 kB]
Get:105 http://127.0.0.1:9999/debian unstable/main amd64 libijs-0.35 amd64 0.35-13 [18.5 kB]
Get:106 http://127.0.0.1:9999/debian unstable/main amd64 libjbig2dec0 amd64 0.13-6 [60.3 kB]
Get:107 http://127.0.0.1:9999/debian unstable/main amd64 liblcms2-2 amd64 2.9-1 [145 kB]
Get:108 http://127.0.0.1:9999/debian unstable/main amd64 libopenjp2-7 amd64 2.3.0-1 [163 kB]
Get:109 http://127.0.0.1:9999/debian unstable/main amd64 libpaper1 amd64 1.1.24+nmu5 [21.6 kB]
Get:110 http://127.0.0.1:9999/debian unstable/main amd64 libgs9-common all 9.22~dfsg-2.1 [5241 kB]
Get:111 http://127.0.0.1:9999/debian unstable/main amd64 libgs9 amd64 9.22~dfsg-2.1 [2155 kB]
Get:112 http://127.0.0.1:9999/debian unstable/main amd64 libharfbuzz0b amd64 1.7.6-1 [842 kB]
Get:113 http://127.0.0.1:9999/debian unstable/main amd64 libharfbuzz-icu0 amd64 1.7.6-1 [584 kB]
Get:114 http://127.0.0.1:9999/debian unstable/main amd64 lsb-base all 9.20170808 [28.1 kB]
Get:115 http://127.0.0.1:9999/debian unstable/main amd64 x11-common all 1:7.7+19 [251 kB]
Get:116 http://127.0.0.1:9999/debian unstable/main amd64 libice6 amd64 2:1.0.9-2 [58.7 kB]
Get:117 http://127.0.0.1:9999/debian unstable/main amd64 libpotrace0 amd64 1.14-2 [25.7 kB]
Get:118 http://127.0.0.1:9999/debian unstable/main amd64 libsm6 amd64 2:1.2.2-1+b3 [33.3 kB]
Get:119 http://127.0.0.1:9999/debian unstable/main amd64 libxt6 amd64 1:1.1.5-1 [188 kB]
Get:120 http://127.0.0.1:9999/debian unstable/main amd64 libxmu6 amd64 2:1.1.2-2 [60.3 kB]
Get:121 http://127.0.0.1:9999/debian unstable/main amd64 libxaw7 amd64 2:1.0.13-1+b2 [201 kB]
Get:122 http://127.0.0.1:9999/debian unstable/main amd64 libxi6 amd64 2:1.7.9-1 [82.6 kB]
Get:123 http://127.0.0.1:9999/debian unstable/main amd64 libzzip-0-13 amd64 0.13.62-3.1 [55.4 kB]
Get:124 http://127.0.0.1:9999/debian unstable/main amd64 texlive-binaries amd64 2018.20180416.47457-2 [11.6 MB]
Get:125 http://127.0.0.1:9999/debian unstable/main amd64 ghostscript amd64 9.22~dfsg-2.1 [95.8 kB]
Get:126 http://127.0.0.1:9999/debian unstable/main amd64 dvipng amd64 1.15-1 [87.1 kB]
Get:127 http://127.0.0.1:9999/debian unstable/main amd64 fonts-font-awesome all 4.7.0~dfsg-3 [514 kB]
Get:128 http://127.0.0.1:9999/debian unstable/main amd64 fonts-lmodern all 2.004.5-3 [4540 kB]
Get:129 http://127.0.0.1:9999/debian unstable/main amd64 libgfortran4 amd64 7.3.0-17 [487 kB]
Get:130 http://127.0.0.1:9999/debian unstable/main amd64 libblas3 amd64 3.8.0-1 [150 kB]
Get:131 http://127.0.0.1:9999/debian unstable/main amd64 libblas-dev amd64 3.8.0-1 [156 kB]
Get:132 http://127.0.0.1:9999/debian unstable/main amd64 libc-ares2 amd64 1.14.0-1 [85.8 kB]
Get:133 http://127.0.0.1:9999/debian unstable/main amd64 libexpat1-dev amd64 2.2.5-3 [140 kB]
Get:134 http://127.0.0.1:9999/debian unstable/main amd64 libhttp-parser2.8 amd64 2.8.1-1 [20.7 kB]
Get:135 http://127.0.0.1:9999/debian unstable/main amd64 libjs-d3 all 3.5.17-2 [132 kB]
Get:136 http://127.0.0.1:9999/debian unstable/main amd64 libjs-jquery all 3.2.1-1 [154 kB]
Get:137 http://127.0.0.1:9999/debian unstable/main amd64 libjs-modernizr all 2.6.2+ds1-1.1 [46.5 kB]
Get:138 http://127.0.0.1:9999/debian unstable/main amd64 libjs-underscore all 1.8.3~dfsg-1 [63.8 kB]
Get:139 http://127.0.0.1:9999/debian unstable/main amd64 libjs-sphinxdoc all 1.7.4-1 [89.7 kB]
Get:140 http://127.0.0.1:9999/debian unstable/main amd64 liblapack3 amd64 3.8.0-1 [2146 kB]
Get:141 http://127.0.0.1:9999/debian unstable/main amd64 libnghttp2-14 amd64 1.31.1-1 [80.7 kB]
Get:142 http://127.0.0.1:9999/debian unstable/main amd64 libpaper-utils amd64 1.1.24+nmu5 [17.6 kB]
Get:143 http://127.0.0.1:9999/debian unstable/main amd64 libpython2.7 amd64 2.7.15-1 [1052 kB]
Get:144 http://127.0.0.1:9999/debian unstable/main amd64 libpython2.7-dev amd64 2.7.15-1 [28.3 MB]
Get:145 http://127.0.0.1:9999/debian unstable/main amd64 libpython-dev amd64 2.7.15~rc1-1 [20.6 kB]
Get:146 http://127.0.0.1:9999/debian unstable/main amd64 libpython3.6 amd64 3.6.5-5 [1441 kB]
Get:147 http://127.0.0.1:9999/debian unstable/main amd64 libpython3.6-dev amd64 3.6.5-5 [39.7 MB]
Get:148 http://127.0.0.1:9999/debian unstable/main amd64 libpython3-dev amd64 3.6.5-3 [19.7 kB]
Get:149 http://127.0.0.1:9999/debian unstable/main amd64 libuv1 amd64 1.18.0-3 [98.5 kB]
Get:150 http://127.0.0.1:9999/debian unstable/main amd64 nodejs amd64 8.11.1~dfsg-2 [4785 kB]
Get:151 http://127.0.0.1:9999/debian unstable/main amd64 node-ansi-regex all 3.0.0-1 [3658 B]
Get:152 http://127.0.0.1:9999/debian unstable/main amd64 node-color-name all 1.1.3-1 [4090 B]
Get:153 http://127.0.0.1:9999/debian unstable/main amd64 node-color-convert all 1.9.0-2 [9960 B]
Get:154 http://127.0.0.1:9999/debian unstable/main amd64 node-ansi-styles all 3.2.0-1 [5368 B]
Get:155 http://127.0.0.1:9999/debian unstable/main amd64 node-pend all 1.2.0-1 [3272 B]
Get:156 http://127.0.0.1:9999/debian unstable/main amd64 node-browserify-lite all 0.5.0-1 [6414 B]
Get:157 http://127.0.0.1:9999/debian unstable/main amd64 node-camelcase all 4.1.0-1 [3532 B]
Get:158 http://127.0.0.1:9999/debian unstable/main amd64 node-strip-ansi all 4.0.0-1 [3078 B]
Get:159 http://127.0.0.1:9999/debian unstable/main amd64 node-clone all 2.1.2-1 [7880 B]
Get:160 http://127.0.0.1:9999/debian unstable/main amd64 node-defaults all 1.0.3-1 [3108 B]
Get:161 http://127.0.0.1:9999/debian unstable/main amd64 node-wcwidth.js all 1.0.0-1 [6408 B]
Get:162 http://127.0.0.1:9999/debian unstable/main amd64 node-string-width all 2.1.1-1 [3992 B]
Get:163 http://127.0.0.1:9999/debian unstable/main amd64 node-wrap-ansi all 3.0.1-1 [5368 B]
Get:164 http://127.0.0.1:9999/debian unstable/main amd64 node-cliui all 4.0.0-1 [7516 B]
Get:165 http://127.0.0.1:9999/debian unstable/main amd64 node-yallist all 2.0.0-1 [5362 B]
Get:166 http://127.0.0.1:9999/debian unstable/main amd64 node-pseudomap all 1.0.2-1 [3504 B]
Get:167 http://127.0.0.1:9999/debian unstable/main amd64 node-lru-cache all 4.1.1-1 [8188 B]
Get:168 http://127.0.0.1:9999/debian unstable/main amd64 node-isexe all 2.0.0-3 [4252 B]
Get:169 http://127.0.0.1:9999/debian unstable/main amd64 node-which all 1.3.0-1 [5660 B]
Get:170 http://127.0.0.1:9999/debian unstable/main amd64 node-shebang-regex all 2.0.0-1 [2742 B]
Get:171 http://127.0.0.1:9999/debian unstable/main amd64 node-shebang-command all 1.2.0-1 [2900 B]
Get:172 http://127.0.0.1:9999/debian unstable/main amd64 node-cross-spawn all 5.1.0-1 [8476 B]
Get:173 http://127.0.0.1:9999/debian unstable/main amd64 node-decamelize all 1.2.0-1 [3044 B]
Get:174 http://127.0.0.1:9999/debian unstable/main amd64 node-get-stream all 3.0.0-1 [4724 B]
Get:175 http://127.0.0.1:9999/debian unstable/main amd64 node-is-stream all 1.1.0-1 [2998 B]
Get:176 http://127.0.0.1:9999/debian unstable/main amd64 node-npm-run-path all 2.0.2-2 [4412 B]
Get:177 http://127.0.0.1:9999/debian unstable/main amd64 node-p-finally all 1.0.0-2 [3230 B]
Get:178 http://127.0.0.1:9999/debian unstable/main amd64 node-signal-exit all 3.0.2-1 [5648 B]
Get:179 http://127.0.0.1:9999/debian unstable/main amd64 node-strip-eof all 1.0.0-2 [3010 B]
Get:180 http://127.0.0.1:9999/debian unstable/main amd64 node-execa all 0.10.0+dfsg-1 [8936 B]
Get:181 http://127.0.0.1:9999/debian unstable/main amd64 node-p-limit all 1.1.0-1 [3382 B]
Get:182 http://127.0.0.1:9999/debian unstable/main amd64 node-p-locate all 2.0.0-1 [3986 B]
Get:183 http://127.0.0.1:9999/debian unstable/main amd64 node-path-exists all 3.0.0-1 [3154 B]
Get:184 http://127.0.0.1:9999/debian unstable/main amd64 node-locate-path all 2.0.0-1 [3816 B]
Get:185 http://127.0.0.1:9999/debian unstable/main amd64 node-find-up all 2.1.0-1 [3652 B]
Get:186 http://127.0.0.1:9999/debian unstable/main amd64 node-get-caller-file all 1.0.2-1 [2814 B]
Get:187 http://127.0.0.1:9999/debian unstable/main amd64 node-invert-kv all 1.0.0-1 [2862 B]
Get:188 http://127.0.0.1:9999/debian unstable/main amd64 node-lcid all 1.0.0-1 [4232 B]
Get:189 http://127.0.0.1:9999/debian unstable/main amd64 node-lodash-compat all 3.10.2-1 [80.2 kB]
Get:190 http://127.0.0.1:9999/debian unstable/main amd64 node-mimic-fn all 1.1.0-1 [3070 B]
Get:191 http://127.0.0.1:9999/debian unstable/main amd64 node-mem all 1.1.0-1 [4076 B]
Get:192 http://127.0.0.1:9999/debian unstable/main amd64 node-os-locale all 2.0.0-1 [3702 B]
Get:193 http://127.0.0.1:9999/debian unstable/main amd64 node-pegjs all 0.7.0-2 [28.5 kB]
Get:194 http://127.0.0.1:9999/debian unstable/main amd64 node-require-directory all 2.1.1-1 [5364 B]
Get:195 http://127.0.0.1:9999/debian unstable/main amd64 node-require-main-filename all 1.0.1-1 [3152 B]
Get:196 http://127.0.0.1:9999/debian unstable/main amd64 node-set-blocking all 2.0.0-1 [3806 B]
Get:197 http://127.0.0.1:9999/debian unstable/main amd64 node-which-module all 2.0.0-1 [3792 B]
Get:198 http://127.0.0.1:9999/debian unstable/main amd64 node-y18n all 3.2.1-2 [4708 B]
Get:199 http://127.0.0.1:9999/debian unstable/main amd64 node-yargs-parser all 8.0.0-1 [13.8 kB]
Get:200 http://127.0.0.1:9999/debian unstable/main amd64 node-yargs all 10.0.3-2 [57.1 kB]
Get:201 http://127.0.0.1:9999/debian unstable/main amd64 node-uglify all 2.8.29-3 [122 kB]
Get:202 http://127.0.0.1:9999/debian unstable/main amd64 preview-latex-style all 11.91-1 [201 kB]
Get:203 http://127.0.0.1:9999/debian unstable/main amd64 python-babel-localedata all 2.4.0+dfsg.1-2 [3415 kB]
Get:204 http://127.0.0.1:9999/debian unstable/main amd64 python-decorator all 4.1.2-1 [13.7 kB]
Get:205 http://127.0.0.1:9999/debian unstable/main amd64 python2.7-dev amd64 2.7.15-1 [290 kB]
Get:206 http://127.0.0.1:9999/debian unstable/main amd64 python-dev amd64 2.7.15~rc1-1 [1212 B]
Get:207 http://127.0.0.1:9999/debian unstable/main amd64 python-pkg-resources all 39.0.1-2 [171 kB]
Get:208 http://127.0.0.1:9999/debian unstable/main amd64 python-nose all 1.3.7-4 [132 kB]
Get:209 http://127.0.0.1:9999/debian unstable/main amd64 python-nose-parameterized all 0.3.4-4 [7620 B]
Get:210 http://127.0.0.1:9999/debian unstable/main amd64 python-numpy amd64 1:1.13.3-2 [1950 kB]
Get:211 http://127.0.0.1:9999/debian unstable/main amd64 python-scipy amd64 0.19.1-2 [9701 kB]
Get:212 http://127.0.0.1:9999/debian unstable/main amd64 python-setuptools all 39.0.1-2 [373 kB]
Get:213 http://127.0.0.1:9999/debian unstable/main amd64 python-six all 1.11.0-2 [15.1 kB]
Get:214 http://127.0.0.1:9999/debian unstable/main amd64 python3-alabaster all 0.7.8-1 [18.4 kB]
Get:215 http://127.0.0.1:9999/debian unstable/main amd64 python3-pkg-resources all 39.0.1-2 [142 kB]
Get:216 http://127.0.0.1:9999/debian unstable/main amd64 python3-tz all 2018.4-1 [26.9 kB]
Get:217 http://127.0.0.1:9999/debian unstable/main amd64 python3-babel all 2.4.0+dfsg.1-2 [83.7 kB]
Get:218 http://127.0.0.1:9999/debian unstable/main amd64 python3-certifi all 2018.1.18-3 [144 kB]
Get:219 http://127.0.0.1:9999/debian unstable/main amd64 python3-chardet all 3.0.4-1 [80.2 kB]
Get:220 http://127.0.0.1:9999/debian unstable/main amd64 python3-decorator all 4.1.2-1 [13.7 kB]
Get:221 http://127.0.0.1:9999/debian unstable/main amd64 python3.6-dev amd64 3.6.5-5 [511 kB]
Get:222 http://127.0.0.1:9999/debian unstable/main amd64 python3-lib2to3 all 3.6.5-3 [78.7 kB]
Get:223 http://127.0.0.1:9999/debian unstable/main amd64 python3-distutils all 3.6.5-3 [144 kB]
Get:224 http://127.0.0.1:9999/debian unstable/main amd64 python3-dev amd64 3.6.5-3 [1244 B]
Get:225 http://127.0.0.1:9999/debian unstable/main amd64 python3-roman all 2.0.0-3 [8768 B]
Get:226 http://127.0.0.1:9999/debian unstable/main amd64 python3-docutils all 0.14+dfsg-3 [377 kB]
Get:227 http://127.0.0.1:9999/debian unstable/main amd64 python3-idna all 2.6-1 [34.3 kB]
Get:228 http://127.0.0.1:9999/debian unstable/main amd64 python3-imagesize all 0.7.1-1 [3886 B]
Get:229 http://127.0.0.1:9999/debian unstable/main amd64 python3-markupsafe amd64 1.0-1+b1 [14.5 kB]
Get:230 http://127.0.0.1:9999/debian unstable/main amd64 python3-jinja2 all 2.10-1 [106 kB]
Get:231 http://127.0.0.1:9999/debian unstable/main amd64 python3-nose all 1.3.7-4 [132 kB]
Get:232 http://127.0.0.1:9999/debian unstable/main amd64 python3-nose-parameterized all 0.3.4-4 [7696 B]
Get:233 http://127.0.0.1:9999/debian unstable/main amd64 python3-numpy amd64 1:1.13.3-2 [1956 kB]
Get:234 http://127.0.0.1:9999/debian unstable/main amd64 python3-pyparsing all 2.2.0+dfsg1-2 [89.6 kB]
Get:235 http://127.0.0.1:9999/debian unstable/main amd64 python3-six all 1.11.0-2 [15.2 kB]
Get:236 http://127.0.0.1:9999/debian unstable/main amd64 python3-packaging all 17.1-1 [18.3 kB]
Get:237 http://127.0.0.1:9999/debian unstable/main amd64 python3-pygments all 2.2.0+dfsg-1 [588 kB]
Get:238 http://127.0.0.1:9999/debian unstable/main amd64 python3-urllib3 all 1.22-1 [97.9 kB]
Get:239 http://127.0.0.1:9999/debian unstable/main amd64 python3-requests all 2.18.4-2 [77.1 kB]
Get:240 http://127.0.0.1:9999/debian unstable/main amd64 python3-scipy amd64 0.19.1-2 [9632 kB]
Get:241 http://127.0.0.1:9999/debian unstable/main amd64 python3-setuptools all 39.0.1-2 [291 kB]
Get:242 http://127.0.0.1:9999/debian unstable/main amd64 sphinx-common all 1.7.4-1 [434 kB]
Get:243 http://127.0.0.1:9999/debian unstable/main amd64 python3-sphinx all 1.7.4-1 [444 kB]
Get:244 http://127.0.0.1:9999/debian unstable/main amd64 sphinx-rtd-theme-common all 0.2.4-1 [224 kB]
Get:245 http://127.0.0.1:9999/debian unstable/main amd64 python3-sphinx-rtd-theme all 0.2.4-1 [14.2 kB]
Get:246 http://127.0.0.1:9999/debian unstable/main amd64 rdfind amd64 1.3.5-1 [48.2 kB]
Get:247 http://127.0.0.1:9999/debian unstable/main amd64 symlinks amd64 1.4-3+b1 [11.2 kB]
Get:248 http://127.0.0.1:9999/debian unstable/main amd64 xdg-utils all 1.1.2-2 [72.8 kB]
Get:249 http://127.0.0.1:9999/debian unstable/main amd64 texlive-base all 2018.20180416-1 [18.9 MB]
Get:250 http://127.0.0.1:9999/debian unstable/main amd64 texlive-latex-base all 2018.20180416-1 [985 kB]
Get:251 http://127.0.0.1:9999/debian unstable/main amd64 texlive-latex-recommended all 2018.20180416-1 [15.3 MB]
Get:252 http://127.0.0.1:9999/debian unstable/main amd64 texlive-pictures all 2018.20180416-1 [4091 kB]
Get:253 http://127.0.0.1:9999/debian unstable/main amd64 texlive-latex-extra all 2018.20180416-1 [11.0 MB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 234 MB in 3s (88.2 MB/s)
Selecting previously unselected package bsdmainutils.
(Reading database ... 10771 files and directories currently installed.)
Preparing to unpack .../00-bsdmainutils_11.1.2_amd64.deb ...
Unpacking bsdmainutils (11.1.2) ...
Selecting previously unselected package groff-base.
Preparing to unpack .../01-groff-base_1.22.3-10_amd64.deb ...
Unpacking groff-base (1.22.3-10) ...
Selecting previously unselected package libpipeline1:amd64.
Preparing to unpack .../02-libpipeline1_1.5.0-1_amd64.deb ...
Unpacking libpipeline1:amd64 (1.5.0-1) ...
Selecting previously unselected package man-db.
Preparing to unpack .../03-man-db_2.8.3-2_amd64.deb ...
Unpacking man-db (2.8.3-2) ...
Selecting previously unselected package libpython2.7-minimal:amd64.
Preparing to unpack .../04-libpython2.7-minimal_2.7.15-1_amd64.deb ...
Unpacking libpython2.7-minimal:amd64 (2.7.15-1) ...
Selecting previously unselected package python2.7-minimal.
Preparing to unpack .../05-python2.7-minimal_2.7.15-1_amd64.deb ...
Unpacking python2.7-minimal (2.7.15-1) ...
Selecting previously unselected package python-minimal.
Preparing to unpack .../06-python-minimal_2.7.15~rc1-1_amd64.deb ...
Unpacking python-minimal (2.7.15~rc1-1) ...
Selecting previously unselected package mime-support.
Preparing to unpack .../07-mime-support_3.60_all.deb ...
Unpacking mime-support (3.60) ...
Selecting previously unselected package libexpat1:amd64.
Preparing to unpack .../08-libexpat1_2.2.5-3_amd64.deb ...
Unpacking libexpat1:amd64 (2.2.5-3) ...
Selecting previously unselected package libncursesw6:amd64.
Preparing to unpack .../09-libncursesw6_6.1+20180210-2_amd64.deb ...
Unpacking libncursesw6:amd64 (6.1+20180210-2) ...
Selecting previously unselected package readline-common.
Preparing to unpack .../10-readline-common_7.0-3_all.deb ...
Unpacking readline-common (7.0-3) ...
Selecting previously unselected package libreadline7:amd64.
Preparing to unpack .../11-libreadline7_7.0-3+b1_amd64.deb ...
Unpacking libreadline7:amd64 (7.0-3+b1) ...
Selecting previously unselected package libsqlite3-0:amd64.
Preparing to unpack .../12-libsqlite3-0_3.23.1-1_amd64.deb ...
Unpacking libsqlite3-0:amd64 (3.23.1-1) ...
Selecting previously unselected package libssl1.1:amd64.
Preparing to unpack .../13-libssl1.1_1.1.0h-2_amd64.deb ...
Unpacking libssl1.1:amd64 (1.1.0h-2) ...
Selecting previously unselected package libpython2.7-stdlib:amd64.
Preparing to unpack .../14-libpython2.7-stdlib_2.7.15-1_amd64.deb ...
Unpacking libpython2.7-stdlib:amd64 (2.7.15-1) ...
Selecting previously unselected package python2.7.
Preparing to unpack .../15-python2.7_2.7.15-1_amd64.deb ...
Unpacking python2.7 (2.7.15-1) ...
Selecting previously unselected package libpython-stdlib:amd64.
Preparing to unpack .../16-libpython-stdlib_2.7.15~rc1-1_amd64.deb ...
Unpacking libpython-stdlib:amd64 (2.7.15~rc1-1) ...
Setting up libpython2.7-minimal:amd64 (2.7.15-1) ...
Setting up python2.7-minimal (2.7.15-1) ...
Setting up python-minimal (2.7.15~rc1-1) ...
Selecting previously unselected package python.
(Reading database ... 12213 files and directories currently installed.)
Preparing to unpack .../0-python_2.7.15~rc1-1_amd64.deb ...
Unpacking python (2.7.15~rc1-1) ...
Selecting previously unselected package fonts-lato.
Preparing to unpack .../1-fonts-lato_2.0-2_all.deb ...
Unpacking fonts-lato (2.0-2) ...
Selecting previously unselected package poppler-data.
Preparing to unpack .../2-poppler-data_0.4.9-2_all.deb ...
Unpacking poppler-data (0.4.9-2) ...
Selecting previously unselected package libpython3.6-minimal:amd64.
Preparing to unpack .../3-libpython3.6-minimal_3.6.5-5_amd64.deb ...
Unpacking libpython3.6-minimal:amd64 (3.6.5-5) ...
Selecting previously unselected package python3.6-minimal.
Preparing to unpack .../4-python3.6-minimal_3.6.5-5_amd64.deb ...
Unpacking python3.6-minimal (3.6.5-5) ...
Selecting previously unselected package python3-minimal.
Preparing to unpack .../5-python3-minimal_3.6.5-3_amd64.deb ...
Unpacking python3-minimal (3.6.5-3) ...
Selecting previously unselected package libmpdec2:amd64.
Preparing to unpack .../6-libmpdec2_2.4.2-2_amd64.deb ...
Unpacking libmpdec2:amd64 (2.4.2-2) ...
Selecting previously unselected package libpython3.6-stdlib:amd64.
Preparing to unpack .../7-libpython3.6-stdlib_3.6.5-5_amd64.deb ...
Unpacking libpython3.6-stdlib:amd64 (3.6.5-5) ...
Selecting previously unselected package python3.6.
Preparing to unpack .../8-python3.6_3.6.5-5_amd64.deb ...
Unpacking python3.6 (3.6.5-5) ...
Selecting previously unselected package libpython3-stdlib:amd64.
Preparing to unpack .../9-libpython3-stdlib_3.6.5-3_amd64.deb ...
Unpacking libpython3-stdlib:amd64 (3.6.5-3) ...
Setting up libssl1.1:amd64 (1.1.0h-2) ...
Setting up libpython3.6-minimal:amd64 (3.6.5-5) ...
Setting up libexpat1:amd64 (2.2.5-3) ...
Setting up python3.6-minimal (3.6.5-5) ...
Setting up python3-minimal (3.6.5-3) ...
Selecting previously unselected package python3.
(Reading database ... 13456 files and directories currently installed.)
Preparing to unpack .../000-python3_3.6.5-3_amd64.deb ...
Unpacking python3 (3.6.5-3) ...
Selecting previously unselected package sgml-base.
Preparing to unpack .../001-sgml-base_1.29_all.deb ...
Unpacking sgml-base (1.29) ...
Selecting previously unselected package ucf.
Preparing to unpack .../002-ucf_3.0038_all.deb ...
Moving old data out of the way
Unpacking ucf (3.0038) ...
Selecting previously unselected package tex-common.
Preparing to unpack .../003-tex-common_6.09_all.deb ...
Unpacking tex-common (6.09) ...
Selecting previously unselected package tzdata.
Preparing to unpack .../004-tzdata_2018d-1_all.deb ...
Unpacking tzdata (2018d-1) ...
Selecting previously unselected package libmagic-mgc.
Preparing to unpack .../005-libmagic-mgc_1%3a5.33-2_amd64.deb ...
Unpacking libmagic-mgc (1:5.33-2) ...
Selecting previously unselected package libmagic1:amd64.
Preparing to unpack .../006-libmagic1_1%3a5.33-2_amd64.deb ...
Unpacking libmagic1:amd64 (1:5.33-2) ...
Selecting previously unselected package file.
Preparing to unpack .../007-file_1%3a5.33-2_amd64.deb ...
Unpacking file (1:5.33-2) ...
Selecting previously unselected package gettext-base.
Preparing to unpack .../008-gettext-base_0.19.8.1-6_amd64.deb ...
Unpacking gettext-base (0.19.8.1-6) ...
Selecting previously unselected package libsigsegv2:amd64.
Preparing to unpack .../009-libsigsegv2_2.12-2_amd64.deb ...
Unpacking libsigsegv2:amd64 (2.12-2) ...
Selecting previously unselected package m4.
Preparing to unpack .../010-m4_1.4.18-1_amd64.deb ...
Unpacking m4 (1.4.18-1) ...
Selecting previously unselected package autoconf.
Preparing to unpack .../011-autoconf_2.69-11_all.deb ...
Unpacking autoconf (2.69-11) ...
Selecting previously unselected package autotools-dev.
Preparing to unpack .../012-autotools-dev_20180224.1_all.deb ...
Unpacking autotools-dev (20180224.1) ...
Selecting previously unselected package automake.
Preparing to unpack .../013-automake_1%3a1.15.1-3.1_all.deb ...
Unpacking automake (1:1.15.1-3.1) ...
Selecting previously unselected package autopoint.
Preparing to unpack .../014-autopoint_0.19.8.1-6_all.deb ...
Unpacking autopoint (0.19.8.1-6) ...
Selecting previously unselected package openssl.
Preparing to unpack .../015-openssl_1.1.0h-2_amd64.deb ...
Unpacking openssl (1.1.0h-2) ...
Selecting previously unselected package ca-certificates.
Preparing to unpack .../016-ca-certificates_20180409_all.deb ...
Unpacking ca-certificates (20180409) ...
Selecting previously unselected package libtool.
Preparing to unpack .../017-libtool_2.4.6-2.1_all.deb ...
Unpacking libtool (2.4.6-2.1) ...
Selecting previously unselected package dh-autoreconf.
Preparing to unpack .../018-dh-autoreconf_17_all.deb ...
Unpacking dh-autoreconf (17) ...
Selecting previously unselected package libarchive-zip-perl.
Preparing to unpack .../019-libarchive-zip-perl_1.60-1_all.deb ...
Unpacking libarchive-zip-perl (1.60-1) ...
Selecting previously unselected package libfile-stripnondeterminism-perl.
Preparing to unpack .../020-libfile-stripnondeterminism-perl_0.041-1_all.deb ...
Unpacking libfile-stripnondeterminism-perl (0.041-1) ...
Selecting previously unselected package libtimedate-perl.
Preparing to unpack .../021-libtimedate-perl_2.3000-2_all.deb ...
Unpacking libtimedate-perl (2.3000-2) ...
Selecting previously unselected package dh-strip-nondeterminism.
Preparing to unpack .../022-dh-strip-nondeterminism_0.041-1_all.deb ...
Unpacking dh-strip-nondeterminism (0.041-1) ...
Selecting previously unselected package libglib2.0-0:amd64.
Preparing to unpack .../023-libglib2.0-0_2.56.1-2_amd64.deb ...
Unpacking libglib2.0-0:amd64 (2.56.1-2) ...
Selecting previously unselected package libicu57:amd64.
Preparing to unpack .../024-libicu57_57.1-9_amd64.deb ...
Unpacking libicu57:amd64 (57.1-9) ...
Selecting previously unselected package libxml2:amd64.
Preparing to unpack .../025-libxml2_2.9.4+dfsg1-6.1_amd64.deb ...
Unpacking libxml2:amd64 (2.9.4+dfsg1-6.1) ...
Selecting previously unselected package libcroco3:amd64.
Preparing to unpack .../026-libcroco3_0.6.12-2_amd64.deb ...
Unpacking libcroco3:amd64 (0.6.12-2) ...
Selecting previously unselected package gettext.
Preparing to unpack .../027-gettext_0.19.8.1-6_amd64.deb ...
Unpacking gettext (0.19.8.1-6) ...
Selecting previously unselected package intltool-debian.
Preparing to unpack .../028-intltool-debian_0.35.0+20060710.4_all.deb ...
Unpacking intltool-debian (0.35.0+20060710.4) ...
Selecting previously unselected package po-debconf.
Preparing to unpack .../029-po-debconf_1.0.20_all.deb ...
Unpacking po-debconf (1.0.20) ...
Selecting previously unselected package debhelper.
Preparing to unpack .../030-debhelper_11.2.1_all.deb ...
Unpacking debhelper (11.2.1) ...
Selecting previously unselected package dh-python.
Preparing to unpack .../031-dh-python_3.20180326_all.deb ...
Unpacking dh-python (3.20180326) ...
Selecting previously unselected package xml-core.
Preparing to unpack .../032-xml-core_0.18_all.deb ...
Unpacking xml-core (0.18) ...
Selecting previously unselected package docutils-common.
Preparing to unpack .../033-docutils-common_0.14+dfsg-3_all.deb ...
Unpacking docutils-common (0.14+dfsg-3) ...
Selecting previously unselected package libpng16-16:amd64.
Preparing to unpack .../034-libpng16-16_1.6.34-1_amd64.deb ...
Unpacking libpng16-16:amd64 (1.6.34-1) ...
Selecting previously unselected package libfreetype6:amd64.
Preparing to unpack .../035-libfreetype6_2.8.1-2_amd64.deb ...
Unpacking libfreetype6:amd64 (2.8.1-2) ...
Selecting previously unselected package fonts-dejavu-core.
Preparing to unpack .../036-fonts-dejavu-core_2.37-1_all.deb ...
Unpacking fonts-dejavu-core (2.37-1) ...
Selecting previously unselected package fontconfig-config.
Preparing to unpack .../037-fontconfig-config_2.13.0-4_all.deb ...
Unpacking fontconfig-config (2.13.0-4) ...
Selecting previously unselected package libfontconfig1:amd64.
Preparing to unpack .../038-libfontconfig1_2.13.0-4_amd64.deb ...
Unpacking libfontconfig1:amd64 (2.13.0-4) ...
Selecting previously unselected package libjpeg62-turbo:amd64.
Preparing to unpack .../039-libjpeg62-turbo_1%3a1.5.2-2+b1_amd64.deb ...
Unpacking libjpeg62-turbo:amd64 (1:1.5.2-2+b1) ...
Selecting previously unselected package libjbig0:amd64.
Preparing to unpack .../040-libjbig0_2.1-3.1+b2_amd64.deb ...
Unpacking libjbig0:amd64 (2.1-3.1+b2) ...
Selecting previously unselected package libtiff5:amd64.
Preparing to unpack .../041-libtiff5_4.0.9-5_amd64.deb ...
Unpacking libtiff5:amd64 (4.0.9-5) ...
Selecting previously unselected package libwebp6:amd64.
Preparing to unpack .../042-libwebp6_0.6.1-2_amd64.deb ...
Unpacking libwebp6:amd64 (0.6.1-2) ...
Selecting previously unselected package libxau6:amd64.
Preparing to unpack .../043-libxau6_1%3a1.0.8-1+b2_amd64.deb ...
Unpacking libxau6:amd64 (1:1.0.8-1+b2) ...
Selecting previously unselected package libxdmcp6:amd64.
Preparing to unpack .../044-libxdmcp6_1%3a1.1.2-3_amd64.deb ...
Unpacking libxdmcp6:amd64 (1:1.1.2-3) ...
Selecting previously unselected package libxcb1:amd64.
Preparing to unpack .../045-libxcb1_1.13-1_amd64.deb ...
Unpacking libxcb1:amd64 (1.13-1) ...
Selecting previously unselected package libx11-data.
Preparing to unpack .../046-libx11-data_2%3a1.6.5-1_all.deb ...
Unpacking libx11-data (2:1.6.5-1) ...
Selecting previously unselected package libx11-6:amd64.
Preparing to unpack .../047-libx11-6_2%3a1.6.5-1_amd64.deb ...
Unpacking libx11-6:amd64 (2:1.6.5-1) ...
Selecting previously unselected package libxpm4:amd64.
Preparing to unpack .../048-libxpm4_1%3a3.5.12-1_amd64.deb ...
Unpacking libxpm4:amd64 (1:3.5.12-1) ...
Selecting previously unselected package libgd3:amd64.
Preparing to unpack .../049-libgd3_2.2.5-4_amd64.deb ...
Unpacking libgd3:amd64 (2.2.5-4) ...
Selecting previously unselected package libkpathsea6:amd64.
Preparing to unpack .../050-libkpathsea6_2018.20180416.47457-2_amd64.deb ...
Unpacking libkpathsea6:amd64 (2018.20180416.47457-2) ...
Selecting previously unselected package libptexenc1:amd64.
Preparing to unpack .../051-libptexenc1_2018.20180416.47457-2_amd64.deb ...
Unpacking libptexenc1:amd64 (2018.20180416.47457-2) ...
Selecting previously unselected package libsynctex2:amd64.
Preparing to unpack .../052-libsynctex2_2018.20180416.47457-2_amd64.deb ...
Unpacking libsynctex2:amd64 (2018.20180416.47457-2) ...
Selecting previously unselected package libtexlua52:amd64.
Preparing to unpack .../053-libtexlua52_2018.20180416.47457-2_amd64.deb ...
Unpacking libtexlua52:amd64 (2018.20180416.47457-2) ...
Selecting previously unselected package libtexlua53:amd64.
Preparing to unpack .../054-libtexlua53_2018.20180416.47457-2_amd64.deb ...
Unpacking libtexlua53:amd64 (2018.20180416.47457-2) ...
Selecting previously unselected package libtexluajit2:amd64.
Preparing to unpack .../055-libtexluajit2_2018.20180416.47457-2_amd64.deb ...
Unpacking libtexluajit2:amd64 (2018.20180416.47457-2) ...
Selecting previously unselected package t1utils.
Preparing to unpack .../056-t1utils_1.41-2_amd64.deb ...
Unpacking t1utils (1.41-2) ...
Selecting previously unselected package libpixman-1-0:amd64.
Preparing to unpack .../057-libpixman-1-0_0.34.0-2_amd64.deb ...
Unpacking libpixman-1-0:amd64 (0.34.0-2) ...
Selecting previously unselected package libxcb-render0:amd64.
Preparing to unpack .../058-libxcb-render0_1.13-1_amd64.deb ...
Unpacking libxcb-render0:amd64 (1.13-1) ...
Selecting previously unselected package libxcb-shm0:amd64.
Preparing to unpack .../059-libxcb-shm0_1.13-1_amd64.deb ...
Unpacking libxcb-shm0:amd64 (1.13-1) ...
Selecting previously unselected package libxext6:amd64.
Preparing to unpack .../060-libxext6_2%3a1.3.3-1+b2_amd64.deb ...
Unpacking libxext6:amd64 (2:1.3.3-1+b2) ...
Selecting previously unselected package libxrender1:amd64.
Preparing to unpack .../061-libxrender1_1%3a0.9.10-1_amd64.deb ...
Unpacking libxrender1:amd64 (1:0.9.10-1) ...
Selecting previously unselected package libcairo2:amd64.
Preparing to unpack .../062-libcairo2_1.15.10-3_amd64.deb ...
Unpacking libcairo2:amd64 (1.15.10-3) ...
Selecting previously unselected package libgraphite2-3:amd64.
Preparing to unpack .../063-libgraphite2-3_1.3.11-2_amd64.deb ...
Unpacking libgraphite2-3:amd64 (1.3.11-2) ...
Selecting previously unselected package libavahi-common-data:amd64.
Preparing to unpack .../064-libavahi-common-data_0.7-4_amd64.deb ...
Unpacking libavahi-common-data:amd64 (0.7-4) ...
Selecting previously unselected package libavahi-common3:amd64.
Preparing to unpack .../065-libavahi-common3_0.7-4_amd64.deb ...
Unpacking libavahi-common3:amd64 (0.7-4) ...
Selecting previously unselected package libdbus-1-3:amd64.
Preparing to unpack .../066-libdbus-1-3_1.12.8-1_amd64.deb ...
Unpacking libdbus-1-3:amd64 (1.12.8-1) ...
Selecting previously unselected package libavahi-client3:amd64.
Preparing to unpack .../067-libavahi-client3_0.7-4_amd64.deb ...
Unpacking libavahi-client3:amd64 (0.7-4) ...
Selecting previously unselected package libkeyutils1:amd64.
Preparing to unpack .../068-libkeyutils1_1.5.9-9.2_amd64.deb ...
Unpacking libkeyutils1:amd64 (1.5.9-9.2) ...
Selecting previously unselected package libkrb5support0:amd64.
Preparing to unpack .../069-libkrb5support0_1.16-2_amd64.deb ...
Unpacking libkrb5support0:amd64 (1.16-2) ...
Selecting previously unselected package libk5crypto3:amd64.
Preparing to unpack .../070-libk5crypto3_1.16-2_amd64.deb ...
Unpacking libk5crypto3:amd64 (1.16-2) ...
Selecting previously unselected package libkrb5-3:amd64.
Preparing to unpack .../071-libkrb5-3_1.16-2_amd64.deb ...
Unpacking libkrb5-3:amd64 (1.16-2) ...
Selecting previously unselected package libgssapi-krb5-2:amd64.
Preparing to unpack .../072-libgssapi-krb5-2_1.16-2_amd64.deb ...
Unpacking libgssapi-krb5-2:amd64 (1.16-2) ...
Selecting previously unselected package libcups2:amd64.
Preparing to unpack .../073-libcups2_2.2.7-3_amd64.deb ...
Unpacking libcups2:amd64 (2.2.7-3) ...
Selecting previously unselected package libcupsimage2:amd64.
Preparing to unpack .../074-libcupsimage2_2.2.7-3_amd64.deb ...
Unpacking libcupsimage2:amd64 (2.2.7-3) ...
Selecting previously unselected package libidn11:amd64.
Preparing to unpack .../075-libidn11_1.33-2.2_amd64.deb ...
Unpacking libidn11:amd64 (1.33-2.2) ...
Selecting previously unselected package libijs-0.35:amd64.
Preparing to unpack .../076-libijs-0.35_0.35-13_amd64.deb ...
Unpacking libijs-0.35:amd64 (0.35-13) ...
Selecting previously unselected package libjbig2dec0:amd64.
Preparing to unpack .../077-libjbig2dec0_0.13-6_amd64.deb ...
Unpacking libjbig2dec0:amd64 (0.13-6) ...
Selecting previously unselected package liblcms2-2:amd64.
Preparing to unpack .../078-liblcms2-2_2.9-1_amd64.deb ...
Unpacking liblcms2-2:amd64 (2.9-1) ...
Selecting previously unselected package libopenjp2-7:amd64.
Preparing to unpack .../079-libopenjp2-7_2.3.0-1_amd64.deb ...
Unpacking libopenjp2-7:amd64 (2.3.0-1) ...
Selecting previously unselected package libpaper1:amd64.
Preparing to unpack .../080-libpaper1_1.1.24+nmu5_amd64.deb ...
Unpacking libpaper1:amd64 (1.1.24+nmu5) ...
Selecting previously unselected package libgs9-common.
Preparing to unpack .../081-libgs9-common_9.22~dfsg-2.1_all.deb ...
Unpacking libgs9-common (9.22~dfsg-2.1) ...
Selecting previously unselected package libgs9:amd64.
Preparing to unpack .../082-libgs9_9.22~dfsg-2.1_amd64.deb ...
Unpacking libgs9:amd64 (9.22~dfsg-2.1) ...
Selecting previously unselected package libharfbuzz0b:amd64.
Preparing to unpack .../083-libharfbuzz0b_1.7.6-1_amd64.deb ...
Unpacking libharfbuzz0b:amd64 (1.7.6-1) ...
Selecting previously unselected package libharfbuzz-icu0:amd64.
Preparing to unpack .../084-libharfbuzz-icu0_1.7.6-1_amd64.deb ...
Unpacking libharfbuzz-icu0:amd64 (1.7.6-1) ...
Selecting previously unselected package lsb-base.
Preparing to unpack .../085-lsb-base_9.20170808_all.deb ...
Unpacking lsb-base (9.20170808) ...
Selecting previously unselected package x11-common.
Preparing to unpack .../086-x11-common_1%3a7.7+19_all.deb ...
Unpacking x11-common (1:7.7+19) ...
Selecting previously unselected package libice6:amd64.
Preparing to unpack .../087-libice6_2%3a1.0.9-2_amd64.deb ...
Unpacking libice6:amd64 (2:1.0.9-2) ...
Selecting previously unselected package libpotrace0.
Preparing to unpack .../088-libpotrace0_1.14-2_amd64.deb ...
Unpacking libpotrace0 (1.14-2) ...
Selecting previously unselected package libsm6:amd64.
Preparing to unpack .../089-libsm6_2%3a1.2.2-1+b3_amd64.deb ...
Unpacking libsm6:amd64 (2:1.2.2-1+b3) ...
Selecting previously unselected package libxt6:amd64.
Preparing to unpack .../090-libxt6_1%3a1.1.5-1_amd64.deb ...
Unpacking libxt6:amd64 (1:1.1.5-1) ...
Selecting previously unselected package libxmu6:amd64.
Preparing to unpack .../091-libxmu6_2%3a1.1.2-2_amd64.deb ...
Unpacking libxmu6:amd64 (2:1.1.2-2) ...
Selecting previously unselected package libxaw7:amd64.
Preparing to unpack .../092-libxaw7_2%3a1.0.13-1+b2_amd64.deb ...
Unpacking libxaw7:amd64 (2:1.0.13-1+b2) ...
Selecting previously unselected package libxi6:amd64.
Preparing to unpack .../093-libxi6_2%3a1.7.9-1_amd64.deb ...
Unpacking libxi6:amd64 (2:1.7.9-1) ...
Selecting previously unselected package libzzip-0-13:amd64.
Preparing to unpack .../094-libzzip-0-13_0.13.62-3.1_amd64.deb ...
Unpacking libzzip-0-13:amd64 (0.13.62-3.1) ...
Selecting previously unselected package texlive-binaries.
Preparing to unpack .../095-texlive-binaries_2018.20180416.47457-2_amd64.deb ...
Unpacking texlive-binaries (2018.20180416.47457-2) ...
Selecting previously unselected package ghostscript.
Preparing to unpack .../096-ghostscript_9.22~dfsg-2.1_amd64.deb ...
Unpacking ghostscript (9.22~dfsg-2.1) ...
Selecting previously unselected package dvipng.
Preparing to unpack .../097-dvipng_1.15-1_amd64.deb ...
Unpacking dvipng (1.15-1) ...
Selecting previously unselected package fonts-font-awesome.
Preparing to unpack .../098-fonts-font-awesome_4.7.0~dfsg-3_all.deb ...
Unpacking fonts-font-awesome (4.7.0~dfsg-3) ...
Selecting previously unselected package fonts-lmodern.
Preparing to unpack .../099-fonts-lmodern_2.004.5-3_all.deb ...
Unpacking fonts-lmodern (2.004.5-3) ...
Selecting previously unselected package libgfortran4:amd64.
Preparing to unpack .../100-libgfortran4_7.3.0-17_amd64.deb ...
Unpacking libgfortran4:amd64 (7.3.0-17) ...
Selecting previously unselected package libblas3:amd64.
Preparing to unpack .../101-libblas3_3.8.0-1_amd64.deb ...
Unpacking libblas3:amd64 (3.8.0-1) ...
Selecting previously unselected package libblas-dev:amd64.
Preparing to unpack .../102-libblas-dev_3.8.0-1_amd64.deb ...
Unpacking libblas-dev:amd64 (3.8.0-1) ...
Selecting previously unselected package libc-ares2:amd64.
Preparing to unpack .../103-libc-ares2_1.14.0-1_amd64.deb ...
Unpacking libc-ares2:amd64 (1.14.0-1) ...
Selecting previously unselected package libexpat1-dev:amd64.
Preparing to unpack .../104-libexpat1-dev_2.2.5-3_amd64.deb ...
Unpacking libexpat1-dev:amd64 (2.2.5-3) ...
Selecting previously unselected package libhttp-parser2.8:amd64.
Preparing to unpack .../105-libhttp-parser2.8_2.8.1-1_amd64.deb ...
Unpacking libhttp-parser2.8:amd64 (2.8.1-1) ...
Selecting previously unselected package libjs-d3.
Preparing to unpack .../106-libjs-d3_3.5.17-2_all.deb ...
Unpacking libjs-d3 (3.5.17-2) ...
Selecting previously unselected package libjs-jquery.
Preparing to unpack .../107-libjs-jquery_3.2.1-1_all.deb ...
Unpacking libjs-jquery (3.2.1-1) ...
Selecting previously unselected package libjs-modernizr.
Preparing to unpack .../108-libjs-modernizr_2.6.2+ds1-1.1_all.deb ...
Unpacking libjs-modernizr (2.6.2+ds1-1.1) ...
Selecting previously unselected package libjs-underscore.
Preparing to unpack .../109-libjs-underscore_1.8.3~dfsg-1_all.deb ...
Unpacking libjs-underscore (1.8.3~dfsg-1) ...
Selecting previously unselected package libjs-sphinxdoc.
Preparing to unpack .../110-libjs-sphinxdoc_1.7.4-1_all.deb ...
Unpacking libjs-sphinxdoc (1.7.4-1) ...
Selecting previously unselected package liblapack3:amd64.
Preparing to unpack .../111-liblapack3_3.8.0-1_amd64.deb ...
Unpacking liblapack3:amd64 (3.8.0-1) ...
Selecting previously unselected package libnghttp2-14:amd64.
Preparing to unpack .../112-libnghttp2-14_1.31.1-1_amd64.deb ...
Unpacking libnghttp2-14:amd64 (1.31.1-1) ...
Selecting previously unselected package libpaper-utils.
Preparing to unpack .../113-libpaper-utils_1.1.24+nmu5_amd64.deb ...
Unpacking libpaper-utils (1.1.24+nmu5) ...
Selecting previously unselected package libpython2.7:amd64.
Preparing to unpack .../114-libpython2.7_2.7.15-1_amd64.deb ...
Unpacking libpython2.7:amd64 (2.7.15-1) ...
Selecting previously unselected package libpython2.7-dev:amd64.
Preparing to unpack .../115-libpython2.7-dev_2.7.15-1_amd64.deb ...
Unpacking libpython2.7-dev:amd64 (2.7.15-1) ...
Selecting previously unselected package libpython-dev:amd64.
Preparing to unpack .../116-libpython-dev_2.7.15~rc1-1_amd64.deb ...
Unpacking libpython-dev:amd64 (2.7.15~rc1-1) ...
Selecting previously unselected package libpython3.6:amd64.
Preparing to unpack .../117-libpython3.6_3.6.5-5_amd64.deb ...
Unpacking libpython3.6:amd64 (3.6.5-5) ...
Selecting previously unselected package libpython3.6-dev:amd64.
Preparing to unpack .../118-libpython3.6-dev_3.6.5-5_amd64.deb ...
Unpacking libpython3.6-dev:amd64 (3.6.5-5) ...
Selecting previously unselected package libpython3-dev:amd64.
Preparing to unpack .../119-libpython3-dev_3.6.5-3_amd64.deb ...
Unpacking libpython3-dev:amd64 (3.6.5-3) ...
Selecting previously unselected package libuv1:amd64.
Preparing to unpack .../120-libuv1_1.18.0-3_amd64.deb ...
Unpacking libuv1:amd64 (1.18.0-3) ...
Selecting previously unselected package nodejs.
Preparing to unpack .../121-nodejs_8.11.1~dfsg-2_amd64.deb ...
Unpacking nodejs (8.11.1~dfsg-2) ...
Selecting previously unselected package node-ansi-regex.
Preparing to unpack .../122-node-ansi-regex_3.0.0-1_all.deb ...
Unpacking node-ansi-regex (3.0.0-1) ...
Selecting previously unselected package node-color-name.
Preparing to unpack .../123-node-color-name_1.1.3-1_all.deb ...
Unpacking node-color-name (1.1.3-1) ...
Selecting previously unselected package node-color-convert.
Preparing to unpack .../124-node-color-convert_1.9.0-2_all.deb ...
Unpacking node-color-convert (1.9.0-2) ...
Selecting previously unselected package node-ansi-styles.
Preparing to unpack .../125-node-ansi-styles_3.2.0-1_all.deb ...
Unpacking node-ansi-styles (3.2.0-1) ...
Selecting previously unselected package node-pend.
Preparing to unpack .../126-node-pend_1.2.0-1_all.deb ...
Unpacking node-pend (1.2.0-1) ...
Selecting previously unselected package node-browserify-lite.
Preparing to unpack .../127-node-browserify-lite_0.5.0-1_all.deb ...
Unpacking node-browserify-lite (0.5.0-1) ...
Selecting previously unselected package node-camelcase.
Preparing to unpack .../128-node-camelcase_4.1.0-1_all.deb ...
Unpacking node-camelcase (4.1.0-1) ...
Selecting previously unselected package node-strip-ansi.
Preparing to unpack .../129-node-strip-ansi_4.0.0-1_all.deb ...
Unpacking node-strip-ansi (4.0.0-1) ...
Selecting previously unselected package node-clone.
Preparing to unpack .../130-node-clone_2.1.2-1_all.deb ...
Unpacking node-clone (2.1.2-1) ...
Selecting previously unselected package node-defaults.
Preparing to unpack .../131-node-defaults_1.0.3-1_all.deb ...
Unpacking node-defaults (1.0.3-1) ...
Selecting previously unselected package node-wcwidth.js.
Preparing to unpack .../132-node-wcwidth.js_1.0.0-1_all.deb ...
Unpacking node-wcwidth.js (1.0.0-1) ...
Selecting previously unselected package node-string-width.
Preparing to unpack .../133-node-string-width_2.1.1-1_all.deb ...
Unpacking node-string-width (2.1.1-1) ...
Selecting previously unselected package node-wrap-ansi.
Preparing to unpack .../134-node-wrap-ansi_3.0.1-1_all.deb ...
Unpacking node-wrap-ansi (3.0.1-1) ...
Selecting previously unselected package node-cliui.
Preparing to unpack .../135-node-cliui_4.0.0-1_all.deb ...
Unpacking node-cliui (4.0.0-1) ...
Selecting previously unselected package node-yallist.
Preparing to unpack .../136-node-yallist_2.0.0-1_all.deb ...
Unpacking node-yallist (2.0.0-1) ...
Selecting previously unselected package node-pseudomap.
Preparing to unpack .../137-node-pseudomap_1.0.2-1_all.deb ...
Unpacking node-pseudomap (1.0.2-1) ...
Selecting previously unselected package node-lru-cache.
Preparing to unpack .../138-node-lru-cache_4.1.1-1_all.deb ...
Unpacking node-lru-cache (4.1.1-1) ...
Selecting previously unselected package node-isexe.
Preparing to unpack .../139-node-isexe_2.0.0-3_all.deb ...
Unpacking node-isexe (2.0.0-3) ...
Selecting previously unselected package node-which.
Preparing to unpack .../140-node-which_1.3.0-1_all.deb ...
Unpacking node-which (1.3.0-1) ...
Selecting previously unselected package node-shebang-regex.
Preparing to unpack .../141-node-shebang-regex_2.0.0-1_all.deb ...
Unpacking node-shebang-regex (2.0.0-1) ...
Selecting previously unselected package node-shebang-command.
Preparing to unpack .../142-node-shebang-command_1.2.0-1_all.deb ...
Unpacking node-shebang-command (1.2.0-1) ...
Selecting previously unselected package node-cross-spawn.
Preparing to unpack .../143-node-cross-spawn_5.1.0-1_all.deb ...
Unpacking node-cross-spawn (5.1.0-1) ...
Selecting previously unselected package node-decamelize.
Preparing to unpack .../144-node-decamelize_1.2.0-1_all.deb ...
Unpacking node-decamelize (1.2.0-1) ...
Selecting previously unselected package node-get-stream.
Preparing to unpack .../145-node-get-stream_3.0.0-1_all.deb ...
Unpacking node-get-stream (3.0.0-1) ...
Selecting previously unselected package node-is-stream.
Preparing to unpack .../146-node-is-stream_1.1.0-1_all.deb ...
Unpacking node-is-stream (1.1.0-1) ...
Selecting previously unselected package node-npm-run-path.
Preparing to unpack .../147-node-npm-run-path_2.0.2-2_all.deb ...
Unpacking node-npm-run-path (2.0.2-2) ...
Selecting previously unselected package node-p-finally.
Preparing to unpack .../148-node-p-finally_1.0.0-2_all.deb ...
Unpacking node-p-finally (1.0.0-2) ...
Selecting previously unselected package node-signal-exit.
Preparing to unpack .../149-node-signal-exit_3.0.2-1_all.deb ...
Unpacking node-signal-exit (3.0.2-1) ...
Selecting previously unselected package node-strip-eof.
Preparing to unpack .../150-node-strip-eof_1.0.0-2_all.deb ...
Unpacking node-strip-eof (1.0.0-2) ...
Selecting previously unselected package node-execa.
Preparing to unpack .../151-node-execa_0.10.0+dfsg-1_all.deb ...
Unpacking node-execa (0.10.0+dfsg-1) ...
Selecting previously unselected package node-p-limit.
Preparing to unpack .../152-node-p-limit_1.1.0-1_all.deb ...
Unpacking node-p-limit (1.1.0-1) ...
Selecting previously unselected package node-p-locate.
Preparing to unpack .../153-node-p-locate_2.0.0-1_all.deb ...
Unpacking node-p-locate (2.0.0-1) ...
Selecting previously unselected package node-path-exists.
Preparing to unpack .../154-node-path-exists_3.0.0-1_all.deb ...
Unpacking node-path-exists (3.0.0-1) ...
Selecting previously unselected package node-locate-path.
Preparing to unpack .../155-node-locate-path_2.0.0-1_all.deb ...
Unpacking node-locate-path (2.0.0-1) ...
Selecting previously unselected package node-find-up.
Preparing to unpack .../156-node-find-up_2.1.0-1_all.deb ...
Unpacking node-find-up (2.1.0-1) ...
Selecting previously unselected package node-get-caller-file.
Preparing to unpack .../157-node-get-caller-file_1.0.2-1_all.deb ...
Unpacking node-get-caller-file (1.0.2-1) ...
Selecting previously unselected package node-invert-kv.
Preparing to unpack .../158-node-invert-kv_1.0.0-1_all.deb ...
Unpacking node-invert-kv (1.0.0-1) ...
Selecting previously unselected package node-lcid.
Preparing to unpack .../159-node-lcid_1.0.0-1_all.deb ...
Unpacking node-lcid (1.0.0-1) ...
Selecting previously unselected package node-lodash-compat.
Preparing to unpack .../160-node-lodash-compat_3.10.2-1_all.deb ...
Unpacking node-lodash-compat (3.10.2-1) ...
Selecting previously unselected package node-mimic-fn.
Preparing to unpack .../161-node-mimic-fn_1.1.0-1_all.deb ...
Unpacking node-mimic-fn (1.1.0-1) ...
Selecting previously unselected package node-mem.
Preparing to unpack .../162-node-mem_1.1.0-1_all.deb ...
Unpacking node-mem (1.1.0-1) ...
Selecting previously unselected package node-os-locale.
Preparing to unpack .../163-node-os-locale_2.0.0-1_all.deb ...
Unpacking node-os-locale (2.0.0-1) ...
Selecting previously unselected package node-pegjs.
Preparing to unpack .../164-node-pegjs_0.7.0-2_all.deb ...
Unpacking node-pegjs (0.7.0-2) ...
Selecting previously unselected package node-require-directory.
Preparing to unpack .../165-node-require-directory_2.1.1-1_all.deb ...
Unpacking node-require-directory (2.1.1-1) ...
Selecting previously unselected package node-require-main-filename.
Preparing to unpack .../166-node-require-main-filename_1.0.1-1_all.deb ...
Unpacking node-require-main-filename (1.0.1-1) ...
Selecting previously unselected package node-set-blocking.
Preparing to unpack .../167-node-set-blocking_2.0.0-1_all.deb ...
Unpacking node-set-blocking (2.0.0-1) ...
Selecting previously unselected package node-which-module.
Preparing to unpack .../168-node-which-module_2.0.0-1_all.deb ...
Unpacking node-which-module (2.0.0-1) ...
Selecting previously unselected package node-y18n.
Preparing to unpack .../169-node-y18n_3.2.1-2_all.deb ...
Unpacking node-y18n (3.2.1-2) ...
Selecting previously unselected package node-yargs-parser.
Preparing to unpack .../170-node-yargs-parser_8.0.0-1_all.deb ...
Unpacking node-yargs-parser (8.0.0-1) ...
Selecting previously unselected package node-yargs.
Preparing to unpack .../171-node-yargs_10.0.3-2_all.deb ...
Unpacking node-yargs (10.0.3-2) ...
Selecting previously unselected package node-uglify.
Preparing to unpack .../172-node-uglify_2.8.29-3_all.deb ...
Unpacking node-uglify (2.8.29-3) ...
Selecting previously unselected package preview-latex-style.
Preparing to unpack .../173-preview-latex-style_11.91-1_all.deb ...
Unpacking preview-latex-style (11.91-1) ...
Selecting previously unselected package python-babel-localedata.
Preparing to unpack .../174-python-babel-localedata_2.4.0+dfsg.1-2_all.deb ...
Unpacking python-babel-localedata (2.4.0+dfsg.1-2) ...
Selecting previously unselected package python-decorator.
Preparing to unpack .../175-python-decorator_4.1.2-1_all.deb ...
Unpacking python-decorator (4.1.2-1) ...
Selecting previously unselected package python2.7-dev.
Preparing to unpack .../176-python2.7-dev_2.7.15-1_amd64.deb ...
Unpacking python2.7-dev (2.7.15-1) ...
Selecting previously unselected package python-dev.
Preparing to unpack .../177-python-dev_2.7.15~rc1-1_amd64.deb ...
Unpacking python-dev (2.7.15~rc1-1) ...
Selecting previously unselected package python-pkg-resources.
Preparing to unpack .../178-python-pkg-resources_39.0.1-2_all.deb ...
Unpacking python-pkg-resources (39.0.1-2) ...
Selecting previously unselected package python-nose.
Preparing to unpack .../179-python-nose_1.3.7-4_all.deb ...
Unpacking python-nose (1.3.7-4) ...
Selecting previously unselected package python-nose-parameterized.
Preparing to unpack .../180-python-nose-parameterized_0.3.4-4_all.deb ...
Unpacking python-nose-parameterized (0.3.4-4) ...
Selecting previously unselected package python-numpy.
Preparing to unpack .../181-python-numpy_1%3a1.13.3-2_amd64.deb ...
Unpacking python-numpy (1:1.13.3-2) ...
Selecting previously unselected package python-scipy.
Preparing to unpack .../182-python-scipy_0.19.1-2_amd64.deb ...
Unpacking python-scipy (0.19.1-2) ...
Selecting previously unselected package python-setuptools.
Preparing to unpack .../183-python-setuptools_39.0.1-2_all.deb ...
Unpacking python-setuptools (39.0.1-2) ...
Selecting previously unselected package python-six.
Preparing to unpack .../184-python-six_1.11.0-2_all.deb ...
Unpacking python-six (1.11.0-2) ...
Selecting previously unselected package python3-alabaster.
Preparing to unpack .../185-python3-alabaster_0.7.8-1_all.deb ...
Unpacking python3-alabaster (0.7.8-1) ...
Selecting previously unselected package python3-pkg-resources.
Preparing to unpack .../186-python3-pkg-resources_39.0.1-2_all.deb ...
Unpacking python3-pkg-resources (39.0.1-2) ...
Selecting previously unselected package python3-tz.
Preparing to unpack .../187-python3-tz_2018.4-1_all.deb ...
Unpacking python3-tz (2018.4-1) ...
Selecting previously unselected package python3-babel.
Preparing to unpack .../188-python3-babel_2.4.0+dfsg.1-2_all.deb ...
Unpacking python3-babel (2.4.0+dfsg.1-2) ...
Selecting previously unselected package python3-certifi.
Preparing to unpack .../189-python3-certifi_2018.1.18-3_all.deb ...
Unpacking python3-certifi (2018.1.18-3) ...
Selecting previously unselected package python3-chardet.
Preparing to unpack .../190-python3-chardet_3.0.4-1_all.deb ...
Unpacking python3-chardet (3.0.4-1) ...
Selecting previously unselected package python3-decorator.
Preparing to unpack .../191-python3-decorator_4.1.2-1_all.deb ...
Unpacking python3-decorator (4.1.2-1) ...
Selecting previously unselected package python3.6-dev.
Preparing to unpack .../192-python3.6-dev_3.6.5-5_amd64.deb ...
Unpacking python3.6-dev (3.6.5-5) ...
Selecting previously unselected package python3-lib2to3.
Preparing to unpack .../193-python3-lib2to3_3.6.5-3_all.deb ...
Unpacking python3-lib2to3 (3.6.5-3) ...
Selecting previously unselected package python3-distutils.
Preparing to unpack .../194-python3-distutils_3.6.5-3_all.deb ...
Unpacking python3-distutils (3.6.5-3) ...
Selecting previously unselected package python3-dev.
Preparing to unpack .../195-python3-dev_3.6.5-3_amd64.deb ...
Unpacking python3-dev (3.6.5-3) ...
Selecting previously unselected package python3-roman.
Preparing to unpack .../196-python3-roman_2.0.0-3_all.deb ...
Unpacking python3-roman (2.0.0-3) ...
Selecting previously unselected package python3-docutils.
Preparing to unpack .../197-python3-docutils_0.14+dfsg-3_all.deb ...
Unpacking python3-docutils (0.14+dfsg-3) ...
Selecting previously unselected package python3-idna.
Preparing to unpack .../198-python3-idna_2.6-1_all.deb ...
Unpacking python3-idna (2.6-1) ...
Selecting previously unselected package python3-imagesize.
Preparing to unpack .../199-python3-imagesize_0.7.1-1_all.deb ...
Unpacking python3-imagesize (0.7.1-1) ...
Selecting previously unselected package python3-markupsafe.
Preparing to unpack .../200-python3-markupsafe_1.0-1+b1_amd64.deb ...
Unpacking python3-markupsafe (1.0-1+b1) ...
Selecting previously unselected package python3-jinja2.
Preparing to unpack .../201-python3-jinja2_2.10-1_all.deb ...
Unpacking python3-jinja2 (2.10-1) ...
Selecting previously unselected package python3-nose.
Preparing to unpack .../202-python3-nose_1.3.7-4_all.deb ...
Unpacking python3-nose (1.3.7-4) ...
Selecting previously unselected package python3-nose-parameterized.
Preparing to unpack .../203-python3-nose-parameterized_0.3.4-4_all.deb ...
Unpacking python3-nose-parameterized (0.3.4-4) ...
Selecting previously unselected package python3-numpy.
Preparing to unpack .../204-python3-numpy_1%3a1.13.3-2_amd64.deb ...
Unpacking python3-numpy (1:1.13.3-2) ...
Selecting previously unselected package python3-pyparsing.
Preparing to unpack .../205-python3-pyparsing_2.2.0+dfsg1-2_all.deb ...
Unpacking python3-pyparsing (2.2.0+dfsg1-2) ...
Selecting previously unselected package python3-six.
Preparing to unpack .../206-python3-six_1.11.0-2_all.deb ...
Unpacking python3-six (1.11.0-2) ...
Selecting previously unselected package python3-packaging.
Preparing to unpack .../207-python3-packaging_17.1-1_all.deb ...
Unpacking python3-packaging (17.1-1) ...
Selecting previously unselected package python3-pygments.
Preparing to unpack .../208-python3-pygments_2.2.0+dfsg-1_all.deb ...
Unpacking python3-pygments (2.2.0+dfsg-1) ...
Selecting previously unselected package python3-urllib3.
Preparing to unpack .../209-python3-urllib3_1.22-1_all.deb ...
Unpacking python3-urllib3 (1.22-1) ...
Selecting previously unselected package python3-requests.
Preparing to unpack .../210-python3-requests_2.18.4-2_all.deb ...
Unpacking python3-requests (2.18.4-2) ...
Selecting previously unselected package python3-scipy.
Preparing to unpack .../211-python3-scipy_0.19.1-2_amd64.deb ...
Unpacking python3-scipy (0.19.1-2) ...
Selecting previously unselected package python3-setuptools.
Preparing to unpack .../212-python3-setuptools_39.0.1-2_all.deb ...
Unpacking python3-setuptools (39.0.1-2) ...
Selecting previously unselected package sphinx-common.
Preparing to unpack .../213-sphinx-common_1.7.4-1_all.deb ...
Unpacking sphinx-common (1.7.4-1) ...
Selecting previously unselected package python3-sphinx.
Preparing to unpack .../214-python3-sphinx_1.7.4-1_all.deb ...
Unpacking python3-sphinx (1.7.4-1) ...
Selecting previously unselected package sphinx-rtd-theme-common.
Preparing to unpack .../215-sphinx-rtd-theme-common_0.2.4-1_all.deb ...
Unpacking sphinx-rtd-theme-common (0.2.4-1) ...
Selecting previously unselected package python3-sphinx-rtd-theme.
Preparing to unpack .../216-python3-sphinx-rtd-theme_0.2.4-1_all.deb ...
Unpacking python3-sphinx-rtd-theme (0.2.4-1) ...
Selecting previously unselected package rdfind.
Preparing to unpack .../217-rdfind_1.3.5-1_amd64.deb ...
Unpacking rdfind (1.3.5-1) ...
Selecting previously unselected package symlinks.
Preparing to unpack .../218-symlinks_1.4-3+b1_amd64.deb ...
Unpacking symlinks (1.4-3+b1) ...
Selecting previously unselected package xdg-utils.
Preparing to unpack .../219-xdg-utils_1.1.2-2_all.deb ...
Unpacking xdg-utils (1.1.2-2) ...
Selecting previously unselected package texlive-base.
Preparing to unpack .../220-texlive-base_2018.20180416-1_all.deb ...
Unpacking texlive-base (2018.20180416-1) ...
Selecting previously unselected package texlive-latex-base.
Preparing to unpack .../221-texlive-latex-base_2018.20180416-1_all.deb ...
Unpacking texlive-latex-base (2018.20180416-1) ...
Selecting previously unselected package texlive-latex-recommended.
Preparing to unpack .../222-texlive-latex-recommended_2018.20180416-1_all.deb ...
Unpacking texlive-latex-recommended (2018.20180416-1) ...
Selecting previously unselected package texlive-pictures.
Preparing to unpack .../223-texlive-pictures_2018.20180416-1_all.deb ...
Unpacking texlive-pictures (2018.20180416-1) ...
Selecting previously unselected package texlive-latex-extra.
Preparing to unpack .../224-texlive-latex-extra_2018.20180416-1_all.deb ...
Unpacking texlive-latex-extra (2018.20180416-1) ...
Selecting previously unselected package sbuild-build-depends-theano-dummy.
Preparing to unpack .../225-sbuild-build-depends-theano-dummy_0.invalid.0_amd64.deb ...
Unpacking sbuild-build-depends-theano-dummy (0.invalid.0) ...
Setting up libgs9-common (9.22~dfsg-2.1) ...
Setting up libkpathsea6:amd64 (2018.20180416.47457-2) ...
Setting up libjs-jquery (3.2.1-1) ...
Setting up libtexlua52:amd64 (2018.20180416.47457-2) ...
Setting up readline-common (7.0-3) ...
Setting up libopenjp2-7:amd64 (2.3.0-1) ...
Setting up libptexenc1:amd64 (2018.20180416.47457-2) ...
Setting up libjpeg62-turbo:amd64 (1:1.5.2-2+b1) ...
Setting up libarchive-zip-perl (1.60-1) ...
Setting up libnghttp2-14:amd64 (1.31.1-1) ...
Setting up libjs-underscore (1.8.3~dfsg-1) ...
Setting up mime-support (3.60) ...
Setting up libgfortran4:amd64 (7.3.0-17) ...
Setting up libpng16-16:amd64 (1.6.34-1) ...
Setting up libtimedate-perl (2.3000-2) ...
Setting up liblcms2-2:amd64 (2.9-1) ...
Setting up libjbig0:amd64 (2.1-3.1+b2) ...
Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up fonts-dejavu-core (2.37-1) ...
Setting up poppler-data (0.4.9-2) ...
Setting up libuv1:amd64 (1.18.0-3) ...
Setting up libreadline7:amd64 (7.0-3+b1) ...
Setting up tzdata (2018d-1) ...

Current default time zone: 'Etc/UTC'
Local time is now:      Wed May  2 12:32:47 UTC 2018.
Universal Time is now:  Wed May  2 12:32:47 UTC 2018.
Run 'dpkg-reconfigure tzdata' if you wish to change it.

Setting up rdfind (1.3.5-1) ...
Setting up groff-base (1.22.3-10) ...
Setting up libglib2.0-0:amd64 (2.56.1-2) ...
No schema files found: doing nothing.
Setting up libncursesw6:amd64 (6.1+20180210-2) ...
Setting up libtexlua53:amd64 (2018.20180416.47457-2) ...
Setting up libjs-sphinxdoc (1.7.4-1) ...
Setting up libtiff5:amd64 (4.0.9-5) ...
Setting up gettext-base (0.19.8.1-6) ...
Setting up libsynctex2:amd64 (2018.20180416.47457-2) ...
Setting up libpipeline1:amd64 (1.5.0-1) ...
Setting up m4 (1.4.18-1) ...
Setting up sgml-base (1.29) ...
Setting up libicu57:amd64 (57.1-9) ...
Setting up ucf (3.0038) ...
Setting up fonts-font-awesome (4.7.0~dfsg-3) ...
Setting up libxml2:amd64 (2.9.4+dfsg1-6.1) ...
Setting up libfreetype6:amd64 (2.8.1-2) ...
Setting up libmagic-mgc (1:5.33-2) ...
Setting up libjs-d3 (3.5.17-2) ...
Setting up libmagic1:amd64 (1:5.33-2) ...
Setting up lsb-base (9.20170808) ...
Setting up libgraphite2-3:amd64 (1.3.11-2) ...
Setting up libcroco3:amd64 (0.6.12-2) ...
Setting up fonts-lato (2.0-2) ...
Setting up libjbig2dec0:amd64 (0.13-6) ...
Setting up libpixman-1-0:amd64 (0.34.0-2) ...
Setting up libblas3:amd64 (3.8.0-1) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/blas/libblas.so.3 to provide /usr/lib/x86_64-linux-gnu/libblas.so.3 (libblas.so.3-x86_64-linux-gnu) in auto mode
Processing triggers for libc-bin (2.27-3) ...
Setting up autotools-dev (20180224.1) ...
Setting up t1utils (1.41-2) ...
Setting up python-babel-localedata (2.4.0+dfsg.1-2) ...
Setting up openssl (1.1.0h-2) ...
Setting up sphinx-common (1.7.4-1) ...
Setting up libijs-0.35:amd64 (0.35-13) ...
Setting up libsqlite3-0:amd64 (3.23.1-1) ...
Setting up symlinks (1.4-3+b1) ...
Setting up libexpat1-dev:amd64 (2.2.5-3) ...
Setting up libpotrace0 (1.14-2) ...
Setting up libxdmcp6:amd64 (1:1.1.2-3) ...
Setting up xml-core (0.18) ...
Setting up libkeyutils1:amd64 (1.5.9-9.2) ...
Setting up bsdmainutils (11.1.2) ...
update-alternatives: using /usr/bin/bsd-write to provide /usr/bin/write (write) in auto mode
update-alternatives: using /usr/bin/bsd-from to provide /usr/bin/from (from) in auto mode
Setting up libzzip-0-13:amd64 (0.13.62-3.1) ...
Setting up x11-common (1:7.7+19) ...
update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults
invoke-rc.d: could not determine current runlevel
All runlevel operations denied by policy
invoke-rc.d: policy-rc.d denied execution of start.
Setting up xdg-utils (1.1.2-2) ...
Setting up ca-certificates (20180409) ...
Updating certificates in /etc/ssl/certs...
133 added, 0 removed; done.
Setting up libc-ares2:amd64 (1.14.0-1) ...
Setting up libtexluajit2:amd64 (2018.20180416.47457-2) ...
Setting up libjs-modernizr (2.6.2+ds1-1.1) ...
Setting up libx11-data (2:1.6.5-1) ...
Setting up libpython2.7-stdlib:amd64 (2.7.15-1) ...
Setting up libxau6:amd64 (1:1.0.8-1+b2) ...
Setting up autopoint (0.19.8.1-6) ...
Setting up libidn11:amd64 (1.33-2.2) ...
Setting up libmpdec2:amd64 (2.4.2-2) ...
Setting up libdbus-1-3:amd64 (1.12.8-1) ...
Setting up fonts-lmodern (2.004.5-3) ...
Setting up libavahi-common-data:amd64 (0.7-4) ...
Setting up libwebp6:amd64 (0.6.1-2) ...
Setting up libfile-stripnondeterminism-perl (0.041-1) ...
Setting up libhttp-parser2.8:amd64 (2.8.1-1) ...
Setting up libpaper1:amd64 (1.1.24+nmu5) ...

Creating config file /etc/papersize with new version
Setting up libpython3.6-stdlib:amd64 (3.6.5-5) ...
Setting up libpaper-utils (1.1.24+nmu5) ...
Setting up fontconfig-config (2.13.0-4) ...
Setting up python3.6 (3.6.5-5) ...
Setting up tex-common (6.09) ...
update-language: texlive-base not installed and configured, doing nothing!
Setting up gettext (0.19.8.1-6) ...
Setting up nodejs (8.11.1~dfsg-2) ...
update-alternatives: using /usr/bin/nodejs to provide /usr/bin/js (js) in auto mode
Setting up libblas-dev:amd64 (3.8.0-1) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/blas/libblas.so to provide /usr/lib/x86_64-linux-gnu/libblas.so (libblas.so-x86_64-linux-gnu) in auto mode
Setting up node-mimic-fn (1.1.0-1) ...
Setting up node-yallist (2.0.0-1) ...
Setting up liblapack3:amd64 (3.8.0-1) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3 to provide /usr/lib/x86_64-linux-gnu/liblapack.so.3 (liblapack.so.3-x86_64-linux-gnu) in auto mode
Setting up node-pseudomap (1.0.2-1) ...
Setting up python2.7 (2.7.15-1) ...
Setting up libharfbuzz0b:amd64 (1.7.6-1) ...
Setting up preview-latex-style (11.91-1) ...
Setting up autoconf (2.69-11) ...
Setting up file (1:5.33-2) ...
Setting up node-p-limit (1.1.0-1) ...
Setting up node-mem (1.1.0-1) ...
Setting up libkrb5support0:amd64 (1.16-2) ...
Setting up node-get-caller-file (1.0.2-1) ...
Setting up node-get-stream (3.0.0-1) ...
Setting up libpython-stdlib:amd64 (2.7.15~rc1-1) ...
Setting up intltool-debian (0.35.0+20060710.4) ...
Setting up node-set-blocking (2.0.0-1) ...
Setting up node-require-directory (2.1.1-1) ...
Setting up node-signal-exit (3.0.2-1) ...
Setting up node-camelcase (4.1.0-1) ...
Setting up sphinx-rtd-theme-common (0.2.4-1) ...
Setting up libpython2.7:amd64 (2.7.15-1) ...
Setting up node-which-module (2.0.0-1) ...
Setting up automake (1:1.15.1-3.1) ...
update-alternatives: using /usr/bin/automake-1.15 to provide /usr/bin/automake (automake) in auto mode
Setting up libice6:amd64 (2:1.0.9-2) ...
Setting up node-shebang-regex (2.0.0-1) ...
Setting up node-decamelize (1.2.0-1) ...
Setting up man-db (2.8.3-2) ...
Not building database; man-db/auto-update is not 'true'.
Setting up node-y18n (3.2.1-2) ...
Setting up node-ansi-regex (3.0.0-1) ...
Setting up libpython2.7-dev:amd64 (2.7.15-1) ...
Setting up node-isexe (2.0.0-3) ...
Setting up node-npm-run-path (2.0.2-2) ...
Setting up libavahi-common3:amd64 (0.7-4) ...
Setting up python2.7-dev (2.7.15-1) ...
Setting up node-strip-eof (1.0.0-2) ...
Setting up libxcb1:amd64 (1.13-1) ...
Setting up node-require-main-filename (1.0.1-1) ...
Setting up node-strip-ansi (4.0.0-1) ...
Setting up python (2.7.15~rc1-1) ...
Setting up node-pend (1.2.0-1) ...
Setting up node-yargs-parser (8.0.0-1) ...
Setting up libpython3.6:amd64 (3.6.5-5) ...
Setting up node-path-exists (3.0.0-1) ...
Setting up node-clone (2.1.2-1) ...
Setting up node-lodash-compat (3.10.2-1) ...
Setting up node-browserify-lite (0.5.0-1) ...
Setting up libtool (2.4.6-2.1) ...
Setting up libpython3-stdlib:amd64 (3.6.5-3) ...
Setting up libpython-dev:amd64 (2.7.15~rc1-1) ...
Setting up libfontconfig1:amd64 (2.13.0-4) ...
Setting up node-invert-kv (1.0.0-1) ...
Setting up libsm6:amd64 (2:1.2.2-1+b3) ...
Setting up node-pegjs (0.7.0-2) ...
Setting up libk5crypto3:amd64 (1.16-2) ...
Setting up node-color-name (1.1.3-1) ...
Setting up node-lcid (1.0.0-1) ...
Setting up node-p-locate (2.0.0-1) ...
Setting up libxcb-render0:amd64 (1.13-1) ...
Setting up node-defaults (1.0.3-1) ...
Setting up libharfbuzz-icu0:amd64 (1.7.6-1) ...
Setting up node-p-finally (1.0.0-2) ...
Setting up node-is-stream (1.1.0-1) ...
Setting up po-debconf (1.0.20) ...
Setting up python3 (3.6.5-3) ...
Setting up node-shebang-command (1.2.0-1) ...
Setting up python3-numpy (1:1.13.3-2) ...
Setting up python-dev (2.7.15~rc1-1) ...
Setting up python3-alabaster (0.7.8-1) ...
Setting up node-which (1.3.0-1) ...
Setting up node-lru-cache (4.1.1-1) ...
Setting up python3-idna (2.6-1) ...
Setting up python3-six (1.11.0-2) ...
Setting up libx11-6:amd64 (2:1.6.5-1) ...
Setting up python3-pyparsing (2.2.0+dfsg1-2) ...
Setting up python3-certifi (2018.1.18-3) ...
Setting up python3-pkg-resources (39.0.1-2) ...
Setting up python-pkg-resources (39.0.1-2) ...
Setting up libpython3.6-dev:amd64 (3.6.5-5) ...
Setting up python-numpy (1:1.13.3-2) ...
Setting up python3-markupsafe (1.0-1+b1) ...
Setting up node-cross-spawn (5.1.0-1) ...
Setting up python-six (1.11.0-2) ...
Setting up python3-nose (1.3.7-4) ...
Setting up python3-chardet (3.0.4-1) ...
Setting up python3-jinja2 (2.10-1) ...
Setting up libxcb-shm0:amd64 (1.13-1) ...
Setting up libxpm4:amd64 (1:3.5.12-1) ...
Setting up libxt6:amd64 (1:1.1.5-1) ...
Setting up libxrender1:amd64 (1:0.9.10-1) ...
Setting up libavahi-client3:amd64 (0.7-4) ...
Setting up python3-urllib3 (1.22-1) ...
Setting up libkrb5-3:amd64 (1.16-2) ...
Setting up python-decorator (4.1.2-1) ...
Setting up python3-packaging (17.1-1) ...
Setting up node-color-convert (1.9.0-2) ...
Setting up python3.6-dev (3.6.5-5) ...
Setting up python3-lib2to3 (3.6.5-3) ...
Setting up dh-python (3.20180326) ...
Setting up python3-decorator (4.1.2-1) ...
Setting up python-nose (1.3.7-4) ...
Setting up python3-tz (2018.4-1) ...
Setting up python3-distutils (3.6.5-3) ...
Setting up node-wcwidth.js (1.0.0-1) ...
Setting up libpython3-dev:amd64 (3.6.5-3) ...
Setting up python3-pygments (2.2.0+dfsg-1) ...
Setting up node-locate-path (2.0.0-1) ...
Setting up python3-sphinx-rtd-theme (0.2.4-1) ...
Setting up python-setuptools (39.0.1-2) ...
Setting up python3-roman (2.0.0-3) ...
Setting up python3-scipy (0.19.1-2) ...
Setting up node-execa (0.10.0+dfsg-1) ...
Setting up python3-imagesize (0.7.1-1) ...
Setting up node-string-width (2.1.1-1) ...
Setting up libxext6:amd64 (2:1.3.3-1+b2) ...
Setting up python-scipy (0.19.1-2) ...
Setting up python3-nose-parameterized (0.3.4-4) ...
Setting up libgd3:amd64 (2.2.5-4) ...
Setting up python3-dev (3.6.5-3) ...
Setting up node-os-locale (2.0.0-1) ...
Setting up libxmu6:amd64 (2:1.1.2-2) ...
Setting up python3-babel (2.4.0+dfsg.1-2) ...
update-alternatives: using /usr/bin/pybabel-python3 to provide /usr/bin/pybabel (pybabel) in auto mode
Setting up libgssapi-krb5-2:amd64 (1.16-2) ...
Setting up node-ansi-styles (3.2.0-1) ...
Setting up python3-requests (2.18.4-2) ...
Setting up python-nose-parameterized (0.3.4-4) ...
Setting up python3-setuptools (39.0.1-2) ...
Setting up libcups2:amd64 (2.2.7-3) ...
Setting up node-find-up (2.1.0-1) ...
Setting up libxi6:amd64 (2:1.7.9-1) ...
Setting up libxaw7:amd64 (2:1.0.13-1+b2) ...
Setting up libcairo2:amd64 (1.15.10-3) ...
Setting up node-wrap-ansi (3.0.1-1) ...
Setting up libcupsimage2:amd64 (2.2.7-3) ...
Setting up node-cliui (4.0.0-1) ...
Setting up libgs9:amd64 (9.22~dfsg-2.1) ...
Setting up ghostscript (9.22~dfsg-2.1) ...
Setting up texlive-binaries (2018.20180416.47457-2) ...
update-alternatives: using /usr/bin/xdvi-xaw to provide /usr/bin/xdvi.bin (xdvi.bin) in auto mode
update-alternatives: using /usr/bin/bibtex.original to provide /usr/bin/bibtex (bibtex) in auto mode
Setting up texlive-base (2018.20180416-1) ...
tl-paper: setting paper size for dvips to a4: /var/lib/texmf/dvips/config/config-paper.ps
tl-paper: setting paper size for dvipdfmx to a4: /var/lib/texmf/dvipdfmx/dvipdfmx-paper.cfg
tl-paper: setting paper size for xdvi to a4: /var/lib/texmf/xdvi/XDvi-paper
tl-paper: setting paper size for pdftex to a4: /var/lib/texmf/tex/generic/config/pdftexconfig.tex
Setting up node-yargs (10.0.3-2) ...
Setting up texlive-latex-base (2018.20180416-1) ...
Setting up texlive-latex-recommended (2018.20180416-1) ...
Setting up node-uglify (2.8.29-3) ...
Setting up texlive-pictures (2018.20180416-1) ...
Setting up dvipng (1.15-1) ...
Setting up texlive-latex-extra (2018.20180416-1) ...
Processing triggers for sgml-base (1.29) ...
Setting up docutils-common (0.14+dfsg-3) ...
Processing triggers for sgml-base (1.29) ...
Setting up python3-docutils (0.14+dfsg-3) ...
update-alternatives: using /usr/share/docutils/scripts/python3/rst-buildhtml to provide /usr/bin/rst-buildhtml (rst-buildhtml) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2html to provide /usr/bin/rst2html (rst2html) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2html4 to provide /usr/bin/rst2html4 (rst2html4) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2html5 to provide /usr/bin/rst2html5 (rst2html5) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2latex to provide /usr/bin/rst2latex (rst2latex) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2man to provide /usr/bin/rst2man (rst2man) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2odt to provide /usr/bin/rst2odt (rst2odt) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2odt_prepstyles to provide /usr/bin/rst2odt_prepstyles (rst2odt_prepstyles) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2pseudoxml to provide /usr/bin/rst2pseudoxml (rst2pseudoxml) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2s5 to provide /usr/bin/rst2s5 (rst2s5) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2xetex to provide /usr/bin/rst2xetex (rst2xetex) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rst2xml to provide /usr/bin/rst2xml (rst2xml) in auto mode
update-alternatives: using /usr/share/docutils/scripts/python3/rstpep2html to provide /usr/bin/rstpep2html (rstpep2html) in auto mode
Setting up python3-sphinx (1.7.4-1) ...
Setting up dh-autoreconf (17) ...
Setting up dh-strip-nondeterminism (0.041-1) ...
Setting up debhelper (11.2.1) ...
Setting up sbuild-build-depends-theano-dummy (0.invalid.0) ...
Processing triggers for libc-bin (2.27-3) ...
Processing triggers for ca-certificates (20180409) ...
Updating certificates in /etc/ssl/certs...
0 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d...
done.
Processing triggers for tex-common (6.09) ...
Running updmap-sys. This may take some time... done.
Running mktexlsr /var/lib/texmf ... done.
Building format(s) --all.
	This may take some time... done.

+------------------------------------------------------------------------------+
| Build environment                                                            |
+------------------------------------------------------------------------------+

Kernel: Linux 4.9.0-5-amd64 amd64 (x86_64)
Toolchain package versions: binutils_2.30-16 dpkg-dev_1.19.0.5 g++-7_7.3.0-17 gcc-7_7.3.0-17 libc6-dev_2.27-3 libstdc++-7-dev_7.3.0-17 libstdc++6_8-20180425-1 linux-libc-dev_4.15.17-1
Package versions: adduser_3.117 apt_1.6.1 autoconf_2.69-11 automake_1:1.15.1-3.1 autopoint_0.19.8.1-6 autotools-dev_20180224.1 base-files_10.1 base-passwd_3.5.45 bash_4.4.18-2 binutils_2.30-16 binutils-common_2.30-16 binutils-x86-64-linux-gnu_2.30-16 bsdmainutils_11.1.2 bsdutils_1:2.31.1-0.5 build-essential_12.5 bzip2_1.0.6-8.1 ca-certificates_20180409 clang-6.0_1:6.0-3 coreutils_8.28-1 cpp_4:7.3.0-3 cpp-7_7.3.0-17 dash_0.5.8-2.10 debconf_1.5.66 debfoster_2.7-2.1+b1 debhelper_11.2.1 debian-archive-keyring_2017.7 debianutils_4.8.4 dh-autoreconf_17 dh-python_3.20180326 dh-strip-nondeterminism_0.041-1 diffutils_1:3.6-1 docutils-common_0.14+dfsg-3 dpkg_1.19.0.5 dpkg-dev_1.19.0.5 dvipng_1.15-1 e2fslibs_1.44.1-2 e2fsprogs_1.44.1-2 eatmydata_105-6 fakeroot_1.22-2 fdisk_2.31.1-0.5 file_1:5.33-2 findutils_4.6.0+git+20171230-2 fontconfig-config_2.13.0-4 fonts-dejavu-core_2.37-1 fonts-font-awesome_4.7.0~dfsg-3 fonts-lato_2.0-2 fonts-lmodern_2.004.5-3 g++_4:7.3.0-3 g++-7_7.3.0-17 gcc_4:7.3.0-3 gcc-6-base_6.4.0-17 gcc-7_7.3.0-17 gcc-7-base_7.3.0-17 gcc-8-base_8-20180425-1 gettext_0.19.8.1-6 gettext-base_0.19.8.1-6 ghostscript_9.22~dfsg-2.1 gpgv_2.2.5-1 grep_3.1-2 groff-base_1.22.3-10 gzip_1.6-5+b1 hostname_3.20 init-system-helpers_1.51 intltool-debian_0.35.0+20060710.4 lib32gcc1_1:8-20180425-1 lib32stdc++6_8-20180425-1 libacl1_2.2.52-3+b1 libapt-pkg5.0_1.6.1 libarchive-zip-perl_1.60-1 libasan4_7.3.0-17 libatomic1_8-20180425-1 libattr1_1:2.4.47-2+b2 libaudit-common_1:2.8.3-1 libaudit1_1:2.8.3-1 libavahi-client3_0.7-4 libavahi-common-data_0.7-4 libavahi-common3_0.7-4 libbinutils_2.30-16 libblas-dev_3.8.0-1 libblas3_3.8.0-1 libblkid1_2.31.1-0.5 libbsd0_0.8.7-1 libbz2-1.0_1.0.6-8.1 libc-ares2_1.14.0-1 libc-bin_2.27-3 libc-dev-bin_2.27-3 libc6_2.27-3 libc6-dev_2.27-3 libc6-i386_2.27-3 libcairo2_1.15.10-3 libcap-ng0_0.7.9-1 libcc1-0_8-20180425-1 libcilkrts5_7.3.0-17 libclang-common-6.0-dev_1:6.0-3 libclang1-6.0_1:6.0-3 libcom-err2_1.44.1-2 libcomerr2_1.44.1-2 libcroco3_0.6.12-2 libcups2_2.2.7-3 libcupsimage2_2.2.7-3 libdb5.3_5.3.28-13.1+b1 libdbus-1-3_1.12.8-1 libdebconfclient0_0.243 libdpkg-perl_1.19.0.5 libeatmydata1_105-6 libedit2_3.1-20170329-1 libexpat1_2.2.5-3 libexpat1-dev_2.2.5-3 libext2fs2_1.44.1-2 libfakeroot_1.22-2 libfdisk1_2.31.1-0.5 libffi6_3.2.1-8 libfile-stripnondeterminism-perl_0.041-1 libfontconfig1_2.13.0-4 libfreetype6_2.8.1-2 libgc1c2_1:7.4.2-8.2 libgcc-7-dev_7.3.0-17 libgcc1_1:8-20180425-1 libgcrypt20_1.8.2-2 libgd3_2.2.5-4 libgdbm-compat4_1.14.1-6 libgdbm3_1.8.3-14 libgdbm5_1.14.1-6 libgfortran4_7.3.0-17 libglib2.0-0_2.56.1-2 libgmp10_2:6.1.2+dfsg-3 libgnutls30_3.5.18-1 libgomp1_8-20180425-1 libgpg-error0_1.29-4 libgraphite2-3_1.3.11-2 libgs9_9.22~dfsg-2.1 libgs9-common_9.22~dfsg-2.1 libgssapi-krb5-2_1.16-2 libharfbuzz-icu0_1.7.6-1 libharfbuzz0b_1.7.6-1 libhogweed4_3.4-1 libhttp-parser2.8_2.8.1-1 libice6_2:1.0.9-2 libicu57_57.1-9 libidn11_1.33-2.2 libidn2-0_2.0.4-1.1 libijs-0.35_0.35-13 libisl15_0.18-4 libisl19_0.19-1 libitm1_8-20180425-1 libjbig0_2.1-3.1+b2 libjbig2dec0_0.13-6 libjpeg62-turbo_1:1.5.2-2+b1 libjs-d3_3.5.17-2 libjs-jquery_3.2.1-1 libjs-modernizr_2.6.2+ds1-1.1 libjs-sphinxdoc_1.7.4-1 libjs-underscore_1.8.3~dfsg-1 libjsoncpp1_1.7.4-3 libk5crypto3_1.16-2 libkeyutils1_1.5.9-9.2 libkpathsea6_2018.20180416.47457-2 libkrb5-3_1.16-2 libkrb5support0_1.16-2 liblapack3_3.8.0-1 liblcms2-2_2.9-1 libllvm6.0_1:6.0-3 liblsan0_8-20180425-1 liblz4-1_1.8.1.2-1 liblzma5_5.2.2-1.3 libmagic-mgc_1:5.33-2 libmagic1_1:5.33-2 libmount1_2.31.1-0.5 libmpc3_1.1.0-1 libmpdec2_2.4.2-2 libmpfr4_3.1.6-1 libmpfr6_4.0.1-1 libmpx2_8-20180425-1 libncurses5_6.1+20180210-2 libncursesw5_6.1+20180210-2 libncursesw6_6.1+20180210-2 libnettle6_3.4-1 libnghttp2-14_1.31.1-1 libobjc-7-dev_7.3.0-17 libobjc4_8-20180425-1 libopenjp2-7_2.3.0-1 libp11-kit0_0.23.10-2 libpam-modules_1.1.8-3.7 libpam-modules-bin_1.1.8-3.7 libpam-runtime_1.1.8-3.7 libpam0g_1.1.8-3.7 libpaper-utils_1.1.24+nmu5 libpaper1_1.1.24+nmu5 libpcre3_2:8.39-9 libperl5.26_5.26.2-3 libpipeline1_1.5.0-1 libpixman-1-0_0.34.0-2 libpng16-16_1.6.34-1 libpotrace0_1.14-2 libptexenc1_2018.20180416.47457-2 libpython-dev_2.7.15~rc1-1 libpython-stdlib_2.7.15~rc1-1 libpython2.7_2.7.15-1 libpython2.7-dev_2.7.15-1 libpython2.7-minimal_2.7.15-1 libpython2.7-stdlib_2.7.15-1 libpython3-dev_3.6.5-3 libpython3-stdlib_3.6.5-3 libpython3.6_3.6.5-5 libpython3.6-dev_3.6.5-5 libpython3.6-minimal_3.6.5-5 libpython3.6-stdlib_3.6.5-5 libquadmath0_8-20180425-1 libreadline7_7.0-3+b1 libseccomp2_2.3.3-1 libselinux1_2.7-2+b2 libsemanage-common_2.7-2 libsemanage1_2.7-2+b2 libsepol1_2.7-1 libsigsegv2_2.12-2 libsm6_2:1.2.2-1+b3 libsmartcols1_2.31.1-0.5 libsqlite3-0_3.23.1-1 libss2_1.44.1-2 libssl1.1_1.1.0h-2 libstdc++-7-dev_7.3.0-17 libstdc++6_8-20180425-1 libsynctex2_2018.20180416.47457-2 libsystemd0_238-4 libtasn1-6_4.13-2 libtexlua52_2018.20180416.47457-2 libtexlua53_2018.20180416.47457-2 libtexluajit2_2018.20180416.47457-2 libtiff5_4.0.9-5 libtimedate-perl_2.3000-2 libtinfo5_6.1+20180210-2 libtinfo6_6.1+20180210-2 libtool_2.4.6-2.1 libtsan0_8-20180425-1 libubsan0_7.3.0-17 libudev1_238-4 libunistring2_0.9.8-1 libustr-1.0-1_1.0.4-6 libuuid1_2.31.1-0.5 libuv1_1.18.0-3 libwebp6_0.6.1-2 libx11-6_2:1.6.5-1 libx11-data_2:1.6.5-1 libxau6_1:1.0.8-1+b2 libxaw7_2:1.0.13-1+b2 libxcb-render0_1.13-1 libxcb-shm0_1.13-1 libxcb1_1.13-1 libxdmcp6_1:1.1.2-3 libxext6_2:1.3.3-1+b2 libxi6_2:1.7.9-1 libxml2_2.9.4+dfsg1-6.1 libxmu6_2:1.1.2-2 libxpm4_1:3.5.12-1 libxrender1_1:0.9.10-1 libxt6_1:1.1.5-1 libzstd1_1.3.4+dfsg-1 libzzip-0-13_0.13.62-3.1 linux-libc-dev_4.15.17-1 login_1:4.5-1 lsb-base_9.20170808 m4_1.4.18-1 make_4.2.1-1 man-db_2.8.3-2 mawk_1.3.3-17+b3 mime-support_3.60 mount_2.31.1-0.5 multiarch-support_2.27-3 ncurses-base_6.1+20180210-2 ncurses-bin_6.1+20180210-2 node-ansi-regex_3.0.0-1 node-ansi-styles_3.2.0-1 node-browserify-lite_0.5.0-1 node-camelcase_4.1.0-1 node-cliui_4.0.0-1 node-clone_2.1.2-1 node-color-convert_1.9.0-2 node-color-name_1.1.3-1 node-cross-spawn_5.1.0-1 node-decamelize_1.2.0-1 node-defaults_1.0.3-1 node-execa_0.10.0+dfsg-1 node-find-up_2.1.0-1 node-get-caller-file_1.0.2-1 node-get-stream_3.0.0-1 node-invert-kv_1.0.0-1 node-is-stream_1.1.0-1 node-isexe_2.0.0-3 node-lcid_1.0.0-1 node-locate-path_2.0.0-1 node-lodash-compat_3.10.2-1 node-lru-cache_4.1.1-1 node-mem_1.1.0-1 node-mimic-fn_1.1.0-1 node-npm-run-path_2.0.2-2 node-os-locale_2.0.0-1 node-p-finally_1.0.0-2 node-p-limit_1.1.0-1 node-p-locate_2.0.0-1 node-path-exists_3.0.0-1 node-pegjs_0.7.0-2 node-pend_1.2.0-1 node-pseudomap_1.0.2-1 node-require-directory_2.1.1-1 node-require-main-filename_1.0.1-1 node-set-blocking_2.0.0-1 node-shebang-command_1.2.0-1 node-shebang-regex_2.0.0-1 node-signal-exit_3.0.2-1 node-string-width_2.1.1-1 node-strip-ansi_4.0.0-1 node-strip-eof_1.0.0-2 node-uglify_2.8.29-3 node-wcwidth.js_1.0.0-1 node-which_1.3.0-1 node-which-module_2.0.0-1 node-wrap-ansi_3.0.1-1 node-y18n_3.2.1-2 node-yallist_2.0.0-1 node-yargs_10.0.3-2 node-yargs-parser_8.0.0-1 nodejs_8.11.1~dfsg-2 openssl_1.1.0h-2 passwd_1:4.5-1 patch_2.7.6-2 perl_5.26.2-3 perl-base_5.26.2-3 perl-modules-5.26_5.26.2-3 po-debconf_1.0.20 poppler-data_0.4.9-2 preview-latex-style_11.91-1 python_2.7.15~rc1-1 python-babel-localedata_2.4.0+dfsg.1-2 python-decorator_4.1.2-1 python-dev_2.7.15~rc1-1 python-minimal_2.7.15~rc1-1 python-nose_1.3.7-4 python-nose-parameterized_0.3.4-4 python-numpy_1:1.13.3-2 python-pkg-resources_39.0.1-2 python-scipy_0.19.1-2 python-setuptools_39.0.1-2 python-six_1.11.0-2 python2.7_2.7.15-1 python2.7-dev_2.7.15-1 python2.7-minimal_2.7.15-1 python3_3.6.5-3 python3-alabaster_0.7.8-1 python3-babel_2.4.0+dfsg.1-2 python3-certifi_2018.1.18-3 python3-chardet_3.0.4-1 python3-decorator_4.1.2-1 python3-dev_3.6.5-3 python3-distutils_3.6.5-3 python3-docutils_0.14+dfsg-3 python3-idna_2.6-1 python3-imagesize_0.7.1-1 python3-jinja2_2.10-1 python3-lib2to3_3.6.5-3 python3-markupsafe_1.0-1+b1 python3-minimal_3.6.5-3 python3-nose_1.3.7-4 python3-nose-parameterized_0.3.4-4 python3-numpy_1:1.13.3-2 python3-packaging_17.1-1 python3-pkg-resources_39.0.1-2 python3-pygments_2.2.0+dfsg-1 python3-pyparsing_2.2.0+dfsg1-2 python3-requests_2.18.4-2 python3-roman_2.0.0-3 python3-scipy_0.19.1-2 python3-setuptools_39.0.1-2 python3-six_1.11.0-2 python3-sphinx_1.7.4-1 python3-sphinx-rtd-theme_0.2.4-1 python3-tz_2018.4-1 python3-urllib3_1.22-1 python3.6_3.6.5-5 python3.6-dev_3.6.5-5 python3.6-minimal_3.6.5-5 rdfind_1.3.5-1 readline-common_7.0-3 sbuild-build-depends-core-dummy_0.invalid.0 sbuild-build-depends-theano-dummy_0.invalid.0 sed_4.4-2 sensible-utils_0.0.12 sgml-base_1.29 sphinx-common_1.7.4-1 sphinx-rtd-theme-common_0.2.4-1 symlinks_1.4-3+b1 sysvinit-utils_2.88dsf-59.10 t1utils_1.41-2 tar_1.30+dfsg-1 tex-common_6.09 texlive-base_2018.20180416-1 texlive-binaries_2018.20180416.47457-2 texlive-latex-base_2018.20180416-1 texlive-latex-extra_2018.20180416-1 texlive-latex-recommended_2018.20180416-1 texlive-pictures_2018.20180416-1 tzdata_2018d-1 ucf_3.0038 util-linux_2.31.1-0.5 x11-common_1:7.7+19 xdg-utils_1.1.2-2 xml-core_0.18 xz-utils_5.2.2-1.3 zlib1g_1:1.2.11.dfsg-1

+------------------------------------------------------------------------------+
| Build                                                                        |
+------------------------------------------------------------------------------+


Unpack source
-------------

gpgv: unknown type of key resource 'trustedkeys.kbx'
gpgv: keyblock resource '/sbuild-nonexistent/.gnupg/trustedkeys.kbx': General error
gpgv: Signature made Thu Nov  9 00:48:20 2017 UTC
gpgv:                using RSA key 46CB1CA89EA3B74376761DB915E09AF4DF5182C8
gpgv: Can't check signature: No public key
dpkg-source: warning: failed to verify signature on ./theano_0.9.0+dfsg-2.dsc
dpkg-source: info: extracting theano in /<<BUILDDIR>>/theano-0.9.0+dfsg
dpkg-source: info: unpacking theano_0.9.0+dfsg.orig.tar.gz
dpkg-source: info: unpacking theano_0.9.0+dfsg-2.debian.tar.xz
dpkg-source: info: applying disable-overly-environment-dependent-test.patch
dpkg-source: info: applying strip-docs.patch
dpkg-source: info: applying linkcode.patch
dpkg-source: info: applying old-nose-parameterized.patch
dpkg-source: info: applying 878596.patch

Check disk space
----------------

Sufficient free space for build

User Environment
----------------

APT_CONFIG=/var/lib/sbuild/apt.conf
HOME=/sbuild-nonexistent
LANG=en_US.UTF-8
LC_ALL=POSIX
LOGNAME=user42
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
SCHROOT_ALIAS_NAME=unstable-amd64-sbuild
SCHROOT_CHROOT_NAME=unstable-amd64-sbuild
SCHROOT_COMMAND=env
SCHROOT_GID=1001
SCHROOT_GROUP=user42
SCHROOT_SESSION_ID=unstable-amd64-sbuild-3cab53e2-0e2e-4e57-b08b-da1fdd6297d6
SCHROOT_UID=1001
SCHROOT_USER=user42
SHELL=/bin/sh
USER=user42

dpkg-buildpackage
-----------------

dpkg-buildpackage: info: source package theano
dpkg-buildpackage: info: source version 0.9.0+dfsg-2
dpkg-buildpackage: info: source distribution unstable
dpkg-buildpackage: info: source changed by Daniel Stender <stender@debian.org>
 dpkg-source --before-build theano-0.9.0+dfsg
dpkg-buildpackage: info: host architecture amd64
dpkg-source: info: using options from theano-0.9.0+dfsg/debian/source/options: --extend-diff-ignore=theano/generated_version.py|^[^/]+\.egg-info/
 fakeroot debian/rules clean
dh clean --with python2,python3,sphinxdoc --buildsystem=pybuild
   debian/rules override_dh_auto_clean
make[1]: Entering directory '/<<BUILDDIR>>/theano-0.9.0+dfsg'
rm -rf theano/d3viz/js/*.min.js doc/library/d3viz/examples/d3viz/js/*.min.js debian/missing-source/*.js debian/missing-source/lodash debian/missing-source/graphlib-dot/bower.json debian/missing-source/graphlib-dot/lib/dot-grammar.js debian/missing-source/graphlib-dot/lib/version.js debian/missing-source/graphlib-dot/dist doc/.pybuild Theano.egg-info
make -C debian/missing-source/graphlib-dot clean
make[2]: Entering directory '/<<BUILDDIR>>/theano-0.9.0+dfsg/debian/missing-source/graphlib-dot'
rm -rf build
make[2]: Leaving directory '/<<BUILDDIR>>/theano-0.9.0+dfsg/debian/missing-source/graphlib-dot'
dh_auto_clean
I: pybuild base:217: python2.7 setup.py clean 
running clean
removing '/<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/cpython2_2.7_theano/build' (and everything under it)
'build/bdist.linux-amd64' does not exist -- can't clean it
'build/scripts-2.7' does not exist -- can't clean it
I: pybuild base:217: python3.6 setup.py clean 
running clean
removing '/<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/cpython3_3.6_theano/build' (and everything under it)
'build/bdist.linux-amd64' does not exist -- can't clean it
'build/scripts-3.6' does not exist -- can't clean it
make[1]: Leaving directory '/<<BUILDDIR>>/theano-0.9.0+dfsg'
   dh_clean -O--buildsystem=pybuild
 debian/rules build-arch
dh build-arch --with python2,python3,sphinxdoc --buildsystem=pybuild
   dh_update_autotools_config -a -O--buildsystem=pybuild
   dh_autoreconf -a -O--buildsystem=pybuild
   dh_auto_configure -a -O--buildsystem=pybuild
I: pybuild base:217: python2.7 setup.py config 
running config
I: pybuild base:217: python3.6 setup.py config 
running config
   debian/rules override_dh_auto_build
make[1]: Entering directory '/<<BUILDDIR>>/theano-0.9.0+dfsg'
ln -s /usr/lib/nodejs/lodash-compat debian/missing-source/lodash
#graphlib-dot.js
make -C debian/missing-source/graphlib-dot --always-make dist
make[2]: Entering directory '/<<BUILDDIR>>/theano-0.9.0+dfsg/debian/missing-source/graphlib-dot'
pegjs -e 'module.exports' src/dot-grammar.pegjs lib/dot-grammar.js
cp build/graphlib-dot.js build/graphlib-dot.min.js dist
make[2]: Leaving directory '/<<BUILDDIR>>/theano-0.9.0+dfsg/debian/missing-source/graphlib-dot'
cp debian/missing-source/graphlib-dot/dist/graphlib-dot.min.js theano/d3viz/js
#dagre-d3.js
browserify-lite ./debian/missing-source/dagre-d3/index.js --outfile debian/missing-source/dagre-d3.js --standalone dagreD3
uglifyjs debian/missing-source/dagre-d3.js --comments '@license' -o theano/d3viz/js/dagre-d3.min.js
#d3 - workaround for #745688
uglifyjs /usr/share/javascript/d3/d3.js -m -c --comments '@license' -o theano/d3viz/js/d3.v3.min.js
cp theano/d3viz/js/*.min.js doc/library/d3viz/examples/d3viz/js
#theano itself doesn't need a build as such
make[1]: Leaving directory '/<<BUILDDIR>>/theano-0.9.0+dfsg'
   debian/rules override_dh_auto_test
make[1]: Entering directory '/<<BUILDDIR>>/theano-0.9.0+dfsg'
PYBUILD_SYSTEM=custom PYBUILD_TEST_ARGS='PYTHONPATH=. {interpreter} bin/theano-nose -v' dh_auto_test
I: pybuild base:217: PYTHONPATH=. python2.7 bin/theano-nose -v
/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/misc/pycuda_init.py:35: UserWarning: PyCUDA import failed in theano.misc.pycuda_init
  warnings.warn("PyCUDA import failed in theano.misc.pycuda_init")
/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/sandbox/gpuarray/__init__.py:10: UserWarning: theano.sandbox.gpuarray has been moved to theano.gpuarray. Please update your code and pickles. If the warning persists, clear theano's cache ('$theano/bin/theano-cache clear').
  warnings.warn(message)
test_connection_pattern_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_connection_pattern_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_grad_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V1;
00021	        
00022	
00023	        __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331() {
00024	            // This is only somewhat safe because we:
00025	            //  1) Are not a virtual class
00026	            //  2) Do not use any virtual classes in the members
00027	            //  3) Deal with mostly POD and pointers
00028	
00029	            // If this changes, we would have to revise this, but for
00030	            // now I am tired of chasing segfaults because
00031	            // initialization code had an error and some pointer has
00032	            // a junk value.
00033	            memset(this, 0, sizeof(*this));
00034	        }
00035	        ~__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331(void) {
00036	            cleanup();
00037	        }
00038	
00039	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V1) {
00040	            Py_XINCREF(storage_V3);
00041	Py_XINCREF(storage_V5);
00042	Py_XINCREF(storage_V7);
00043	Py_XINCREF(storage_V1);
00044	            this->storage_V3 = storage_V3;
00045	this->storage_V5 = storage_V5;
00046	this->storage_V7 = storage_V7;
00047	this->storage_V1 = storage_V1;
00048	            
00049	
00050	
00051	
00052	
00053	
00054	            this->__ERROR = __ERROR;
00055	            return 0;
00056	        }
00057	        void cleanup(void) {
00058	            __label_1:
00059	
00060	double __DUMMY_1;
00061	__label_3:
00062	
00063	double __DUMMY_3;
00064	__label_5:
00065	
00066	double __DUMMY_5;
00067	__label_7:
00068	
00069	double __DUMMY_7;
00070	__label_10:
00071	
00072	double __DUMMY_10;
00073	
00074	            Py_XDECREF(this->storage_V3);
00075	Py_XDECREF(this->storage_V5);
00076	Py_XDECREF(this->storage_V7);
00077	Py_XDECREF(this->storage_V1);
00078	        }
00079	        int run(void) {
00080	            int __failure = 0;
00081	            
00082	    PyObject* py_V1;
00083	    
00084	        PyArrayObject* V1;
00085	        
00086	            typedef npy_float64 dtype_V1;
00087	            
00088	    PyObject* py_V3;
00089	    
00090	        PyArrayObject* V3;
00091	        
00092	            typedef npy_float64 dtype_V3;
00093	            
00094	    PyObject* py_V5;
00095	    
00096	        PyArrayObject* V5;
00097	        
00098	            typedef npy_float64 dtype_V5;
00099	            
00100	    PyObject* py_V7;
00101	    
00102	        PyArrayObject* V7;
00103	        
00104	            typedef npy_float64 dtype_V7;
00105	            
00106	{
00107	
00108	    py_V1 = Py_None;
00109	    {Py_XINCREF(py_V1);}
00110	    
00111	        V1 = NULL;
00112	        
00113	{
00114	
00115	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00116	    {Py_XINCREF(py_V3);}
00117	    
00118	            V3 = NULL;
00119	            if (py_V3 == Py_None) {
00120	                // We can either fail here or set V3 to NULL and rely on Ops
00121	                // using tensors to handle the NULL case, but if they fail to do so
00122	                // they'll end up with nasty segfaults, so this is public service.
00123	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00124	                {
00125	        __failure = 4;
00126	        if (!PyErr_Occurred()) {
00127	            PyErr_SetString(PyExc_RuntimeError,
00128	                "Unexpected error in an Op's C code. "
00129	                "No Python exception was set.");
00130	            }
00131	        goto __label_4;}
00132	            }
00133	            if (!PyArray_Check(py_V3)) {
00134	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00135	                {
00136	        __failure = 4;
00137	        if (!PyErr_Occurred()) {
00138	            PyErr_SetString(PyExc_RuntimeError,
00139	                "Unexpected error in an Op's C code. "
00140	                "No Python exception was set.");
00141	            }
00142	        goto __label_4;}
00143	            }
00144	            // We expect NPY_FLOAT64
00145	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00146	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00147	                PyErr_Format(PyExc_NotImplementedError,
00148	                             "expected an aligned array of type %ld "
00149	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00150	                             " with %ld dimensions, with 3 last dims "
00151	                             "%ld, %ld, %ld"
00152	                             " and 3 last strides %ld %ld, %ld.",
00153	                             (long int) NPY_FLOAT64,
00154	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00155	                             (long int) PyArray_NDIM(tmp),
00156	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00157	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00158	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00159	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00160	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00161	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00162	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00163	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00164	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00165	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00166	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00167	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00168	            );
00169	                {
00170	        __failure = 4;
00171	        if (!PyErr_Occurred()) {
00172	            PyErr_SetString(PyExc_RuntimeError,
00173	                "Unexpected error in an Op's C code. "
00174	                "No Python exception was set.");
00175	            }
00176	        goto __label_4;}
00177	            }
00178	            // This is a TypeError to be consistent with DEBUG_MODE
00179	            // Note: DEBUG_MODE also tells the name of the container
00180	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00181	                PyErr_Format(PyExc_TypeError,
00182	                             "expected type_num %d (NPY_FLOAT64) got %d",
00183	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            
00194	        V3 = (PyArrayObject*)(py_V3);
00195	        Py_XINCREF(V3);
00196	        
00197	{
00198	
00199	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00200	    {Py_XINCREF(py_V5);}
00201	    
00202	            V5 = NULL;
00203	            if (py_V5 == Py_None) {
00204	                // We can either fail here or set V5 to NULL and rely on Ops
00205	                // using tensors to handle the NULL case, but if they fail to do so
00206	                // they'll end up with nasty segfaults, so this is public service.
00207	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00208	                {
00209	        __failure = 6;
00210	        if (!PyErr_Occurred()) {
00211	            PyErr_SetString(PyExc_RuntimeError,
00212	                "Unexpected error in an Op's C code. "
00213	                "No Python exception was set.");
00214	            }
00215	        goto __label_6;}
00216	            }
00217	            if (!PyArray_Check(py_V5)) {
00218	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00219	                {
00220	        __failure = 6;
00221	        if (!PyErr_Occurred()) {
00222	            PyErr_SetString(PyExc_RuntimeError,
00223	                "Unexpected error in an Op's C code. "
00224	                "No Python exception was set.");
00225	            }
00226	        goto __label_6;}
00227	            }
00228	            // We expect NPY_FLOAT64
00229	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00230	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00231	                PyErr_Format(PyExc_NotImplementedError,
00232	                             "expected an aligned array of type %ld "
00233	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00234	                             " with %ld dimensions, with 3 last dims "
00235	                             "%ld, %ld, %ld"
00236	                             " and 3 last strides %ld %ld, %ld.",
00237	                             (long int) NPY_FLOAT64,
00238	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00239	                             (long int) PyArray_NDIM(tmp),
00240	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00241	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00242	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00243	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00244	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00245	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00246	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00247	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00248	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00249	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00250	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00251	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00252	            );
00253	                {
00254	        __failure = 6;
00255	        if (!PyErr_Occurred()) {
00256	            PyErr_SetString(PyExc_RuntimeError,
00257	                "Unexpected error in an Op's C code. "
00258	                "No Python exception was set.");
00259	            }
00260	        goto __label_6;}
00261	            }
00262	            // This is a TypeError to be consistent with DEBUG_MODE
00263	            // Note: DEBUG_MODE also tells the name of the container
00264	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00265	                PyErr_Format(PyExc_TypeError,
00266	                             "expected type_num %d (NPY_FLOAT64) got %d",
00267	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00268	                {
00269	        __failure = 6;
00270	        if (!PyErr_Occurred()) {
00271	            PyErr_SetString(PyExc_RuntimeError,
00272	                "Unexpected error in an Op's C code. "
00273	                "No Python exception was set.");
00274	            }
00275	        goto __label_6;}
00276	            }
00277	            
00278	        V5 = (PyArrayObject*)(py_V5);
00279	        Py_XINCREF(V5);
00280	        
00281	{
00282	
00283	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00284	    {Py_XINCREF(py_V7);}
00285	    
00286	            V7 = NULL;
00287	            if (py_V7 == Py_None) {
00288	                // We can either fail here or set V7 to NULL and rely on Ops
00289	                // using tensors to handle the NULL case, but if they fail to do so
00290	                // they'll end up with nasty segfaults, so this is public service.
00291	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00292	                {
00293	        __failure = 8;
00294	        if (!PyErr_Occurred()) {
00295	            PyErr_SetString(PyExc_RuntimeError,
00296	                "Unexpected error in an Op's C code. "
00297	                "No Python exception was set.");
00298	            }
00299	        goto __label_8;}
00300	            }
00301	            if (!PyArray_Check(py_V7)) {
00302	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00303	                {
00304	        __failure = 8;
00305	        if (!PyErr_Occurred()) {
00306	            PyErr_SetString(PyExc_RuntimeError,
00307	                "Unexpected error in an Op's C code. "
00308	                "No Python exception was set.");
00309	            }
00310	        goto __label_8;}
00311	            }
00312	            // We expect NPY_FLOAT64
00313	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00314	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00315	                PyErr_Format(PyExc_NotImplementedError,
00316	                             "expected an aligned array of type %ld "
00317	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00318	                             " with %ld dimensions, with 3 last dims "
00319	                             "%ld, %ld, %ld"
00320	                             " and 3 last strides %ld %ld, %ld.",
00321	                             (long int) NPY_FLOAT64,
00322	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00323	                             (long int) PyArray_NDIM(tmp),
00324	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00325	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00326	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00327	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00328	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00329	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00330	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00331	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00332	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00333	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00334	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00335	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00336	            );
00337	                {
00338	        __failure = 8;
00339	        if (!PyErr_Occurred()) {
00340	            PyErr_SetString(PyExc_RuntimeError,
00341	                "Unexpected error in an Op's C code. "
00342	                "No Python exception was set.");
00343	            }
00344	        goto __label_8;}
00345	            }
00346	            // This is a TypeError to be consistent with DEBUG_MODE
00347	            // Note: DEBUG_MODE also tells the name of the container
00348	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00349	                PyErr_Format(PyExc_TypeError,
00350	                             "expected type_num %d (NPY_FLOAT64) got %d",
00351	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00352	                {
00353	        __failure = 8;
00354	        if (!PyErr_Occurred()) {
00355	            PyErr_SetString(PyExc_RuntimeError,
00356	                "Unexpected error in an Op's C code. "
00357	                "No Python exception was set.");
00358	            }
00359	        goto __label_8;}
00360	            }
00361	            
00362	        V7 = (PyArrayObject*)(py_V7);
00363	        Py_XINCREF(V7);
00364	        
00365	{
00366	// Op class Elemwise
00367	
00368	        npy_float64* V3_iter;
00369	        
00370	                npy_intp V3_n0;
00371	                ssize_t V3_stride0;
00372	                int V3_jump0_0;
00373	                
00374	                npy_intp V3_n1;
00375	                ssize_t V3_stride1;
00376	                int V3_jump1_1;
00377	                
00378	        npy_float64* V5_iter;
00379	        
00380	                npy_intp V5_n0;
00381	                ssize_t V5_stride0;
00382	                int V5_jump0_0;
00383	                
00384	                npy_intp V5_n1;
00385	                ssize_t V5_stride1;
00386	                int V5_jump1_1;
00387	                
00388	        npy_float64* V7_iter;
00389	        
00390	                npy_intp V7_n0;
00391	                ssize_t V7_stride0;
00392	                int V7_jump0_0;
00393	                
00394	                npy_intp V7_n1;
00395	                ssize_t V7_stride1;
00396	                int V7_jump1_1;
00397	                
00398	
00399	            if (PyArray_NDIM(V3) < 2) {
00400	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00401	                {
00402	        __failure = 9;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_9;}
00409	            }
00410	            
00411	                V3_n1 = PyArray_DIMS(V3)[1];
00412	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00413	                V3_jump1_1 = (V3_stride1) - (0);
00414	                //printf("V3_jump1_1 is:");
00415	                //std::cout << V3_jump1_1 << std::endl;
00416	                
00417	                V3_n0 = PyArray_DIMS(V3)[0];
00418	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00419	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00420	                //printf("V3_jump0_0 is:");
00421	                //std::cout << V3_jump0_0 << std::endl;
00422	                
00423	            if (PyArray_NDIM(V5) < 2) {
00424	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00425	                {
00426	        __failure = 9;
00427	        if (!PyErr_Occurred()) {
00428	            PyErr_SetString(PyExc_RuntimeError,
00429	                "Unexpected error in an Op's C code. "
00430	                "No Python exception was set.");
00431	            }
00432	        goto __label_9;}
00433	            }
00434	            
00435	                V5_n1 = PyArray_DIMS(V5)[1];
00436	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00437	                V5_jump1_1 = (V5_stride1) - (0);
00438	                //printf("V5_jump1_1 is:");
00439	                //std::cout << V5_jump1_1 << std::endl;
00440	                
00441	                V5_n0 = PyArray_DIMS(V5)[0];
00442	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00443	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00444	                //printf("V5_jump0_0 is:");
00445	                //std::cout << V5_jump0_0 << std::endl;
00446	                
00447	            if (PyArray_NDIM(V7) < 2) {
00448	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00449	                {
00450	        __failure = 9;
00451	        if (!PyErr_Occurred()) {
00452	            PyErr_SetString(PyExc_RuntimeError,
00453	                "Unexpected error in an Op's C code. "
00454	                "No Python exception was set.");
00455	            }
00456	        goto __label_9;}
00457	            }
00458	            
00459	                V7_n1 = PyArray_DIMS(V7)[1];
00460	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00461	                V7_jump1_1 = (V7_stride1) - (0);
00462	                //printf("V7_jump1_1 is:");
00463	                //std::cout << V7_jump1_1 << std::endl;
00464	                
00465	                V7_n0 = PyArray_DIMS(V7)[0];
00466	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00467	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00468	                //printf("V7_jump0_0 is:");
00469	                //std::cout << V7_jump0_0 << std::endl;
00470	                
00471	            if (V3_n0 != V5_n0)
00472	            {
00473	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00474	                   0,
00475	                   0,
00476	                   V3_n0,
00477	                   1,
00478	                   0,
00479	                   V5_n0
00480	                );
00481	                {
00482	        __failure = 9;
00483	        if (!PyErr_Occurred()) {
00484	            PyErr_SetString(PyExc_RuntimeError,
00485	                "Unexpected error in an Op's C code. "
00486	                "No Python exception was set.");
00487	            }
00488	        goto __label_9;}
00489	            }
00490	            
00491	            if (V3_n0 != V7_n0)
00492	            {
00493	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00494	                   0,
00495	                   0,
00496	                   V3_n0,
00497	                   2,
00498	                   0,
00499	                   V7_n0
00500	                );
00501	                {
00502	        __failure = 9;
00503	        if (!PyErr_Occurred()) {
00504	            PyErr_SetString(PyExc_RuntimeError,
00505	                "Unexpected error in an Op's C code. "
00506	                "No Python exception was set.");
00507	            }
00508	        goto __label_9;}
00509	            }
00510	            
00511	            if (V3_n1 != V5_n1)
00512	            {
00513	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00514	                   0,
00515	                   1,
00516	                   V3_n1,
00517	                   1,
00518	                   1,
00519	                   V5_n1
00520	                );
00521	                {
00522	        __failure = 9;
00523	        if (!PyErr_Occurred()) {
00524	            PyErr_SetString(PyExc_RuntimeError,
00525	                "Unexpected error in an Op's C code. "
00526	                "No Python exception was set.");
00527	            }
00528	        goto __label_9;}
00529	            }
00530	            
00531	            if (V3_n1 != V7_n1)
00532	            {
00533	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00534	                   0,
00535	                   1,
00536	                   V3_n1,
00537	                   2,
00538	                   1,
00539	                   V7_n1
00540	                );
00541	                {
00542	        __failure = 9;
00543	        if (!PyErr_Occurred()) {
00544	            PyErr_SetString(PyExc_RuntimeError,
00545	                "Unexpected error in an Op's C code. "
00546	                "No Python exception was set.");
00547	            }
00548	        goto __label_9;}
00549	            }
00550	            
00551	
00552	        npy_float64* V1_iter;
00553	        
00554	                npy_intp V1_n0;
00555	                ssize_t V1_stride0;
00556	                int V1_jump0_0;
00557	                
00558	                npy_intp V1_n1;
00559	                ssize_t V1_stride1;
00560	                int V1_jump1_1;
00561	                
00562	    {
00563	        npy_intp dims[2];
00564	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00565	        dims[0] = V3_n0;
00566	dims[1] = V3_n1;
00567	
00568	        if (!V1) {
00569	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00570	                                                    NPY_FLOAT64,
00571	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7));
00572	        }
00573	        else {
00574	            PyArray_Dims new_dims;
00575	            new_dims.len = 2;
00576	            new_dims.ptr = dims;
00577	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00578	            if (!success) {
00579	                // If we can't resize the ndarray we have we can allocate a new one.
00580	                PyErr_Clear();
00581	                Py_XDECREF(V1);
00582	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00583	            }
00584	        }
00585	        if (!V1) {
00586	            {
00587	        __failure = 9;
00588	        if (!PyErr_Occurred()) {
00589	            PyErr_SetString(PyExc_RuntimeError,
00590	                "Unexpected error in an Op's C code. "
00591	                "No Python exception was set.");
00592	            }
00593	        goto __label_9;}
00594	        }
00595	    }
00596	    
00597	            if (PyArray_NDIM(V1) < 2) {
00598	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00599	                {
00600	        __failure = 9;
00601	        if (!PyErr_Occurred()) {
00602	            PyErr_SetString(PyExc_RuntimeError,
00603	                "Unexpected error in an Op's C code. "
00604	                "No Python exception was set.");
00605	            }
00606	        goto __label_9;}
00607	            }
00608	            
00609	                V1_n1 = PyArray_DIMS(V1)[1];
00610	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00611	                V1_jump1_1 = (V1_stride1) - (0);
00612	                //printf("V1_jump1_1 is:");
00613	                //std::cout << V1_jump1_1 << std::endl;
00614	                
00615	                V1_n0 = PyArray_DIMS(V1)[0];
00616	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00617	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00618	                //printf("V1_jump0_0 is:");
00619	                //std::cout << V1_jump0_0 << std::endl;
00620	                
00621	
00622	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V1))){
00623	                
00624	                    // All output have the same size
00625	                    npy_intp n = PyArray_SIZE(V1);
00626	                    
00627	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00628	                            
00629	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00630	                            
00631	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00632	                            
00633	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00634	                            
00635	                    for(int i=0; i<n; i++){
00636	                        
00637	            dtype_V3& V3_i = V3_ptr[i];
00638	                            
00639	            dtype_V5& V5_i = V5_ptr[i];
00640	                            
00641	            dtype_V7& V7_i = V7_ptr[i];
00642	                            
00643	            dtype_V1& V1_i = V1_ptr[i];
00644	                            
00645	                        {
00646	npy_float64 V9_tmp1;
00647	V9_tmp1 = V5_i * V7_i;
00648	V1_i = V3_i + V9_tmp1;
00649	}
00650	;
00651	                    }
00652	                    
00653	            }else{
00654	                {
00655	
00656	    std::vector< std::pair<int, int> > V1_loops(2);
00657	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00658	    
00659	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00660	            
00661	        V1_loops_it->second = 0;
00662	        ++V1_loops_it;
00663	        
00664	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00665	            
00666	        V1_loops_it->second = 1;
00667	        ++V1_loops_it;
00668	        
00669	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00670	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00671	    
00672	
00673	    int init_totals[2] = {V3_n0, V3_n1};
00674	    
00675	    V1_loops_it = V1_loops.begin();
00676	    
00677	        int TOTAL_0 = init_totals[V1_loops_it->second];
00678	        ++V1_loops_it;
00679	        
00680	        int TOTAL_1 = init_totals[V1_loops_it->second];
00681	        ++V1_loops_it;
00682	        
00683	
00684	    int init_strides[4][2] = {
00685	        V3_stride0, V3_stride1, 
00686	V5_stride0, V5_stride1, 
00687	V7_stride0, V7_stride1, 
00688	V1_stride0, V1_stride1
00689	    };
00690	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00691	    
00692	        V1_loops_rit = V1_loops.rbegin();
00693	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00694	            ++V1_loops_rit;
00695	            
00696	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00697	            ++V1_loops_rit;
00698	            
00699	        V1_loops_rit = V1_loops.rbegin();
00700	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00701	            ++V1_loops_rit;
00702	            
00703	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00704	            ++V1_loops_rit;
00705	            
00706	        V1_loops_rit = V1_loops.rbegin();
00707	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00708	            ++V1_loops_rit;
00709	            
00710	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00711	            ++V1_loops_rit;
00712	            
00713	        V1_loops_rit = V1_loops.rbegin();
00714	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00715	            ++V1_loops_rit;
00716	            
00717	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00718	            ++V1_loops_rit;
00719	            
00720	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00721	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00722	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00723	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00724	
00725	
00726	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00727	        { // begin loop 0
00728	            
00729	            
00730	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00731	        { // begin loop 1
00732	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00733	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00734	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00735	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00736	
00737	            
00738	        {
00739	            
00740	            {
00741	npy_float64 V9_tmp1;
00742	V9_tmp1 = V5_i * V7_i;
00743	V1_i = V3_i + V9_tmp1;
00744	}
00745	
00746	            
00747	        }
00748	        
00749	        } // end loop 1
00750	        
00751	        } // end loop 0
00752	        
00753	}
00754	
00755	            }
00756	            __label_9:
00757	
00758	double __DUMMY_9;
00759	
00760	}
00761	__label_8:
00762	
00763	        if (V7) {
00764	            Py_XDECREF(V7);
00765	        }
00766	        
00767	    {Py_XDECREF(py_V7);}
00768	    
00769	double __DUMMY_8;
00770	
00771	}
00772	__label_6:
00773	
00774	        if (V5) {
00775	            Py_XDECREF(V5);
00776	        }
00777	        
00778	    {Py_XDECREF(py_V5);}
00779	    
00780	double __DUMMY_6;
00781	
00782	}
00783	__label_4:
00784	
00785	        if (V3) {
00786	            Py_XDECREF(V3);
00787	        }
00788	        
00789	    {Py_XDECREF(py_V3);}
00790	    
00791	double __DUMMY_4;
00792	
00793	}
00794	__label_2:
00795	
00796	    if (!__failure) {
00797	      
00798	        {Py_XDECREF(py_V1);}
00799	        if (!V1) {
00800	            Py_INCREF(Py_None);
00801	            py_V1 = Py_None;
00802	        }
00803	        else if ((void*)py_V1 != (void*)V1) {
00804	            py_V1 = (PyObject*)V1;
00805	        }
00806	
00807	        {Py_XINCREF(py_V1);}
00808	
00809	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00810	            PyErr_Format(PyExc_NotImplementedError,
00811	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00812	                         " with %ld dimensions, with 3 last dims "
00813	                         "%ld, %ld, %ld"
00814	                         " and 3 last strides %ld %ld, %ld.",
00815	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00816	                         (long int) PyArray_NDIM(V1),
00817	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00818	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00819	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00820	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00821	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00822	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00823	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00824	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00825	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00826	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00827	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00828	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00829	        );
00830	            {
00831	        __failure = 2;
00832	        if (!PyErr_Occurred()) {
00833	            PyErr_SetString(PyExc_RuntimeError,
00834	                "Unexpected error in an Op's C code. "
00835	                "No Python exception was set.");
00836	            }
00837	        goto __label_2;}
00838	        }
00839	        
00840	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00841	      {Py_XINCREF(py_V1);}
00842	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00843	      {Py_XDECREF(old);}
00844	    }
00845	    
00846	        if (V1) {
00847	            Py_XDECREF(V1);
00848	        }
00849	        
00850	    {Py_XDECREF(py_V1);}
00851	    
00852	double __DUMMY_2;
00853	
00854	}
00855	
00856	            
00857	        if (__failure) {
00858	            // When there is a failure, this code puts the exception
00859	            // in __ERROR.
00860	            PyObject* err_type = NULL;
00861	            PyObject* err_msg = NULL;
00862	            PyObject* err_traceback = NULL;
00863	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00864	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00865	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00866	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00867	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00868	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00869	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00870	            PyList_SET_ITEM(__ERROR, 0, err_type);
00871	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00872	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00873	            {Py_XDECREF(old_err_type);}
00874	            {Py_XDECREF(old_err_msg);}
00875	            {Py_XDECREF(old_err_traceback);}
00876	        }
00877	        // The failure code is returned to index what code block failed.
00878	        return __failure;
00879	        
00880	        }
00881	    };
00882	    }
00883	    
00884	
00885	        static int __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_executor(__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331* self) {
00886	            return self->run();
00887	        }
00888	
00889	        static void __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_destructor(void* executor, void* self) {
00890	            delete ((__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331*)self);
00891	        }
00892	        
00893	//////////////////////
00894	////  Functions
00895	//////////////////////
00896	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00897	  assert(PyTuple_Check(argtuple));
00898	  if (5 != PyTuple_Size(argtuple)){ 
00899	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
00900	     return NULL;
00901	  }
00902	  __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331* struct_ptr = new __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331();
00903	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
00904	    delete struct_ptr;
00905	    return NULL;
00906	  }
00907	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_executor), struct_ptr, __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_destructor);
00908	  return thunk; }
00909	
00910	//////////////////////
00911	////  Module init
00912	//////////////////////
00913	static PyMethodDef MyMethods[] = {
00914		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00915		{NULL, NULL, 0, NULL}
00916	};
00917	PyMODINIT_FUNC initb91887856157bcaaaf7e3d73e9cce331(void){
00918	   import_array();
00919	   (void) Py_InitModule("b91887856157bcaaaf7e3d73e9cce331", MyMethods);
00920	}
00921	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpUX4Li0/b91887856157bcaaaf7e3d73e9cce331.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpUX4Li0/mod.cpp -lpython2.7
ERROR
test_grad_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_5331b1484fffcaeeb536a994be9de64d {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V1;
00021	        
00022	
00023	        __struct_compiled_op_5331b1484fffcaeeb536a994be9de64d() {
00024	            // This is only somewhat safe because we:
00025	            //  1) Are not a virtual class
00026	            //  2) Do not use any virtual classes in the members
00027	            //  3) Deal with mostly POD and pointers
00028	
00029	            // If this changes, we would have to revise this, but for
00030	            // now I am tired of chasing segfaults because
00031	            // initialization code had an error and some pointer has
00032	            // a junk value.
00033	            memset(this, 0, sizeof(*this));
00034	        }
00035	        ~__struct_compiled_op_5331b1484fffcaeeb536a994be9de64d(void) {
00036	            cleanup();
00037	        }
00038	
00039	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V1) {
00040	            Py_XINCREF(storage_V3);
00041	Py_XINCREF(storage_V5);
00042	Py_XINCREF(storage_V7);
00043	Py_XINCREF(storage_V1);
00044	            this->storage_V3 = storage_V3;
00045	this->storage_V5 = storage_V5;
00046	this->storage_V7 = storage_V7;
00047	this->storage_V1 = storage_V1;
00048	            
00049	
00050	
00051	
00052	
00053	
00054	            this->__ERROR = __ERROR;
00055	            return 0;
00056	        }
00057	        void cleanup(void) {
00058	            __label_1:
00059	
00060	double __DUMMY_1;
00061	__label_3:
00062	
00063	double __DUMMY_3;
00064	__label_5:
00065	
00066	double __DUMMY_5;
00067	__label_7:
00068	
00069	double __DUMMY_7;
00070	__label_10:
00071	
00072	double __DUMMY_10;
00073	
00074	            Py_XDECREF(this->storage_V3);
00075	Py_XDECREF(this->storage_V5);
00076	Py_XDECREF(this->storage_V7);
00077	Py_XDECREF(this->storage_V1);
00078	        }
00079	        int run(void) {
00080	            int __failure = 0;
00081	            
00082	    PyObject* py_V1;
00083	    
00084	        PyArrayObject* V1;
00085	        
00086	            typedef npy_float64 dtype_V1;
00087	            
00088	    PyObject* py_V3;
00089	    
00090	        PyArrayObject* V3;
00091	        
00092	            typedef npy_float64 dtype_V3;
00093	            
00094	    PyObject* py_V5;
00095	    
00096	        PyArrayObject* V5;
00097	        
00098	            typedef npy_float64 dtype_V5;
00099	            
00100	    PyObject* py_V7;
00101	    
00102	        PyArrayObject* V7;
00103	        
00104	            typedef npy_float64 dtype_V7;
00105	            
00106	{
00107	
00108	    py_V1 = Py_None;
00109	    {Py_XINCREF(py_V1);}
00110	    
00111	        V1 = NULL;
00112	        
00113	{
00114	
00115	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00116	    {Py_XINCREF(py_V3);}
00117	    
00118	            V3 = NULL;
00119	            if (py_V3 == Py_None) {
00120	                // We can either fail here or set V3 to NULL and rely on Ops
00121	                // using tensors to handle the NULL case, but if they fail to do so
00122	                // they'll end up with nasty segfaults, so this is public service.
00123	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00124	                {
00125	        __failure = 4;
00126	        if (!PyErr_Occurred()) {
00127	            PyErr_SetString(PyExc_RuntimeError,
00128	                "Unexpected error in an Op's C code. "
00129	                "No Python exception was set.");
00130	            }
00131	        goto __label_4;}
00132	            }
00133	            if (!PyArray_Check(py_V3)) {
00134	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00135	                {
00136	        __failure = 4;
00137	        if (!PyErr_Occurred()) {
00138	            PyErr_SetString(PyExc_RuntimeError,
00139	                "Unexpected error in an Op's C code. "
00140	                "No Python exception was set.");
00141	            }
00142	        goto __label_4;}
00143	            }
00144	            // We expect NPY_FLOAT64
00145	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00146	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00147	                PyErr_Format(PyExc_NotImplementedError,
00148	                             "expected an aligned array of type %ld "
00149	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00150	                             " with %ld dimensions, with 3 last dims "
00151	                             "%ld, %ld, %ld"
00152	                             " and 3 last strides %ld %ld, %ld.",
00153	                             (long int) NPY_FLOAT64,
00154	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00155	                             (long int) PyArray_NDIM(tmp),
00156	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00157	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00158	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00159	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00160	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00161	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00162	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00163	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00164	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00165	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00166	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00167	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00168	            );
00169	                {
00170	        __failure = 4;
00171	        if (!PyErr_Occurred()) {
00172	            PyErr_SetString(PyExc_RuntimeError,
00173	                "Unexpected error in an Op's C code. "
00174	                "No Python exception was set.");
00175	            }
00176	        goto __label_4;}
00177	            }
00178	            // This is a TypeError to be consistent with DEBUG_MODE
00179	            // Note: DEBUG_MODE also tells the name of the container
00180	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00181	                PyErr_Format(PyExc_TypeError,
00182	                             "expected type_num %d (NPY_FLOAT64) got %d",
00183	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            
00194	        V3 = (PyArrayObject*)(py_V3);
00195	        Py_XINCREF(V3);
00196	        
00197	{
00198	
00199	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00200	    {Py_XINCREF(py_V5);}
00201	    
00202	            V5 = NULL;
00203	            if (py_V5 == Py_None) {
00204	                // We can either fail here or set V5 to NULL and rely on Ops
00205	                // using tensors to handle the NULL case, but if they fail to do so
00206	                // they'll end up with nasty segfaults, so this is public service.
00207	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00208	                {
00209	        __failure = 6;
00210	        if (!PyErr_Occurred()) {
00211	            PyErr_SetString(PyExc_RuntimeError,
00212	                "Unexpected error in an Op's C code. "
00213	                "No Python exception was set.");
00214	            }
00215	        goto __label_6;}
00216	            }
00217	            if (!PyArray_Check(py_V5)) {
00218	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00219	                {
00220	        __failure = 6;
00221	        if (!PyErr_Occurred()) {
00222	            PyErr_SetString(PyExc_RuntimeError,
00223	                "Unexpected error in an Op's C code. "
00224	                "No Python exception was set.");
00225	            }
00226	        goto __label_6;}
00227	            }
00228	            // We expect NPY_FLOAT64
00229	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00230	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00231	                PyErr_Format(PyExc_NotImplementedError,
00232	                             "expected an aligned array of type %ld "
00233	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00234	                             " with %ld dimensions, with 3 last dims "
00235	                             "%ld, %ld, %ld"
00236	                             " and 3 last strides %ld %ld, %ld.",
00237	                             (long int) NPY_FLOAT64,
00238	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00239	                             (long int) PyArray_NDIM(tmp),
00240	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00241	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00242	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00243	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00244	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00245	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00246	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00247	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00248	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00249	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00250	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00251	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00252	            );
00253	                {
00254	        __failure = 6;
00255	        if (!PyErr_Occurred()) {
00256	            PyErr_SetString(PyExc_RuntimeError,
00257	                "Unexpected error in an Op's C code. "
00258	                "No Python exception was set.");
00259	            }
00260	        goto __label_6;}
00261	            }
00262	            // This is a TypeError to be consistent with DEBUG_MODE
00263	            // Note: DEBUG_MODE also tells the name of the container
00264	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00265	                PyErr_Format(PyExc_TypeError,
00266	                             "expected type_num %d (NPY_FLOAT64) got %d",
00267	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00268	                {
00269	        __failure = 6;
00270	        if (!PyErr_Occurred()) {
00271	            PyErr_SetString(PyExc_RuntimeError,
00272	                "Unexpected error in an Op's C code. "
00273	                "No Python exception was set.");
00274	            }
00275	        goto __label_6;}
00276	            }
00277	            
00278	        V5 = (PyArrayObject*)(py_V5);
00279	        Py_XINCREF(V5);
00280	        
00281	{
00282	
00283	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00284	    {Py_XINCREF(py_V7);}
00285	    
00286	            V7 = NULL;
00287	            if (py_V7 == Py_None) {
00288	                // We can either fail here or set V7 to NULL and rely on Ops
00289	                // using tensors to handle the NULL case, but if they fail to do so
00290	                // they'll end up with nasty segfaults, so this is public service.
00291	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00292	                {
00293	        __failure = 8;
00294	        if (!PyErr_Occurred()) {
00295	            PyErr_SetString(PyExc_RuntimeError,
00296	                "Unexpected error in an Op's C code. "
00297	                "No Python exception was set.");
00298	            }
00299	        goto __label_8;}
00300	            }
00301	            if (!PyArray_Check(py_V7)) {
00302	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00303	                {
00304	        __failure = 8;
00305	        if (!PyErr_Occurred()) {
00306	            PyErr_SetString(PyExc_RuntimeError,
00307	                "Unexpected error in an Op's C code. "
00308	                "No Python exception was set.");
00309	            }
00310	        goto __label_8;}
00311	            }
00312	            // We expect NPY_FLOAT64
00313	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00314	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00315	                PyErr_Format(PyExc_NotImplementedError,
00316	                             "expected an aligned array of type %ld "
00317	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00318	                             " with %ld dimensions, with 3 last dims "
00319	                             "%ld, %ld, %ld"
00320	                             " and 3 last strides %ld %ld, %ld.",
00321	                             (long int) NPY_FLOAT64,
00322	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00323	                             (long int) PyArray_NDIM(tmp),
00324	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00325	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00326	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00327	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00328	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00329	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00330	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00331	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00332	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00333	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00334	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00335	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00336	            );
00337	                {
00338	        __failure = 8;
00339	        if (!PyErr_Occurred()) {
00340	            PyErr_SetString(PyExc_RuntimeError,
00341	                "Unexpected error in an Op's C code. "
00342	                "No Python exception was set.");
00343	            }
00344	        goto __label_8;}
00345	            }
00346	            // This is a TypeError to be consistent with DEBUG_MODE
00347	            // Note: DEBUG_MODE also tells the name of the container
00348	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00349	                PyErr_Format(PyExc_TypeError,
00350	                             "expected type_num %d (NPY_FLOAT64) got %d",
00351	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00352	                {
00353	        __failure = 8;
00354	        if (!PyErr_Occurred()) {
00355	            PyErr_SetString(PyExc_RuntimeError,
00356	                "Unexpected error in an Op's C code. "
00357	                "No Python exception was set.");
00358	            }
00359	        goto __label_8;}
00360	            }
00361	            
00362	        V7 = (PyArrayObject*)(py_V7);
00363	        Py_XINCREF(V7);
00364	        
00365	{
00366	// Op class Elemwise
00367	
00368	        npy_float64* V3_iter;
00369	        
00370	                npy_intp V3_n0;
00371	                ssize_t V3_stride0;
00372	                int V3_jump0_0;
00373	                
00374	                npy_intp V3_n1;
00375	                ssize_t V3_stride1;
00376	                int V3_jump1_1;
00377	                
00378	        npy_float64* V5_iter;
00379	        
00380	                npy_intp V5_n0;
00381	                ssize_t V5_stride0;
00382	                int V5_jump0_0;
00383	                
00384	                npy_intp V5_n1;
00385	                ssize_t V5_stride1;
00386	                int V5_jump1_1;
00387	                
00388	        npy_float64* V7_iter;
00389	        
00390	                npy_intp V7_n0;
00391	                ssize_t V7_stride0;
00392	                int V7_jump0_0;
00393	                
00394	                npy_intp V7_n1;
00395	                ssize_t V7_stride1;
00396	                int V7_jump1_1;
00397	                
00398	
00399	            if (PyArray_NDIM(V3) < 2) {
00400	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00401	                {
00402	        __failure = 9;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_9;}
00409	            }
00410	            
00411	                V3_n1 = PyArray_DIMS(V3)[1];
00412	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00413	                V3_jump1_1 = (V3_stride1) - (0);
00414	                //printf("V3_jump1_1 is:");
00415	                //std::cout << V3_jump1_1 << std::endl;
00416	                
00417	                V3_n0 = PyArray_DIMS(V3)[0];
00418	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00419	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00420	                //printf("V3_jump0_0 is:");
00421	                //std::cout << V3_jump0_0 << std::endl;
00422	                
00423	            if (PyArray_NDIM(V5) < 2) {
00424	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00425	                {
00426	        __failure = 9;
00427	        if (!PyErr_Occurred()) {
00428	            PyErr_SetString(PyExc_RuntimeError,
00429	                "Unexpected error in an Op's C code. "
00430	                "No Python exception was set.");
00431	            }
00432	        goto __label_9;}
00433	            }
00434	            
00435	                V5_n1 = PyArray_DIMS(V5)[1];
00436	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00437	                V5_jump1_1 = (V5_stride1) - (0);
00438	                //printf("V5_jump1_1 is:");
00439	                //std::cout << V5_jump1_1 << std::endl;
00440	                
00441	                V5_n0 = PyArray_DIMS(V5)[0];
00442	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00443	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00444	                //printf("V5_jump0_0 is:");
00445	                //std::cout << V5_jump0_0 << std::endl;
00446	                
00447	            if (PyArray_NDIM(V7) < 2) {
00448	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00449	                {
00450	        __failure = 9;
00451	        if (!PyErr_Occurred()) {
00452	            PyErr_SetString(PyExc_RuntimeError,
00453	                "Unexpected error in an Op's C code. "
00454	                "No Python exception was set.");
00455	            }
00456	        goto __label_9;}
00457	            }
00458	            
00459	                V7_n1 = PyArray_DIMS(V7)[1];
00460	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00461	                V7_jump1_1 = (V7_stride1) - (0);
00462	                //printf("V7_jump1_1 is:");
00463	                //std::cout << V7_jump1_1 << std::endl;
00464	                
00465	                V7_n0 = PyArray_DIMS(V7)[0];
00466	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00467	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00468	                //printf("V7_jump0_0 is:");
00469	                //std::cout << V7_jump0_0 << std::endl;
00470	                
00471	            if (V3_n0 != V5_n0)
00472	            {
00473	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00474	                   0,
00475	                   0,
00476	                   V3_n0,
00477	                   1,
00478	                   0,
00479	                   V5_n0
00480	                );
00481	                {
00482	        __failure = 9;
00483	        if (!PyErr_Occurred()) {
00484	            PyErr_SetString(PyExc_RuntimeError,
00485	                "Unexpected error in an Op's C code. "
00486	                "No Python exception was set.");
00487	            }
00488	        goto __label_9;}
00489	            }
00490	            
00491	            if (V3_n0 != V7_n0)
00492	            {
00493	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00494	                   0,
00495	                   0,
00496	                   V3_n0,
00497	                   2,
00498	                   0,
00499	                   V7_n0
00500	                );
00501	                {
00502	        __failure = 9;
00503	        if (!PyErr_Occurred()) {
00504	            PyErr_SetString(PyExc_RuntimeError,
00505	                "Unexpected error in an Op's C code. "
00506	                "No Python exception was set.");
00507	            }
00508	        goto __label_9;}
00509	            }
00510	            
00511	            if (V3_n1 != V5_n1)
00512	            {
00513	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00514	                   0,
00515	                   1,
00516	                   V3_n1,
00517	                   1,
00518	                   1,
00519	                   V5_n1
00520	                );
00521	                {
00522	        __failure = 9;
00523	        if (!PyErr_Occurred()) {
00524	            PyErr_SetString(PyExc_RuntimeError,
00525	                "Unexpected error in an Op's C code. "
00526	                "No Python exception was set.");
00527	            }
00528	        goto __label_9;}
00529	            }
00530	            
00531	            if (V3_n1 != V7_n1)
00532	            {
00533	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00534	                   0,
00535	                   1,
00536	                   V3_n1,
00537	                   2,
00538	                   1,
00539	                   V7_n1
00540	                );
00541	                {
00542	        __failure = 9;
00543	        if (!PyErr_Occurred()) {
00544	            PyErr_SetString(PyExc_RuntimeError,
00545	                "Unexpected error in an Op's C code. "
00546	                "No Python exception was set.");
00547	            }
00548	        goto __label_9;}
00549	            }
00550	            
00551	
00552	        npy_float64* V1_iter;
00553	        
00554	                npy_intp V1_n0;
00555	                ssize_t V1_stride0;
00556	                int V1_jump0_0;
00557	                
00558	                npy_intp V1_n1;
00559	                ssize_t V1_stride1;
00560	                int V1_jump1_1;
00561	                
00562	    {
00563	        npy_intp dims[2];
00564	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00565	        dims[0] = V3_n0;
00566	dims[1] = V3_n1;
00567	
00568	        if (!V1) {
00569	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00570	                                                    NPY_FLOAT64,
00571	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7));
00572	        }
00573	        else {
00574	            PyArray_Dims new_dims;
00575	            new_dims.len = 2;
00576	            new_dims.ptr = dims;
00577	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00578	            if (!success) {
00579	                // If we can't resize the ndarray we have we can allocate a new one.
00580	                PyErr_Clear();
00581	                Py_XDECREF(V1);
00582	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00583	            }
00584	        }
00585	        if (!V1) {
00586	            {
00587	        __failure = 9;
00588	        if (!PyErr_Occurred()) {
00589	            PyErr_SetString(PyExc_RuntimeError,
00590	                "Unexpected error in an Op's C code. "
00591	                "No Python exception was set.");
00592	            }
00593	        goto __label_9;}
00594	        }
00595	    }
00596	    
00597	            if (PyArray_NDIM(V1) < 2) {
00598	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00599	                {
00600	        __failure = 9;
00601	        if (!PyErr_Occurred()) {
00602	            PyErr_SetString(PyExc_RuntimeError,
00603	                "Unexpected error in an Op's C code. "
00604	                "No Python exception was set.");
00605	            }
00606	        goto __label_9;}
00607	            }
00608	            
00609	                V1_n1 = PyArray_DIMS(V1)[1];
00610	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00611	                V1_jump1_1 = (V1_stride1) - (0);
00612	                //printf("V1_jump1_1 is:");
00613	                //std::cout << V1_jump1_1 << std::endl;
00614	                
00615	                V1_n0 = PyArray_DIMS(V1)[0];
00616	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00617	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00618	                //printf("V1_jump0_0 is:");
00619	                //std::cout << V1_jump0_0 << std::endl;
00620	                
00621	
00622	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V1))){
00623	                
00624	                    // All output have the same size
00625	                    npy_intp n = PyArray_SIZE(V1);
00626	                    
00627	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00628	                            
00629	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00630	                            
00631	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00632	                            
00633	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00634	                            
00635	                    for(int i=0; i<n; i++){
00636	                        
00637	            dtype_V3& V3_i = V3_ptr[i];
00638	                            
00639	            dtype_V5& V5_i = V5_ptr[i];
00640	                            
00641	            dtype_V7& V7_i = V7_ptr[i];
00642	                            
00643	            dtype_V1& V1_i = V1_ptr[i];
00644	                            
00645	                        {
00646	npy_float64 V9_tmp1;
00647	V9_tmp1 = V5_i * V7_i;
00648	npy_float64 V9_tmp2;
00649	V9_tmp2 = V3_i + V9_tmp1;
00650	V1_i = V9_tmp2 - V7_i;
00651	}
00652	;
00653	                    }
00654	                    
00655	            }else{
00656	                {
00657	
00658	    std::vector< std::pair<int, int> > V1_loops(2);
00659	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00660	    
00661	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00662	            
00663	        V1_loops_it->second = 0;
00664	        ++V1_loops_it;
00665	        
00666	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00667	            
00668	        V1_loops_it->second = 1;
00669	        ++V1_loops_it;
00670	        
00671	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00672	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00673	    
00674	
00675	    int init_totals[2] = {V3_n0, V3_n1};
00676	    
00677	    V1_loops_it = V1_loops.begin();
00678	    
00679	        int TOTAL_0 = init_totals[V1_loops_it->second];
00680	        ++V1_loops_it;
00681	        
00682	        int TOTAL_1 = init_totals[V1_loops_it->second];
00683	        ++V1_loops_it;
00684	        
00685	
00686	    int init_strides[4][2] = {
00687	        V3_stride0, V3_stride1, 
00688	V5_stride0, V5_stride1, 
00689	V7_stride0, V7_stride1, 
00690	V1_stride0, V1_stride1
00691	    };
00692	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00693	    
00694	        V1_loops_rit = V1_loops.rbegin();
00695	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00696	            ++V1_loops_rit;
00697	            
00698	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00699	            ++V1_loops_rit;
00700	            
00701	        V1_loops_rit = V1_loops.rbegin();
00702	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00703	            ++V1_loops_rit;
00704	            
00705	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00706	            ++V1_loops_rit;
00707	            
00708	        V1_loops_rit = V1_loops.rbegin();
00709	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00710	            ++V1_loops_rit;
00711	            
00712	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00713	            ++V1_loops_rit;
00714	            
00715	        V1_loops_rit = V1_loops.rbegin();
00716	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00717	            ++V1_loops_rit;
00718	            
00719	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00720	            ++V1_loops_rit;
00721	            
00722	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00723	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00724	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00725	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00726	
00727	
00728	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00729	        { // begin loop 0
00730	            
00731	            
00732	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00733	        { // begin loop 1
00734	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00735	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00736	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00737	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00738	
00739	            
00740	        {
00741	            
00742	            {
00743	npy_float64 V9_tmp1;
00744	V9_tmp1 = V5_i * V7_i;
00745	npy_float64 V9_tmp2;
00746	V9_tmp2 = V3_i + V9_tmp1;
00747	V1_i = V9_tmp2 - V7_i;
00748	}
00749	
00750	            
00751	        }
00752	        
00753	        } // end loop 1
00754	        
00755	        } // end loop 0
00756	        
00757	}
00758	
00759	            }
00760	            __label_9:
00761	
00762	double __DUMMY_9;
00763	
00764	}
00765	__label_8:
00766	
00767	        if (V7) {
00768	            Py_XDECREF(V7);
00769	        }
00770	        
00771	    {Py_XDECREF(py_V7);}
00772	    
00773	double __DUMMY_8;
00774	
00775	}
00776	__label_6:
00777	
00778	        if (V5) {
00779	            Py_XDECREF(V5);
00780	        }
00781	        
00782	    {Py_XDECREF(py_V5);}
00783	    
00784	double __DUMMY_6;
00785	
00786	}
00787	__label_4:
00788	
00789	        if (V3) {
00790	            Py_XDECREF(V3);
00791	        }
00792	        
00793	    {Py_XDECREF(py_V3);}
00794	    
00795	double __DUMMY_4;
00796	
00797	}
00798	__label_2:
00799	
00800	    if (!__failure) {
00801	      
00802	        {Py_XDECREF(py_V1);}
00803	        if (!V1) {
00804	            Py_INCREF(Py_None);
00805	            py_V1 = Py_None;
00806	        }
00807	        else if ((void*)py_V1 != (void*)V1) {
00808	            py_V1 = (PyObject*)V1;
00809	        }
00810	
00811	        {Py_XINCREF(py_V1);}
00812	
00813	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00814	            PyErr_Format(PyExc_NotImplementedError,
00815	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00816	                         " with %ld dimensions, with 3 last dims "
00817	                         "%ld, %ld, %ld"
00818	                         " and 3 last strides %ld %ld, %ld.",
00819	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00820	                         (long int) PyArray_NDIM(V1),
00821	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00822	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00823	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00824	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00825	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00826	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00827	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00828	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00829	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00830	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00831	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00832	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00833	        );
00834	            {
00835	        __failure = 2;
00836	        if (!PyErr_Occurred()) {
00837	            PyErr_SetString(PyExc_RuntimeError,
00838	                "Unexpected error in an Op's C code. "
00839	                "No Python exception was set.");
00840	            }
00841	        goto __label_2;}
00842	        }
00843	        
00844	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00845	      {Py_XINCREF(py_V1);}
00846	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00847	      {Py_XDECREF(old);}
00848	    }
00849	    
00850	        if (V1) {
00851	            Py_XDECREF(V1);
00852	        }
00853	        
00854	    {Py_XDECREF(py_V1);}
00855	    
00856	double __DUMMY_2;
00857	
00858	}
00859	
00860	            
00861	        if (__failure) {
00862	            // When there is a failure, this code puts the exception
00863	            // in __ERROR.
00864	            PyObject* err_type = NULL;
00865	            PyObject* err_msg = NULL;
00866	            PyObject* err_traceback = NULL;
00867	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00868	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00869	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00870	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00871	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00872	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00873	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00874	            PyList_SET_ITEM(__ERROR, 0, err_type);
00875	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00876	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00877	            {Py_XDECREF(old_err_type);}
00878	            {Py_XDECREF(old_err_msg);}
00879	            {Py_XDECREF(old_err_traceback);}
00880	        }
00881	        // The failure code is returned to index what code block failed.
00882	        return __failure;
00883	        
00884	        }
00885	    };
00886	    }
00887	    
00888	
00889	        static int __struct_compiled_op_5331b1484fffcaeeb536a994be9de64d_executor(__struct_compiled_op_5331b1484fffcaeeb536a994be9de64d* self) {
00890	            return self->run();
00891	        }
00892	
00893	        static void __struct_compiled_op_5331b1484fffcaeeb536a994be9de64d_destructor(void* executor, void* self) {
00894	            delete ((__struct_compiled_op_5331b1484fffcaeeb536a994be9de64d*)self);
00895	        }
00896	        
00897	//////////////////////
00898	////  Functions
00899	//////////////////////
00900	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00901	  assert(PyTuple_Check(argtuple));
00902	  if (5 != PyTuple_Size(argtuple)){ 
00903	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
00904	     return NULL;
00905	  }
00906	  __struct_compiled_op_5331b1484fffcaeeb536a994be9de64d* struct_ptr = new __struct_compiled_op_5331b1484fffcaeeb536a994be9de64d();
00907	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
00908	    delete struct_ptr;
00909	    return NULL;
00910	  }
00911	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_5331b1484fffcaeeb536a994be9de64d_executor), struct_ptr, __struct_compiled_op_5331b1484fffcaeeb536a994be9de64d_destructor);
00912	  return thunk; }
00913	
00914	//////////////////////
00915	////  Module init
00916	//////////////////////
00917	static PyMethodDef MyMethods[] = {
00918		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00919		{NULL, NULL, 0, NULL}
00920	};
00921	PyMODINIT_FUNC init5331b1484fffcaeeb536a994be9de64d(void){
00922	   import_array();
00923	   (void) Py_InitModule("5331b1484fffcaeeb536a994be9de64d", MyMethods);
00924	}
00925	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp6JjNJU/5331b1484fffcaeeb536a994be9de64d.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp6JjNJU/mod.cpp -lpython2.7
ERROR
test_grad_grad_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V1;
00021	        
00022	
00023	        __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331() {
00024	            // This is only somewhat safe because we:
00025	            //  1) Are not a virtual class
00026	            //  2) Do not use any virtual classes in the members
00027	            //  3) Deal with mostly POD and pointers
00028	
00029	            // If this changes, we would have to revise this, but for
00030	            // now I am tired of chasing segfaults because
00031	            // initialization code had an error and some pointer has
00032	            // a junk value.
00033	            memset(this, 0, sizeof(*this));
00034	        }
00035	        ~__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331(void) {
00036	            cleanup();
00037	        }
00038	
00039	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V1) {
00040	            Py_XINCREF(storage_V3);
00041	Py_XINCREF(storage_V5);
00042	Py_XINCREF(storage_V7);
00043	Py_XINCREF(storage_V1);
00044	            this->storage_V3 = storage_V3;
00045	this->storage_V5 = storage_V5;
00046	this->storage_V7 = storage_V7;
00047	this->storage_V1 = storage_V1;
00048	            
00049	
00050	
00051	
00052	
00053	
00054	            this->__ERROR = __ERROR;
00055	            return 0;
00056	        }
00057	        void cleanup(void) {
00058	            __label_1:
00059	
00060	double __DUMMY_1;
00061	__label_3:
00062	
00063	double __DUMMY_3;
00064	__label_5:
00065	
00066	double __DUMMY_5;
00067	__label_7:
00068	
00069	double __DUMMY_7;
00070	__label_10:
00071	
00072	double __DUMMY_10;
00073	
00074	            Py_XDECREF(this->storage_V3);
00075	Py_XDECREF(this->storage_V5);
00076	Py_XDECREF(this->storage_V7);
00077	Py_XDECREF(this->storage_V1);
00078	        }
00079	        int run(void) {
00080	            int __failure = 0;
00081	            
00082	    PyObject* py_V1;
00083	    
00084	        PyArrayObject* V1;
00085	        
00086	            typedef npy_float64 dtype_V1;
00087	            
00088	    PyObject* py_V3;
00089	    
00090	        PyArrayObject* V3;
00091	        
00092	            typedef npy_float64 dtype_V3;
00093	            
00094	    PyObject* py_V5;
00095	    
00096	        PyArrayObject* V5;
00097	        
00098	            typedef npy_float64 dtype_V5;
00099	            
00100	    PyObject* py_V7;
00101	    
00102	        PyArrayObject* V7;
00103	        
00104	            typedef npy_float64 dtype_V7;
00105	            
00106	{
00107	
00108	    py_V1 = Py_None;
00109	    {Py_XINCREF(py_V1);}
00110	    
00111	        V1 = NULL;
00112	        
00113	{
00114	
00115	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00116	    {Py_XINCREF(py_V3);}
00117	    
00118	            V3 = NULL;
00119	            if (py_V3 == Py_None) {
00120	                // We can either fail here or set V3 to NULL and rely on Ops
00121	                // using tensors to handle the NULL case, but if they fail to do so
00122	                // they'll end up with nasty segfaults, so this is public service.
00123	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00124	                {
00125	        __failure = 4;
00126	        if (!PyErr_Occurred()) {
00127	            PyErr_SetString(PyExc_RuntimeError,
00128	                "Unexpected error in an Op's C code. "
00129	                "No Python exception was set.");
00130	            }
00131	        goto __label_4;}
00132	            }
00133	            if (!PyArray_Check(py_V3)) {
00134	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00135	                {
00136	        __failure = 4;
00137	        if (!PyErr_Occurred()) {
00138	            PyErr_SetString(PyExc_RuntimeError,
00139	                "Unexpected error in an Op's C code. "
00140	                "No Python exception was set.");
00141	            }
00142	        goto __label_4;}
00143	            }
00144	            // We expect NPY_FLOAT64
00145	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00146	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00147	                PyErr_Format(PyExc_NotImplementedError,
00148	                             "expected an aligned array of type %ld "
00149	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00150	                             " with %ld dimensions, with 3 last dims "
00151	                             "%ld, %ld, %ld"
00152	                             " and 3 last strides %ld %ld, %ld.",
00153	                             (long int) NPY_FLOAT64,
00154	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00155	                             (long int) PyArray_NDIM(tmp),
00156	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00157	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00158	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00159	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00160	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00161	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00162	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00163	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00164	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00165	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00166	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00167	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00168	            );
00169	                {
00170	        __failure = 4;
00171	        if (!PyErr_Occurred()) {
00172	            PyErr_SetString(PyExc_RuntimeError,
00173	                "Unexpected error in an Op's C code. "
00174	                "No Python exception was set.");
00175	            }
00176	        goto __label_4;}
00177	            }
00178	            // This is a TypeError to be consistent with DEBUG_MODE
00179	            // Note: DEBUG_MODE also tells the name of the container
00180	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00181	                PyErr_Format(PyExc_TypeError,
00182	                             "expected type_num %d (NPY_FLOAT64) got %d",
00183	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            
00194	        V3 = (PyArrayObject*)(py_V3);
00195	        Py_XINCREF(V3);
00196	        
00197	{
00198	
00199	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00200	    {Py_XINCREF(py_V5);}
00201	    
00202	            V5 = NULL;
00203	            if (py_V5 == Py_None) {
00204	                // We can either fail here or set V5 to NULL and rely on Ops
00205	                // using tensors to handle the NULL case, but if they fail to do so
00206	                // they'll end up with nasty segfaults, so this is public service.
00207	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00208	                {
00209	        __failure = 6;
00210	        if (!PyErr_Occurred()) {
00211	            PyErr_SetString(PyExc_RuntimeError,
00212	                "Unexpected error in an Op's C code. "
00213	                "No Python exception was set.");
00214	            }
00215	        goto __label_6;}
00216	            }
00217	            if (!PyArray_Check(py_V5)) {
00218	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00219	                {
00220	        __failure = 6;
00221	        if (!PyErr_Occurred()) {
00222	            PyErr_SetString(PyExc_RuntimeError,
00223	                "Unexpected error in an Op's C code. "
00224	                "No Python exception was set.");
00225	            }
00226	        goto __label_6;}
00227	            }
00228	            // We expect NPY_FLOAT64
00229	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00230	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00231	                PyErr_Format(PyExc_NotImplementedError,
00232	                             "expected an aligned array of type %ld "
00233	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00234	                             " with %ld dimensions, with 3 last dims "
00235	                             "%ld, %ld, %ld"
00236	                             " and 3 last strides %ld %ld, %ld.",
00237	                             (long int) NPY_FLOAT64,
00238	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00239	                             (long int) PyArray_NDIM(tmp),
00240	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00241	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00242	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00243	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00244	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00245	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00246	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00247	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00248	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00249	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00250	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00251	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00252	            );
00253	                {
00254	        __failure = 6;
00255	        if (!PyErr_Occurred()) {
00256	            PyErr_SetString(PyExc_RuntimeError,
00257	                "Unexpected error in an Op's C code. "
00258	                "No Python exception was set.");
00259	            }
00260	        goto __label_6;}
00261	            }
00262	            // This is a TypeError to be consistent with DEBUG_MODE
00263	            // Note: DEBUG_MODE also tells the name of the container
00264	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00265	                PyErr_Format(PyExc_TypeError,
00266	                             "expected type_num %d (NPY_FLOAT64) got %d",
00267	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00268	                {
00269	        __failure = 6;
00270	        if (!PyErr_Occurred()) {
00271	            PyErr_SetString(PyExc_RuntimeError,
00272	                "Unexpected error in an Op's C code. "
00273	                "No Python exception was set.");
00274	            }
00275	        goto __label_6;}
00276	            }
00277	            
00278	        V5 = (PyArrayObject*)(py_V5);
00279	        Py_XINCREF(V5);
00280	        
00281	{
00282	
00283	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00284	    {Py_XINCREF(py_V7);}
00285	    
00286	            V7 = NULL;
00287	            if (py_V7 == Py_None) {
00288	                // We can either fail here or set V7 to NULL and rely on Ops
00289	                // using tensors to handle the NULL case, but if they fail to do so
00290	                // they'll end up with nasty segfaults, so this is public service.
00291	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00292	                {
00293	        __failure = 8;
00294	        if (!PyErr_Occurred()) {
00295	            PyErr_SetString(PyExc_RuntimeError,
00296	                "Unexpected error in an Op's C code. "
00297	                "No Python exception was set.");
00298	            }
00299	        goto __label_8;}
00300	            }
00301	            if (!PyArray_Check(py_V7)) {
00302	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00303	                {
00304	        __failure = 8;
00305	        if (!PyErr_Occurred()) {
00306	            PyErr_SetString(PyExc_RuntimeError,
00307	                "Unexpected error in an Op's C code. "
00308	                "No Python exception was set.");
00309	            }
00310	        goto __label_8;}
00311	            }
00312	            // We expect NPY_FLOAT64
00313	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00314	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00315	                PyErr_Format(PyExc_NotImplementedError,
00316	                             "expected an aligned array of type %ld "
00317	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00318	                             " with %ld dimensions, with 3 last dims "
00319	                             "%ld, %ld, %ld"
00320	                             " and 3 last strides %ld %ld, %ld.",
00321	                             (long int) NPY_FLOAT64,
00322	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00323	                             (long int) PyArray_NDIM(tmp),
00324	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00325	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00326	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00327	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00328	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00329	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00330	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00331	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00332	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00333	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00334	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00335	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00336	            );
00337	                {
00338	        __failure = 8;
00339	        if (!PyErr_Occurred()) {
00340	            PyErr_SetString(PyExc_RuntimeError,
00341	                "Unexpected error in an Op's C code. "
00342	                "No Python exception was set.");
00343	            }
00344	        goto __label_8;}
00345	            }
00346	            // This is a TypeError to be consistent with DEBUG_MODE
00347	            // Note: DEBUG_MODE also tells the name of the container
00348	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00349	                PyErr_Format(PyExc_TypeError,
00350	                             "expected type_num %d (NPY_FLOAT64) got %d",
00351	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00352	                {
00353	        __failure = 8;
00354	        if (!PyErr_Occurred()) {
00355	            PyErr_SetString(PyExc_RuntimeError,
00356	                "Unexpected error in an Op's C code. "
00357	                "No Python exception was set.");
00358	            }
00359	        goto __label_8;}
00360	            }
00361	            
00362	        V7 = (PyArrayObject*)(py_V7);
00363	        Py_XINCREF(V7);
00364	        
00365	{
00366	// Op class Elemwise
00367	
00368	        npy_float64* V3_iter;
00369	        
00370	                npy_intp V3_n0;
00371	                ssize_t V3_stride0;
00372	                int V3_jump0_0;
00373	                
00374	                npy_intp V3_n1;
00375	                ssize_t V3_stride1;
00376	                int V3_jump1_1;
00377	                
00378	        npy_float64* V5_iter;
00379	        
00380	                npy_intp V5_n0;
00381	                ssize_t V5_stride0;
00382	                int V5_jump0_0;
00383	                
00384	                npy_intp V5_n1;
00385	                ssize_t V5_stride1;
00386	                int V5_jump1_1;
00387	                
00388	        npy_float64* V7_iter;
00389	        
00390	                npy_intp V7_n0;
00391	                ssize_t V7_stride0;
00392	                int V7_jump0_0;
00393	                
00394	                npy_intp V7_n1;
00395	                ssize_t V7_stride1;
00396	                int V7_jump1_1;
00397	                
00398	
00399	            if (PyArray_NDIM(V3) < 2) {
00400	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00401	                {
00402	        __failure = 9;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_9;}
00409	            }
00410	            
00411	                V3_n1 = PyArray_DIMS(V3)[1];
00412	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00413	                V3_jump1_1 = (V3_stride1) - (0);
00414	                //printf("V3_jump1_1 is:");
00415	                //std::cout << V3_jump1_1 << std::endl;
00416	                
00417	                V3_n0 = PyArray_DIMS(V3)[0];
00418	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00419	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00420	                //printf("V3_jump0_0 is:");
00421	                //std::cout << V3_jump0_0 << std::endl;
00422	                
00423	            if (PyArray_NDIM(V5) < 2) {
00424	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00425	                {
00426	        __failure = 9;
00427	        if (!PyErr_Occurred()) {
00428	            PyErr_SetString(PyExc_RuntimeError,
00429	                "Unexpected error in an Op's C code. "
00430	                "No Python exception was set.");
00431	            }
00432	        goto __label_9;}
00433	            }
00434	            
00435	                V5_n1 = PyArray_DIMS(V5)[1];
00436	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00437	                V5_jump1_1 = (V5_stride1) - (0);
00438	                //printf("V5_jump1_1 is:");
00439	                //std::cout << V5_jump1_1 << std::endl;
00440	                
00441	                V5_n0 = PyArray_DIMS(V5)[0];
00442	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00443	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00444	                //printf("V5_jump0_0 is:");
00445	                //std::cout << V5_jump0_0 << std::endl;
00446	                
00447	            if (PyArray_NDIM(V7) < 2) {
00448	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00449	                {
00450	        __failure = 9;
00451	        if (!PyErr_Occurred()) {
00452	            PyErr_SetString(PyExc_RuntimeError,
00453	                "Unexpected error in an Op's C code. "
00454	                "No Python exception was set.");
00455	            }
00456	        goto __label_9;}
00457	            }
00458	            
00459	                V7_n1 = PyArray_DIMS(V7)[1];
00460	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00461	                V7_jump1_1 = (V7_stride1) - (0);
00462	                //printf("V7_jump1_1 is:");
00463	                //std::cout << V7_jump1_1 << std::endl;
00464	                
00465	                V7_n0 = PyArray_DIMS(V7)[0];
00466	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00467	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00468	                //printf("V7_jump0_0 is:");
00469	                //std::cout << V7_jump0_0 << std::endl;
00470	                
00471	            if (V3_n0 != V5_n0)
00472	            {
00473	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00474	                   0,
00475	                   0,
00476	                   V3_n0,
00477	                   1,
00478	                   0,
00479	                   V5_n0
00480	                );
00481	                {
00482	        __failure = 9;
00483	        if (!PyErr_Occurred()) {
00484	            PyErr_SetString(PyExc_RuntimeError,
00485	                "Unexpected error in an Op's C code. "
00486	                "No Python exception was set.");
00487	            }
00488	        goto __label_9;}
00489	            }
00490	            
00491	            if (V3_n0 != V7_n0)
00492	            {
00493	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00494	                   0,
00495	                   0,
00496	                   V3_n0,
00497	                   2,
00498	                   0,
00499	                   V7_n0
00500	                );
00501	                {
00502	        __failure = 9;
00503	        if (!PyErr_Occurred()) {
00504	            PyErr_SetString(PyExc_RuntimeError,
00505	                "Unexpected error in an Op's C code. "
00506	                "No Python exception was set.");
00507	            }
00508	        goto __label_9;}
00509	            }
00510	            
00511	            if (V3_n1 != V5_n1)
00512	            {
00513	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00514	                   0,
00515	                   1,
00516	                   V3_n1,
00517	                   1,
00518	                   1,
00519	                   V5_n1
00520	                );
00521	                {
00522	        __failure = 9;
00523	        if (!PyErr_Occurred()) {
00524	            PyErr_SetString(PyExc_RuntimeError,
00525	                "Unexpected error in an Op's C code. "
00526	                "No Python exception was set.");
00527	            }
00528	        goto __label_9;}
00529	            }
00530	            
00531	            if (V3_n1 != V7_n1)
00532	            {
00533	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00534	                   0,
00535	                   1,
00536	                   V3_n1,
00537	                   2,
00538	                   1,
00539	                   V7_n1
00540	                );
00541	                {
00542	        __failure = 9;
00543	        if (!PyErr_Occurred()) {
00544	            PyErr_SetString(PyExc_RuntimeError,
00545	                "Unexpected error in an Op's C code. "
00546	                "No Python exception was set.");
00547	            }
00548	        goto __label_9;}
00549	            }
00550	            
00551	
00552	        npy_float64* V1_iter;
00553	        
00554	                npy_intp V1_n0;
00555	                ssize_t V1_stride0;
00556	                int V1_jump0_0;
00557	                
00558	                npy_intp V1_n1;
00559	                ssize_t V1_stride1;
00560	                int V1_jump1_1;
00561	                
00562	    {
00563	        npy_intp dims[2];
00564	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00565	        dims[0] = V3_n0;
00566	dims[1] = V3_n1;
00567	
00568	        if (!V1) {
00569	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00570	                                                    NPY_FLOAT64,
00571	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7));
00572	        }
00573	        else {
00574	            PyArray_Dims new_dims;
00575	            new_dims.len = 2;
00576	            new_dims.ptr = dims;
00577	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00578	            if (!success) {
00579	                // If we can't resize the ndarray we have we can allocate a new one.
00580	                PyErr_Clear();
00581	                Py_XDECREF(V1);
00582	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00583	            }
00584	        }
00585	        if (!V1) {
00586	            {
00587	        __failure = 9;
00588	        if (!PyErr_Occurred()) {
00589	            PyErr_SetString(PyExc_RuntimeError,
00590	                "Unexpected error in an Op's C code. "
00591	                "No Python exception was set.");
00592	            }
00593	        goto __label_9;}
00594	        }
00595	    }
00596	    
00597	            if (PyArray_NDIM(V1) < 2) {
00598	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00599	                {
00600	        __failure = 9;
00601	        if (!PyErr_Occurred()) {
00602	            PyErr_SetString(PyExc_RuntimeError,
00603	                "Unexpected error in an Op's C code. "
00604	                "No Python exception was set.");
00605	            }
00606	        goto __label_9;}
00607	            }
00608	            
00609	                V1_n1 = PyArray_DIMS(V1)[1];
00610	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00611	                V1_jump1_1 = (V1_stride1) - (0);
00612	                //printf("V1_jump1_1 is:");
00613	                //std::cout << V1_jump1_1 << std::endl;
00614	                
00615	                V1_n0 = PyArray_DIMS(V1)[0];
00616	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00617	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00618	                //printf("V1_jump0_0 is:");
00619	                //std::cout << V1_jump0_0 << std::endl;
00620	                
00621	
00622	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V1))){
00623	                
00624	                    // All output have the same size
00625	                    npy_intp n = PyArray_SIZE(V1);
00626	                    
00627	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00628	                            
00629	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00630	                            
00631	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00632	                            
00633	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00634	                            
00635	                    for(int i=0; i<n; i++){
00636	                        
00637	            dtype_V3& V3_i = V3_ptr[i];
00638	                            
00639	            dtype_V5& V5_i = V5_ptr[i];
00640	                            
00641	            dtype_V7& V7_i = V7_ptr[i];
00642	                            
00643	            dtype_V1& V1_i = V1_ptr[i];
00644	                            
00645	                        {
00646	npy_float64 V9_tmp1;
00647	V9_tmp1 = V5_i * V7_i;
00648	V1_i = V3_i + V9_tmp1;
00649	}
00650	;
00651	                    }
00652	                    
00653	            }else{
00654	                {
00655	
00656	    std::vector< std::pair<int, int> > V1_loops(2);
00657	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00658	    
00659	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00660	            
00661	        V1_loops_it->second = 0;
00662	        ++V1_loops_it;
00663	        
00664	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00665	            
00666	        V1_loops_it->second = 1;
00667	        ++V1_loops_it;
00668	        
00669	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00670	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00671	    
00672	
00673	    int init_totals[2] = {V3_n0, V3_n1};
00674	    
00675	    V1_loops_it = V1_loops.begin();
00676	    
00677	        int TOTAL_0 = init_totals[V1_loops_it->second];
00678	        ++V1_loops_it;
00679	        
00680	        int TOTAL_1 = init_totals[V1_loops_it->second];
00681	        ++V1_loops_it;
00682	        
00683	
00684	    int init_strides[4][2] = {
00685	        V3_stride0, V3_stride1, 
00686	V5_stride0, V5_stride1, 
00687	V7_stride0, V7_stride1, 
00688	V1_stride0, V1_stride1
00689	    };
00690	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00691	    
00692	        V1_loops_rit = V1_loops.rbegin();
00693	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00694	            ++V1_loops_rit;
00695	            
00696	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00697	            ++V1_loops_rit;
00698	            
00699	        V1_loops_rit = V1_loops.rbegin();
00700	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00701	            ++V1_loops_rit;
00702	            
00703	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00704	            ++V1_loops_rit;
00705	            
00706	        V1_loops_rit = V1_loops.rbegin();
00707	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00708	            ++V1_loops_rit;
00709	            
00710	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00711	            ++V1_loops_rit;
00712	            
00713	        V1_loops_rit = V1_loops.rbegin();
00714	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00715	            ++V1_loops_rit;
00716	            
00717	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00718	            ++V1_loops_rit;
00719	            
00720	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00721	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00722	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00723	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00724	
00725	
00726	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00727	        { // begin loop 0
00728	            
00729	            
00730	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00731	        { // begin loop 1
00732	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00733	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00734	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00735	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00736	
00737	            
00738	        {
00739	            
00740	            {
00741	npy_float64 V9_tmp1;
00742	V9_tmp1 = V5_i * V7_i;
00743	V1_i = V3_i + V9_tmp1;
00744	}
00745	
00746	            
00747	        }
00748	        
00749	        } // end loop 1
00750	        
00751	        } // end loop 0
00752	        
00753	}
00754	
00755	            }
00756	            __label_9:
00757	
00758	double __DUMMY_9;
00759	
00760	}
00761	__label_8:
00762	
00763	        if (V7) {
00764	            Py_XDECREF(V7);
00765	        }
00766	        
00767	    {Py_XDECREF(py_V7);}
00768	    
00769	double __DUMMY_8;
00770	
00771	}
00772	__label_6:
00773	
00774	        if (V5) {
00775	            Py_XDECREF(V5);
00776	        }
00777	        
00778	    {Py_XDECREF(py_V5);}
00779	    
00780	double __DUMMY_6;
00781	
00782	}
00783	__label_4:
00784	
00785	        if (V3) {
00786	            Py_XDECREF(V3);
00787	        }
00788	        
00789	    {Py_XDECREF(py_V3);}
00790	    
00791	double __DUMMY_4;
00792	
00793	}
00794	__label_2:
00795	
00796	    if (!__failure) {
00797	      
00798	        {Py_XDECREF(py_V1);}
00799	        if (!V1) {
00800	            Py_INCREF(Py_None);
00801	            py_V1 = Py_None;
00802	        }
00803	        else if ((void*)py_V1 != (void*)V1) {
00804	            py_V1 = (PyObject*)V1;
00805	        }
00806	
00807	        {Py_XINCREF(py_V1);}
00808	
00809	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00810	            PyErr_Format(PyExc_NotImplementedError,
00811	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00812	                         " with %ld dimensions, with 3 last dims "
00813	                         "%ld, %ld, %ld"
00814	                         " and 3 last strides %ld %ld, %ld.",
00815	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00816	                         (long int) PyArray_NDIM(V1),
00817	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00818	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00819	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00820	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00821	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00822	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00823	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00824	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00825	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00826	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00827	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00828	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00829	        );
00830	            {
00831	        __failure = 2;
00832	        if (!PyErr_Occurred()) {
00833	            PyErr_SetString(PyExc_RuntimeError,
00834	                "Unexpected error in an Op's C code. "
00835	                "No Python exception was set.");
00836	            }
00837	        goto __label_2;}
00838	        }
00839	        
00840	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00841	      {Py_XINCREF(py_V1);}
00842	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00843	      {Py_XDECREF(old);}
00844	    }
00845	    
00846	        if (V1) {
00847	            Py_XDECREF(V1);
00848	        }
00849	        
00850	    {Py_XDECREF(py_V1);}
00851	    
00852	double __DUMMY_2;
00853	
00854	}
00855	
00856	            
00857	        if (__failure) {
00858	            // When there is a failure, this code puts the exception
00859	            // in __ERROR.
00860	            PyObject* err_type = NULL;
00861	            PyObject* err_msg = NULL;
00862	            PyObject* err_traceback = NULL;
00863	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00864	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00865	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00866	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00867	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00868	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00869	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00870	            PyList_SET_ITEM(__ERROR, 0, err_type);
00871	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00872	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00873	            {Py_XDECREF(old_err_type);}
00874	            {Py_XDECREF(old_err_msg);}
00875	            {Py_XDECREF(old_err_traceback);}
00876	        }
00877	        // The failure code is returned to index what code block failed.
00878	        return __failure;
00879	        
00880	        }
00881	    };
00882	    }
00883	    
00884	
00885	        static int __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_executor(__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331* self) {
00886	            return self->run();
00887	        }
00888	
00889	        static void __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_destructor(void* executor, void* self) {
00890	            delete ((__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331*)self);
00891	        }
00892	        
00893	//////////////////////
00894	////  Functions
00895	//////////////////////
00896	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00897	  assert(PyTuple_Check(argtuple));
00898	  if (5 != PyTuple_Size(argtuple)){ 
00899	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
00900	     return NULL;
00901	  }
00902	  __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331* struct_ptr = new __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331();
00903	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
00904	    delete struct_ptr;
00905	    return NULL;
00906	  }
00907	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_executor), struct_ptr, __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_destructor);
00908	  return thunk; }
00909	
00910	//////////////////////
00911	////  Module init
00912	//////////////////////
00913	static PyMethodDef MyMethods[] = {
00914		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00915		{NULL, NULL, 0, NULL}
00916	};
00917	PyMODINIT_FUNC initb91887856157bcaaaf7e3d73e9cce331(void){
00918	   import_array();
00919	   (void) Py_InitModule("b91887856157bcaaaf7e3d73e9cce331", MyMethods);
00920	}
00921	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp62rhgH/b91887856157bcaaaf7e3d73e9cce331.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp62rhgH/mod.cpp -lpython2.7
ERROR
test_grad_grad_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_34ef066b34596f809536d8b71d4a16ff {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V1;
00021	        
00022	
00023	        __struct_compiled_op_34ef066b34596f809536d8b71d4a16ff() {
00024	            // This is only somewhat safe because we:
00025	            //  1) Are not a virtual class
00026	            //  2) Do not use any virtual classes in the members
00027	            //  3) Deal with mostly POD and pointers
00028	
00029	            // If this changes, we would have to revise this, but for
00030	            // now I am tired of chasing segfaults because
00031	            // initialization code had an error and some pointer has
00032	            // a junk value.
00033	            memset(this, 0, sizeof(*this));
00034	        }
00035	        ~__struct_compiled_op_34ef066b34596f809536d8b71d4a16ff(void) {
00036	            cleanup();
00037	        }
00038	
00039	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V1) {
00040	            Py_XINCREF(storage_V3);
00041	Py_XINCREF(storage_V5);
00042	Py_XINCREF(storage_V7);
00043	Py_XINCREF(storage_V1);
00044	            this->storage_V3 = storage_V3;
00045	this->storage_V5 = storage_V5;
00046	this->storage_V7 = storage_V7;
00047	this->storage_V1 = storage_V1;
00048	            
00049	
00050	
00051	
00052	
00053	
00054	            this->__ERROR = __ERROR;
00055	            return 0;
00056	        }
00057	        void cleanup(void) {
00058	            __label_1:
00059	
00060	double __DUMMY_1;
00061	__label_3:
00062	
00063	double __DUMMY_3;
00064	__label_5:
00065	
00066	double __DUMMY_5;
00067	__label_7:
00068	
00069	double __DUMMY_7;
00070	__label_10:
00071	
00072	double __DUMMY_10;
00073	
00074	            Py_XDECREF(this->storage_V3);
00075	Py_XDECREF(this->storage_V5);
00076	Py_XDECREF(this->storage_V7);
00077	Py_XDECREF(this->storage_V1);
00078	        }
00079	        int run(void) {
00080	            int __failure = 0;
00081	            
00082	    PyObject* py_V1;
00083	    
00084	        PyArrayObject* V1;
00085	        
00086	            typedef npy_float64 dtype_V1;
00087	            
00088	    PyObject* py_V3;
00089	    
00090	        PyArrayObject* V3;
00091	        
00092	            typedef npy_float64 dtype_V3;
00093	            
00094	    PyObject* py_V5;
00095	    
00096	        PyArrayObject* V5;
00097	        
00098	            typedef npy_float64 dtype_V5;
00099	            
00100	    PyObject* py_V7;
00101	    
00102	        PyArrayObject* V7;
00103	        
00104	            typedef npy_float64 dtype_V7;
00105	            
00106	{
00107	
00108	    py_V1 = Py_None;
00109	    {Py_XINCREF(py_V1);}
00110	    
00111	        V1 = NULL;
00112	        
00113	{
00114	
00115	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00116	    {Py_XINCREF(py_V3);}
00117	    
00118	            V3 = NULL;
00119	            if (py_V3 == Py_None) {
00120	                // We can either fail here or set V3 to NULL and rely on Ops
00121	                // using tensors to handle the NULL case, but if they fail to do so
00122	                // they'll end up with nasty segfaults, so this is public service.
00123	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00124	                {
00125	        __failure = 4;
00126	        if (!PyErr_Occurred()) {
00127	            PyErr_SetString(PyExc_RuntimeError,
00128	                "Unexpected error in an Op's C code. "
00129	                "No Python exception was set.");
00130	            }
00131	        goto __label_4;}
00132	            }
00133	            if (!PyArray_Check(py_V3)) {
00134	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00135	                {
00136	        __failure = 4;
00137	        if (!PyErr_Occurred()) {
00138	            PyErr_SetString(PyExc_RuntimeError,
00139	                "Unexpected error in an Op's C code. "
00140	                "No Python exception was set.");
00141	            }
00142	        goto __label_4;}
00143	            }
00144	            // We expect NPY_FLOAT64
00145	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00146	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00147	                PyErr_Format(PyExc_NotImplementedError,
00148	                             "expected an aligned array of type %ld "
00149	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00150	                             " with %ld dimensions, with 3 last dims "
00151	                             "%ld, %ld, %ld"
00152	                             " and 3 last strides %ld %ld, %ld.",
00153	                             (long int) NPY_FLOAT64,
00154	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00155	                             (long int) PyArray_NDIM(tmp),
00156	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00157	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00158	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00159	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00160	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00161	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00162	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00163	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00164	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00165	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00166	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00167	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00168	            );
00169	                {
00170	        __failure = 4;
00171	        if (!PyErr_Occurred()) {
00172	            PyErr_SetString(PyExc_RuntimeError,
00173	                "Unexpected error in an Op's C code. "
00174	                "No Python exception was set.");
00175	            }
00176	        goto __label_4;}
00177	            }
00178	            // This is a TypeError to be consistent with DEBUG_MODE
00179	            // Note: DEBUG_MODE also tells the name of the container
00180	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00181	                PyErr_Format(PyExc_TypeError,
00182	                             "expected type_num %d (NPY_FLOAT64) got %d",
00183	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            
00194	        V3 = (PyArrayObject*)(py_V3);
00195	        Py_XINCREF(V3);
00196	        
00197	{
00198	
00199	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00200	    {Py_XINCREF(py_V5);}
00201	    
00202	            V5 = NULL;
00203	            if (py_V5 == Py_None) {
00204	                // We can either fail here or set V5 to NULL and rely on Ops
00205	                // using tensors to handle the NULL case, but if they fail to do so
00206	                // they'll end up with nasty segfaults, so this is public service.
00207	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00208	                {
00209	        __failure = 6;
00210	        if (!PyErr_Occurred()) {
00211	            PyErr_SetString(PyExc_RuntimeError,
00212	                "Unexpected error in an Op's C code. "
00213	                "No Python exception was set.");
00214	            }
00215	        goto __label_6;}
00216	            }
00217	            if (!PyArray_Check(py_V5)) {
00218	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00219	                {
00220	        __failure = 6;
00221	        if (!PyErr_Occurred()) {
00222	            PyErr_SetString(PyExc_RuntimeError,
00223	                "Unexpected error in an Op's C code. "
00224	                "No Python exception was set.");
00225	            }
00226	        goto __label_6;}
00227	            }
00228	            // We expect NPY_FLOAT64
00229	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00230	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00231	                PyErr_Format(PyExc_NotImplementedError,
00232	                             "expected an aligned array of type %ld "
00233	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00234	                             " with %ld dimensions, with 3 last dims "
00235	                             "%ld, %ld, %ld"
00236	                             " and 3 last strides %ld %ld, %ld.",
00237	                             (long int) NPY_FLOAT64,
00238	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00239	                             (long int) PyArray_NDIM(tmp),
00240	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00241	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00242	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00243	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00244	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00245	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00246	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00247	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00248	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00249	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00250	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00251	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00252	            );
00253	                {
00254	        __failure = 6;
00255	        if (!PyErr_Occurred()) {
00256	            PyErr_SetString(PyExc_RuntimeError,
00257	                "Unexpected error in an Op's C code. "
00258	                "No Python exception was set.");
00259	            }
00260	        goto __label_6;}
00261	            }
00262	            // This is a TypeError to be consistent with DEBUG_MODE
00263	            // Note: DEBUG_MODE also tells the name of the container
00264	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00265	                PyErr_Format(PyExc_TypeError,
00266	                             "expected type_num %d (NPY_FLOAT64) got %d",
00267	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00268	                {
00269	        __failure = 6;
00270	        if (!PyErr_Occurred()) {
00271	            PyErr_SetString(PyExc_RuntimeError,
00272	                "Unexpected error in an Op's C code. "
00273	                "No Python exception was set.");
00274	            }
00275	        goto __label_6;}
00276	            }
00277	            
00278	        V5 = (PyArrayObject*)(py_V5);
00279	        Py_XINCREF(V5);
00280	        
00281	{
00282	
00283	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00284	    {Py_XINCREF(py_V7);}
00285	    
00286	            V7 = NULL;
00287	            if (py_V7 == Py_None) {
00288	                // We can either fail here or set V7 to NULL and rely on Ops
00289	                // using tensors to handle the NULL case, but if they fail to do so
00290	                // they'll end up with nasty segfaults, so this is public service.
00291	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00292	                {
00293	        __failure = 8;
00294	        if (!PyErr_Occurred()) {
00295	            PyErr_SetString(PyExc_RuntimeError,
00296	                "Unexpected error in an Op's C code. "
00297	                "No Python exception was set.");
00298	            }
00299	        goto __label_8;}
00300	            }
00301	            if (!PyArray_Check(py_V7)) {
00302	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00303	                {
00304	        __failure = 8;
00305	        if (!PyErr_Occurred()) {
00306	            PyErr_SetString(PyExc_RuntimeError,
00307	                "Unexpected error in an Op's C code. "
00308	                "No Python exception was set.");
00309	            }
00310	        goto __label_8;}
00311	            }
00312	            // We expect NPY_FLOAT64
00313	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00314	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00315	                PyErr_Format(PyExc_NotImplementedError,
00316	                             "expected an aligned array of type %ld "
00317	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00318	                             " with %ld dimensions, with 3 last dims "
00319	                             "%ld, %ld, %ld"
00320	                             " and 3 last strides %ld %ld, %ld.",
00321	                             (long int) NPY_FLOAT64,
00322	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00323	                             (long int) PyArray_NDIM(tmp),
00324	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00325	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00326	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00327	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00328	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00329	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00330	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00331	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00332	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00333	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00334	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00335	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00336	            );
00337	                {
00338	        __failure = 8;
00339	        if (!PyErr_Occurred()) {
00340	            PyErr_SetString(PyExc_RuntimeError,
00341	                "Unexpected error in an Op's C code. "
00342	                "No Python exception was set.");
00343	            }
00344	        goto __label_8;}
00345	            }
00346	            // This is a TypeError to be consistent with DEBUG_MODE
00347	            // Note: DEBUG_MODE also tells the name of the container
00348	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00349	                PyErr_Format(PyExc_TypeError,
00350	                             "expected type_num %d (NPY_FLOAT64) got %d",
00351	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00352	                {
00353	        __failure = 8;
00354	        if (!PyErr_Occurred()) {
00355	            PyErr_SetString(PyExc_RuntimeError,
00356	                "Unexpected error in an Op's C code. "
00357	                "No Python exception was set.");
00358	            }
00359	        goto __label_8;}
00360	            }
00361	            
00362	        V7 = (PyArrayObject*)(py_V7);
00363	        Py_XINCREF(V7);
00364	        
00365	{
00366	// Op class Elemwise
00367	
00368	        npy_float64* V3_iter;
00369	        
00370	                npy_intp V3_n0;
00371	                ssize_t V3_stride0;
00372	                int V3_jump0_0;
00373	                
00374	                npy_intp V3_n1;
00375	                ssize_t V3_stride1;
00376	                int V3_jump1_1;
00377	                
00378	        npy_float64* V5_iter;
00379	        
00380	                npy_intp V5_n0;
00381	                ssize_t V5_stride0;
00382	                int V5_jump0_0;
00383	                
00384	                npy_intp V5_n1;
00385	                ssize_t V5_stride1;
00386	                int V5_jump1_1;
00387	                
00388	        npy_float64* V7_iter;
00389	        
00390	                npy_intp V7_n0;
00391	                ssize_t V7_stride0;
00392	                int V7_jump0_0;
00393	                
00394	                npy_intp V7_n1;
00395	                ssize_t V7_stride1;
00396	                int V7_jump1_1;
00397	                
00398	
00399	            if (PyArray_NDIM(V3) < 2) {
00400	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00401	                {
00402	        __failure = 9;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_9;}
00409	            }
00410	            
00411	                V3_n1 = PyArray_DIMS(V3)[1];
00412	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00413	                V3_jump1_1 = (V3_stride1) - (0);
00414	                //printf("V3_jump1_1 is:");
00415	                //std::cout << V3_jump1_1 << std::endl;
00416	                
00417	                V3_n0 = PyArray_DIMS(V3)[0];
00418	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00419	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00420	                //printf("V3_jump0_0 is:");
00421	                //std::cout << V3_jump0_0 << std::endl;
00422	                
00423	            if (PyArray_NDIM(V5) < 2) {
00424	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00425	                {
00426	        __failure = 9;
00427	        if (!PyErr_Occurred()) {
00428	            PyErr_SetString(PyExc_RuntimeError,
00429	                "Unexpected error in an Op's C code. "
00430	                "No Python exception was set.");
00431	            }
00432	        goto __label_9;}
00433	            }
00434	            
00435	                V5_n1 = PyArray_DIMS(V5)[1];
00436	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00437	                V5_jump1_1 = (V5_stride1) - (0);
00438	                //printf("V5_jump1_1 is:");
00439	                //std::cout << V5_jump1_1 << std::endl;
00440	                
00441	                V5_n0 = PyArray_DIMS(V5)[0];
00442	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00443	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00444	                //printf("V5_jump0_0 is:");
00445	                //std::cout << V5_jump0_0 << std::endl;
00446	                
00447	            if (PyArray_NDIM(V7) < 2) {
00448	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00449	                {
00450	        __failure = 9;
00451	        if (!PyErr_Occurred()) {
00452	            PyErr_SetString(PyExc_RuntimeError,
00453	                "Unexpected error in an Op's C code. "
00454	                "No Python exception was set.");
00455	            }
00456	        goto __label_9;}
00457	            }
00458	            
00459	                V7_n1 = PyArray_DIMS(V7)[1];
00460	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00461	                V7_jump1_1 = (V7_stride1) - (0);
00462	                //printf("V7_jump1_1 is:");
00463	                //std::cout << V7_jump1_1 << std::endl;
00464	                
00465	                V7_n0 = PyArray_DIMS(V7)[0];
00466	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00467	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00468	                //printf("V7_jump0_0 is:");
00469	                //std::cout << V7_jump0_0 << std::endl;
00470	                
00471	            if (V3_n0 != V5_n0)
00472	            {
00473	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00474	                   0,
00475	                   0,
00476	                   V3_n0,
00477	                   1,
00478	                   0,
00479	                   V5_n0
00480	                );
00481	                {
00482	        __failure = 9;
00483	        if (!PyErr_Occurred()) {
00484	            PyErr_SetString(PyExc_RuntimeError,
00485	                "Unexpected error in an Op's C code. "
00486	                "No Python exception was set.");
00487	            }
00488	        goto __label_9;}
00489	            }
00490	            
00491	            if (V3_n0 != V7_n0)
00492	            {
00493	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00494	                   0,
00495	                   0,
00496	                   V3_n0,
00497	                   2,
00498	                   0,
00499	                   V7_n0
00500	                );
00501	                {
00502	        __failure = 9;
00503	        if (!PyErr_Occurred()) {
00504	            PyErr_SetString(PyExc_RuntimeError,
00505	                "Unexpected error in an Op's C code. "
00506	                "No Python exception was set.");
00507	            }
00508	        goto __label_9;}
00509	            }
00510	            
00511	            if (V3_n1 != V5_n1)
00512	            {
00513	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00514	                   0,
00515	                   1,
00516	                   V3_n1,
00517	                   1,
00518	                   1,
00519	                   V5_n1
00520	                );
00521	                {
00522	        __failure = 9;
00523	        if (!PyErr_Occurred()) {
00524	            PyErr_SetString(PyExc_RuntimeError,
00525	                "Unexpected error in an Op's C code. "
00526	                "No Python exception was set.");
00527	            }
00528	        goto __label_9;}
00529	            }
00530	            
00531	            if (V3_n1 != V7_n1)
00532	            {
00533	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00534	                   0,
00535	                   1,
00536	                   V3_n1,
00537	                   2,
00538	                   1,
00539	                   V7_n1
00540	                );
00541	                {
00542	        __failure = 9;
00543	        if (!PyErr_Occurred()) {
00544	            PyErr_SetString(PyExc_RuntimeError,
00545	                "Unexpected error in an Op's C code. "
00546	                "No Python exception was set.");
00547	            }
00548	        goto __label_9;}
00549	            }
00550	            
00551	
00552	        npy_float64* V1_iter;
00553	        
00554	                npy_intp V1_n0;
00555	                ssize_t V1_stride0;
00556	                int V1_jump0_0;
00557	                
00558	                npy_intp V1_n1;
00559	                ssize_t V1_stride1;
00560	                int V1_jump1_1;
00561	                
00562	    {
00563	        npy_intp dims[2];
00564	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00565	        dims[0] = V3_n0;
00566	dims[1] = V3_n1;
00567	
00568	        if (!V1) {
00569	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00570	                                                    NPY_FLOAT64,
00571	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7));
00572	        }
00573	        else {
00574	            PyArray_Dims new_dims;
00575	            new_dims.len = 2;
00576	            new_dims.ptr = dims;
00577	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00578	            if (!success) {
00579	                // If we can't resize the ndarray we have we can allocate a new one.
00580	                PyErr_Clear();
00581	                Py_XDECREF(V1);
00582	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00583	            }
00584	        }
00585	        if (!V1) {
00586	            {
00587	        __failure = 9;
00588	        if (!PyErr_Occurred()) {
00589	            PyErr_SetString(PyExc_RuntimeError,
00590	                "Unexpected error in an Op's C code. "
00591	                "No Python exception was set.");
00592	            }
00593	        goto __label_9;}
00594	        }
00595	    }
00596	    
00597	            if (PyArray_NDIM(V1) < 2) {
00598	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00599	                {
00600	        __failure = 9;
00601	        if (!PyErr_Occurred()) {
00602	            PyErr_SetString(PyExc_RuntimeError,
00603	                "Unexpected error in an Op's C code. "
00604	                "No Python exception was set.");
00605	            }
00606	        goto __label_9;}
00607	            }
00608	            
00609	                V1_n1 = PyArray_DIMS(V1)[1];
00610	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00611	                V1_jump1_1 = (V1_stride1) - (0);
00612	                //printf("V1_jump1_1 is:");
00613	                //std::cout << V1_jump1_1 << std::endl;
00614	                
00615	                V1_n0 = PyArray_DIMS(V1)[0];
00616	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00617	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00618	                //printf("V1_jump0_0 is:");
00619	                //std::cout << V1_jump0_0 << std::endl;
00620	                
00621	
00622	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V1))){
00623	                
00624	                    // All output have the same size
00625	                    npy_intp n = PyArray_SIZE(V1);
00626	                    
00627	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00628	                            
00629	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00630	                            
00631	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00632	                            
00633	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00634	                            
00635	                    for(int i=0; i<n; i++){
00636	                        
00637	            dtype_V3& V3_i = V3_ptr[i];
00638	                            
00639	            dtype_V5& V5_i = V5_ptr[i];
00640	                            
00641	            dtype_V7& V7_i = V7_ptr[i];
00642	                            
00643	            dtype_V1& V1_i = V1_ptr[i];
00644	                            
00645	                        {
00646	npy_float64 V9_tmp1;
00647	V9_tmp1 = V5_i * V7_i;
00648	npy_float64 V9_tmp2;
00649	V9_tmp2 = V3_i + V9_tmp1;
00650	npy_float64 V9_tmp3;
00651	V9_tmp3 = V9_tmp2 - V7_i;
00652	V1_i = V9_tmp3 - V7_i;
00653	}
00654	;
00655	                    }
00656	                    
00657	            }else{
00658	                {
00659	
00660	    std::vector< std::pair<int, int> > V1_loops(2);
00661	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00662	    
00663	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00664	            
00665	        V1_loops_it->second = 0;
00666	        ++V1_loops_it;
00667	        
00668	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00669	            
00670	        V1_loops_it->second = 1;
00671	        ++V1_loops_it;
00672	        
00673	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00674	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00675	    
00676	
00677	    int init_totals[2] = {V3_n0, V3_n1};
00678	    
00679	    V1_loops_it = V1_loops.begin();
00680	    
00681	        int TOTAL_0 = init_totals[V1_loops_it->second];
00682	        ++V1_loops_it;
00683	        
00684	        int TOTAL_1 = init_totals[V1_loops_it->second];
00685	        ++V1_loops_it;
00686	        
00687	
00688	    int init_strides[4][2] = {
00689	        V3_stride0, V3_stride1, 
00690	V5_stride0, V5_stride1, 
00691	V7_stride0, V7_stride1, 
00692	V1_stride0, V1_stride1
00693	    };
00694	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00695	    
00696	        V1_loops_rit = V1_loops.rbegin();
00697	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00698	            ++V1_loops_rit;
00699	            
00700	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00701	            ++V1_loops_rit;
00702	            
00703	        V1_loops_rit = V1_loops.rbegin();
00704	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00705	            ++V1_loops_rit;
00706	            
00707	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00708	            ++V1_loops_rit;
00709	            
00710	        V1_loops_rit = V1_loops.rbegin();
00711	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00712	            ++V1_loops_rit;
00713	            
00714	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00715	            ++V1_loops_rit;
00716	            
00717	        V1_loops_rit = V1_loops.rbegin();
00718	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00719	            ++V1_loops_rit;
00720	            
00721	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00722	            ++V1_loops_rit;
00723	            
00724	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00725	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00726	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00727	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00728	
00729	
00730	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00731	        { // begin loop 0
00732	            
00733	            
00734	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00735	        { // begin loop 1
00736	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00737	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00738	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00739	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00740	
00741	            
00742	        {
00743	            
00744	            {
00745	npy_float64 V9_tmp1;
00746	V9_tmp1 = V5_i * V7_i;
00747	npy_float64 V9_tmp2;
00748	V9_tmp2 = V3_i + V9_tmp1;
00749	npy_float64 V9_tmp3;
00750	V9_tmp3 = V9_tmp2 - V7_i;
00751	V1_i = V9_tmp3 - V7_i;
00752	}
00753	
00754	            
00755	        }
00756	        
00757	        } // end loop 1
00758	        
00759	        } // end loop 0
00760	        
00761	}
00762	
00763	            }
00764	            __label_9:
00765	
00766	double __DUMMY_9;
00767	
00768	}
00769	__label_8:
00770	
00771	        if (V7) {
00772	            Py_XDECREF(V7);
00773	        }
00774	        
00775	    {Py_XDECREF(py_V7);}
00776	    
00777	double __DUMMY_8;
00778	
00779	}
00780	__label_6:
00781	
00782	        if (V5) {
00783	            Py_XDECREF(V5);
00784	        }
00785	        
00786	    {Py_XDECREF(py_V5);}
00787	    
00788	double __DUMMY_6;
00789	
00790	}
00791	__label_4:
00792	
00793	        if (V3) {
00794	            Py_XDECREF(V3);
00795	        }
00796	        
00797	    {Py_XDECREF(py_V3);}
00798	    
00799	double __DUMMY_4;
00800	
00801	}
00802	__label_2:
00803	
00804	    if (!__failure) {
00805	      
00806	        {Py_XDECREF(py_V1);}
00807	        if (!V1) {
00808	            Py_INCREF(Py_None);
00809	            py_V1 = Py_None;
00810	        }
00811	        else if ((void*)py_V1 != (void*)V1) {
00812	            py_V1 = (PyObject*)V1;
00813	        }
00814	
00815	        {Py_XINCREF(py_V1);}
00816	
00817	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00818	            PyErr_Format(PyExc_NotImplementedError,
00819	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00820	                         " with %ld dimensions, with 3 last dims "
00821	                         "%ld, %ld, %ld"
00822	                         " and 3 last strides %ld %ld, %ld.",
00823	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00824	                         (long int) PyArray_NDIM(V1),
00825	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00826	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00827	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00828	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00829	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00830	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00831	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00832	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00833	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00834	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00835	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00836	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00837	        );
00838	            {
00839	        __failure = 2;
00840	        if (!PyErr_Occurred()) {
00841	            PyErr_SetString(PyExc_RuntimeError,
00842	                "Unexpected error in an Op's C code. "
00843	                "No Python exception was set.");
00844	            }
00845	        goto __label_2;}
00846	        }
00847	        
00848	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00849	      {Py_XINCREF(py_V1);}
00850	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00851	      {Py_XDECREF(old);}
00852	    }
00853	    
00854	        if (V1) {
00855	            Py_XDECREF(V1);
00856	        }
00857	        
00858	    {Py_XDECREF(py_V1);}
00859	    
00860	double __DUMMY_2;
00861	
00862	}
00863	
00864	            
00865	        if (__failure) {
00866	            // When there is a failure, this code puts the exception
00867	            // in __ERROR.
00868	            PyObject* err_type = NULL;
00869	            PyObject* err_msg = NULL;
00870	            PyObject* err_traceback = NULL;
00871	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00872	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00873	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00874	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00875	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00876	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00877	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00878	            PyList_SET_ITEM(__ERROR, 0, err_type);
00879	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00880	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00881	            {Py_XDECREF(old_err_type);}
00882	            {Py_XDECREF(old_err_msg);}
00883	            {Py_XDECREF(old_err_traceback);}
00884	        }
00885	        // The failure code is returned to index what code block failed.
00886	        return __failure;
00887	        
00888	        }
00889	    };
00890	    }
00891	    
00892	
00893	        static int __struct_compiled_op_34ef066b34596f809536d8b71d4a16ff_executor(__struct_compiled_op_34ef066b34596f809536d8b71d4a16ff* self) {
00894	            return self->run();
00895	        }
00896	
00897	        static void __struct_compiled_op_34ef066b34596f809536d8b71d4a16ff_destructor(void* executor, void* self) {
00898	            delete ((__struct_compiled_op_34ef066b34596f809536d8b71d4a16ff*)self);
00899	        }
00900	        
00901	//////////////////////
00902	////  Functions
00903	//////////////////////
00904	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00905	  assert(PyTuple_Check(argtuple));
00906	  if (5 != PyTuple_Size(argtuple)){ 
00907	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
00908	     return NULL;
00909	  }
00910	  __struct_compiled_op_34ef066b34596f809536d8b71d4a16ff* struct_ptr = new __struct_compiled_op_34ef066b34596f809536d8b71d4a16ff();
00911	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
00912	    delete struct_ptr;
00913	    return NULL;
00914	  }
00915	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_34ef066b34596f809536d8b71d4a16ff_executor), struct_ptr, __struct_compiled_op_34ef066b34596f809536d8b71d4a16ff_destructor);
00916	  return thunk; }
00917	
00918	//////////////////////
00919	////  Module init
00920	//////////////////////
00921	static PyMethodDef MyMethods[] = {
00922		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00923		{NULL, NULL, 0, NULL}
00924	};
00925	PyMODINIT_FUNC init34ef066b34596f809536d8b71d4a16ff(void){
00926	   import_array();
00927	   (void) Py_InitModule("34ef066b34596f809536d8b71d4a16ff", MyMethods);
00928	}
00929	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpJUnI8q/34ef066b34596f809536d8b71d4a16ff.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpJUnI8q/mod.cpp -lpython2.7
ERROR
test_grad_override_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_grad_override_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_infer_shape (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                npy_intp V3_n0;
00273	                ssize_t V3_stride0;
00274	                int V3_jump0_0;
00275	                
00276	                npy_intp V3_n1;
00277	                ssize_t V3_stride1;
00278	                int V3_jump1_1;
00279	                
00280	        npy_float64* V5_iter;
00281	        
00282	                npy_intp V5_n0;
00283	                ssize_t V5_stride0;
00284	                int V5_jump0_0;
00285	                
00286	                npy_intp V5_n1;
00287	                ssize_t V5_stride1;
00288	                int V5_jump1_1;
00289	                
00290	
00291	            if (PyArray_NDIM(V3) < 2) {
00292	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00293	                {
00294	        __failure = 7;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_7;}
00301	            }
00302	            
00303	                V3_n1 = PyArray_DIMS(V3)[1];
00304	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00305	                V3_jump1_1 = (V3_stride1) - (0);
00306	                //printf("V3_jump1_1 is:");
00307	                //std::cout << V3_jump1_1 << std::endl;
00308	                
00309	                V3_n0 = PyArray_DIMS(V3)[0];
00310	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00311	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00312	                //printf("V3_jump0_0 is:");
00313	                //std::cout << V3_jump0_0 << std::endl;
00314	                
00315	            if (PyArray_NDIM(V5) < 2) {
00316	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00317	                {
00318	        __failure = 7;
00319	        if (!PyErr_Occurred()) {
00320	            PyErr_SetString(PyExc_RuntimeError,
00321	                "Unexpected error in an Op's C code. "
00322	                "No Python exception was set.");
00323	            }
00324	        goto __label_7;}
00325	            }
00326	            
00327	                V5_n1 = PyArray_DIMS(V5)[1];
00328	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00329	                V5_jump1_1 = (V5_stride1) - (0);
00330	                //printf("V5_jump1_1 is:");
00331	                //std::cout << V5_jump1_1 << std::endl;
00332	                
00333	                V5_n0 = PyArray_DIMS(V5)[0];
00334	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00335	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00336	                //printf("V5_jump0_0 is:");
00337	                //std::cout << V5_jump0_0 << std::endl;
00338	                
00339	            if (V3_n0 != V5_n0)
00340	            {
00341	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00342	                   0,
00343	                   0,
00344	                   V3_n0,
00345	                   1,
00346	                   0,
00347	                   V5_n0
00348	                );
00349	                {
00350	        __failure = 7;
00351	        if (!PyErr_Occurred()) {
00352	            PyErr_SetString(PyExc_RuntimeError,
00353	                "Unexpected error in an Op's C code. "
00354	                "No Python exception was set.");
00355	            }
00356	        goto __label_7;}
00357	            }
00358	            
00359	            if (V3_n1 != V5_n1)
00360	            {
00361	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00362	                   0,
00363	                   1,
00364	                   V3_n1,
00365	                   1,
00366	                   1,
00367	                   V5_n1
00368	                );
00369	                {
00370	        __failure = 7;
00371	        if (!PyErr_Occurred()) {
00372	            PyErr_SetString(PyExc_RuntimeError,
00373	                "Unexpected error in an Op's C code. "
00374	                "No Python exception was set.");
00375	            }
00376	        goto __label_7;}
00377	            }
00378	            
00379	
00380	        npy_float64* V1_iter;
00381	        
00382	                npy_intp V1_n0;
00383	                ssize_t V1_stride0;
00384	                int V1_jump0_0;
00385	                
00386	                npy_intp V1_n1;
00387	                ssize_t V1_stride1;
00388	                int V1_jump1_1;
00389	                
00390	    {
00391	        npy_intp dims[2];
00392	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00393	        dims[0] = V3_n0;
00394	dims[1] = V3_n1;
00395	
00396	        if (!V1) {
00397	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00398	                                                    NPY_FLOAT64,
00399	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00400	        }
00401	        else {
00402	            PyArray_Dims new_dims;
00403	            new_dims.len = 2;
00404	            new_dims.ptr = dims;
00405	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00406	            if (!success) {
00407	                // If we can't resize the ndarray we have we can allocate a new one.
00408	                PyErr_Clear();
00409	                Py_XDECREF(V1);
00410	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00411	            }
00412	        }
00413	        if (!V1) {
00414	            {
00415	        __failure = 7;
00416	        if (!PyErr_Occurred()) {
00417	            PyErr_SetString(PyExc_RuntimeError,
00418	                "Unexpected error in an Op's C code. "
00419	                "No Python exception was set.");
00420	            }
00421	        goto __label_7;}
00422	        }
00423	    }
00424	    
00425	            if (PyArray_NDIM(V1) < 2) {
00426	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00427	                {
00428	        __failure = 7;
00429	        if (!PyErr_Occurred()) {
00430	            PyErr_SetString(PyExc_RuntimeError,
00431	                "Unexpected error in an Op's C code. "
00432	                "No Python exception was set.");
00433	            }
00434	        goto __label_7;}
00435	            }
00436	            
00437	                V1_n1 = PyArray_DIMS(V1)[1];
00438	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00439	                V1_jump1_1 = (V1_stride1) - (0);
00440	                //printf("V1_jump1_1 is:");
00441	                //std::cout << V1_jump1_1 << std::endl;
00442	                
00443	                V1_n0 = PyArray_DIMS(V1)[0];
00444	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00445	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00446	                //printf("V1_jump0_0 is:");
00447	                //std::cout << V1_jump0_0 << std::endl;
00448	                
00449	
00450	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00451	                
00452	                    // All output have the same size
00453	                    npy_intp n = PyArray_SIZE(V1);
00454	                    
00455	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00456	                            
00457	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00458	                            
00459	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00460	                            
00461	                    for(int i=0; i<n; i++){
00462	                        
00463	            dtype_V3& V3_i = V3_ptr[i];
00464	                            
00465	            dtype_V5& V5_i = V5_ptr[i];
00466	                            
00467	            dtype_V1& V1_i = V1_ptr[i];
00468	                            
00469	                        V1_i = V3_i * V5_i;;
00470	                    }
00471	                    
00472	            }else{
00473	                {
00474	
00475	    std::vector< std::pair<int, int> > V1_loops(2);
00476	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00477	    
00478	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00479	            
00480	        V1_loops_it->second = 0;
00481	        ++V1_loops_it;
00482	        
00483	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00484	            
00485	        V1_loops_it->second = 1;
00486	        ++V1_loops_it;
00487	        
00488	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00489	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00490	    
00491	
00492	    int init_totals[2] = {V3_n0, V3_n1};
00493	    
00494	    V1_loops_it = V1_loops.begin();
00495	    
00496	        int TOTAL_0 = init_totals[V1_loops_it->second];
00497	        ++V1_loops_it;
00498	        
00499	        int TOTAL_1 = init_totals[V1_loops_it->second];
00500	        ++V1_loops_it;
00501	        
00502	
00503	    int init_strides[3][2] = {
00504	        V3_stride0, V3_stride1, 
00505	V5_stride0, V5_stride1, 
00506	V1_stride0, V1_stride1
00507	    };
00508	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00509	    
00510	        V1_loops_rit = V1_loops.rbegin();
00511	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00512	            ++V1_loops_rit;
00513	            
00514	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00515	            ++V1_loops_rit;
00516	            
00517	        V1_loops_rit = V1_loops.rbegin();
00518	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00519	            ++V1_loops_rit;
00520	            
00521	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00522	            ++V1_loops_rit;
00523	            
00524	        V1_loops_rit = V1_loops.rbegin();
00525	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00526	            ++V1_loops_rit;
00527	            
00528	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00529	            ++V1_loops_rit;
00530	            
00531	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00532	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00533	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00534	
00535	
00536	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00537	        { // begin loop 0
00538	            
00539	            
00540	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00541	        { // begin loop 1
00542	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00543	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00544	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00545	
00546	            
00547	        {
00548	            
00549	            V1_i = V3_i * V5_i;
00550	            
00551	        }
00552	        
00553	        } // end loop 1
00554	        
00555	        } // end loop 0
00556	        
00557	}
00558	
00559	            }
00560	            __label_7:
00561	
00562	double __DUMMY_7;
00563	
00564	}
00565	__label_6:
00566	
00567	        if (V5) {
00568	            Py_XDECREF(V5);
00569	        }
00570	        
00571	    {Py_XDECREF(py_V5);}
00572	    
00573	double __DUMMY_6;
00574	
00575	}
00576	__label_4:
00577	
00578	        if (V3) {
00579	            Py_XDECREF(V3);
00580	        }
00581	        
00582	    {Py_XDECREF(py_V3);}
00583	    
00584	double __DUMMY_4;
00585	
00586	}
00587	__label_2:
00588	
00589	    if (!__failure) {
00590	      
00591	        {Py_XDECREF(py_V1);}
00592	        if (!V1) {
00593	            Py_INCREF(Py_None);
00594	            py_V1 = Py_None;
00595	        }
00596	        else if ((void*)py_V1 != (void*)V1) {
00597	            py_V1 = (PyObject*)V1;
00598	        }
00599	
00600	        {Py_XINCREF(py_V1);}
00601	
00602	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00603	            PyErr_Format(PyExc_NotImplementedError,
00604	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00605	                         " with %ld dimensions, with 3 last dims "
00606	                         "%ld, %ld, %ld"
00607	                         " and 3 last strides %ld %ld, %ld.",
00608	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00609	                         (long int) PyArray_NDIM(V1),
00610	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00611	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00612	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00613	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00614	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00615	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00616	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00617	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00618	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00619	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00620	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00621	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00622	        );
00623	            {
00624	        __failure = 2;
00625	        if (!PyErr_Occurred()) {
00626	            PyErr_SetString(PyExc_RuntimeError,
00627	                "Unexpected error in an Op's C code. "
00628	                "No Python exception was set.");
00629	            }
00630	        goto __label_2;}
00631	        }
00632	        
00633	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00634	      {Py_XINCREF(py_V1);}
00635	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00636	      {Py_XDECREF(old);}
00637	    }
00638	    
00639	        if (V1) {
00640	            Py_XDECREF(V1);
00641	        }
00642	        
00643	    {Py_XDECREF(py_V1);}
00644	    
00645	double __DUMMY_2;
00646	
00647	}
00648	
00649	            
00650	        if (__failure) {
00651	            // When there is a failure, this code puts the exception
00652	            // in __ERROR.
00653	            PyObject* err_type = NULL;
00654	            PyObject* err_msg = NULL;
00655	            PyObject* err_traceback = NULL;
00656	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00657	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00658	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00659	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00660	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00661	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00662	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00663	            PyList_SET_ITEM(__ERROR, 0, err_type);
00664	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00665	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00666	            {Py_XDECREF(old_err_type);}
00667	            {Py_XDECREF(old_err_msg);}
00668	            {Py_XDECREF(old_err_traceback);}
00669	        }
00670	        // The failure code is returned to index what code block failed.
00671	        return __failure;
00672	        
00673	        }
00674	    };
00675	    }
00676	    
00677	
00678	        static int __struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5_executor(__struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5* self) {
00679	            return self->run();
00680	        }
00681	
00682	        static void __struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5_destructor(void* executor, void* self) {
00683	            delete ((__struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5*)self);
00684	        }
00685	        
00686	//////////////////////
00687	////  Functions
00688	//////////////////////
00689	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00690	  assert(PyTuple_Check(argtuple));
00691	  if (4 != PyTuple_Size(argtuple)){ 
00692	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00693	     return NULL;
00694	  }
00695	  __struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5* struct_ptr = new __struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5();
00696	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00697	    delete struct_ptr;
00698	    return NULL;
00699	  }
00700	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5_executor), struct_ptr, __struct_compiled_op_b7c1ef66d2c2253e9fd9b0170a7245a5_destructor);
00701	  return thunk; }
00702	
00703	//////////////////////
00704	////  Module init
00705	//////////////////////
00706	static PyMethodDef MyMethods[] = {
00707		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00708		{NULL, NULL, 0, NULL}
00709	};
00710	PyMODINIT_FUNC initb7c1ef66d2c2253e9fd9b0170a7245a5(void){
00711	   import_array();
00712	   (void) Py_InitModule("b7c1ef66d2c2253e9fd9b0170a7245a5", MyMethods);
00713	}
00714	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpGbCaag/b7c1ef66d2c2253e9fd9b0170a7245a5.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpGbCaag/mod.cpp -lpython2.7
ERROR
test_nested_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_nested_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_rop_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_rop_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_rop_override_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_rop_override_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_shared_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V9;
00021	PyObject* storage_V1;
00022	        
00023	
00024	        __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426() {
00025	            // This is only somewhat safe because we:
00026	            //  1) Are not a virtual class
00027	            //  2) Do not use any virtual classes in the members
00028	            //  3) Deal with mostly POD and pointers
00029	
00030	            // If this changes, we would have to revise this, but for
00031	            // now I am tired of chasing segfaults because
00032	            // initialization code had an error and some pointer has
00033	            // a junk value.
00034	            memset(this, 0, sizeof(*this));
00035	        }
00036	        ~__struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426(void) {
00037	            cleanup();
00038	        }
00039	
00040	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V9, PyObject* storage_V1) {
00041	            Py_XINCREF(storage_V3);
00042	Py_XINCREF(storage_V5);
00043	Py_XINCREF(storage_V7);
00044	Py_XINCREF(storage_V9);
00045	Py_XINCREF(storage_V1);
00046	            this->storage_V3 = storage_V3;
00047	this->storage_V5 = storage_V5;
00048	this->storage_V7 = storage_V7;
00049	this->storage_V9 = storage_V9;
00050	this->storage_V1 = storage_V1;
00051	            
00052	
00053	
00054	
00055	
00056	
00057	
00058	            this->__ERROR = __ERROR;
00059	            return 0;
00060	        }
00061	        void cleanup(void) {
00062	            __label_1:
00063	
00064	double __DUMMY_1;
00065	__label_3:
00066	
00067	double __DUMMY_3;
00068	__label_5:
00069	
00070	double __DUMMY_5;
00071	__label_7:
00072	
00073	double __DUMMY_7;
00074	__label_9:
00075	
00076	double __DUMMY_9;
00077	__label_12:
00078	
00079	double __DUMMY_12;
00080	
00081	            Py_XDECREF(this->storage_V3);
00082	Py_XDECREF(this->storage_V5);
00083	Py_XDECREF(this->storage_V7);
00084	Py_XDECREF(this->storage_V9);
00085	Py_XDECREF(this->storage_V1);
00086	        }
00087	        int run(void) {
00088	            int __failure = 0;
00089	            
00090	    PyObject* py_V1;
00091	    
00092	        PyArrayObject* V1;
00093	        
00094	            typedef npy_float64 dtype_V1;
00095	            
00096	    PyObject* py_V3;
00097	    
00098	        PyArrayObject* V3;
00099	        
00100	            typedef npy_float64 dtype_V3;
00101	            
00102	    PyObject* py_V5;
00103	    
00104	        PyArrayObject* V5;
00105	        
00106	            typedef npy_float64 dtype_V5;
00107	            
00108	    PyObject* py_V7;
00109	    
00110	        PyArrayObject* V7;
00111	        
00112	            typedef npy_float64 dtype_V7;
00113	            
00114	    PyObject* py_V9;
00115	    
00116	        PyArrayObject* V9;
00117	        
00118	            typedef npy_float64 dtype_V9;
00119	            
00120	{
00121	
00122	    py_V1 = Py_None;
00123	    {Py_XINCREF(py_V1);}
00124	    
00125	        V1 = NULL;
00126	        
00127	{
00128	
00129	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00130	    {Py_XINCREF(py_V3);}
00131	    
00132	            V3 = NULL;
00133	            if (py_V3 == Py_None) {
00134	                // We can either fail here or set V3 to NULL and rely on Ops
00135	                // using tensors to handle the NULL case, but if they fail to do so
00136	                // they'll end up with nasty segfaults, so this is public service.
00137	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00138	                {
00139	        __failure = 4;
00140	        if (!PyErr_Occurred()) {
00141	            PyErr_SetString(PyExc_RuntimeError,
00142	                "Unexpected error in an Op's C code. "
00143	                "No Python exception was set.");
00144	            }
00145	        goto __label_4;}
00146	            }
00147	            if (!PyArray_Check(py_V3)) {
00148	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00149	                {
00150	        __failure = 4;
00151	        if (!PyErr_Occurred()) {
00152	            PyErr_SetString(PyExc_RuntimeError,
00153	                "Unexpected error in an Op's C code. "
00154	                "No Python exception was set.");
00155	            }
00156	        goto __label_4;}
00157	            }
00158	            // We expect NPY_FLOAT64
00159	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00160	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00161	                PyErr_Format(PyExc_NotImplementedError,
00162	                             "expected an aligned array of type %ld "
00163	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00164	                             " with %ld dimensions, with 3 last dims "
00165	                             "%ld, %ld, %ld"
00166	                             " and 3 last strides %ld %ld, %ld.",
00167	                             (long int) NPY_FLOAT64,
00168	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00169	                             (long int) PyArray_NDIM(tmp),
00170	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00171	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00172	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00173	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00174	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00175	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00176	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00177	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00178	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00179	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00180	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00181	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00182	            );
00183	                {
00184	        __failure = 4;
00185	        if (!PyErr_Occurred()) {
00186	            PyErr_SetString(PyExc_RuntimeError,
00187	                "Unexpected error in an Op's C code. "
00188	                "No Python exception was set.");
00189	            }
00190	        goto __label_4;}
00191	            }
00192	            // This is a TypeError to be consistent with DEBUG_MODE
00193	            // Note: DEBUG_MODE also tells the name of the container
00194	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00195	                PyErr_Format(PyExc_TypeError,
00196	                             "expected type_num %d (NPY_FLOAT64) got %d",
00197	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            
00208	        V3 = (PyArrayObject*)(py_V3);
00209	        Py_XINCREF(V3);
00210	        
00211	{
00212	
00213	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00214	    {Py_XINCREF(py_V5);}
00215	    
00216	            V5 = NULL;
00217	            if (py_V5 == Py_None) {
00218	                // We can either fail here or set V5 to NULL and rely on Ops
00219	                // using tensors to handle the NULL case, but if they fail to do so
00220	                // they'll end up with nasty segfaults, so this is public service.
00221	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00222	                {
00223	        __failure = 6;
00224	        if (!PyErr_Occurred()) {
00225	            PyErr_SetString(PyExc_RuntimeError,
00226	                "Unexpected error in an Op's C code. "
00227	                "No Python exception was set.");
00228	            }
00229	        goto __label_6;}
00230	            }
00231	            if (!PyArray_Check(py_V5)) {
00232	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00233	                {
00234	        __failure = 6;
00235	        if (!PyErr_Occurred()) {
00236	            PyErr_SetString(PyExc_RuntimeError,
00237	                "Unexpected error in an Op's C code. "
00238	                "No Python exception was set.");
00239	            }
00240	        goto __label_6;}
00241	            }
00242	            // We expect NPY_FLOAT64
00243	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00244	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00245	                PyErr_Format(PyExc_NotImplementedError,
00246	                             "expected an aligned array of type %ld "
00247	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00248	                             " with %ld dimensions, with 3 last dims "
00249	                             "%ld, %ld, %ld"
00250	                             " and 3 last strides %ld %ld, %ld.",
00251	                             (long int) NPY_FLOAT64,
00252	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00253	                             (long int) PyArray_NDIM(tmp),
00254	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00255	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00256	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00257	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00258	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00259	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00260	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00261	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00262	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00263	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00264	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00265	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00266	            );
00267	                {
00268	        __failure = 6;
00269	        if (!PyErr_Occurred()) {
00270	            PyErr_SetString(PyExc_RuntimeError,
00271	                "Unexpected error in an Op's C code. "
00272	                "No Python exception was set.");
00273	            }
00274	        goto __label_6;}
00275	            }
00276	            // This is a TypeError to be consistent with DEBUG_MODE
00277	            // Note: DEBUG_MODE also tells the name of the container
00278	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00279	                PyErr_Format(PyExc_TypeError,
00280	                             "expected type_num %d (NPY_FLOAT64) got %d",
00281	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            
00292	        V5 = (PyArrayObject*)(py_V5);
00293	        Py_XINCREF(V5);
00294	        
00295	{
00296	
00297	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00298	    {Py_XINCREF(py_V7);}
00299	    
00300	            V7 = NULL;
00301	            if (py_V7 == Py_None) {
00302	                // We can either fail here or set V7 to NULL and rely on Ops
00303	                // using tensors to handle the NULL case, but if they fail to do so
00304	                // they'll end up with nasty segfaults, so this is public service.
00305	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00306	                {
00307	        __failure = 8;
00308	        if (!PyErr_Occurred()) {
00309	            PyErr_SetString(PyExc_RuntimeError,
00310	                "Unexpected error in an Op's C code. "
00311	                "No Python exception was set.");
00312	            }
00313	        goto __label_8;}
00314	            }
00315	            if (!PyArray_Check(py_V7)) {
00316	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00317	                {
00318	        __failure = 8;
00319	        if (!PyErr_Occurred()) {
00320	            PyErr_SetString(PyExc_RuntimeError,
00321	                "Unexpected error in an Op's C code. "
00322	                "No Python exception was set.");
00323	            }
00324	        goto __label_8;}
00325	            }
00326	            // We expect NPY_FLOAT64
00327	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00328	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00329	                PyErr_Format(PyExc_NotImplementedError,
00330	                             "expected an aligned array of type %ld "
00331	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00332	                             " with %ld dimensions, with 3 last dims "
00333	                             "%ld, %ld, %ld"
00334	                             " and 3 last strides %ld %ld, %ld.",
00335	                             (long int) NPY_FLOAT64,
00336	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00337	                             (long int) PyArray_NDIM(tmp),
00338	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00339	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00340	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00341	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00342	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00343	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00344	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00345	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00346	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00347	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00348	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00349	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00350	            );
00351	                {
00352	        __failure = 8;
00353	        if (!PyErr_Occurred()) {
00354	            PyErr_SetString(PyExc_RuntimeError,
00355	                "Unexpected error in an Op's C code. "
00356	                "No Python exception was set.");
00357	            }
00358	        goto __label_8;}
00359	            }
00360	            // This is a TypeError to be consistent with DEBUG_MODE
00361	            // Note: DEBUG_MODE also tells the name of the container
00362	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00363	                PyErr_Format(PyExc_TypeError,
00364	                             "expected type_num %d (NPY_FLOAT64) got %d",
00365	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00366	                {
00367	        __failure = 8;
00368	        if (!PyErr_Occurred()) {
00369	            PyErr_SetString(PyExc_RuntimeError,
00370	                "Unexpected error in an Op's C code. "
00371	                "No Python exception was set.");
00372	            }
00373	        goto __label_8;}
00374	            }
00375	            
00376	        V7 = (PyArrayObject*)(py_V7);
00377	        Py_XINCREF(V7);
00378	        
00379	{
00380	
00381	    py_V9 = PyList_GET_ITEM(storage_V9, 0);
00382	    {Py_XINCREF(py_V9);}
00383	    
00384	            V9 = NULL;
00385	            if (py_V9 == Py_None) {
00386	                // We can either fail here or set V9 to NULL and rely on Ops
00387	                // using tensors to handle the NULL case, but if they fail to do so
00388	                // they'll end up with nasty segfaults, so this is public service.
00389	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00390	                {
00391	        __failure = 10;
00392	        if (!PyErr_Occurred()) {
00393	            PyErr_SetString(PyExc_RuntimeError,
00394	                "Unexpected error in an Op's C code. "
00395	                "No Python exception was set.");
00396	            }
00397	        goto __label_10;}
00398	            }
00399	            if (!PyArray_Check(py_V9)) {
00400	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00401	                {
00402	        __failure = 10;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_10;}
00409	            }
00410	            // We expect NPY_FLOAT64
00411	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V9)) {
00412	                PyArrayObject * tmp = (PyArrayObject*) py_V9;
00413	                PyErr_Format(PyExc_NotImplementedError,
00414	                             "expected an aligned array of type %ld "
00415	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00416	                             " with %ld dimensions, with 3 last dims "
00417	                             "%ld, %ld, %ld"
00418	                             " and 3 last strides %ld %ld, %ld.",
00419	                             (long int) NPY_FLOAT64,
00420	                             (long int) PyArray_TYPE((PyArrayObject*) py_V9),
00421	                             (long int) PyArray_NDIM(tmp),
00422	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00423	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00424	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00425	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00426	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00427	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00428	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00429	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00430	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00431	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00432	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00433	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00434	            );
00435	                {
00436	        __failure = 10;
00437	        if (!PyErr_Occurred()) {
00438	            PyErr_SetString(PyExc_RuntimeError,
00439	                "Unexpected error in an Op's C code. "
00440	                "No Python exception was set.");
00441	            }
00442	        goto __label_10;}
00443	            }
00444	            // This is a TypeError to be consistent with DEBUG_MODE
00445	            // Note: DEBUG_MODE also tells the name of the container
00446	            if (PyArray_TYPE((PyArrayObject*) py_V9) != NPY_FLOAT64) {
00447	                PyErr_Format(PyExc_TypeError,
00448	                             "expected type_num %d (NPY_FLOAT64) got %d",
00449	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V9));
00450	                {
00451	        __failure = 10;
00452	        if (!PyErr_Occurred()) {
00453	            PyErr_SetString(PyExc_RuntimeError,
00454	                "Unexpected error in an Op's C code. "
00455	                "No Python exception was set.");
00456	            }
00457	        goto __label_10;}
00458	            }
00459	            
00460	        V9 = (PyArrayObject*)(py_V9);
00461	        Py_XINCREF(V9);
00462	        
00463	{
00464	// Op class Elemwise
00465	
00466	        npy_float64* V3_iter;
00467	        
00468	                npy_intp V3_n0;
00469	                ssize_t V3_stride0;
00470	                int V3_jump0_0;
00471	                
00472	                npy_intp V3_n1;
00473	                ssize_t V3_stride1;
00474	                int V3_jump1_1;
00475	                
00476	        npy_float64* V5_iter;
00477	        
00478	                npy_intp V5_n0;
00479	                ssize_t V5_stride0;
00480	                int V5_jump0_0;
00481	                
00482	                npy_intp V5_n1;
00483	                ssize_t V5_stride1;
00484	                int V5_jump1_1;
00485	                
00486	        npy_float64* V7_iter;
00487	        
00488	                npy_intp V7_n0;
00489	                ssize_t V7_stride0;
00490	                int V7_jump0_0;
00491	                
00492	                npy_intp V7_n1;
00493	                ssize_t V7_stride1;
00494	                int V7_jump1_1;
00495	                
00496	        npy_float64* V9_iter;
00497	        
00498	                npy_intp V9_n0;
00499	                ssize_t V9_stride0;
00500	                int V9_jump0_0;
00501	                
00502	                npy_intp V9_n1;
00503	                ssize_t V9_stride1;
00504	                int V9_jump1_1;
00505	                
00506	
00507	            if (PyArray_NDIM(V3) < 2) {
00508	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00509	                {
00510	        __failure = 11;
00511	        if (!PyErr_Occurred()) {
00512	            PyErr_SetString(PyExc_RuntimeError,
00513	                "Unexpected error in an Op's C code. "
00514	                "No Python exception was set.");
00515	            }
00516	        goto __label_11;}
00517	            }
00518	            
00519	                V3_n1 = PyArray_DIMS(V3)[1];
00520	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00521	                V3_jump1_1 = (V3_stride1) - (0);
00522	                //printf("V3_jump1_1 is:");
00523	                //std::cout << V3_jump1_1 << std::endl;
00524	                
00525	                V3_n0 = PyArray_DIMS(V3)[0];
00526	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00527	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00528	                //printf("V3_jump0_0 is:");
00529	                //std::cout << V3_jump0_0 << std::endl;
00530	                
00531	            if (PyArray_NDIM(V5) < 2) {
00532	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00533	                {
00534	        __failure = 11;
00535	        if (!PyErr_Occurred()) {
00536	            PyErr_SetString(PyExc_RuntimeError,
00537	                "Unexpected error in an Op's C code. "
00538	                "No Python exception was set.");
00539	            }
00540	        goto __label_11;}
00541	            }
00542	            
00543	                V5_n1 = PyArray_DIMS(V5)[1];
00544	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00545	                V5_jump1_1 = (V5_stride1) - (0);
00546	                //printf("V5_jump1_1 is:");
00547	                //std::cout << V5_jump1_1 << std::endl;
00548	                
00549	                V5_n0 = PyArray_DIMS(V5)[0];
00550	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00551	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00552	                //printf("V5_jump0_0 is:");
00553	                //std::cout << V5_jump0_0 << std::endl;
00554	                
00555	            if (PyArray_NDIM(V7) < 2) {
00556	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00557	                {
00558	        __failure = 11;
00559	        if (!PyErr_Occurred()) {
00560	            PyErr_SetString(PyExc_RuntimeError,
00561	                "Unexpected error in an Op's C code. "
00562	                "No Python exception was set.");
00563	            }
00564	        goto __label_11;}
00565	            }
00566	            
00567	                V7_n1 = PyArray_DIMS(V7)[1];
00568	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00569	                V7_jump1_1 = (V7_stride1) - (0);
00570	                //printf("V7_jump1_1 is:");
00571	                //std::cout << V7_jump1_1 << std::endl;
00572	                
00573	                V7_n0 = PyArray_DIMS(V7)[0];
00574	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00575	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00576	                //printf("V7_jump0_0 is:");
00577	                //std::cout << V7_jump0_0 << std::endl;
00578	                
00579	            if (PyArray_NDIM(V9) < 2) {
00580	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00581	                {
00582	        __failure = 11;
00583	        if (!PyErr_Occurred()) {
00584	            PyErr_SetString(PyExc_RuntimeError,
00585	                "Unexpected error in an Op's C code. "
00586	                "No Python exception was set.");
00587	            }
00588	        goto __label_11;}
00589	            }
00590	            
00591	                V9_n1 = PyArray_DIMS(V9)[1];
00592	                V9_stride1 = PyArray_STRIDES(V9)[1] / sizeof(npy_float64);
00593	                V9_jump1_1 = (V9_stride1) - (0);
00594	                //printf("V9_jump1_1 is:");
00595	                //std::cout << V9_jump1_1 << std::endl;
00596	                
00597	                V9_n0 = PyArray_DIMS(V9)[0];
00598	                V9_stride0 = PyArray_STRIDES(V9)[0] / sizeof(npy_float64);
00599	                V9_jump0_0 = (V9_stride0) - (V9_n1*V9_stride1);
00600	                //printf("V9_jump0_0 is:");
00601	                //std::cout << V9_jump0_0 << std::endl;
00602	                
00603	            if (V3_n0 != V5_n0)
00604	            {
00605	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00606	                   0,
00607	                   0,
00608	                   V3_n0,
00609	                   1,
00610	                   0,
00611	                   V5_n0
00612	                );
00613	                {
00614	        __failure = 11;
00615	        if (!PyErr_Occurred()) {
00616	            PyErr_SetString(PyExc_RuntimeError,
00617	                "Unexpected error in an Op's C code. "
00618	                "No Python exception was set.");
00619	            }
00620	        goto __label_11;}
00621	            }
00622	            
00623	            if (V3_n0 != V7_n0)
00624	            {
00625	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00626	                   0,
00627	                   0,
00628	                   V3_n0,
00629	                   2,
00630	                   0,
00631	                   V7_n0
00632	                );
00633	                {
00634	        __failure = 11;
00635	        if (!PyErr_Occurred()) {
00636	            PyErr_SetString(PyExc_RuntimeError,
00637	                "Unexpected error in an Op's C code. "
00638	                "No Python exception was set.");
00639	            }
00640	        goto __label_11;}
00641	            }
00642	            
00643	            if (V3_n0 != V9_n0)
00644	            {
00645	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00646	                   0,
00647	                   0,
00648	                   V3_n0,
00649	                   3,
00650	                   0,
00651	                   V9_n0
00652	                );
00653	                {
00654	        __failure = 11;
00655	        if (!PyErr_Occurred()) {
00656	            PyErr_SetString(PyExc_RuntimeError,
00657	                "Unexpected error in an Op's C code. "
00658	                "No Python exception was set.");
00659	            }
00660	        goto __label_11;}
00661	            }
00662	            
00663	            if (V3_n1 != V5_n1)
00664	            {
00665	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00666	                   0,
00667	                   1,
00668	                   V3_n1,
00669	                   1,
00670	                   1,
00671	                   V5_n1
00672	                );
00673	                {
00674	        __failure = 11;
00675	        if (!PyErr_Occurred()) {
00676	            PyErr_SetString(PyExc_RuntimeError,
00677	                "Unexpected error in an Op's C code. "
00678	                "No Python exception was set.");
00679	            }
00680	        goto __label_11;}
00681	            }
00682	            
00683	            if (V3_n1 != V7_n1)
00684	            {
00685	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00686	                   0,
00687	                   1,
00688	                   V3_n1,
00689	                   2,
00690	                   1,
00691	                   V7_n1
00692	                );
00693	                {
00694	        __failure = 11;
00695	        if (!PyErr_Occurred()) {
00696	            PyErr_SetString(PyExc_RuntimeError,
00697	                "Unexpected error in an Op's C code. "
00698	                "No Python exception was set.");
00699	            }
00700	        goto __label_11;}
00701	            }
00702	            
00703	            if (V3_n1 != V9_n1)
00704	            {
00705	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00706	                   0,
00707	                   1,
00708	                   V3_n1,
00709	                   3,
00710	                   1,
00711	                   V9_n1
00712	                );
00713	                {
00714	        __failure = 11;
00715	        if (!PyErr_Occurred()) {
00716	            PyErr_SetString(PyExc_RuntimeError,
00717	                "Unexpected error in an Op's C code. "
00718	                "No Python exception was set.");
00719	            }
00720	        goto __label_11;}
00721	            }
00722	            
00723	
00724	        npy_float64* V1_iter;
00725	        
00726	                npy_intp V1_n0;
00727	                ssize_t V1_stride0;
00728	                int V1_jump0_0;
00729	                
00730	                npy_intp V1_n1;
00731	                ssize_t V1_stride1;
00732	                int V1_jump1_1;
00733	                
00734	    {
00735	        npy_intp dims[2];
00736	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00737	        dims[0] = V3_n0;
00738	dims[1] = V3_n1;
00739	
00740	        if (!V1) {
00741	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00742	                                                    NPY_FLOAT64,
00743	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V9));
00744	        }
00745	        else {
00746	            PyArray_Dims new_dims;
00747	            new_dims.len = 2;
00748	            new_dims.ptr = dims;
00749	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00750	            if (!success) {
00751	                // If we can't resize the ndarray we have we can allocate a new one.
00752	                PyErr_Clear();
00753	                Py_XDECREF(V1);
00754	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00755	            }
00756	        }
00757	        if (!V1) {
00758	            {
00759	        __failure = 11;
00760	        if (!PyErr_Occurred()) {
00761	            PyErr_SetString(PyExc_RuntimeError,
00762	                "Unexpected error in an Op's C code. "
00763	                "No Python exception was set.");
00764	            }
00765	        goto __label_11;}
00766	        }
00767	    }
00768	    
00769	            if (PyArray_NDIM(V1) < 2) {
00770	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00771	                {
00772	        __failure = 11;
00773	        if (!PyErr_Occurred()) {
00774	            PyErr_SetString(PyExc_RuntimeError,
00775	                "Unexpected error in an Op's C code. "
00776	                "No Python exception was set.");
00777	            }
00778	        goto __label_11;}
00779	            }
00780	            
00781	                V1_n1 = PyArray_DIMS(V1)[1];
00782	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00783	                V1_jump1_1 = (V1_stride1) - (0);
00784	                //printf("V1_jump1_1 is:");
00785	                //std::cout << V1_jump1_1 << std::endl;
00786	                
00787	                V1_n0 = PyArray_DIMS(V1)[0];
00788	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00789	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00790	                //printf("V1_jump0_0 is:");
00791	                //std::cout << V1_jump0_0 << std::endl;
00792	                
00793	
00794	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V9) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V9) && PyArray_ISFORTRAN(V1))){
00795	                
00796	                    // All output have the same size
00797	                    npy_intp n = PyArray_SIZE(V1);
00798	                    
00799	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00800	                            
00801	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00802	                            
00803	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00804	                            
00805	            dtype_V9 * V9_ptr = (dtype_V9*) PyArray_DATA(V9);
00806	                            
00807	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00808	                            
00809	                    for(int i=0; i<n; i++){
00810	                        
00811	            dtype_V3& V3_i = V3_ptr[i];
00812	                            
00813	            dtype_V5& V5_i = V5_ptr[i];
00814	                            
00815	            dtype_V7& V7_i = V7_ptr[i];
00816	                            
00817	            dtype_V9& V9_i = V9_ptr[i];
00818	                            
00819	            dtype_V1& V1_i = V1_ptr[i];
00820	                            
00821	                        {
00822	npy_float64 V11_tmp1;
00823	V11_tmp1 = V5_i * V7_i;
00824	V1_i = V3_i + V11_tmp1 + V9_i;
00825	}
00826	;
00827	                    }
00828	                    
00829	            }else{
00830	                {
00831	
00832	    std::vector< std::pair<int, int> > V1_loops(2);
00833	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00834	    
00835	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00836	            
00837	        V1_loops_it->second = 0;
00838	        ++V1_loops_it;
00839	        
00840	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00841	            
00842	        V1_loops_it->second = 1;
00843	        ++V1_loops_it;
00844	        
00845	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00846	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00847	    
00848	
00849	    int init_totals[2] = {V3_n0, V3_n1};
00850	    
00851	    V1_loops_it = V1_loops.begin();
00852	    
00853	        int TOTAL_0 = init_totals[V1_loops_it->second];
00854	        ++V1_loops_it;
00855	        
00856	        int TOTAL_1 = init_totals[V1_loops_it->second];
00857	        ++V1_loops_it;
00858	        
00859	
00860	    int init_strides[5][2] = {
00861	        V3_stride0, V3_stride1, 
00862	V5_stride0, V5_stride1, 
00863	V7_stride0, V7_stride1, 
00864	V9_stride0, V9_stride1, 
00865	V1_stride0, V1_stride1
00866	    };
00867	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00868	    
00869	        V1_loops_rit = V1_loops.rbegin();
00870	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00871	            ++V1_loops_rit;
00872	            
00873	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00874	            ++V1_loops_rit;
00875	            
00876	        V1_loops_rit = V1_loops.rbegin();
00877	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00878	            ++V1_loops_rit;
00879	            
00880	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00881	            ++V1_loops_rit;
00882	            
00883	        V1_loops_rit = V1_loops.rbegin();
00884	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00885	            ++V1_loops_rit;
00886	            
00887	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00888	            ++V1_loops_rit;
00889	            
00890	        V1_loops_rit = V1_loops.rbegin();
00891	            int V9_stride_l1 = init_strides[3][V1_loops_rit->second];
00892	            ++V1_loops_rit;
00893	            
00894	            int V9_stride_l0 = init_strides[3][V1_loops_rit->second];
00895	            ++V1_loops_rit;
00896	            
00897	        V1_loops_rit = V1_loops.rbegin();
00898	            int V1_stride_l1 = init_strides[4][V1_loops_rit->second];
00899	            ++V1_loops_rit;
00900	            
00901	            int V1_stride_l0 = init_strides[4][V1_loops_rit->second];
00902	            ++V1_loops_rit;
00903	            
00904	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00905	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00906	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00907	V9_iter = (npy_float64*)(PyArray_DATA(V9));
00908	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00909	
00910	
00911	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00912	        { // begin loop 0
00913	            
00914	            
00915	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00916	        { // begin loop 1
00917	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00918	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00919	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00920	npy_float64 &V9_i = * ( V9_iter+V9_stride_l1*ITER_1+V9_stride_l0*ITER_0);
00921	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00922	
00923	            
00924	        {
00925	            
00926	            {
00927	npy_float64 V11_tmp1;
00928	V11_tmp1 = V5_i * V7_i;
00929	V1_i = V3_i + V11_tmp1 + V9_i;
00930	}
00931	
00932	            
00933	        }
00934	        
00935	        } // end loop 1
00936	        
00937	        } // end loop 0
00938	        
00939	}
00940	
00941	            }
00942	            __label_11:
00943	
00944	double __DUMMY_11;
00945	
00946	}
00947	__label_10:
00948	
00949	        if (V9) {
00950	            Py_XDECREF(V9);
00951	        }
00952	        
00953	    {Py_XDECREF(py_V9);}
00954	    
00955	double __DUMMY_10;
00956	
00957	}
00958	__label_8:
00959	
00960	        if (V7) {
00961	            Py_XDECREF(V7);
00962	        }
00963	        
00964	    {Py_XDECREF(py_V7);}
00965	    
00966	double __DUMMY_8;
00967	
00968	}
00969	__label_6:
00970	
00971	        if (V5) {
00972	            Py_XDECREF(V5);
00973	        }
00974	        
00975	    {Py_XDECREF(py_V5);}
00976	    
00977	double __DUMMY_6;
00978	
00979	}
00980	__label_4:
00981	
00982	        if (V3) {
00983	            Py_XDECREF(V3);
00984	        }
00985	        
00986	    {Py_XDECREF(py_V3);}
00987	    
00988	double __DUMMY_4;
00989	
00990	}
00991	__label_2:
00992	
00993	    if (!__failure) {
00994	      
00995	        {Py_XDECREF(py_V1);}
00996	        if (!V1) {
00997	            Py_INCREF(Py_None);
00998	            py_V1 = Py_None;
00999	        }
01000	        else if ((void*)py_V1 != (void*)V1) {
01001	            py_V1 = (PyObject*)V1;
01002	        }
01003	
01004	        {Py_XINCREF(py_V1);}
01005	
01006	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
01007	            PyErr_Format(PyExc_NotImplementedError,
01008	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
01009	                         " with %ld dimensions, with 3 last dims "
01010	                         "%ld, %ld, %ld"
01011	                         " and 3 last strides %ld %ld, %ld.",
01012	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
01013	                         (long int) PyArray_NDIM(V1),
01014	                         (long int) (PyArray_NDIM(V1) >= 3 ?
01015	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
01016	                         (long int) (PyArray_NDIM(V1) >= 2 ?
01017	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
01018	                         (long int) (PyArray_NDIM(V1) >= 1 ?
01019	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
01020	                         (long int) (PyArray_NDIM(V1) >= 3 ?
01021	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
01022	                         (long int) (PyArray_NDIM(V1) >= 2 ?
01023	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
01024	                         (long int) (PyArray_NDIM(V1) >= 1 ?
01025	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
01026	        );
01027	            {
01028	        __failure = 2;
01029	        if (!PyErr_Occurred()) {
01030	            PyErr_SetString(PyExc_RuntimeError,
01031	                "Unexpected error in an Op's C code. "
01032	                "No Python exception was set.");
01033	            }
01034	        goto __label_2;}
01035	        }
01036	        
01037	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
01038	      {Py_XINCREF(py_V1);}
01039	      PyList_SET_ITEM(storage_V1, 0, py_V1);
01040	      {Py_XDECREF(old);}
01041	    }
01042	    
01043	        if (V1) {
01044	            Py_XDECREF(V1);
01045	        }
01046	        
01047	    {Py_XDECREF(py_V1);}
01048	    
01049	double __DUMMY_2;
01050	
01051	}
01052	
01053	            
01054	        if (__failure) {
01055	            // When there is a failure, this code puts the exception
01056	            // in __ERROR.
01057	            PyObject* err_type = NULL;
01058	            PyObject* err_msg = NULL;
01059	            PyObject* err_traceback = NULL;
01060	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
01061	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
01062	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
01063	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
01064	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
01065	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
01066	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
01067	            PyList_SET_ITEM(__ERROR, 0, err_type);
01068	            PyList_SET_ITEM(__ERROR, 1, err_msg);
01069	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
01070	            {Py_XDECREF(old_err_type);}
01071	            {Py_XDECREF(old_err_msg);}
01072	            {Py_XDECREF(old_err_traceback);}
01073	        }
01074	        // The failure code is returned to index what code block failed.
01075	        return __failure;
01076	        
01077	        }
01078	    };
01079	    }
01080	    
01081	
01082	        static int __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426_executor(__struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426* self) {
01083	            return self->run();
01084	        }
01085	
01086	        static void __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426_destructor(void* executor, void* self) {
01087	            delete ((__struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426*)self);
01088	        }
01089	        
01090	//////////////////////
01091	////  Functions
01092	//////////////////////
01093	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
01094	  assert(PyTuple_Check(argtuple));
01095	  if (6 != PyTuple_Size(argtuple)){ 
01096	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 6, got %i", (int)PyTuple_Size(argtuple));
01097	     return NULL;
01098	  }
01099	  __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426* struct_ptr = new __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426();
01100	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4),PyTuple_GET_ITEM(argtuple, 5) ) != 0) {
01101	    delete struct_ptr;
01102	    return NULL;
01103	  }
01104	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426_executor), struct_ptr, __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426_destructor);
01105	  return thunk; }
01106	
01107	//////////////////////
01108	////  Module init
01109	//////////////////////
01110	static PyMethodDef MyMethods[] = {
01111		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
01112		{NULL, NULL, 0, NULL}
01113	};
01114	PyMODINIT_FUNC initf3422b161dfba6898df3bf8e09c3c426(void){
01115	   import_array();
01116	   (void) Py_InitModule("f3422b161dfba6898df3bf8e09c3c426", MyMethods);
01117	}
01118	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpK3Er3c/f3422b161dfba6898df3bf8e09c3c426.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpK3Er3c/mod.cpp -lpython2.7
ERROR
test_shared_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_d207601a572b1835a75f349e2a6426bd {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V1;
00021	        
00022	
00023	        __struct_compiled_op_d207601a572b1835a75f349e2a6426bd() {
00024	            // This is only somewhat safe because we:
00025	            //  1) Are not a virtual class
00026	            //  2) Do not use any virtual classes in the members
00027	            //  3) Deal with mostly POD and pointers
00028	
00029	            // If this changes, we would have to revise this, but for
00030	            // now I am tired of chasing segfaults because
00031	            // initialization code had an error and some pointer has
00032	            // a junk value.
00033	            memset(this, 0, sizeof(*this));
00034	        }
00035	        ~__struct_compiled_op_d207601a572b1835a75f349e2a6426bd(void) {
00036	            cleanup();
00037	        }
00038	
00039	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V1) {
00040	            Py_XINCREF(storage_V3);
00041	Py_XINCREF(storage_V5);
00042	Py_XINCREF(storage_V7);
00043	Py_XINCREF(storage_V1);
00044	            this->storage_V3 = storage_V3;
00045	this->storage_V5 = storage_V5;
00046	this->storage_V7 = storage_V7;
00047	this->storage_V1 = storage_V1;
00048	            
00049	
00050	
00051	
00052	
00053	
00054	            this->__ERROR = __ERROR;
00055	            return 0;
00056	        }
00057	        void cleanup(void) {
00058	            __label_1:
00059	
00060	double __DUMMY_1;
00061	__label_3:
00062	
00063	double __DUMMY_3;
00064	__label_5:
00065	
00066	double __DUMMY_5;
00067	__label_7:
00068	
00069	double __DUMMY_7;
00070	__label_10:
00071	
00072	double __DUMMY_10;
00073	
00074	            Py_XDECREF(this->storage_V3);
00075	Py_XDECREF(this->storage_V5);
00076	Py_XDECREF(this->storage_V7);
00077	Py_XDECREF(this->storage_V1);
00078	        }
00079	        int run(void) {
00080	            int __failure = 0;
00081	            
00082	    PyObject* py_V1;
00083	    
00084	        PyArrayObject* V1;
00085	        
00086	            typedef npy_float64 dtype_V1;
00087	            
00088	    PyObject* py_V3;
00089	    
00090	        PyArrayObject* V3;
00091	        
00092	            typedef npy_float64 dtype_V3;
00093	            
00094	    PyObject* py_V5;
00095	    
00096	        PyArrayObject* V5;
00097	        
00098	            typedef npy_float64 dtype_V5;
00099	            
00100	    PyObject* py_V7;
00101	    
00102	        PyArrayObject* V7;
00103	        
00104	            typedef npy_float64 dtype_V7;
00105	            
00106	{
00107	
00108	    py_V1 = Py_None;
00109	    {Py_XINCREF(py_V1);}
00110	    
00111	        V1 = NULL;
00112	        
00113	{
00114	
00115	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00116	    {Py_XINCREF(py_V3);}
00117	    
00118	            V3 = NULL;
00119	            if (py_V3 == Py_None) {
00120	                // We can either fail here or set V3 to NULL and rely on Ops
00121	                // using tensors to handle the NULL case, but if they fail to do so
00122	                // they'll end up with nasty segfaults, so this is public service.
00123	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00124	                {
00125	        __failure = 4;
00126	        if (!PyErr_Occurred()) {
00127	            PyErr_SetString(PyExc_RuntimeError,
00128	                "Unexpected error in an Op's C code. "
00129	                "No Python exception was set.");
00130	            }
00131	        goto __label_4;}
00132	            }
00133	            if (!PyArray_Check(py_V3)) {
00134	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00135	                {
00136	        __failure = 4;
00137	        if (!PyErr_Occurred()) {
00138	            PyErr_SetString(PyExc_RuntimeError,
00139	                "Unexpected error in an Op's C code. "
00140	                "No Python exception was set.");
00141	            }
00142	        goto __label_4;}
00143	            }
00144	            // We expect NPY_FLOAT64
00145	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00146	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00147	                PyErr_Format(PyExc_NotImplementedError,
00148	                             "expected an aligned array of type %ld "
00149	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00150	                             " with %ld dimensions, with 3 last dims "
00151	                             "%ld, %ld, %ld"
00152	                             " and 3 last strides %ld %ld, %ld.",
00153	                             (long int) NPY_FLOAT64,
00154	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00155	                             (long int) PyArray_NDIM(tmp),
00156	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00157	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00158	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00159	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00160	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00161	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00162	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00163	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00164	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00165	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00166	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00167	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00168	            );
00169	                {
00170	        __failure = 4;
00171	        if (!PyErr_Occurred()) {
00172	            PyErr_SetString(PyExc_RuntimeError,
00173	                "Unexpected error in an Op's C code. "
00174	                "No Python exception was set.");
00175	            }
00176	        goto __label_4;}
00177	            }
00178	            // This is a TypeError to be consistent with DEBUG_MODE
00179	            // Note: DEBUG_MODE also tells the name of the container
00180	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00181	                PyErr_Format(PyExc_TypeError,
00182	                             "expected type_num %d (NPY_FLOAT64) got %d",
00183	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            
00194	        V3 = (PyArrayObject*)(py_V3);
00195	        Py_XINCREF(V3);
00196	        
00197	{
00198	
00199	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00200	    {Py_XINCREF(py_V5);}
00201	    
00202	            V5 = NULL;
00203	            if (py_V5 == Py_None) {
00204	                // We can either fail here or set V5 to NULL and rely on Ops
00205	                // using tensors to handle the NULL case, but if they fail to do so
00206	                // they'll end up with nasty segfaults, so this is public service.
00207	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00208	                {
00209	        __failure = 6;
00210	        if (!PyErr_Occurred()) {
00211	            PyErr_SetString(PyExc_RuntimeError,
00212	                "Unexpected error in an Op's C code. "
00213	                "No Python exception was set.");
00214	            }
00215	        goto __label_6;}
00216	            }
00217	            if (!PyArray_Check(py_V5)) {
00218	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00219	                {
00220	        __failure = 6;
00221	        if (!PyErr_Occurred()) {
00222	            PyErr_SetString(PyExc_RuntimeError,
00223	                "Unexpected error in an Op's C code. "
00224	                "No Python exception was set.");
00225	            }
00226	        goto __label_6;}
00227	            }
00228	            // We expect NPY_FLOAT64
00229	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00230	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00231	                PyErr_Format(PyExc_NotImplementedError,
00232	                             "expected an aligned array of type %ld "
00233	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00234	                             " with %ld dimensions, with 3 last dims "
00235	                             "%ld, %ld, %ld"
00236	                             " and 3 last strides %ld %ld, %ld.",
00237	                             (long int) NPY_FLOAT64,
00238	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00239	                             (long int) PyArray_NDIM(tmp),
00240	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00241	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00242	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00243	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00244	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00245	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00246	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00247	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00248	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00249	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00250	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00251	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00252	            );
00253	                {
00254	        __failure = 6;
00255	        if (!PyErr_Occurred()) {
00256	            PyErr_SetString(PyExc_RuntimeError,
00257	                "Unexpected error in an Op's C code. "
00258	                "No Python exception was set.");
00259	            }
00260	        goto __label_6;}
00261	            }
00262	            // This is a TypeError to be consistent with DEBUG_MODE
00263	            // Note: DEBUG_MODE also tells the name of the container
00264	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00265	                PyErr_Format(PyExc_TypeError,
00266	                             "expected type_num %d (NPY_FLOAT64) got %d",
00267	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00268	                {
00269	        __failure = 6;
00270	        if (!PyErr_Occurred()) {
00271	            PyErr_SetString(PyExc_RuntimeError,
00272	                "Unexpected error in an Op's C code. "
00273	                "No Python exception was set.");
00274	            }
00275	        goto __label_6;}
00276	            }
00277	            
00278	        V5 = (PyArrayObject*)(py_V5);
00279	        Py_XINCREF(V5);
00280	        
00281	{
00282	
00283	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00284	    {Py_XINCREF(py_V7);}
00285	    
00286	            V7 = NULL;
00287	            if (py_V7 == Py_None) {
00288	                // We can either fail here or set V7 to NULL and rely on Ops
00289	                // using tensors to handle the NULL case, but if they fail to do so
00290	                // they'll end up with nasty segfaults, so this is public service.
00291	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00292	                {
00293	        __failure = 8;
00294	        if (!PyErr_Occurred()) {
00295	            PyErr_SetString(PyExc_RuntimeError,
00296	                "Unexpected error in an Op's C code. "
00297	                "No Python exception was set.");
00298	            }
00299	        goto __label_8;}
00300	            }
00301	            if (!PyArray_Check(py_V7)) {
00302	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00303	                {
00304	        __failure = 8;
00305	        if (!PyErr_Occurred()) {
00306	            PyErr_SetString(PyExc_RuntimeError,
00307	                "Unexpected error in an Op's C code. "
00308	                "No Python exception was set.");
00309	            }
00310	        goto __label_8;}
00311	            }
00312	            // We expect NPY_FLOAT64
00313	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00314	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00315	                PyErr_Format(PyExc_NotImplementedError,
00316	                             "expected an aligned array of type %ld "
00317	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00318	                             " with %ld dimensions, with 3 last dims "
00319	                             "%ld, %ld, %ld"
00320	                             " and 3 last strides %ld %ld, %ld.",
00321	                             (long int) NPY_FLOAT64,
00322	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00323	                             (long int) PyArray_NDIM(tmp),
00324	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00325	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00326	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00327	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00328	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00329	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00330	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00331	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00332	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00333	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00334	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00335	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00336	            );
00337	                {
00338	        __failure = 8;
00339	        if (!PyErr_Occurred()) {
00340	            PyErr_SetString(PyExc_RuntimeError,
00341	                "Unexpected error in an Op's C code. "
00342	                "No Python exception was set.");
00343	            }
00344	        goto __label_8;}
00345	            }
00346	            // This is a TypeError to be consistent with DEBUG_MODE
00347	            // Note: DEBUG_MODE also tells the name of the container
00348	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00349	                PyErr_Format(PyExc_TypeError,
00350	                             "expected type_num %d (NPY_FLOAT64) got %d",
00351	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00352	                {
00353	        __failure = 8;
00354	        if (!PyErr_Occurred()) {
00355	            PyErr_SetString(PyExc_RuntimeError,
00356	                "Unexpected error in an Op's C code. "
00357	                "No Python exception was set.");
00358	            }
00359	        goto __label_8;}
00360	            }
00361	            
00362	        V7 = (PyArrayObject*)(py_V7);
00363	        Py_XINCREF(V7);
00364	        
00365	{
00366	// Op class Elemwise
00367	
00368	        npy_float64* V3_iter;
00369	        
00370	                npy_intp V3_n0;
00371	                ssize_t V3_stride0;
00372	                int V3_jump0_0;
00373	                
00374	                npy_intp V3_n1;
00375	                ssize_t V3_stride1;
00376	                int V3_jump1_1;
00377	                
00378	        npy_float64* V5_iter;
00379	        
00380	                npy_intp V5_n0;
00381	                ssize_t V5_stride0;
00382	                int V5_jump0_0;
00383	                
00384	                npy_intp V5_n1;
00385	                ssize_t V5_stride1;
00386	                int V5_jump1_1;
00387	                
00388	        npy_float64* V7_iter;
00389	        
00390	                npy_intp V7_n0;
00391	                ssize_t V7_stride0;
00392	                int V7_jump0_0;
00393	                
00394	                npy_intp V7_n1;
00395	                ssize_t V7_stride1;
00396	                int V7_jump1_1;
00397	                
00398	
00399	            if (PyArray_NDIM(V3) < 2) {
00400	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00401	                {
00402	        __failure = 9;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_9;}
00409	            }
00410	            
00411	                V3_n1 = PyArray_DIMS(V3)[1];
00412	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00413	                V3_jump1_1 = (V3_stride1) - (0);
00414	                //printf("V3_jump1_1 is:");
00415	                //std::cout << V3_jump1_1 << std::endl;
00416	                
00417	                V3_n0 = PyArray_DIMS(V3)[0];
00418	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00419	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00420	                //printf("V3_jump0_0 is:");
00421	                //std::cout << V3_jump0_0 << std::endl;
00422	                
00423	            if (PyArray_NDIM(V5) < 2) {
00424	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00425	                {
00426	        __failure = 9;
00427	        if (!PyErr_Occurred()) {
00428	            PyErr_SetString(PyExc_RuntimeError,
00429	                "Unexpected error in an Op's C code. "
00430	                "No Python exception was set.");
00431	            }
00432	        goto __label_9;}
00433	            }
00434	            
00435	                V5_n1 = PyArray_DIMS(V5)[1];
00436	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00437	                V5_jump1_1 = (V5_stride1) - (0);
00438	                //printf("V5_jump1_1 is:");
00439	                //std::cout << V5_jump1_1 << std::endl;
00440	                
00441	                V5_n0 = PyArray_DIMS(V5)[0];
00442	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00443	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00444	                //printf("V5_jump0_0 is:");
00445	                //std::cout << V5_jump0_0 << std::endl;
00446	                
00447	            if (PyArray_NDIM(V7) < 2) {
00448	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00449	                {
00450	        __failure = 9;
00451	        if (!PyErr_Occurred()) {
00452	            PyErr_SetString(PyExc_RuntimeError,
00453	                "Unexpected error in an Op's C code. "
00454	                "No Python exception was set.");
00455	            }
00456	        goto __label_9;}
00457	            }
00458	            
00459	                V7_n1 = PyArray_DIMS(V7)[1];
00460	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00461	                V7_jump1_1 = (V7_stride1) - (0);
00462	                //printf("V7_jump1_1 is:");
00463	                //std::cout << V7_jump1_1 << std::endl;
00464	                
00465	                V7_n0 = PyArray_DIMS(V7)[0];
00466	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00467	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00468	                //printf("V7_jump0_0 is:");
00469	                //std::cout << V7_jump0_0 << std::endl;
00470	                
00471	            if (V3_n0 != V5_n0)
00472	            {
00473	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00474	                   0,
00475	                   0,
00476	                   V3_n0,
00477	                   1,
00478	                   0,
00479	                   V5_n0
00480	                );
00481	                {
00482	        __failure = 9;
00483	        if (!PyErr_Occurred()) {
00484	            PyErr_SetString(PyExc_RuntimeError,
00485	                "Unexpected error in an Op's C code. "
00486	                "No Python exception was set.");
00487	            }
00488	        goto __label_9;}
00489	            }
00490	            
00491	            if (V3_n0 != V7_n0)
00492	            {
00493	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00494	                   0,
00495	                   0,
00496	                   V3_n0,
00497	                   2,
00498	                   0,
00499	                   V7_n0
00500	                );
00501	                {
00502	        __failure = 9;
00503	        if (!PyErr_Occurred()) {
00504	            PyErr_SetString(PyExc_RuntimeError,
00505	                "Unexpected error in an Op's C code. "
00506	                "No Python exception was set.");
00507	            }
00508	        goto __label_9;}
00509	            }
00510	            
00511	            if (V3_n1 != V5_n1)
00512	            {
00513	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00514	                   0,
00515	                   1,
00516	                   V3_n1,
00517	                   1,
00518	                   1,
00519	                   V5_n1
00520	                );
00521	                {
00522	        __failure = 9;
00523	        if (!PyErr_Occurred()) {
00524	            PyErr_SetString(PyExc_RuntimeError,
00525	                "Unexpected error in an Op's C code. "
00526	                "No Python exception was set.");
00527	            }
00528	        goto __label_9;}
00529	            }
00530	            
00531	            if (V3_n1 != V7_n1)
00532	            {
00533	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00534	                   0,
00535	                   1,
00536	                   V3_n1,
00537	                   2,
00538	                   1,
00539	                   V7_n1
00540	                );
00541	                {
00542	        __failure = 9;
00543	        if (!PyErr_Occurred()) {
00544	            PyErr_SetString(PyExc_RuntimeError,
00545	                "Unexpected error in an Op's C code. "
00546	                "No Python exception was set.");
00547	            }
00548	        goto __label_9;}
00549	            }
00550	            
00551	
00552	        npy_float64* V1_iter;
00553	        
00554	                npy_intp V1_n0;
00555	                ssize_t V1_stride0;
00556	                int V1_jump0_0;
00557	                
00558	                npy_intp V1_n1;
00559	                ssize_t V1_stride1;
00560	                int V1_jump1_1;
00561	                
00562	    {
00563	        npy_intp dims[2];
00564	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00565	        dims[0] = V3_n0;
00566	dims[1] = V3_n1;
00567	
00568	        if (!V1) {
00569	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00570	                                                    NPY_FLOAT64,
00571	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7));
00572	        }
00573	        else {
00574	            PyArray_Dims new_dims;
00575	            new_dims.len = 2;
00576	            new_dims.ptr = dims;
00577	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00578	            if (!success) {
00579	                // If we can't resize the ndarray we have we can allocate a new one.
00580	                PyErr_Clear();
00581	                Py_XDECREF(V1);
00582	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00583	            }
00584	        }
00585	        if (!V1) {
00586	            {
00587	        __failure = 9;
00588	        if (!PyErr_Occurred()) {
00589	            PyErr_SetString(PyExc_RuntimeError,
00590	                "Unexpected error in an Op's C code. "
00591	                "No Python exception was set.");
00592	            }
00593	        goto __label_9;}
00594	        }
00595	    }
00596	    
00597	            if (PyArray_NDIM(V1) < 2) {
00598	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00599	                {
00600	        __failure = 9;
00601	        if (!PyErr_Occurred()) {
00602	            PyErr_SetString(PyExc_RuntimeError,
00603	                "Unexpected error in an Op's C code. "
00604	                "No Python exception was set.");
00605	            }
00606	        goto __label_9;}
00607	            }
00608	            
00609	                V1_n1 = PyArray_DIMS(V1)[1];
00610	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00611	                V1_jump1_1 = (V1_stride1) - (0);
00612	                //printf("V1_jump1_1 is:");
00613	                //std::cout << V1_jump1_1 << std::endl;
00614	                
00615	                V1_n0 = PyArray_DIMS(V1)[0];
00616	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00617	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00618	                //printf("V1_jump0_0 is:");
00619	                //std::cout << V1_jump0_0 << std::endl;
00620	                
00621	
00622	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V1))){
00623	                
00624	                    // All output have the same size
00625	                    npy_intp n = PyArray_SIZE(V1);
00626	                    
00627	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00628	                            
00629	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00630	                            
00631	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00632	                            
00633	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00634	                            
00635	                    for(int i=0; i<n; i++){
00636	                        
00637	            dtype_V3& V3_i = V3_ptr[i];
00638	                            
00639	            dtype_V5& V5_i = V5_ptr[i];
00640	                            
00641	            dtype_V7& V7_i = V7_ptr[i];
00642	                            
00643	            dtype_V1& V1_i = V1_ptr[i];
00644	                            
00645	                        {
00646	npy_float64 V9_tmp1;
00647	V9_tmp1 = V7_i * V3_i;
00648	npy_float64 V9_tmp2;
00649	V9_tmp2 = V5_i * V7_i;
00650	npy_float64 V9_tmp3;
00651	V9_tmp3 = V5_i + V9_tmp1;
00652	npy_float64 V9_tmp4;
00653	V9_tmp4 = V3_i + V9_tmp2;
00654	V1_i = V9_tmp4 - V9_tmp3;
00655	}
00656	;
00657	                    }
00658	                    
00659	            }else{
00660	                {
00661	
00662	    std::vector< std::pair<int, int> > V1_loops(2);
00663	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00664	    
00665	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00666	            
00667	        V1_loops_it->second = 0;
00668	        ++V1_loops_it;
00669	        
00670	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00671	            
00672	        V1_loops_it->second = 1;
00673	        ++V1_loops_it;
00674	        
00675	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00676	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00677	    
00678	
00679	    int init_totals[2] = {V3_n0, V3_n1};
00680	    
00681	    V1_loops_it = V1_loops.begin();
00682	    
00683	        int TOTAL_0 = init_totals[V1_loops_it->second];
00684	        ++V1_loops_it;
00685	        
00686	        int TOTAL_1 = init_totals[V1_loops_it->second];
00687	        ++V1_loops_it;
00688	        
00689	
00690	    int init_strides[4][2] = {
00691	        V3_stride0, V3_stride1, 
00692	V5_stride0, V5_stride1, 
00693	V7_stride0, V7_stride1, 
00694	V1_stride0, V1_stride1
00695	    };
00696	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00697	    
00698	        V1_loops_rit = V1_loops.rbegin();
00699	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00700	            ++V1_loops_rit;
00701	            
00702	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00703	            ++V1_loops_rit;
00704	            
00705	        V1_loops_rit = V1_loops.rbegin();
00706	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00707	            ++V1_loops_rit;
00708	            
00709	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00710	            ++V1_loops_rit;
00711	            
00712	        V1_loops_rit = V1_loops.rbegin();
00713	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00714	            ++V1_loops_rit;
00715	            
00716	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00717	            ++V1_loops_rit;
00718	            
00719	        V1_loops_rit = V1_loops.rbegin();
00720	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00721	            ++V1_loops_rit;
00722	            
00723	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00724	            ++V1_loops_rit;
00725	            
00726	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00727	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00728	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00729	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00730	
00731	
00732	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00733	        { // begin loop 0
00734	            
00735	            
00736	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00737	        { // begin loop 1
00738	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00739	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00740	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00741	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00742	
00743	            
00744	        {
00745	            
00746	            {
00747	npy_float64 V9_tmp1;
00748	V9_tmp1 = V7_i * V3_i;
00749	npy_float64 V9_tmp2;
00750	V9_tmp2 = V5_i * V7_i;
00751	npy_float64 V9_tmp3;
00752	V9_tmp3 = V5_i + V9_tmp1;
00753	npy_float64 V9_tmp4;
00754	V9_tmp4 = V3_i + V9_tmp2;
00755	V1_i = V9_tmp4 - V9_tmp3;
00756	}
00757	
00758	            
00759	        }
00760	        
00761	        } // end loop 1
00762	        
00763	        } // end loop 0
00764	        
00765	}
00766	
00767	            }
00768	            __label_9:
00769	
00770	double __DUMMY_9;
00771	
00772	}
00773	__label_8:
00774	
00775	        if (V7) {
00776	            Py_XDECREF(V7);
00777	        }
00778	        
00779	    {Py_XDECREF(py_V7);}
00780	    
00781	double __DUMMY_8;
00782	
00783	}
00784	__label_6:
00785	
00786	        if (V5) {
00787	            Py_XDECREF(V5);
00788	        }
00789	        
00790	    {Py_XDECREF(py_V5);}
00791	    
00792	double __DUMMY_6;
00793	
00794	}
00795	__label_4:
00796	
00797	        if (V3) {
00798	            Py_XDECREF(V3);
00799	        }
00800	        
00801	    {Py_XDECREF(py_V3);}
00802	    
00803	double __DUMMY_4;
00804	
00805	}
00806	__label_2:
00807	
00808	    if (!__failure) {
00809	      
00810	        {Py_XDECREF(py_V1);}
00811	        if (!V1) {
00812	            Py_INCREF(Py_None);
00813	            py_V1 = Py_None;
00814	        }
00815	        else if ((void*)py_V1 != (void*)V1) {
00816	            py_V1 = (PyObject*)V1;
00817	        }
00818	
00819	        {Py_XINCREF(py_V1);}
00820	
00821	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00822	            PyErr_Format(PyExc_NotImplementedError,
00823	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00824	                         " with %ld dimensions, with 3 last dims "
00825	                         "%ld, %ld, %ld"
00826	                         " and 3 last strides %ld %ld, %ld.",
00827	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00828	                         (long int) PyArray_NDIM(V1),
00829	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00830	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00831	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00832	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00833	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00834	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00835	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00836	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00837	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00838	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00839	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00840	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00841	        );
00842	            {
00843	        __failure = 2;
00844	        if (!PyErr_Occurred()) {
00845	            PyErr_SetString(PyExc_RuntimeError,
00846	                "Unexpected error in an Op's C code. "
00847	                "No Python exception was set.");
00848	            }
00849	        goto __label_2;}
00850	        }
00851	        
00852	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00853	      {Py_XINCREF(py_V1);}
00854	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00855	      {Py_XDECREF(old);}
00856	    }
00857	    
00858	        if (V1) {
00859	            Py_XDECREF(V1);
00860	        }
00861	        
00862	    {Py_XDECREF(py_V1);}
00863	    
00864	double __DUMMY_2;
00865	
00866	}
00867	
00868	            
00869	        if (__failure) {
00870	            // When there is a failure, this code puts the exception
00871	            // in __ERROR.
00872	            PyObject* err_type = NULL;
00873	            PyObject* err_msg = NULL;
00874	            PyObject* err_traceback = NULL;
00875	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00876	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00877	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00878	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00879	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00880	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00881	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00882	            PyList_SET_ITEM(__ERROR, 0, err_type);
00883	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00884	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00885	            {Py_XDECREF(old_err_type);}
00886	            {Py_XDECREF(old_err_msg);}
00887	            {Py_XDECREF(old_err_traceback);}
00888	        }
00889	        // The failure code is returned to index what code block failed.
00890	        return __failure;
00891	        
00892	        }
00893	    };
00894	    }
00895	    
00896	
00897	        static int __struct_compiled_op_d207601a572b1835a75f349e2a6426bd_executor(__struct_compiled_op_d207601a572b1835a75f349e2a6426bd* self) {
00898	            return self->run();
00899	        }
00900	
00901	        static void __struct_compiled_op_d207601a572b1835a75f349e2a6426bd_destructor(void* executor, void* self) {
00902	            delete ((__struct_compiled_op_d207601a572b1835a75f349e2a6426bd*)self);
00903	        }
00904	        
00905	//////////////////////
00906	////  Functions
00907	//////////////////////
00908	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00909	  assert(PyTuple_Check(argtuple));
00910	  if (5 != PyTuple_Size(argtuple)){ 
00911	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
00912	     return NULL;
00913	  }
00914	  __struct_compiled_op_d207601a572b1835a75f349e2a6426bd* struct_ptr = new __struct_compiled_op_d207601a572b1835a75f349e2a6426bd();
00915	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
00916	    delete struct_ptr;
00917	    return NULL;
00918	  }
00919	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_d207601a572b1835a75f349e2a6426bd_executor), struct_ptr, __struct_compiled_op_d207601a572b1835a75f349e2a6426bd_destructor);
00920	  return thunk; }
00921	
00922	//////////////////////
00923	////  Module init
00924	//////////////////////
00925	static PyMethodDef MyMethods[] = {
00926		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00927		{NULL, NULL, 0, NULL}
00928	};
00929	PyMODINIT_FUNC initd207601a572b1835a75f349e2a6426bd(void){
00930	   import_array();
00931	   (void) Py_InitModule("d207601a572b1835a75f349e2a6426bd", MyMethods);
00932	}
00933	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpKHy0cm/d207601a572b1835a75f349e2a6426bd.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpKHy0cm/mod.cpp -lpython2.7
ERROR
test_shared_grad_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V9;
00021	PyObject* storage_V1;
00022	        
00023	
00024	        __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426() {
00025	            // This is only somewhat safe because we:
00026	            //  1) Are not a virtual class
00027	            //  2) Do not use any virtual classes in the members
00028	            //  3) Deal with mostly POD and pointers
00029	
00030	            // If this changes, we would have to revise this, but for
00031	            // now I am tired of chasing segfaults because
00032	            // initialization code had an error and some pointer has
00033	            // a junk value.
00034	            memset(this, 0, sizeof(*this));
00035	        }
00036	        ~__struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426(void) {
00037	            cleanup();
00038	        }
00039	
00040	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V9, PyObject* storage_V1) {
00041	            Py_XINCREF(storage_V3);
00042	Py_XINCREF(storage_V5);
00043	Py_XINCREF(storage_V7);
00044	Py_XINCREF(storage_V9);
00045	Py_XINCREF(storage_V1);
00046	            this->storage_V3 = storage_V3;
00047	this->storage_V5 = storage_V5;
00048	this->storage_V7 = storage_V7;
00049	this->storage_V9 = storage_V9;
00050	this->storage_V1 = storage_V1;
00051	            
00052	
00053	
00054	
00055	
00056	
00057	
00058	            this->__ERROR = __ERROR;
00059	            return 0;
00060	        }
00061	        void cleanup(void) {
00062	            __label_1:
00063	
00064	double __DUMMY_1;
00065	__label_3:
00066	
00067	double __DUMMY_3;
00068	__label_5:
00069	
00070	double __DUMMY_5;
00071	__label_7:
00072	
00073	double __DUMMY_7;
00074	__label_9:
00075	
00076	double __DUMMY_9;
00077	__label_12:
00078	
00079	double __DUMMY_12;
00080	
00081	            Py_XDECREF(this->storage_V3);
00082	Py_XDECREF(this->storage_V5);
00083	Py_XDECREF(this->storage_V7);
00084	Py_XDECREF(this->storage_V9);
00085	Py_XDECREF(this->storage_V1);
00086	        }
00087	        int run(void) {
00088	            int __failure = 0;
00089	            
00090	    PyObject* py_V1;
00091	    
00092	        PyArrayObject* V1;
00093	        
00094	            typedef npy_float64 dtype_V1;
00095	            
00096	    PyObject* py_V3;
00097	    
00098	        PyArrayObject* V3;
00099	        
00100	            typedef npy_float64 dtype_V3;
00101	            
00102	    PyObject* py_V5;
00103	    
00104	        PyArrayObject* V5;
00105	        
00106	            typedef npy_float64 dtype_V5;
00107	            
00108	    PyObject* py_V7;
00109	    
00110	        PyArrayObject* V7;
00111	        
00112	            typedef npy_float64 dtype_V7;
00113	            
00114	    PyObject* py_V9;
00115	    
00116	        PyArrayObject* V9;
00117	        
00118	            typedef npy_float64 dtype_V9;
00119	            
00120	{
00121	
00122	    py_V1 = Py_None;
00123	    {Py_XINCREF(py_V1);}
00124	    
00125	        V1 = NULL;
00126	        
00127	{
00128	
00129	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00130	    {Py_XINCREF(py_V3);}
00131	    
00132	            V3 = NULL;
00133	            if (py_V3 == Py_None) {
00134	                // We can either fail here or set V3 to NULL and rely on Ops
00135	                // using tensors to handle the NULL case, but if they fail to do so
00136	                // they'll end up with nasty segfaults, so this is public service.
00137	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00138	                {
00139	        __failure = 4;
00140	        if (!PyErr_Occurred()) {
00141	            PyErr_SetString(PyExc_RuntimeError,
00142	                "Unexpected error in an Op's C code. "
00143	                "No Python exception was set.");
00144	            }
00145	        goto __label_4;}
00146	            }
00147	            if (!PyArray_Check(py_V3)) {
00148	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00149	                {
00150	        __failure = 4;
00151	        if (!PyErr_Occurred()) {
00152	            PyErr_SetString(PyExc_RuntimeError,
00153	                "Unexpected error in an Op's C code. "
00154	                "No Python exception was set.");
00155	            }
00156	        goto __label_4;}
00157	            }
00158	            // We expect NPY_FLOAT64
00159	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00160	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00161	                PyErr_Format(PyExc_NotImplementedError,
00162	                             "expected an aligned array of type %ld "
00163	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00164	                             " with %ld dimensions, with 3 last dims "
00165	                             "%ld, %ld, %ld"
00166	                             " and 3 last strides %ld %ld, %ld.",
00167	                             (long int) NPY_FLOAT64,
00168	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00169	                             (long int) PyArray_NDIM(tmp),
00170	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00171	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00172	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00173	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00174	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00175	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00176	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00177	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00178	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00179	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00180	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00181	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00182	            );
00183	                {
00184	        __failure = 4;
00185	        if (!PyErr_Occurred()) {
00186	            PyErr_SetString(PyExc_RuntimeError,
00187	                "Unexpected error in an Op's C code. "
00188	                "No Python exception was set.");
00189	            }
00190	        goto __label_4;}
00191	            }
00192	            // This is a TypeError to be consistent with DEBUG_MODE
00193	            // Note: DEBUG_MODE also tells the name of the container
00194	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00195	                PyErr_Format(PyExc_TypeError,
00196	                             "expected type_num %d (NPY_FLOAT64) got %d",
00197	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            
00208	        V3 = (PyArrayObject*)(py_V3);
00209	        Py_XINCREF(V3);
00210	        
00211	{
00212	
00213	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00214	    {Py_XINCREF(py_V5);}
00215	    
00216	            V5 = NULL;
00217	            if (py_V5 == Py_None) {
00218	                // We can either fail here or set V5 to NULL and rely on Ops
00219	                // using tensors to handle the NULL case, but if they fail to do so
00220	                // they'll end up with nasty segfaults, so this is public service.
00221	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00222	                {
00223	        __failure = 6;
00224	        if (!PyErr_Occurred()) {
00225	            PyErr_SetString(PyExc_RuntimeError,
00226	                "Unexpected error in an Op's C code. "
00227	                "No Python exception was set.");
00228	            }
00229	        goto __label_6;}
00230	            }
00231	            if (!PyArray_Check(py_V5)) {
00232	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00233	                {
00234	        __failure = 6;
00235	        if (!PyErr_Occurred()) {
00236	            PyErr_SetString(PyExc_RuntimeError,
00237	                "Unexpected error in an Op's C code. "
00238	                "No Python exception was set.");
00239	            }
00240	        goto __label_6;}
00241	            }
00242	            // We expect NPY_FLOAT64
00243	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00244	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00245	                PyErr_Format(PyExc_NotImplementedError,
00246	                             "expected an aligned array of type %ld "
00247	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00248	                             " with %ld dimensions, with 3 last dims "
00249	                             "%ld, %ld, %ld"
00250	                             " and 3 last strides %ld %ld, %ld.",
00251	                             (long int) NPY_FLOAT64,
00252	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00253	                             (long int) PyArray_NDIM(tmp),
00254	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00255	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00256	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00257	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00258	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00259	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00260	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00261	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00262	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00263	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00264	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00265	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00266	            );
00267	                {
00268	        __failure = 6;
00269	        if (!PyErr_Occurred()) {
00270	            PyErr_SetString(PyExc_RuntimeError,
00271	                "Unexpected error in an Op's C code. "
00272	                "No Python exception was set.");
00273	            }
00274	        goto __label_6;}
00275	            }
00276	            // This is a TypeError to be consistent with DEBUG_MODE
00277	            // Note: DEBUG_MODE also tells the name of the container
00278	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00279	                PyErr_Format(PyExc_TypeError,
00280	                             "expected type_num %d (NPY_FLOAT64) got %d",
00281	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            
00292	        V5 = (PyArrayObject*)(py_V5);
00293	        Py_XINCREF(V5);
00294	        
00295	{
00296	
00297	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00298	    {Py_XINCREF(py_V7);}
00299	    
00300	            V7 = NULL;
00301	            if (py_V7 == Py_None) {
00302	                // We can either fail here or set V7 to NULL and rely on Ops
00303	                // using tensors to handle the NULL case, but if they fail to do so
00304	                // they'll end up with nasty segfaults, so this is public service.
00305	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00306	                {
00307	        __failure = 8;
00308	        if (!PyErr_Occurred()) {
00309	            PyErr_SetString(PyExc_RuntimeError,
00310	                "Unexpected error in an Op's C code. "
00311	                "No Python exception was set.");
00312	            }
00313	        goto __label_8;}
00314	            }
00315	            if (!PyArray_Check(py_V7)) {
00316	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00317	                {
00318	        __failure = 8;
00319	        if (!PyErr_Occurred()) {
00320	            PyErr_SetString(PyExc_RuntimeError,
00321	                "Unexpected error in an Op's C code. "
00322	                "No Python exception was set.");
00323	            }
00324	        goto __label_8;}
00325	            }
00326	            // We expect NPY_FLOAT64
00327	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00328	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00329	                PyErr_Format(PyExc_NotImplementedError,
00330	                             "expected an aligned array of type %ld "
00331	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00332	                             " with %ld dimensions, with 3 last dims "
00333	                             "%ld, %ld, %ld"
00334	                             " and 3 last strides %ld %ld, %ld.",
00335	                             (long int) NPY_FLOAT64,
00336	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00337	                             (long int) PyArray_NDIM(tmp),
00338	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00339	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00340	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00341	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00342	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00343	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00344	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00345	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00346	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00347	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00348	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00349	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00350	            );
00351	                {
00352	        __failure = 8;
00353	        if (!PyErr_Occurred()) {
00354	            PyErr_SetString(PyExc_RuntimeError,
00355	                "Unexpected error in an Op's C code. "
00356	                "No Python exception was set.");
00357	            }
00358	        goto __label_8;}
00359	            }
00360	            // This is a TypeError to be consistent with DEBUG_MODE
00361	            // Note: DEBUG_MODE also tells the name of the container
00362	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00363	                PyErr_Format(PyExc_TypeError,
00364	                             "expected type_num %d (NPY_FLOAT64) got %d",
00365	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00366	                {
00367	        __failure = 8;
00368	        if (!PyErr_Occurred()) {
00369	            PyErr_SetString(PyExc_RuntimeError,
00370	                "Unexpected error in an Op's C code. "
00371	                "No Python exception was set.");
00372	            }
00373	        goto __label_8;}
00374	            }
00375	            
00376	        V7 = (PyArrayObject*)(py_V7);
00377	        Py_XINCREF(V7);
00378	        
00379	{
00380	
00381	    py_V9 = PyList_GET_ITEM(storage_V9, 0);
00382	    {Py_XINCREF(py_V9);}
00383	    
00384	            V9 = NULL;
00385	            if (py_V9 == Py_None) {
00386	                // We can either fail here or set V9 to NULL and rely on Ops
00387	                // using tensors to handle the NULL case, but if they fail to do so
00388	                // they'll end up with nasty segfaults, so this is public service.
00389	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00390	                {
00391	        __failure = 10;
00392	        if (!PyErr_Occurred()) {
00393	            PyErr_SetString(PyExc_RuntimeError,
00394	                "Unexpected error in an Op's C code. "
00395	                "No Python exception was set.");
00396	            }
00397	        goto __label_10;}
00398	            }
00399	            if (!PyArray_Check(py_V9)) {
00400	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00401	                {
00402	        __failure = 10;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_10;}
00409	            }
00410	            // We expect NPY_FLOAT64
00411	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V9)) {
00412	                PyArrayObject * tmp = (PyArrayObject*) py_V9;
00413	                PyErr_Format(PyExc_NotImplementedError,
00414	                             "expected an aligned array of type %ld "
00415	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00416	                             " with %ld dimensions, with 3 last dims "
00417	                             "%ld, %ld, %ld"
00418	                             " and 3 last strides %ld %ld, %ld.",
00419	                             (long int) NPY_FLOAT64,
00420	                             (long int) PyArray_TYPE((PyArrayObject*) py_V9),
00421	                             (long int) PyArray_NDIM(tmp),
00422	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00423	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00424	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00425	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00426	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00427	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00428	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00429	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00430	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00431	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00432	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00433	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00434	            );
00435	                {
00436	        __failure = 10;
00437	        if (!PyErr_Occurred()) {
00438	            PyErr_SetString(PyExc_RuntimeError,
00439	                "Unexpected error in an Op's C code. "
00440	                "No Python exception was set.");
00441	            }
00442	        goto __label_10;}
00443	            }
00444	            // This is a TypeError to be consistent with DEBUG_MODE
00445	            // Note: DEBUG_MODE also tells the name of the container
00446	            if (PyArray_TYPE((PyArrayObject*) py_V9) != NPY_FLOAT64) {
00447	                PyErr_Format(PyExc_TypeError,
00448	                             "expected type_num %d (NPY_FLOAT64) got %d",
00449	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V9));
00450	                {
00451	        __failure = 10;
00452	        if (!PyErr_Occurred()) {
00453	            PyErr_SetString(PyExc_RuntimeError,
00454	                "Unexpected error in an Op's C code. "
00455	                "No Python exception was set.");
00456	            }
00457	        goto __label_10;}
00458	            }
00459	            
00460	        V9 = (PyArrayObject*)(py_V9);
00461	        Py_XINCREF(V9);
00462	        
00463	{
00464	// Op class Elemwise
00465	
00466	        npy_float64* V3_iter;
00467	        
00468	                npy_intp V3_n0;
00469	                ssize_t V3_stride0;
00470	                int V3_jump0_0;
00471	                
00472	                npy_intp V3_n1;
00473	                ssize_t V3_stride1;
00474	                int V3_jump1_1;
00475	                
00476	        npy_float64* V5_iter;
00477	        
00478	                npy_intp V5_n0;
00479	                ssize_t V5_stride0;
00480	                int V5_jump0_0;
00481	                
00482	                npy_intp V5_n1;
00483	                ssize_t V5_stride1;
00484	                int V5_jump1_1;
00485	                
00486	        npy_float64* V7_iter;
00487	        
00488	                npy_intp V7_n0;
00489	                ssize_t V7_stride0;
00490	                int V7_jump0_0;
00491	                
00492	                npy_intp V7_n1;
00493	                ssize_t V7_stride1;
00494	                int V7_jump1_1;
00495	                
00496	        npy_float64* V9_iter;
00497	        
00498	                npy_intp V9_n0;
00499	                ssize_t V9_stride0;
00500	                int V9_jump0_0;
00501	                
00502	                npy_intp V9_n1;
00503	                ssize_t V9_stride1;
00504	                int V9_jump1_1;
00505	                
00506	
00507	            if (PyArray_NDIM(V3) < 2) {
00508	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00509	                {
00510	        __failure = 11;
00511	        if (!PyErr_Occurred()) {
00512	            PyErr_SetString(PyExc_RuntimeError,
00513	                "Unexpected error in an Op's C code. "
00514	                "No Python exception was set.");
00515	            }
00516	        goto __label_11;}
00517	            }
00518	            
00519	                V3_n1 = PyArray_DIMS(V3)[1];
00520	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00521	                V3_jump1_1 = (V3_stride1) - (0);
00522	                //printf("V3_jump1_1 is:");
00523	                //std::cout << V3_jump1_1 << std::endl;
00524	                
00525	                V3_n0 = PyArray_DIMS(V3)[0];
00526	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00527	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00528	                //printf("V3_jump0_0 is:");
00529	                //std::cout << V3_jump0_0 << std::endl;
00530	                
00531	            if (PyArray_NDIM(V5) < 2) {
00532	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00533	                {
00534	        __failure = 11;
00535	        if (!PyErr_Occurred()) {
00536	            PyErr_SetString(PyExc_RuntimeError,
00537	                "Unexpected error in an Op's C code. "
00538	                "No Python exception was set.");
00539	            }
00540	        goto __label_11;}
00541	            }
00542	            
00543	                V5_n1 = PyArray_DIMS(V5)[1];
00544	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00545	                V5_jump1_1 = (V5_stride1) - (0);
00546	                //printf("V5_jump1_1 is:");
00547	                //std::cout << V5_jump1_1 << std::endl;
00548	                
00549	                V5_n0 = PyArray_DIMS(V5)[0];
00550	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00551	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00552	                //printf("V5_jump0_0 is:");
00553	                //std::cout << V5_jump0_0 << std::endl;
00554	                
00555	            if (PyArray_NDIM(V7) < 2) {
00556	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00557	                {
00558	        __failure = 11;
00559	        if (!PyErr_Occurred()) {
00560	            PyErr_SetString(PyExc_RuntimeError,
00561	                "Unexpected error in an Op's C code. "
00562	                "No Python exception was set.");
00563	            }
00564	        goto __label_11;}
00565	            }
00566	            
00567	                V7_n1 = PyArray_DIMS(V7)[1];
00568	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00569	                V7_jump1_1 = (V7_stride1) - (0);
00570	                //printf("V7_jump1_1 is:");
00571	                //std::cout << V7_jump1_1 << std::endl;
00572	                
00573	                V7_n0 = PyArray_DIMS(V7)[0];
00574	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00575	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00576	                //printf("V7_jump0_0 is:");
00577	                //std::cout << V7_jump0_0 << std::endl;
00578	                
00579	            if (PyArray_NDIM(V9) < 2) {
00580	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00581	                {
00582	        __failure = 11;
00583	        if (!PyErr_Occurred()) {
00584	            PyErr_SetString(PyExc_RuntimeError,
00585	                "Unexpected error in an Op's C code. "
00586	                "No Python exception was set.");
00587	            }
00588	        goto __label_11;}
00589	            }
00590	            
00591	                V9_n1 = PyArray_DIMS(V9)[1];
00592	                V9_stride1 = PyArray_STRIDES(V9)[1] / sizeof(npy_float64);
00593	                V9_jump1_1 = (V9_stride1) - (0);
00594	                //printf("V9_jump1_1 is:");
00595	                //std::cout << V9_jump1_1 << std::endl;
00596	                
00597	                V9_n0 = PyArray_DIMS(V9)[0];
00598	                V9_stride0 = PyArray_STRIDES(V9)[0] / sizeof(npy_float64);
00599	                V9_jump0_0 = (V9_stride0) - (V9_n1*V9_stride1);
00600	                //printf("V9_jump0_0 is:");
00601	                //std::cout << V9_jump0_0 << std::endl;
00602	                
00603	            if (V3_n0 != V5_n0)
00604	            {
00605	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00606	                   0,
00607	                   0,
00608	                   V3_n0,
00609	                   1,
00610	                   0,
00611	                   V5_n0
00612	                );
00613	                {
00614	        __failure = 11;
00615	        if (!PyErr_Occurred()) {
00616	            PyErr_SetString(PyExc_RuntimeError,
00617	                "Unexpected error in an Op's C code. "
00618	                "No Python exception was set.");
00619	            }
00620	        goto __label_11;}
00621	            }
00622	            
00623	            if (V3_n0 != V7_n0)
00624	            {
00625	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00626	                   0,
00627	                   0,
00628	                   V3_n0,
00629	                   2,
00630	                   0,
00631	                   V7_n0
00632	                );
00633	                {
00634	        __failure = 11;
00635	        if (!PyErr_Occurred()) {
00636	            PyErr_SetString(PyExc_RuntimeError,
00637	                "Unexpected error in an Op's C code. "
00638	                "No Python exception was set.");
00639	            }
00640	        goto __label_11;}
00641	            }
00642	            
00643	            if (V3_n0 != V9_n0)
00644	            {
00645	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00646	                   0,
00647	                   0,
00648	                   V3_n0,
00649	                   3,
00650	                   0,
00651	                   V9_n0
00652	                );
00653	                {
00654	        __failure = 11;
00655	        if (!PyErr_Occurred()) {
00656	            PyErr_SetString(PyExc_RuntimeError,
00657	                "Unexpected error in an Op's C code. "
00658	                "No Python exception was set.");
00659	            }
00660	        goto __label_11;}
00661	            }
00662	            
00663	            if (V3_n1 != V5_n1)
00664	            {
00665	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00666	                   0,
00667	                   1,
00668	                   V3_n1,
00669	                   1,
00670	                   1,
00671	                   V5_n1
00672	                );
00673	                {
00674	        __failure = 11;
00675	        if (!PyErr_Occurred()) {
00676	            PyErr_SetString(PyExc_RuntimeError,
00677	                "Unexpected error in an Op's C code. "
00678	                "No Python exception was set.");
00679	            }
00680	        goto __label_11;}
00681	            }
00682	            
00683	            if (V3_n1 != V7_n1)
00684	            {
00685	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00686	                   0,
00687	                   1,
00688	                   V3_n1,
00689	                   2,
00690	                   1,
00691	                   V7_n1
00692	                );
00693	                {
00694	        __failure = 11;
00695	        if (!PyErr_Occurred()) {
00696	            PyErr_SetString(PyExc_RuntimeError,
00697	                "Unexpected error in an Op's C code. "
00698	                "No Python exception was set.");
00699	            }
00700	        goto __label_11;}
00701	            }
00702	            
00703	            if (V3_n1 != V9_n1)
00704	            {
00705	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00706	                   0,
00707	                   1,
00708	                   V3_n1,
00709	                   3,
00710	                   1,
00711	                   V9_n1
00712	                );
00713	                {
00714	        __failure = 11;
00715	        if (!PyErr_Occurred()) {
00716	            PyErr_SetString(PyExc_RuntimeError,
00717	                "Unexpected error in an Op's C code. "
00718	                "No Python exception was set.");
00719	            }
00720	        goto __label_11;}
00721	            }
00722	            
00723	
00724	        npy_float64* V1_iter;
00725	        
00726	                npy_intp V1_n0;
00727	                ssize_t V1_stride0;
00728	                int V1_jump0_0;
00729	                
00730	                npy_intp V1_n1;
00731	                ssize_t V1_stride1;
00732	                int V1_jump1_1;
00733	                
00734	    {
00735	        npy_intp dims[2];
00736	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00737	        dims[0] = V3_n0;
00738	dims[1] = V3_n1;
00739	
00740	        if (!V1) {
00741	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00742	                                                    NPY_FLOAT64,
00743	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V9));
00744	        }
00745	        else {
00746	            PyArray_Dims new_dims;
00747	            new_dims.len = 2;
00748	            new_dims.ptr = dims;
00749	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00750	            if (!success) {
00751	                // If we can't resize the ndarray we have we can allocate a new one.
00752	                PyErr_Clear();
00753	                Py_XDECREF(V1);
00754	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00755	            }
00756	        }
00757	        if (!V1) {
00758	            {
00759	        __failure = 11;
00760	        if (!PyErr_Occurred()) {
00761	            PyErr_SetString(PyExc_RuntimeError,
00762	                "Unexpected error in an Op's C code. "
00763	                "No Python exception was set.");
00764	            }
00765	        goto __label_11;}
00766	        }
00767	    }
00768	    
00769	            if (PyArray_NDIM(V1) < 2) {
00770	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00771	                {
00772	        __failure = 11;
00773	        if (!PyErr_Occurred()) {
00774	            PyErr_SetString(PyExc_RuntimeError,
00775	                "Unexpected error in an Op's C code. "
00776	                "No Python exception was set.");
00777	            }
00778	        goto __label_11;}
00779	            }
00780	            
00781	                V1_n1 = PyArray_DIMS(V1)[1];
00782	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00783	                V1_jump1_1 = (V1_stride1) - (0);
00784	                //printf("V1_jump1_1 is:");
00785	                //std::cout << V1_jump1_1 << std::endl;
00786	                
00787	                V1_n0 = PyArray_DIMS(V1)[0];
00788	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00789	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00790	                //printf("V1_jump0_0 is:");
00791	                //std::cout << V1_jump0_0 << std::endl;
00792	                
00793	
00794	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V9) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V9) && PyArray_ISFORTRAN(V1))){
00795	                
00796	                    // All output have the same size
00797	                    npy_intp n = PyArray_SIZE(V1);
00798	                    
00799	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00800	                            
00801	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00802	                            
00803	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00804	                            
00805	            dtype_V9 * V9_ptr = (dtype_V9*) PyArray_DATA(V9);
00806	                            
00807	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00808	                            
00809	                    for(int i=0; i<n; i++){
00810	                        
00811	            dtype_V3& V3_i = V3_ptr[i];
00812	                            
00813	            dtype_V5& V5_i = V5_ptr[i];
00814	                            
00815	            dtype_V7& V7_i = V7_ptr[i];
00816	                            
00817	            dtype_V9& V9_i = V9_ptr[i];
00818	                            
00819	            dtype_V1& V1_i = V1_ptr[i];
00820	                            
00821	                        {
00822	npy_float64 V11_tmp1;
00823	V11_tmp1 = V5_i * V7_i;
00824	V1_i = V3_i + V11_tmp1 + V9_i;
00825	}
00826	;
00827	                    }
00828	                    
00829	            }else{
00830	                {
00831	
00832	    std::vector< std::pair<int, int> > V1_loops(2);
00833	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00834	    
00835	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00836	            
00837	        V1_loops_it->second = 0;
00838	        ++V1_loops_it;
00839	        
00840	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00841	            
00842	        V1_loops_it->second = 1;
00843	        ++V1_loops_it;
00844	        
00845	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00846	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00847	    
00848	
00849	    int init_totals[2] = {V3_n0, V3_n1};
00850	    
00851	    V1_loops_it = V1_loops.begin();
00852	    
00853	        int TOTAL_0 = init_totals[V1_loops_it->second];
00854	        ++V1_loops_it;
00855	        
00856	        int TOTAL_1 = init_totals[V1_loops_it->second];
00857	        ++V1_loops_it;
00858	        
00859	
00860	    int init_strides[5][2] = {
00861	        V3_stride0, V3_stride1, 
00862	V5_stride0, V5_stride1, 
00863	V7_stride0, V7_stride1, 
00864	V9_stride0, V9_stride1, 
00865	V1_stride0, V1_stride1
00866	    };
00867	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00868	    
00869	        V1_loops_rit = V1_loops.rbegin();
00870	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00871	            ++V1_loops_rit;
00872	            
00873	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00874	            ++V1_loops_rit;
00875	            
00876	        V1_loops_rit = V1_loops.rbegin();
00877	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00878	            ++V1_loops_rit;
00879	            
00880	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00881	            ++V1_loops_rit;
00882	            
00883	        V1_loops_rit = V1_loops.rbegin();
00884	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00885	            ++V1_loops_rit;
00886	            
00887	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00888	            ++V1_loops_rit;
00889	            
00890	        V1_loops_rit = V1_loops.rbegin();
00891	            int V9_stride_l1 = init_strides[3][V1_loops_rit->second];
00892	            ++V1_loops_rit;
00893	            
00894	            int V9_stride_l0 = init_strides[3][V1_loops_rit->second];
00895	            ++V1_loops_rit;
00896	            
00897	        V1_loops_rit = V1_loops.rbegin();
00898	            int V1_stride_l1 = init_strides[4][V1_loops_rit->second];
00899	            ++V1_loops_rit;
00900	            
00901	            int V1_stride_l0 = init_strides[4][V1_loops_rit->second];
00902	            ++V1_loops_rit;
00903	            
00904	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00905	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00906	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00907	V9_iter = (npy_float64*)(PyArray_DATA(V9));
00908	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00909	
00910	
00911	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00912	        { // begin loop 0
00913	            
00914	            
00915	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00916	        { // begin loop 1
00917	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00918	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00919	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00920	npy_float64 &V9_i = * ( V9_iter+V9_stride_l1*ITER_1+V9_stride_l0*ITER_0);
00921	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00922	
00923	            
00924	        {
00925	            
00926	            {
00927	npy_float64 V11_tmp1;
00928	V11_tmp1 = V5_i * V7_i;
00929	V1_i = V3_i + V11_tmp1 + V9_i;
00930	}
00931	
00932	            
00933	        }
00934	        
00935	        } // end loop 1
00936	        
00937	        } // end loop 0
00938	        
00939	}
00940	
00941	            }
00942	            __label_11:
00943	
00944	double __DUMMY_11;
00945	
00946	}
00947	__label_10:
00948	
00949	        if (V9) {
00950	            Py_XDECREF(V9);
00951	        }
00952	        
00953	    {Py_XDECREF(py_V9);}
00954	    
00955	double __DUMMY_10;
00956	
00957	}
00958	__label_8:
00959	
00960	        if (V7) {
00961	            Py_XDECREF(V7);
00962	        }
00963	        
00964	    {Py_XDECREF(py_V7);}
00965	    
00966	double __DUMMY_8;
00967	
00968	}
00969	__label_6:
00970	
00971	        if (V5) {
00972	            Py_XDECREF(V5);
00973	        }
00974	        
00975	    {Py_XDECREF(py_V5);}
00976	    
00977	double __DUMMY_6;
00978	
00979	}
00980	__label_4:
00981	
00982	        if (V3) {
00983	            Py_XDECREF(V3);
00984	        }
00985	        
00986	    {Py_XDECREF(py_V3);}
00987	    
00988	double __DUMMY_4;
00989	
00990	}
00991	__label_2:
00992	
00993	    if (!__failure) {
00994	      
00995	        {Py_XDECREF(py_V1);}
00996	        if (!V1) {
00997	            Py_INCREF(Py_None);
00998	            py_V1 = Py_None;
00999	        }
01000	        else if ((void*)py_V1 != (void*)V1) {
01001	            py_V1 = (PyObject*)V1;
01002	        }
01003	
01004	        {Py_XINCREF(py_V1);}
01005	
01006	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
01007	            PyErr_Format(PyExc_NotImplementedError,
01008	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
01009	                         " with %ld dimensions, with 3 last dims "
01010	                         "%ld, %ld, %ld"
01011	                         " and 3 last strides %ld %ld, %ld.",
01012	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
01013	                         (long int) PyArray_NDIM(V1),
01014	                         (long int) (PyArray_NDIM(V1) >= 3 ?
01015	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
01016	                         (long int) (PyArray_NDIM(V1) >= 2 ?
01017	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
01018	                         (long int) (PyArray_NDIM(V1) >= 1 ?
01019	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
01020	                         (long int) (PyArray_NDIM(V1) >= 3 ?
01021	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
01022	                         (long int) (PyArray_NDIM(V1) >= 2 ?
01023	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
01024	                         (long int) (PyArray_NDIM(V1) >= 1 ?
01025	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
01026	        );
01027	            {
01028	        __failure = 2;
01029	        if (!PyErr_Occurred()) {
01030	            PyErr_SetString(PyExc_RuntimeError,
01031	                "Unexpected error in an Op's C code. "
01032	                "No Python exception was set.");
01033	            }
01034	        goto __label_2;}
01035	        }
01036	        
01037	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
01038	      {Py_XINCREF(py_V1);}
01039	      PyList_SET_ITEM(storage_V1, 0, py_V1);
01040	      {Py_XDECREF(old);}
01041	    }
01042	    
01043	        if (V1) {
01044	            Py_XDECREF(V1);
01045	        }
01046	        
01047	    {Py_XDECREF(py_V1);}
01048	    
01049	double __DUMMY_2;
01050	
01051	}
01052	
01053	            
01054	        if (__failure) {
01055	            // When there is a failure, this code puts the exception
01056	            // in __ERROR.
01057	            PyObject* err_type = NULL;
01058	            PyObject* err_msg = NULL;
01059	            PyObject* err_traceback = NULL;
01060	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
01061	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
01062	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
01063	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
01064	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
01065	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
01066	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
01067	            PyList_SET_ITEM(__ERROR, 0, err_type);
01068	            PyList_SET_ITEM(__ERROR, 1, err_msg);
01069	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
01070	            {Py_XDECREF(old_err_type);}
01071	            {Py_XDECREF(old_err_msg);}
01072	            {Py_XDECREF(old_err_traceback);}
01073	        }
01074	        // The failure code is returned to index what code block failed.
01075	        return __failure;
01076	        
01077	        }
01078	    };
01079	    }
01080	    
01081	
01082	        static int __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426_executor(__struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426* self) {
01083	            return self->run();
01084	        }
01085	
01086	        static void __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426_destructor(void* executor, void* self) {
01087	            delete ((__struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426*)self);
01088	        }
01089	        
01090	//////////////////////
01091	////  Functions
01092	//////////////////////
01093	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
01094	  assert(PyTuple_Check(argtuple));
01095	  if (6 != PyTuple_Size(argtuple)){ 
01096	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 6, got %i", (int)PyTuple_Size(argtuple));
01097	     return NULL;
01098	  }
01099	  __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426* struct_ptr = new __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426();
01100	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4),PyTuple_GET_ITEM(argtuple, 5) ) != 0) {
01101	    delete struct_ptr;
01102	    return NULL;
01103	  }
01104	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426_executor), struct_ptr, __struct_compiled_op_f3422b161dfba6898df3bf8e09c3c426_destructor);
01105	  return thunk; }
01106	
01107	//////////////////////
01108	////  Module init
01109	//////////////////////
01110	static PyMethodDef MyMethods[] = {
01111		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
01112		{NULL, NULL, 0, NULL}
01113	};
01114	PyMODINIT_FUNC initf3422b161dfba6898df3bf8e09c3c426(void){
01115	   import_array();
01116	   (void) Py_InitModule("f3422b161dfba6898df3bf8e09c3c426", MyMethods);
01117	}
01118	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpa081RI/f3422b161dfba6898df3bf8e09c3c426.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpa081RI/mod.cpp -lpython2.7
ERROR
test_shared_grad_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_89b8ff2c8ba122c373c019867f28a698 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V9;
00021	PyObject* storage_V1;
00022	        
00023	
00024	        __struct_compiled_op_89b8ff2c8ba122c373c019867f28a698() {
00025	            // This is only somewhat safe because we:
00026	            //  1) Are not a virtual class
00027	            //  2) Do not use any virtual classes in the members
00028	            //  3) Deal with mostly POD and pointers
00029	
00030	            // If this changes, we would have to revise this, but for
00031	            // now I am tired of chasing segfaults because
00032	            // initialization code had an error and some pointer has
00033	            // a junk value.
00034	            memset(this, 0, sizeof(*this));
00035	        }
00036	        ~__struct_compiled_op_89b8ff2c8ba122c373c019867f28a698(void) {
00037	            cleanup();
00038	        }
00039	
00040	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V9, PyObject* storage_V1) {
00041	            Py_XINCREF(storage_V3);
00042	Py_XINCREF(storage_V5);
00043	Py_XINCREF(storage_V7);
00044	Py_XINCREF(storage_V9);
00045	Py_XINCREF(storage_V1);
00046	            this->storage_V3 = storage_V3;
00047	this->storage_V5 = storage_V5;
00048	this->storage_V7 = storage_V7;
00049	this->storage_V9 = storage_V9;
00050	this->storage_V1 = storage_V1;
00051	            
00052	
00053	
00054	
00055	
00056	
00057	
00058	            this->__ERROR = __ERROR;
00059	            return 0;
00060	        }
00061	        void cleanup(void) {
00062	            __label_1:
00063	
00064	double __DUMMY_1;
00065	__label_3:
00066	
00067	double __DUMMY_3;
00068	__label_5:
00069	
00070	double __DUMMY_5;
00071	__label_7:
00072	
00073	double __DUMMY_7;
00074	__label_9:
00075	
00076	double __DUMMY_9;
00077	__label_12:
00078	
00079	double __DUMMY_12;
00080	
00081	            Py_XDECREF(this->storage_V3);
00082	Py_XDECREF(this->storage_V5);
00083	Py_XDECREF(this->storage_V7);
00084	Py_XDECREF(this->storage_V9);
00085	Py_XDECREF(this->storage_V1);
00086	        }
00087	        int run(void) {
00088	            int __failure = 0;
00089	            
00090	    PyObject* py_V1;
00091	    
00092	        PyArrayObject* V1;
00093	        
00094	            typedef npy_float64 dtype_V1;
00095	            
00096	    PyObject* py_V3;
00097	    
00098	        PyArrayObject* V3;
00099	        
00100	            typedef npy_float64 dtype_V3;
00101	            
00102	    PyObject* py_V5;
00103	    
00104	        PyArrayObject* V5;
00105	        
00106	            typedef npy_float64 dtype_V5;
00107	            
00108	    PyObject* py_V7;
00109	    
00110	        PyArrayObject* V7;
00111	        
00112	            typedef npy_float64 dtype_V7;
00113	            
00114	    PyObject* py_V9;
00115	    
00116	        PyArrayObject* V9;
00117	        
00118	            typedef npy_float64 dtype_V9;
00119	            
00120	{
00121	
00122	    py_V1 = Py_None;
00123	    {Py_XINCREF(py_V1);}
00124	    
00125	        V1 = NULL;
00126	        
00127	{
00128	
00129	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00130	    {Py_XINCREF(py_V3);}
00131	    
00132	            V3 = NULL;
00133	            if (py_V3 == Py_None) {
00134	                // We can either fail here or set V3 to NULL and rely on Ops
00135	                // using tensors to handle the NULL case, but if they fail to do so
00136	                // they'll end up with nasty segfaults, so this is public service.
00137	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00138	                {
00139	        __failure = 4;
00140	        if (!PyErr_Occurred()) {
00141	            PyErr_SetString(PyExc_RuntimeError,
00142	                "Unexpected error in an Op's C code. "
00143	                "No Python exception was set.");
00144	            }
00145	        goto __label_4;}
00146	            }
00147	            if (!PyArray_Check(py_V3)) {
00148	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00149	                {
00150	        __failure = 4;
00151	        if (!PyErr_Occurred()) {
00152	            PyErr_SetString(PyExc_RuntimeError,
00153	                "Unexpected error in an Op's C code. "
00154	                "No Python exception was set.");
00155	            }
00156	        goto __label_4;}
00157	            }
00158	            // We expect NPY_FLOAT64
00159	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00160	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00161	                PyErr_Format(PyExc_NotImplementedError,
00162	                             "expected an aligned array of type %ld "
00163	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00164	                             " with %ld dimensions, with 3 last dims "
00165	                             "%ld, %ld, %ld"
00166	                             " and 3 last strides %ld %ld, %ld.",
00167	                             (long int) NPY_FLOAT64,
00168	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00169	                             (long int) PyArray_NDIM(tmp),
00170	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00171	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00172	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00173	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00174	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00175	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00176	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00177	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00178	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00179	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00180	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00181	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00182	            );
00183	                {
00184	        __failure = 4;
00185	        if (!PyErr_Occurred()) {
00186	            PyErr_SetString(PyExc_RuntimeError,
00187	                "Unexpected error in an Op's C code. "
00188	                "No Python exception was set.");
00189	            }
00190	        goto __label_4;}
00191	            }
00192	            // This is a TypeError to be consistent with DEBUG_MODE
00193	            // Note: DEBUG_MODE also tells the name of the container
00194	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00195	                PyErr_Format(PyExc_TypeError,
00196	                             "expected type_num %d (NPY_FLOAT64) got %d",
00197	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            
00208	        V3 = (PyArrayObject*)(py_V3);
00209	        Py_XINCREF(V3);
00210	        
00211	{
00212	
00213	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00214	    {Py_XINCREF(py_V5);}
00215	    
00216	            V5 = NULL;
00217	            if (py_V5 == Py_None) {
00218	                // We can either fail here or set V5 to NULL and rely on Ops
00219	                // using tensors to handle the NULL case, but if they fail to do so
00220	                // they'll end up with nasty segfaults, so this is public service.
00221	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00222	                {
00223	        __failure = 6;
00224	        if (!PyErr_Occurred()) {
00225	            PyErr_SetString(PyExc_RuntimeError,
00226	                "Unexpected error in an Op's C code. "
00227	                "No Python exception was set.");
00228	            }
00229	        goto __label_6;}
00230	            }
00231	            if (!PyArray_Check(py_V5)) {
00232	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00233	                {
00234	        __failure = 6;
00235	        if (!PyErr_Occurred()) {
00236	            PyErr_SetString(PyExc_RuntimeError,
00237	                "Unexpected error in an Op's C code. "
00238	                "No Python exception was set.");
00239	            }
00240	        goto __label_6;}
00241	            }
00242	            // We expect NPY_FLOAT64
00243	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00244	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00245	                PyErr_Format(PyExc_NotImplementedError,
00246	                             "expected an aligned array of type %ld "
00247	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00248	                             " with %ld dimensions, with 3 last dims "
00249	                             "%ld, %ld, %ld"
00250	                             " and 3 last strides %ld %ld, %ld.",
00251	                             (long int) NPY_FLOAT64,
00252	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00253	                             (long int) PyArray_NDIM(tmp),
00254	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00255	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00256	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00257	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00258	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00259	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00260	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00261	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00262	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00263	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00264	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00265	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00266	            );
00267	                {
00268	        __failure = 6;
00269	        if (!PyErr_Occurred()) {
00270	            PyErr_SetString(PyExc_RuntimeError,
00271	                "Unexpected error in an Op's C code. "
00272	                "No Python exception was set.");
00273	            }
00274	        goto __label_6;}
00275	            }
00276	            // This is a TypeError to be consistent with DEBUG_MODE
00277	            // Note: DEBUG_MODE also tells the name of the container
00278	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00279	                PyErr_Format(PyExc_TypeError,
00280	                             "expected type_num %d (NPY_FLOAT64) got %d",
00281	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            
00292	        V5 = (PyArrayObject*)(py_V5);
00293	        Py_XINCREF(V5);
00294	        
00295	{
00296	
00297	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00298	    {Py_XINCREF(py_V7);}
00299	    
00300	            V7 = NULL;
00301	            if (py_V7 == Py_None) {
00302	                // We can either fail here or set V7 to NULL and rely on Ops
00303	                // using tensors to handle the NULL case, but if they fail to do so
00304	                // they'll end up with nasty segfaults, so this is public service.
00305	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00306	                {
00307	        __failure = 8;
00308	        if (!PyErr_Occurred()) {
00309	            PyErr_SetString(PyExc_RuntimeError,
00310	                "Unexpected error in an Op's C code. "
00311	                "No Python exception was set.");
00312	            }
00313	        goto __label_8;}
00314	            }
00315	            if (!PyArray_Check(py_V7)) {
00316	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00317	                {
00318	        __failure = 8;
00319	        if (!PyErr_Occurred()) {
00320	            PyErr_SetString(PyExc_RuntimeError,
00321	                "Unexpected error in an Op's C code. "
00322	                "No Python exception was set.");
00323	            }
00324	        goto __label_8;}
00325	            }
00326	            // We expect NPY_FLOAT64
00327	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00328	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00329	                PyErr_Format(PyExc_NotImplementedError,
00330	                             "expected an aligned array of type %ld "
00331	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00332	                             " with %ld dimensions, with 3 last dims "
00333	                             "%ld, %ld, %ld"
00334	                             " and 3 last strides %ld %ld, %ld.",
00335	                             (long int) NPY_FLOAT64,
00336	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00337	                             (long int) PyArray_NDIM(tmp),
00338	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00339	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00340	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00341	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00342	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00343	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00344	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00345	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00346	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00347	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00348	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00349	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00350	            );
00351	                {
00352	        __failure = 8;
00353	        if (!PyErr_Occurred()) {
00354	            PyErr_SetString(PyExc_RuntimeError,
00355	                "Unexpected error in an Op's C code. "
00356	                "No Python exception was set.");
00357	            }
00358	        goto __label_8;}
00359	            }
00360	            // This is a TypeError to be consistent with DEBUG_MODE
00361	            // Note: DEBUG_MODE also tells the name of the container
00362	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00363	                PyErr_Format(PyExc_TypeError,
00364	                             "expected type_num %d (NPY_FLOAT64) got %d",
00365	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00366	                {
00367	        __failure = 8;
00368	        if (!PyErr_Occurred()) {
00369	            PyErr_SetString(PyExc_RuntimeError,
00370	                "Unexpected error in an Op's C code. "
00371	                "No Python exception was set.");
00372	            }
00373	        goto __label_8;}
00374	            }
00375	            
00376	        V7 = (PyArrayObject*)(py_V7);
00377	        Py_XINCREF(V7);
00378	        
00379	{
00380	
00381	    py_V9 = PyList_GET_ITEM(storage_V9, 0);
00382	    {Py_XINCREF(py_V9);}
00383	    
00384	            V9 = NULL;
00385	            if (py_V9 == Py_None) {
00386	                // We can either fail here or set V9 to NULL and rely on Ops
00387	                // using tensors to handle the NULL case, but if they fail to do so
00388	                // they'll end up with nasty segfaults, so this is public service.
00389	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00390	                {
00391	        __failure = 10;
00392	        if (!PyErr_Occurred()) {
00393	            PyErr_SetString(PyExc_RuntimeError,
00394	                "Unexpected error in an Op's C code. "
00395	                "No Python exception was set.");
00396	            }
00397	        goto __label_10;}
00398	            }
00399	            if (!PyArray_Check(py_V9)) {
00400	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00401	                {
00402	        __failure = 10;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_10;}
00409	            }
00410	            // We expect NPY_FLOAT64
00411	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V9)) {
00412	                PyArrayObject * tmp = (PyArrayObject*) py_V9;
00413	                PyErr_Format(PyExc_NotImplementedError,
00414	                             "expected an aligned array of type %ld "
00415	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00416	                             " with %ld dimensions, with 3 last dims "
00417	                             "%ld, %ld, %ld"
00418	                             " and 3 last strides %ld %ld, %ld.",
00419	                             (long int) NPY_FLOAT64,
00420	                             (long int) PyArray_TYPE((PyArrayObject*) py_V9),
00421	                             (long int) PyArray_NDIM(tmp),
00422	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00423	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00424	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00425	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00426	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00427	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00428	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00429	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00430	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00431	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00432	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00433	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00434	            );
00435	                {
00436	        __failure = 10;
00437	        if (!PyErr_Occurred()) {
00438	            PyErr_SetString(PyExc_RuntimeError,
00439	                "Unexpected error in an Op's C code. "
00440	                "No Python exception was set.");
00441	            }
00442	        goto __label_10;}
00443	            }
00444	            // This is a TypeError to be consistent with DEBUG_MODE
00445	            // Note: DEBUG_MODE also tells the name of the container
00446	            if (PyArray_TYPE((PyArrayObject*) py_V9) != NPY_FLOAT64) {
00447	                PyErr_Format(PyExc_TypeError,
00448	                             "expected type_num %d (NPY_FLOAT64) got %d",
00449	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V9));
00450	                {
00451	        __failure = 10;
00452	        if (!PyErr_Occurred()) {
00453	            PyErr_SetString(PyExc_RuntimeError,
00454	                "Unexpected error in an Op's C code. "
00455	                "No Python exception was set.");
00456	            }
00457	        goto __label_10;}
00458	            }
00459	            
00460	        V9 = (PyArrayObject*)(py_V9);
00461	        Py_XINCREF(V9);
00462	        
00463	{
00464	// Op class Elemwise
00465	
00466	        npy_float64* V3_iter;
00467	        
00468	                npy_intp V3_n0;
00469	                ssize_t V3_stride0;
00470	                int V3_jump0_0;
00471	                
00472	                npy_intp V3_n1;
00473	                ssize_t V3_stride1;
00474	                int V3_jump1_1;
00475	                
00476	        npy_float64* V5_iter;
00477	        
00478	                npy_intp V5_n0;
00479	                ssize_t V5_stride0;
00480	                int V5_jump0_0;
00481	                
00482	                npy_intp V5_n1;
00483	                ssize_t V5_stride1;
00484	                int V5_jump1_1;
00485	                
00486	        npy_float64* V7_iter;
00487	        
00488	                npy_intp V7_n0;
00489	                ssize_t V7_stride0;
00490	                int V7_jump0_0;
00491	                
00492	                npy_intp V7_n1;
00493	                ssize_t V7_stride1;
00494	                int V7_jump1_1;
00495	                
00496	        npy_float64* V9_iter;
00497	        
00498	                npy_intp V9_n0;
00499	                ssize_t V9_stride0;
00500	                int V9_jump0_0;
00501	                
00502	                npy_intp V9_n1;
00503	                ssize_t V9_stride1;
00504	                int V9_jump1_1;
00505	                
00506	
00507	            if (PyArray_NDIM(V3) < 2) {
00508	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00509	                {
00510	        __failure = 11;
00511	        if (!PyErr_Occurred()) {
00512	            PyErr_SetString(PyExc_RuntimeError,
00513	                "Unexpected error in an Op's C code. "
00514	                "No Python exception was set.");
00515	            }
00516	        goto __label_11;}
00517	            }
00518	            
00519	                V3_n1 = PyArray_DIMS(V3)[1];
00520	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00521	                V3_jump1_1 = (V3_stride1) - (0);
00522	                //printf("V3_jump1_1 is:");
00523	                //std::cout << V3_jump1_1 << std::endl;
00524	                
00525	                V3_n0 = PyArray_DIMS(V3)[0];
00526	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00527	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00528	                //printf("V3_jump0_0 is:");
00529	                //std::cout << V3_jump0_0 << std::endl;
00530	                
00531	            if (PyArray_NDIM(V5) < 2) {
00532	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00533	                {
00534	        __failure = 11;
00535	        if (!PyErr_Occurred()) {
00536	            PyErr_SetString(PyExc_RuntimeError,
00537	                "Unexpected error in an Op's C code. "
00538	                "No Python exception was set.");
00539	            }
00540	        goto __label_11;}
00541	            }
00542	            
00543	                V5_n1 = PyArray_DIMS(V5)[1];
00544	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00545	                V5_jump1_1 = (V5_stride1) - (0);
00546	                //printf("V5_jump1_1 is:");
00547	                //std::cout << V5_jump1_1 << std::endl;
00548	                
00549	                V5_n0 = PyArray_DIMS(V5)[0];
00550	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00551	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00552	                //printf("V5_jump0_0 is:");
00553	                //std::cout << V5_jump0_0 << std::endl;
00554	                
00555	            if (PyArray_NDIM(V7) < 2) {
00556	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00557	                {
00558	        __failure = 11;
00559	        if (!PyErr_Occurred()) {
00560	            PyErr_SetString(PyExc_RuntimeError,
00561	                "Unexpected error in an Op's C code. "
00562	                "No Python exception was set.");
00563	            }
00564	        goto __label_11;}
00565	            }
00566	            
00567	                V7_n1 = PyArray_DIMS(V7)[1];
00568	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00569	                V7_jump1_1 = (V7_stride1) - (0);
00570	                //printf("V7_jump1_1 is:");
00571	                //std::cout << V7_jump1_1 << std::endl;
00572	                
00573	                V7_n0 = PyArray_DIMS(V7)[0];
00574	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00575	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00576	                //printf("V7_jump0_0 is:");
00577	                //std::cout << V7_jump0_0 << std::endl;
00578	                
00579	            if (PyArray_NDIM(V9) < 2) {
00580	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00581	                {
00582	        __failure = 11;
00583	        if (!PyErr_Occurred()) {
00584	            PyErr_SetString(PyExc_RuntimeError,
00585	                "Unexpected error in an Op's C code. "
00586	                "No Python exception was set.");
00587	            }
00588	        goto __label_11;}
00589	            }
00590	            
00591	                V9_n1 = PyArray_DIMS(V9)[1];
00592	                V9_stride1 = PyArray_STRIDES(V9)[1] / sizeof(npy_float64);
00593	                V9_jump1_1 = (V9_stride1) - (0);
00594	                //printf("V9_jump1_1 is:");
00595	                //std::cout << V9_jump1_1 << std::endl;
00596	                
00597	                V9_n0 = PyArray_DIMS(V9)[0];
00598	                V9_stride0 = PyArray_STRIDES(V9)[0] / sizeof(npy_float64);
00599	                V9_jump0_0 = (V9_stride0) - (V9_n1*V9_stride1);
00600	                //printf("V9_jump0_0 is:");
00601	                //std::cout << V9_jump0_0 << std::endl;
00602	                
00603	            if (V3_n0 != V5_n0)
00604	            {
00605	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00606	                   0,
00607	                   0,
00608	                   V3_n0,
00609	                   1,
00610	                   0,
00611	                   V5_n0
00612	                );
00613	                {
00614	        __failure = 11;
00615	        if (!PyErr_Occurred()) {
00616	            PyErr_SetString(PyExc_RuntimeError,
00617	                "Unexpected error in an Op's C code. "
00618	                "No Python exception was set.");
00619	            }
00620	        goto __label_11;}
00621	            }
00622	            
00623	            if (V3_n0 != V7_n0)
00624	            {
00625	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00626	                   0,
00627	                   0,
00628	                   V3_n0,
00629	                   2,
00630	                   0,
00631	                   V7_n0
00632	                );
00633	                {
00634	        __failure = 11;
00635	        if (!PyErr_Occurred()) {
00636	            PyErr_SetString(PyExc_RuntimeError,
00637	                "Unexpected error in an Op's C code. "
00638	                "No Python exception was set.");
00639	            }
00640	        goto __label_11;}
00641	            }
00642	            
00643	            if (V3_n0 != V9_n0)
00644	            {
00645	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00646	                   0,
00647	                   0,
00648	                   V3_n0,
00649	                   3,
00650	                   0,
00651	                   V9_n0
00652	                );
00653	                {
00654	        __failure = 11;
00655	        if (!PyErr_Occurred()) {
00656	            PyErr_SetString(PyExc_RuntimeError,
00657	                "Unexpected error in an Op's C code. "
00658	                "No Python exception was set.");
00659	            }
00660	        goto __label_11;}
00661	            }
00662	            
00663	            if (V3_n1 != V5_n1)
00664	            {
00665	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00666	                   0,
00667	                   1,
00668	                   V3_n1,
00669	                   1,
00670	                   1,
00671	                   V5_n1
00672	                );
00673	                {
00674	        __failure = 11;
00675	        if (!PyErr_Occurred()) {
00676	            PyErr_SetString(PyExc_RuntimeError,
00677	                "Unexpected error in an Op's C code. "
00678	                "No Python exception was set.");
00679	            }
00680	        goto __label_11;}
00681	            }
00682	            
00683	            if (V3_n1 != V7_n1)
00684	            {
00685	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00686	                   0,
00687	                   1,
00688	                   V3_n1,
00689	                   2,
00690	                   1,
00691	                   V7_n1
00692	                );
00693	                {
00694	        __failure = 11;
00695	        if (!PyErr_Occurred()) {
00696	            PyErr_SetString(PyExc_RuntimeError,
00697	                "Unexpected error in an Op's C code. "
00698	                "No Python exception was set.");
00699	            }
00700	        goto __label_11;}
00701	            }
00702	            
00703	            if (V3_n1 != V9_n1)
00704	            {
00705	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00706	                   0,
00707	                   1,
00708	                   V3_n1,
00709	                   3,
00710	                   1,
00711	                   V9_n1
00712	                );
00713	                {
00714	        __failure = 11;
00715	        if (!PyErr_Occurred()) {
00716	            PyErr_SetString(PyExc_RuntimeError,
00717	                "Unexpected error in an Op's C code. "
00718	                "No Python exception was set.");
00719	            }
00720	        goto __label_11;}
00721	            }
00722	            
00723	
00724	        npy_float64* V1_iter;
00725	        
00726	                npy_intp V1_n0;
00727	                ssize_t V1_stride0;
00728	                int V1_jump0_0;
00729	                
00730	                npy_intp V1_n1;
00731	                ssize_t V1_stride1;
00732	                int V1_jump1_1;
00733	                
00734	    {
00735	        npy_intp dims[2];
00736	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00737	        dims[0] = V3_n0;
00738	dims[1] = V3_n1;
00739	
00740	        if (!V1) {
00741	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00742	                                                    NPY_FLOAT64,
00743	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V9));
00744	        }
00745	        else {
00746	            PyArray_Dims new_dims;
00747	            new_dims.len = 2;
00748	            new_dims.ptr = dims;
00749	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00750	            if (!success) {
00751	                // If we can't resize the ndarray we have we can allocate a new one.
00752	                PyErr_Clear();
00753	                Py_XDECREF(V1);
00754	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00755	            }
00756	        }
00757	        if (!V1) {
00758	            {
00759	        __failure = 11;
00760	        if (!PyErr_Occurred()) {
00761	            PyErr_SetString(PyExc_RuntimeError,
00762	                "Unexpected error in an Op's C code. "
00763	                "No Python exception was set.");
00764	            }
00765	        goto __label_11;}
00766	        }
00767	    }
00768	    
00769	            if (PyArray_NDIM(V1) < 2) {
00770	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00771	                {
00772	        __failure = 11;
00773	        if (!PyErr_Occurred()) {
00774	            PyErr_SetString(PyExc_RuntimeError,
00775	                "Unexpected error in an Op's C code. "
00776	                "No Python exception was set.");
00777	            }
00778	        goto __label_11;}
00779	            }
00780	            
00781	                V1_n1 = PyArray_DIMS(V1)[1];
00782	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00783	                V1_jump1_1 = (V1_stride1) - (0);
00784	                //printf("V1_jump1_1 is:");
00785	                //std::cout << V1_jump1_1 << std::endl;
00786	                
00787	                V1_n0 = PyArray_DIMS(V1)[0];
00788	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00789	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00790	                //printf("V1_jump0_0 is:");
00791	                //std::cout << V1_jump0_0 << std::endl;
00792	                
00793	
00794	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V9) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V9) && PyArray_ISFORTRAN(V1))){
00795	                
00796	                    // All output have the same size
00797	                    npy_intp n = PyArray_SIZE(V1);
00798	                    
00799	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00800	                            
00801	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00802	                            
00803	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00804	                            
00805	            dtype_V9 * V9_ptr = (dtype_V9*) PyArray_DATA(V9);
00806	                            
00807	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00808	                            
00809	                    for(int i=0; i<n; i++){
00810	                        
00811	            dtype_V3& V3_i = V3_ptr[i];
00812	                            
00813	            dtype_V5& V5_i = V5_ptr[i];
00814	                            
00815	            dtype_V7& V7_i = V7_ptr[i];
00816	                            
00817	            dtype_V9& V9_i = V9_ptr[i];
00818	                            
00819	            dtype_V1& V1_i = V1_ptr[i];
00820	                            
00821	                        {
00822	npy_float64 V11_tmp1;
00823	V11_tmp1 = V5_i * V7_i;
00824	npy_float64 V11_tmp2;
00825	V11_tmp2 = V3_i + V11_tmp1 + V9_i;
00826	V1_i = V11_tmp2 - V7_i;
00827	}
00828	;
00829	                    }
00830	                    
00831	            }else{
00832	                {
00833	
00834	    std::vector< std::pair<int, int> > V1_loops(2);
00835	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00836	    
00837	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00838	            
00839	        V1_loops_it->second = 0;
00840	        ++V1_loops_it;
00841	        
00842	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00843	            
00844	        V1_loops_it->second = 1;
00845	        ++V1_loops_it;
00846	        
00847	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00848	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00849	    
00850	
00851	    int init_totals[2] = {V3_n0, V3_n1};
00852	    
00853	    V1_loops_it = V1_loops.begin();
00854	    
00855	        int TOTAL_0 = init_totals[V1_loops_it->second];
00856	        ++V1_loops_it;
00857	        
00858	        int TOTAL_1 = init_totals[V1_loops_it->second];
00859	        ++V1_loops_it;
00860	        
00861	
00862	    int init_strides[5][2] = {
00863	        V3_stride0, V3_stride1, 
00864	V5_stride0, V5_stride1, 
00865	V7_stride0, V7_stride1, 
00866	V9_stride0, V9_stride1, 
00867	V1_stride0, V1_stride1
00868	    };
00869	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00870	    
00871	        V1_loops_rit = V1_loops.rbegin();
00872	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00873	            ++V1_loops_rit;
00874	            
00875	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00876	            ++V1_loops_rit;
00877	            
00878	        V1_loops_rit = V1_loops.rbegin();
00879	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00880	            ++V1_loops_rit;
00881	            
00882	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00883	            ++V1_loops_rit;
00884	            
00885	        V1_loops_rit = V1_loops.rbegin();
00886	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00887	            ++V1_loops_rit;
00888	            
00889	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00890	            ++V1_loops_rit;
00891	            
00892	        V1_loops_rit = V1_loops.rbegin();
00893	            int V9_stride_l1 = init_strides[3][V1_loops_rit->second];
00894	            ++V1_loops_rit;
00895	            
00896	            int V9_stride_l0 = init_strides[3][V1_loops_rit->second];
00897	            ++V1_loops_rit;
00898	            
00899	        V1_loops_rit = V1_loops.rbegin();
00900	            int V1_stride_l1 = init_strides[4][V1_loops_rit->second];
00901	            ++V1_loops_rit;
00902	            
00903	            int V1_stride_l0 = init_strides[4][V1_loops_rit->second];
00904	            ++V1_loops_rit;
00905	            
00906	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00907	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00908	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00909	V9_iter = (npy_float64*)(PyArray_DATA(V9));
00910	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00911	
00912	
00913	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00914	        { // begin loop 0
00915	            
00916	            
00917	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00918	        { // begin loop 1
00919	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00920	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00921	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00922	npy_float64 &V9_i = * ( V9_iter+V9_stride_l1*ITER_1+V9_stride_l0*ITER_0);
00923	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00924	
00925	            
00926	        {
00927	            
00928	            {
00929	npy_float64 V11_tmp1;
00930	V11_tmp1 = V5_i * V7_i;
00931	npy_float64 V11_tmp2;
00932	V11_tmp2 = V3_i + V11_tmp1 + V9_i;
00933	V1_i = V11_tmp2 - V7_i;
00934	}
00935	
00936	            
00937	        }
00938	        
00939	        } // end loop 1
00940	        
00941	        } // end loop 0
00942	        
00943	}
00944	
00945	            }
00946	            __label_11:
00947	
00948	double __DUMMY_11;
00949	
00950	}
00951	__label_10:
00952	
00953	        if (V9) {
00954	            Py_XDECREF(V9);
00955	        }
00956	        
00957	    {Py_XDECREF(py_V9);}
00958	    
00959	double __DUMMY_10;
00960	
00961	}
00962	__label_8:
00963	
00964	        if (V7) {
00965	            Py_XDECREF(V7);
00966	        }
00967	        
00968	    {Py_XDECREF(py_V7);}
00969	    
00970	double __DUMMY_8;
00971	
00972	}
00973	__label_6:
00974	
00975	        if (V5) {
00976	            Py_XDECREF(V5);
00977	        }
00978	        
00979	    {Py_XDECREF(py_V5);}
00980	    
00981	double __DUMMY_6;
00982	
00983	}
00984	__label_4:
00985	
00986	        if (V3) {
00987	            Py_XDECREF(V3);
00988	        }
00989	        
00990	    {Py_XDECREF(py_V3);}
00991	    
00992	double __DUMMY_4;
00993	
00994	}
00995	__label_2:
00996	
00997	    if (!__failure) {
00998	      
00999	        {Py_XDECREF(py_V1);}
01000	        if (!V1) {
01001	            Py_INCREF(Py_None);
01002	            py_V1 = Py_None;
01003	        }
01004	        else if ((void*)py_V1 != (void*)V1) {
01005	            py_V1 = (PyObject*)V1;
01006	        }
01007	
01008	        {Py_XINCREF(py_V1);}
01009	
01010	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
01011	            PyErr_Format(PyExc_NotImplementedError,
01012	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
01013	                         " with %ld dimensions, with 3 last dims "
01014	                         "%ld, %ld, %ld"
01015	                         " and 3 last strides %ld %ld, %ld.",
01016	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
01017	                         (long int) PyArray_NDIM(V1),
01018	                         (long int) (PyArray_NDIM(V1) >= 3 ?
01019	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
01020	                         (long int) (PyArray_NDIM(V1) >= 2 ?
01021	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
01022	                         (long int) (PyArray_NDIM(V1) >= 1 ?
01023	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
01024	                         (long int) (PyArray_NDIM(V1) >= 3 ?
01025	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
01026	                         (long int) (PyArray_NDIM(V1) >= 2 ?
01027	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
01028	                         (long int) (PyArray_NDIM(V1) >= 1 ?
01029	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
01030	        );
01031	            {
01032	        __failure = 2;
01033	        if (!PyErr_Occurred()) {
01034	            PyErr_SetString(PyExc_RuntimeError,
01035	                "Unexpected error in an Op's C code. "
01036	                "No Python exception was set.");
01037	            }
01038	        goto __label_2;}
01039	        }
01040	        
01041	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
01042	      {Py_XINCREF(py_V1);}
01043	      PyList_SET_ITEM(storage_V1, 0, py_V1);
01044	      {Py_XDECREF(old);}
01045	    }
01046	    
01047	        if (V1) {
01048	            Py_XDECREF(V1);
01049	        }
01050	        
01051	    {Py_XDECREF(py_V1);}
01052	    
01053	double __DUMMY_2;
01054	
01055	}
01056	
01057	            
01058	        if (__failure) {
01059	            // When there is a failure, this code puts the exception
01060	            // in __ERROR.
01061	            PyObject* err_type = NULL;
01062	            PyObject* err_msg = NULL;
01063	            PyObject* err_traceback = NULL;
01064	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
01065	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
01066	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
01067	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
01068	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
01069	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
01070	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
01071	            PyList_SET_ITEM(__ERROR, 0, err_type);
01072	            PyList_SET_ITEM(__ERROR, 1, err_msg);
01073	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
01074	            {Py_XDECREF(old_err_type);}
01075	            {Py_XDECREF(old_err_msg);}
01076	            {Py_XDECREF(old_err_traceback);}
01077	        }
01078	        // The failure code is returned to index what code block failed.
01079	        return __failure;
01080	        
01081	        }
01082	    };
01083	    }
01084	    
01085	
01086	        static int __struct_compiled_op_89b8ff2c8ba122c373c019867f28a698_executor(__struct_compiled_op_89b8ff2c8ba122c373c019867f28a698* self) {
01087	            return self->run();
01088	        }
01089	
01090	        static void __struct_compiled_op_89b8ff2c8ba122c373c019867f28a698_destructor(void* executor, void* self) {
01091	            delete ((__struct_compiled_op_89b8ff2c8ba122c373c019867f28a698*)self);
01092	        }
01093	        
01094	//////////////////////
01095	////  Functions
01096	//////////////////////
01097	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
01098	  assert(PyTuple_Check(argtuple));
01099	  if (6 != PyTuple_Size(argtuple)){ 
01100	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 6, got %i", (int)PyTuple_Size(argtuple));
01101	     return NULL;
01102	  }
01103	  __struct_compiled_op_89b8ff2c8ba122c373c019867f28a698* struct_ptr = new __struct_compiled_op_89b8ff2c8ba122c373c019867f28a698();
01104	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4),PyTuple_GET_ITEM(argtuple, 5) ) != 0) {
01105	    delete struct_ptr;
01106	    return NULL;
01107	  }
01108	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_89b8ff2c8ba122c373c019867f28a698_executor), struct_ptr, __struct_compiled_op_89b8ff2c8ba122c373c019867f28a698_destructor);
01109	  return thunk; }
01110	
01111	//////////////////////
01112	////  Module init
01113	//////////////////////
01114	static PyMethodDef MyMethods[] = {
01115		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
01116		{NULL, NULL, 0, NULL}
01117	};
01118	PyMODINIT_FUNC init89b8ff2c8ba122c373c019867f28a698(void){
01119	   import_array();
01120	   (void) Py_InitModule("89b8ff2c8ba122c373c019867f28a698", MyMethods);
01121	}
01122	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpf9_3X5/89b8ff2c8ba122c373c019867f28a698.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpf9_3X5/mod.cpp -lpython2.7
ERROR
test_size_changes_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_size_changes_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... ok
test_straightforward_0 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V1;
00021	        
00022	
00023	        __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331() {
00024	            // This is only somewhat safe because we:
00025	            //  1) Are not a virtual class
00026	            //  2) Do not use any virtual classes in the members
00027	            //  3) Deal with mostly POD and pointers
00028	
00029	            // If this changes, we would have to revise this, but for
00030	            // now I am tired of chasing segfaults because
00031	            // initialization code had an error and some pointer has
00032	            // a junk value.
00033	            memset(this, 0, sizeof(*this));
00034	        }
00035	        ~__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331(void) {
00036	            cleanup();
00037	        }
00038	
00039	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V1) {
00040	            Py_XINCREF(storage_V3);
00041	Py_XINCREF(storage_V5);
00042	Py_XINCREF(storage_V7);
00043	Py_XINCREF(storage_V1);
00044	            this->storage_V3 = storage_V3;
00045	this->storage_V5 = storage_V5;
00046	this->storage_V7 = storage_V7;
00047	this->storage_V1 = storage_V1;
00048	            
00049	
00050	
00051	
00052	
00053	
00054	            this->__ERROR = __ERROR;
00055	            return 0;
00056	        }
00057	        void cleanup(void) {
00058	            __label_1:
00059	
00060	double __DUMMY_1;
00061	__label_3:
00062	
00063	double __DUMMY_3;
00064	__label_5:
00065	
00066	double __DUMMY_5;
00067	__label_7:
00068	
00069	double __DUMMY_7;
00070	__label_10:
00071	
00072	double __DUMMY_10;
00073	
00074	            Py_XDECREF(this->storage_V3);
00075	Py_XDECREF(this->storage_V5);
00076	Py_XDECREF(this->storage_V7);
00077	Py_XDECREF(this->storage_V1);
00078	        }
00079	        int run(void) {
00080	            int __failure = 0;
00081	            
00082	    PyObject* py_V1;
00083	    
00084	        PyArrayObject* V1;
00085	        
00086	            typedef npy_float64 dtype_V1;
00087	            
00088	    PyObject* py_V3;
00089	    
00090	        PyArrayObject* V3;
00091	        
00092	            typedef npy_float64 dtype_V3;
00093	            
00094	    PyObject* py_V5;
00095	    
00096	        PyArrayObject* V5;
00097	        
00098	            typedef npy_float64 dtype_V5;
00099	            
00100	    PyObject* py_V7;
00101	    
00102	        PyArrayObject* V7;
00103	        
00104	            typedef npy_float64 dtype_V7;
00105	            
00106	{
00107	
00108	    py_V1 = Py_None;
00109	    {Py_XINCREF(py_V1);}
00110	    
00111	        V1 = NULL;
00112	        
00113	{
00114	
00115	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00116	    {Py_XINCREF(py_V3);}
00117	    
00118	            V3 = NULL;
00119	            if (py_V3 == Py_None) {
00120	                // We can either fail here or set V3 to NULL and rely on Ops
00121	                // using tensors to handle the NULL case, but if they fail to do so
00122	                // they'll end up with nasty segfaults, so this is public service.
00123	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00124	                {
00125	        __failure = 4;
00126	        if (!PyErr_Occurred()) {
00127	            PyErr_SetString(PyExc_RuntimeError,
00128	                "Unexpected error in an Op's C code. "
00129	                "No Python exception was set.");
00130	            }
00131	        goto __label_4;}
00132	            }
00133	            if (!PyArray_Check(py_V3)) {
00134	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00135	                {
00136	        __failure = 4;
00137	        if (!PyErr_Occurred()) {
00138	            PyErr_SetString(PyExc_RuntimeError,
00139	                "Unexpected error in an Op's C code. "
00140	                "No Python exception was set.");
00141	            }
00142	        goto __label_4;}
00143	            }
00144	            // We expect NPY_FLOAT64
00145	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00146	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00147	                PyErr_Format(PyExc_NotImplementedError,
00148	                             "expected an aligned array of type %ld "
00149	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00150	                             " with %ld dimensions, with 3 last dims "
00151	                             "%ld, %ld, %ld"
00152	                             " and 3 last strides %ld %ld, %ld.",
00153	                             (long int) NPY_FLOAT64,
00154	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00155	                             (long int) PyArray_NDIM(tmp),
00156	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00157	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00158	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00159	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00160	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00161	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00162	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00163	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00164	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00165	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00166	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00167	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00168	            );
00169	                {
00170	        __failure = 4;
00171	        if (!PyErr_Occurred()) {
00172	            PyErr_SetString(PyExc_RuntimeError,
00173	                "Unexpected error in an Op's C code. "
00174	                "No Python exception was set.");
00175	            }
00176	        goto __label_4;}
00177	            }
00178	            // This is a TypeError to be consistent with DEBUG_MODE
00179	            // Note: DEBUG_MODE also tells the name of the container
00180	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00181	                PyErr_Format(PyExc_TypeError,
00182	                             "expected type_num %d (NPY_FLOAT64) got %d",
00183	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            
00194	        V3 = (PyArrayObject*)(py_V3);
00195	        Py_XINCREF(V3);
00196	        
00197	{
00198	
00199	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00200	    {Py_XINCREF(py_V5);}
00201	    
00202	            V5 = NULL;
00203	            if (py_V5 == Py_None) {
00204	                // We can either fail here or set V5 to NULL and rely on Ops
00205	                // using tensors to handle the NULL case, but if they fail to do so
00206	                // they'll end up with nasty segfaults, so this is public service.
00207	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00208	                {
00209	        __failure = 6;
00210	        if (!PyErr_Occurred()) {
00211	            PyErr_SetString(PyExc_RuntimeError,
00212	                "Unexpected error in an Op's C code. "
00213	                "No Python exception was set.");
00214	            }
00215	        goto __label_6;}
00216	            }
00217	            if (!PyArray_Check(py_V5)) {
00218	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00219	                {
00220	        __failure = 6;
00221	        if (!PyErr_Occurred()) {
00222	            PyErr_SetString(PyExc_RuntimeError,
00223	                "Unexpected error in an Op's C code. "
00224	                "No Python exception was set.");
00225	            }
00226	        goto __label_6;}
00227	            }
00228	            // We expect NPY_FLOAT64
00229	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00230	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00231	                PyErr_Format(PyExc_NotImplementedError,
00232	                             "expected an aligned array of type %ld "
00233	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00234	                             " with %ld dimensions, with 3 last dims "
00235	                             "%ld, %ld, %ld"
00236	                             " and 3 last strides %ld %ld, %ld.",
00237	                             (long int) NPY_FLOAT64,
00238	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00239	                             (long int) PyArray_NDIM(tmp),
00240	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00241	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00242	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00243	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00244	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00245	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00246	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00247	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00248	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00249	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00250	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00251	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00252	            );
00253	                {
00254	        __failure = 6;
00255	        if (!PyErr_Occurred()) {
00256	            PyErr_SetString(PyExc_RuntimeError,
00257	                "Unexpected error in an Op's C code. "
00258	                "No Python exception was set.");
00259	            }
00260	        goto __label_6;}
00261	            }
00262	            // This is a TypeError to be consistent with DEBUG_MODE
00263	            // Note: DEBUG_MODE also tells the name of the container
00264	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00265	                PyErr_Format(PyExc_TypeError,
00266	                             "expected type_num %d (NPY_FLOAT64) got %d",
00267	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00268	                {
00269	        __failure = 6;
00270	        if (!PyErr_Occurred()) {
00271	            PyErr_SetString(PyExc_RuntimeError,
00272	                "Unexpected error in an Op's C code. "
00273	                "No Python exception was set.");
00274	            }
00275	        goto __label_6;}
00276	            }
00277	            
00278	        V5 = (PyArrayObject*)(py_V5);
00279	        Py_XINCREF(V5);
00280	        
00281	{
00282	
00283	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00284	    {Py_XINCREF(py_V7);}
00285	    
00286	            V7 = NULL;
00287	            if (py_V7 == Py_None) {
00288	                // We can either fail here or set V7 to NULL and rely on Ops
00289	                // using tensors to handle the NULL case, but if they fail to do so
00290	                // they'll end up with nasty segfaults, so this is public service.
00291	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00292	                {
00293	        __failure = 8;
00294	        if (!PyErr_Occurred()) {
00295	            PyErr_SetString(PyExc_RuntimeError,
00296	                "Unexpected error in an Op's C code. "
00297	                "No Python exception was set.");
00298	            }
00299	        goto __label_8;}
00300	            }
00301	            if (!PyArray_Check(py_V7)) {
00302	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00303	                {
00304	        __failure = 8;
00305	        if (!PyErr_Occurred()) {
00306	            PyErr_SetString(PyExc_RuntimeError,
00307	                "Unexpected error in an Op's C code. "
00308	                "No Python exception was set.");
00309	            }
00310	        goto __label_8;}
00311	            }
00312	            // We expect NPY_FLOAT64
00313	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00314	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00315	                PyErr_Format(PyExc_NotImplementedError,
00316	                             "expected an aligned array of type %ld "
00317	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00318	                             " with %ld dimensions, with 3 last dims "
00319	                             "%ld, %ld, %ld"
00320	                             " and 3 last strides %ld %ld, %ld.",
00321	                             (long int) NPY_FLOAT64,
00322	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00323	                             (long int) PyArray_NDIM(tmp),
00324	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00325	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00326	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00327	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00328	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00329	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00330	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00331	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00332	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00333	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00334	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00335	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00336	            );
00337	                {
00338	        __failure = 8;
00339	        if (!PyErr_Occurred()) {
00340	            PyErr_SetString(PyExc_RuntimeError,
00341	                "Unexpected error in an Op's C code. "
00342	                "No Python exception was set.");
00343	            }
00344	        goto __label_8;}
00345	            }
00346	            // This is a TypeError to be consistent with DEBUG_MODE
00347	            // Note: DEBUG_MODE also tells the name of the container
00348	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00349	                PyErr_Format(PyExc_TypeError,
00350	                             "expected type_num %d (NPY_FLOAT64) got %d",
00351	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00352	                {
00353	        __failure = 8;
00354	        if (!PyErr_Occurred()) {
00355	            PyErr_SetString(PyExc_RuntimeError,
00356	                "Unexpected error in an Op's C code. "
00357	                "No Python exception was set.");
00358	            }
00359	        goto __label_8;}
00360	            }
00361	            
00362	        V7 = (PyArrayObject*)(py_V7);
00363	        Py_XINCREF(V7);
00364	        
00365	{
00366	// Op class Elemwise
00367	
00368	        npy_float64* V3_iter;
00369	        
00370	                npy_intp V3_n0;
00371	                ssize_t V3_stride0;
00372	                int V3_jump0_0;
00373	                
00374	                npy_intp V3_n1;
00375	                ssize_t V3_stride1;
00376	                int V3_jump1_1;
00377	                
00378	        npy_float64* V5_iter;
00379	        
00380	                npy_intp V5_n0;
00381	                ssize_t V5_stride0;
00382	                int V5_jump0_0;
00383	                
00384	                npy_intp V5_n1;
00385	                ssize_t V5_stride1;
00386	                int V5_jump1_1;
00387	                
00388	        npy_float64* V7_iter;
00389	        
00390	                npy_intp V7_n0;
00391	                ssize_t V7_stride0;
00392	                int V7_jump0_0;
00393	                
00394	                npy_intp V7_n1;
00395	                ssize_t V7_stride1;
00396	                int V7_jump1_1;
00397	                
00398	
00399	            if (PyArray_NDIM(V3) < 2) {
00400	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00401	                {
00402	        __failure = 9;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_9;}
00409	            }
00410	            
00411	                V3_n1 = PyArray_DIMS(V3)[1];
00412	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00413	                V3_jump1_1 = (V3_stride1) - (0);
00414	                //printf("V3_jump1_1 is:");
00415	                //std::cout << V3_jump1_1 << std::endl;
00416	                
00417	                V3_n0 = PyArray_DIMS(V3)[0];
00418	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00419	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00420	                //printf("V3_jump0_0 is:");
00421	                //std::cout << V3_jump0_0 << std::endl;
00422	                
00423	            if (PyArray_NDIM(V5) < 2) {
00424	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00425	                {
00426	        __failure = 9;
00427	        if (!PyErr_Occurred()) {
00428	            PyErr_SetString(PyExc_RuntimeError,
00429	                "Unexpected error in an Op's C code. "
00430	                "No Python exception was set.");
00431	            }
00432	        goto __label_9;}
00433	            }
00434	            
00435	                V5_n1 = PyArray_DIMS(V5)[1];
00436	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00437	                V5_jump1_1 = (V5_stride1) - (0);
00438	                //printf("V5_jump1_1 is:");
00439	                //std::cout << V5_jump1_1 << std::endl;
00440	                
00441	                V5_n0 = PyArray_DIMS(V5)[0];
00442	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00443	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00444	                //printf("V5_jump0_0 is:");
00445	                //std::cout << V5_jump0_0 << std::endl;
00446	                
00447	            if (PyArray_NDIM(V7) < 2) {
00448	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00449	                {
00450	        __failure = 9;
00451	        if (!PyErr_Occurred()) {
00452	            PyErr_SetString(PyExc_RuntimeError,
00453	                "Unexpected error in an Op's C code. "
00454	                "No Python exception was set.");
00455	            }
00456	        goto __label_9;}
00457	            }
00458	            
00459	                V7_n1 = PyArray_DIMS(V7)[1];
00460	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00461	                V7_jump1_1 = (V7_stride1) - (0);
00462	                //printf("V7_jump1_1 is:");
00463	                //std::cout << V7_jump1_1 << std::endl;
00464	                
00465	                V7_n0 = PyArray_DIMS(V7)[0];
00466	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00467	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00468	                //printf("V7_jump0_0 is:");
00469	                //std::cout << V7_jump0_0 << std::endl;
00470	                
00471	            if (V3_n0 != V5_n0)
00472	            {
00473	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00474	                   0,
00475	                   0,
00476	                   V3_n0,
00477	                   1,
00478	                   0,
00479	                   V5_n0
00480	                );
00481	                {
00482	        __failure = 9;
00483	        if (!PyErr_Occurred()) {
00484	            PyErr_SetString(PyExc_RuntimeError,
00485	                "Unexpected error in an Op's C code. "
00486	                "No Python exception was set.");
00487	            }
00488	        goto __label_9;}
00489	            }
00490	            
00491	            if (V3_n0 != V7_n0)
00492	            {
00493	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00494	                   0,
00495	                   0,
00496	                   V3_n0,
00497	                   2,
00498	                   0,
00499	                   V7_n0
00500	                );
00501	                {
00502	        __failure = 9;
00503	        if (!PyErr_Occurred()) {
00504	            PyErr_SetString(PyExc_RuntimeError,
00505	                "Unexpected error in an Op's C code. "
00506	                "No Python exception was set.");
00507	            }
00508	        goto __label_9;}
00509	            }
00510	            
00511	            if (V3_n1 != V5_n1)
00512	            {
00513	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00514	                   0,
00515	                   1,
00516	                   V3_n1,
00517	                   1,
00518	                   1,
00519	                   V5_n1
00520	                );
00521	                {
00522	        __failure = 9;
00523	        if (!PyErr_Occurred()) {
00524	            PyErr_SetString(PyExc_RuntimeError,
00525	                "Unexpected error in an Op's C code. "
00526	                "No Python exception was set.");
00527	            }
00528	        goto __label_9;}
00529	            }
00530	            
00531	            if (V3_n1 != V7_n1)
00532	            {
00533	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00534	                   0,
00535	                   1,
00536	                   V3_n1,
00537	                   2,
00538	                   1,
00539	                   V7_n1
00540	                );
00541	                {
00542	        __failure = 9;
00543	        if (!PyErr_Occurred()) {
00544	            PyErr_SetString(PyExc_RuntimeError,
00545	                "Unexpected error in an Op's C code. "
00546	                "No Python exception was set.");
00547	            }
00548	        goto __label_9;}
00549	            }
00550	            
00551	
00552	        npy_float64* V1_iter;
00553	        
00554	                npy_intp V1_n0;
00555	                ssize_t V1_stride0;
00556	                int V1_jump0_0;
00557	                
00558	                npy_intp V1_n1;
00559	                ssize_t V1_stride1;
00560	                int V1_jump1_1;
00561	                
00562	    {
00563	        npy_intp dims[2];
00564	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00565	        dims[0] = V3_n0;
00566	dims[1] = V3_n1;
00567	
00568	        if (!V1) {
00569	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00570	                                                    NPY_FLOAT64,
00571	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7));
00572	        }
00573	        else {
00574	            PyArray_Dims new_dims;
00575	            new_dims.len = 2;
00576	            new_dims.ptr = dims;
00577	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00578	            if (!success) {
00579	                // If we can't resize the ndarray we have we can allocate a new one.
00580	                PyErr_Clear();
00581	                Py_XDECREF(V1);
00582	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00583	            }
00584	        }
00585	        if (!V1) {
00586	            {
00587	        __failure = 9;
00588	        if (!PyErr_Occurred()) {
00589	            PyErr_SetString(PyExc_RuntimeError,
00590	                "Unexpected error in an Op's C code. "
00591	                "No Python exception was set.");
00592	            }
00593	        goto __label_9;}
00594	        }
00595	    }
00596	    
00597	            if (PyArray_NDIM(V1) < 2) {
00598	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00599	                {
00600	        __failure = 9;
00601	        if (!PyErr_Occurred()) {
00602	            PyErr_SetString(PyExc_RuntimeError,
00603	                "Unexpected error in an Op's C code. "
00604	                "No Python exception was set.");
00605	            }
00606	        goto __label_9;}
00607	            }
00608	            
00609	                V1_n1 = PyArray_DIMS(V1)[1];
00610	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00611	                V1_jump1_1 = (V1_stride1) - (0);
00612	                //printf("V1_jump1_1 is:");
00613	                //std::cout << V1_jump1_1 << std::endl;
00614	                
00615	                V1_n0 = PyArray_DIMS(V1)[0];
00616	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00617	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00618	                //printf("V1_jump0_0 is:");
00619	                //std::cout << V1_jump0_0 << std::endl;
00620	                
00621	
00622	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V1))){
00623	                
00624	                    // All output have the same size
00625	                    npy_intp n = PyArray_SIZE(V1);
00626	                    
00627	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00628	                            
00629	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00630	                            
00631	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00632	                            
00633	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00634	                            
00635	                    for(int i=0; i<n; i++){
00636	                        
00637	            dtype_V3& V3_i = V3_ptr[i];
00638	                            
00639	            dtype_V5& V5_i = V5_ptr[i];
00640	                            
00641	            dtype_V7& V7_i = V7_ptr[i];
00642	                            
00643	            dtype_V1& V1_i = V1_ptr[i];
00644	                            
00645	                        {
00646	npy_float64 V9_tmp1;
00647	V9_tmp1 = V5_i * V7_i;
00648	V1_i = V3_i + V9_tmp1;
00649	}
00650	;
00651	                    }
00652	                    
00653	            }else{
00654	                {
00655	
00656	    std::vector< std::pair<int, int> > V1_loops(2);
00657	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00658	    
00659	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00660	            
00661	        V1_loops_it->second = 0;
00662	        ++V1_loops_it;
00663	        
00664	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00665	            
00666	        V1_loops_it->second = 1;
00667	        ++V1_loops_it;
00668	        
00669	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00670	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00671	    
00672	
00673	    int init_totals[2] = {V3_n0, V3_n1};
00674	    
00675	    V1_loops_it = V1_loops.begin();
00676	    
00677	        int TOTAL_0 = init_totals[V1_loops_it->second];
00678	        ++V1_loops_it;
00679	        
00680	        int TOTAL_1 = init_totals[V1_loops_it->second];
00681	        ++V1_loops_it;
00682	        
00683	
00684	    int init_strides[4][2] = {
00685	        V3_stride0, V3_stride1, 
00686	V5_stride0, V5_stride1, 
00687	V7_stride0, V7_stride1, 
00688	V1_stride0, V1_stride1
00689	    };
00690	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00691	    
00692	        V1_loops_rit = V1_loops.rbegin();
00693	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00694	            ++V1_loops_rit;
00695	            
00696	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00697	            ++V1_loops_rit;
00698	            
00699	        V1_loops_rit = V1_loops.rbegin();
00700	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00701	            ++V1_loops_rit;
00702	            
00703	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00704	            ++V1_loops_rit;
00705	            
00706	        V1_loops_rit = V1_loops.rbegin();
00707	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00708	            ++V1_loops_rit;
00709	            
00710	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00711	            ++V1_loops_rit;
00712	            
00713	        V1_loops_rit = V1_loops.rbegin();
00714	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00715	            ++V1_loops_rit;
00716	            
00717	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00718	            ++V1_loops_rit;
00719	            
00720	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00721	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00722	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00723	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00724	
00725	
00726	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00727	        { // begin loop 0
00728	            
00729	            
00730	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00731	        { // begin loop 1
00732	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00733	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00734	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00735	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00736	
00737	            
00738	        {
00739	            
00740	            {
00741	npy_float64 V9_tmp1;
00742	V9_tmp1 = V5_i * V7_i;
00743	V1_i = V3_i + V9_tmp1;
00744	}
00745	
00746	            
00747	        }
00748	        
00749	        } // end loop 1
00750	        
00751	        } // end loop 0
00752	        
00753	}
00754	
00755	            }
00756	            __label_9:
00757	
00758	double __DUMMY_9;
00759	
00760	}
00761	__label_8:
00762	
00763	        if (V7) {
00764	            Py_XDECREF(V7);
00765	        }
00766	        
00767	    {Py_XDECREF(py_V7);}
00768	    
00769	double __DUMMY_8;
00770	
00771	}
00772	__label_6:
00773	
00774	        if (V5) {
00775	            Py_XDECREF(V5);
00776	        }
00777	        
00778	    {Py_XDECREF(py_V5);}
00779	    
00780	double __DUMMY_6;
00781	
00782	}
00783	__label_4:
00784	
00785	        if (V3) {
00786	            Py_XDECREF(V3);
00787	        }
00788	        
00789	    {Py_XDECREF(py_V3);}
00790	    
00791	double __DUMMY_4;
00792	
00793	}
00794	__label_2:
00795	
00796	    if (!__failure) {
00797	      
00798	        {Py_XDECREF(py_V1);}
00799	        if (!V1) {
00800	            Py_INCREF(Py_None);
00801	            py_V1 = Py_None;
00802	        }
00803	        else if ((void*)py_V1 != (void*)V1) {
00804	            py_V1 = (PyObject*)V1;
00805	        }
00806	
00807	        {Py_XINCREF(py_V1);}
00808	
00809	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00810	            PyErr_Format(PyExc_NotImplementedError,
00811	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00812	                         " with %ld dimensions, with 3 last dims "
00813	                         "%ld, %ld, %ld"
00814	                         " and 3 last strides %ld %ld, %ld.",
00815	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00816	                         (long int) PyArray_NDIM(V1),
00817	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00818	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00819	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00820	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00821	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00822	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00823	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00824	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00825	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00826	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00827	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00828	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00829	        );
00830	            {
00831	        __failure = 2;
00832	        if (!PyErr_Occurred()) {
00833	            PyErr_SetString(PyExc_RuntimeError,
00834	                "Unexpected error in an Op's C code. "
00835	                "No Python exception was set.");
00836	            }
00837	        goto __label_2;}
00838	        }
00839	        
00840	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00841	      {Py_XINCREF(py_V1);}
00842	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00843	      {Py_XDECREF(old);}
00844	    }
00845	    
00846	        if (V1) {
00847	            Py_XDECREF(V1);
00848	        }
00849	        
00850	    {Py_XDECREF(py_V1);}
00851	    
00852	double __DUMMY_2;
00853	
00854	}
00855	
00856	            
00857	        if (__failure) {
00858	            // When there is a failure, this code puts the exception
00859	            // in __ERROR.
00860	            PyObject* err_type = NULL;
00861	            PyObject* err_msg = NULL;
00862	            PyObject* err_traceback = NULL;
00863	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00864	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00865	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00866	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00867	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00868	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00869	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00870	            PyList_SET_ITEM(__ERROR, 0, err_type);
00871	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00872	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00873	            {Py_XDECREF(old_err_type);}
00874	            {Py_XDECREF(old_err_msg);}
00875	            {Py_XDECREF(old_err_traceback);}
00876	        }
00877	        // The failure code is returned to index what code block failed.
00878	        return __failure;
00879	        
00880	        }
00881	    };
00882	    }
00883	    
00884	
00885	        static int __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_executor(__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331* self) {
00886	            return self->run();
00887	        }
00888	
00889	        static void __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_destructor(void* executor, void* self) {
00890	            delete ((__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331*)self);
00891	        }
00892	        
00893	//////////////////////
00894	////  Functions
00895	//////////////////////
00896	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00897	  assert(PyTuple_Check(argtuple));
00898	  if (5 != PyTuple_Size(argtuple)){ 
00899	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
00900	     return NULL;
00901	  }
00902	  __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331* struct_ptr = new __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331();
00903	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
00904	    delete struct_ptr;
00905	    return NULL;
00906	  }
00907	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_executor), struct_ptr, __struct_compiled_op_b91887856157bcaaaf7e3d73e9cce331_destructor);
00908	  return thunk; }
00909	
00910	//////////////////////
00911	////  Module init
00912	//////////////////////
00913	static PyMethodDef MyMethods[] = {
00914		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00915		{NULL, NULL, 0, NULL}
00916	};
00917	PyMODINIT_FUNC initb91887856157bcaaaf7e3d73e9cce331(void){
00918	   import_array();
00919	   (void) Py_InitModule("b91887856157bcaaaf7e3d73e9cce331", MyMethods);
00920	}
00921	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpjf2NFZ/b91887856157bcaaaf7e3d73e9cce331.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpjf2NFZ/mod.cpp -lpython2.7
ERROR
test_straightforward_1 (theano.compile.tests.test_builders.T_OpFromGraph) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_d207601a572b1835a75f349e2a6426bd {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V1;
00021	        
00022	
00023	        __struct_compiled_op_d207601a572b1835a75f349e2a6426bd() {
00024	            // This is only somewhat safe because we:
00025	            //  1) Are not a virtual class
00026	            //  2) Do not use any virtual classes in the members
00027	            //  3) Deal with mostly POD and pointers
00028	
00029	            // If this changes, we would have to revise this, but for
00030	            // now I am tired of chasing segfaults because
00031	            // initialization code had an error and some pointer has
00032	            // a junk value.
00033	            memset(this, 0, sizeof(*this));
00034	        }
00035	        ~__struct_compiled_op_d207601a572b1835a75f349e2a6426bd(void) {
00036	            cleanup();
00037	        }
00038	
00039	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V1) {
00040	            Py_XINCREF(storage_V3);
00041	Py_XINCREF(storage_V5);
00042	Py_XINCREF(storage_V7);
00043	Py_XINCREF(storage_V1);
00044	            this->storage_V3 = storage_V3;
00045	this->storage_V5 = storage_V5;
00046	this->storage_V7 = storage_V7;
00047	this->storage_V1 = storage_V1;
00048	            
00049	
00050	
00051	
00052	
00053	
00054	            this->__ERROR = __ERROR;
00055	            return 0;
00056	        }
00057	        void cleanup(void) {
00058	            __label_1:
00059	
00060	double __DUMMY_1;
00061	__label_3:
00062	
00063	double __DUMMY_3;
00064	__label_5:
00065	
00066	double __DUMMY_5;
00067	__label_7:
00068	
00069	double __DUMMY_7;
00070	__label_10:
00071	
00072	double __DUMMY_10;
00073	
00074	            Py_XDECREF(this->storage_V3);
00075	Py_XDECREF(this->storage_V5);
00076	Py_XDECREF(this->storage_V7);
00077	Py_XDECREF(this->storage_V1);
00078	        }
00079	        int run(void) {
00080	            int __failure = 0;
00081	            
00082	    PyObject* py_V1;
00083	    
00084	        PyArrayObject* V1;
00085	        
00086	            typedef npy_float64 dtype_V1;
00087	            
00088	    PyObject* py_V3;
00089	    
00090	        PyArrayObject* V3;
00091	        
00092	            typedef npy_float64 dtype_V3;
00093	            
00094	    PyObject* py_V5;
00095	    
00096	        PyArrayObject* V5;
00097	        
00098	            typedef npy_float64 dtype_V5;
00099	            
00100	    PyObject* py_V7;
00101	    
00102	        PyArrayObject* V7;
00103	        
00104	            typedef npy_float64 dtype_V7;
00105	            
00106	{
00107	
00108	    py_V1 = Py_None;
00109	    {Py_XINCREF(py_V1);}
00110	    
00111	        V1 = NULL;
00112	        
00113	{
00114	
00115	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00116	    {Py_XINCREF(py_V3);}
00117	    
00118	            V3 = NULL;
00119	            if (py_V3 == Py_None) {
00120	                // We can either fail here or set V3 to NULL and rely on Ops
00121	                // using tensors to handle the NULL case, but if they fail to do so
00122	                // they'll end up with nasty segfaults, so this is public service.
00123	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00124	                {
00125	        __failure = 4;
00126	        if (!PyErr_Occurred()) {
00127	            PyErr_SetString(PyExc_RuntimeError,
00128	                "Unexpected error in an Op's C code. "
00129	                "No Python exception was set.");
00130	            }
00131	        goto __label_4;}
00132	            }
00133	            if (!PyArray_Check(py_V3)) {
00134	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00135	                {
00136	        __failure = 4;
00137	        if (!PyErr_Occurred()) {
00138	            PyErr_SetString(PyExc_RuntimeError,
00139	                "Unexpected error in an Op's C code. "
00140	                "No Python exception was set.");
00141	            }
00142	        goto __label_4;}
00143	            }
00144	            // We expect NPY_FLOAT64
00145	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00146	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00147	                PyErr_Format(PyExc_NotImplementedError,
00148	                             "expected an aligned array of type %ld "
00149	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00150	                             " with %ld dimensions, with 3 last dims "
00151	                             "%ld, %ld, %ld"
00152	                             " and 3 last strides %ld %ld, %ld.",
00153	                             (long int) NPY_FLOAT64,
00154	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00155	                             (long int) PyArray_NDIM(tmp),
00156	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00157	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00158	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00159	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00160	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00161	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00162	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00163	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00164	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00165	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00166	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00167	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00168	            );
00169	                {
00170	        __failure = 4;
00171	        if (!PyErr_Occurred()) {
00172	            PyErr_SetString(PyExc_RuntimeError,
00173	                "Unexpected error in an Op's C code. "
00174	                "No Python exception was set.");
00175	            }
00176	        goto __label_4;}
00177	            }
00178	            // This is a TypeError to be consistent with DEBUG_MODE
00179	            // Note: DEBUG_MODE also tells the name of the container
00180	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00181	                PyErr_Format(PyExc_TypeError,
00182	                             "expected type_num %d (NPY_FLOAT64) got %d",
00183	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            
00194	        V3 = (PyArrayObject*)(py_V3);
00195	        Py_XINCREF(V3);
00196	        
00197	{
00198	
00199	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00200	    {Py_XINCREF(py_V5);}
00201	    
00202	            V5 = NULL;
00203	            if (py_V5 == Py_None) {
00204	                // We can either fail here or set V5 to NULL and rely on Ops
00205	                // using tensors to handle the NULL case, but if they fail to do so
00206	                // they'll end up with nasty segfaults, so this is public service.
00207	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00208	                {
00209	        __failure = 6;
00210	        if (!PyErr_Occurred()) {
00211	            PyErr_SetString(PyExc_RuntimeError,
00212	                "Unexpected error in an Op's C code. "
00213	                "No Python exception was set.");
00214	            }
00215	        goto __label_6;}
00216	            }
00217	            if (!PyArray_Check(py_V5)) {
00218	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00219	                {
00220	        __failure = 6;
00221	        if (!PyErr_Occurred()) {
00222	            PyErr_SetString(PyExc_RuntimeError,
00223	                "Unexpected error in an Op's C code. "
00224	                "No Python exception was set.");
00225	            }
00226	        goto __label_6;}
00227	            }
00228	            // We expect NPY_FLOAT64
00229	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00230	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00231	                PyErr_Format(PyExc_NotImplementedError,
00232	                             "expected an aligned array of type %ld "
00233	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00234	                             " with %ld dimensions, with 3 last dims "
00235	                             "%ld, %ld, %ld"
00236	                             " and 3 last strides %ld %ld, %ld.",
00237	                             (long int) NPY_FLOAT64,
00238	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00239	                             (long int) PyArray_NDIM(tmp),
00240	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00241	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00242	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00243	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00244	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00245	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00246	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00247	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00248	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00249	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00250	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00251	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00252	            );
00253	                {
00254	        __failure = 6;
00255	        if (!PyErr_Occurred()) {
00256	            PyErr_SetString(PyExc_RuntimeError,
00257	                "Unexpected error in an Op's C code. "
00258	                "No Python exception was set.");
00259	            }
00260	        goto __label_6;}
00261	            }
00262	            // This is a TypeError to be consistent with DEBUG_MODE
00263	            // Note: DEBUG_MODE also tells the name of the container
00264	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00265	                PyErr_Format(PyExc_TypeError,
00266	                             "expected type_num %d (NPY_FLOAT64) got %d",
00267	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00268	                {
00269	        __failure = 6;
00270	        if (!PyErr_Occurred()) {
00271	            PyErr_SetString(PyExc_RuntimeError,
00272	                "Unexpected error in an Op's C code. "
00273	                "No Python exception was set.");
00274	            }
00275	        goto __label_6;}
00276	            }
00277	            
00278	        V5 = (PyArrayObject*)(py_V5);
00279	        Py_XINCREF(V5);
00280	        
00281	{
00282	
00283	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00284	    {Py_XINCREF(py_V7);}
00285	    
00286	            V7 = NULL;
00287	            if (py_V7 == Py_None) {
00288	                // We can either fail here or set V7 to NULL and rely on Ops
00289	                // using tensors to handle the NULL case, but if they fail to do so
00290	                // they'll end up with nasty segfaults, so this is public service.
00291	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00292	                {
00293	        __failure = 8;
00294	        if (!PyErr_Occurred()) {
00295	            PyErr_SetString(PyExc_RuntimeError,
00296	                "Unexpected error in an Op's C code. "
00297	                "No Python exception was set.");
00298	            }
00299	        goto __label_8;}
00300	            }
00301	            if (!PyArray_Check(py_V7)) {
00302	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00303	                {
00304	        __failure = 8;
00305	        if (!PyErr_Occurred()) {
00306	            PyErr_SetString(PyExc_RuntimeError,
00307	                "Unexpected error in an Op's C code. "
00308	                "No Python exception was set.");
00309	            }
00310	        goto __label_8;}
00311	            }
00312	            // We expect NPY_FLOAT64
00313	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00314	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00315	                PyErr_Format(PyExc_NotImplementedError,
00316	                             "expected an aligned array of type %ld "
00317	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00318	                             " with %ld dimensions, with 3 last dims "
00319	                             "%ld, %ld, %ld"
00320	                             " and 3 last strides %ld %ld, %ld.",
00321	                             (long int) NPY_FLOAT64,
00322	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00323	                             (long int) PyArray_NDIM(tmp),
00324	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00325	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00326	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00327	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00328	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00329	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00330	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00331	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00332	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00333	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00334	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00335	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00336	            );
00337	                {
00338	        __failure = 8;
00339	        if (!PyErr_Occurred()) {
00340	            PyErr_SetString(PyExc_RuntimeError,
00341	                "Unexpected error in an Op's C code. "
00342	                "No Python exception was set.");
00343	            }
00344	        goto __label_8;}
00345	            }
00346	            // This is a TypeError to be consistent with DEBUG_MODE
00347	            // Note: DEBUG_MODE also tells the name of the container
00348	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00349	                PyErr_Format(PyExc_TypeError,
00350	                             "expected type_num %d (NPY_FLOAT64) got %d",
00351	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00352	                {
00353	        __failure = 8;
00354	        if (!PyErr_Occurred()) {
00355	            PyErr_SetString(PyExc_RuntimeError,
00356	                "Unexpected error in an Op's C code. "
00357	                "No Python exception was set.");
00358	            }
00359	        goto __label_8;}
00360	            }
00361	            
00362	        V7 = (PyArrayObject*)(py_V7);
00363	        Py_XINCREF(V7);
00364	        
00365	{
00366	// Op class Elemwise
00367	
00368	        npy_float64* V3_iter;
00369	        
00370	                npy_intp V3_n0;
00371	                ssize_t V3_stride0;
00372	                int V3_jump0_0;
00373	                
00374	                npy_intp V3_n1;
00375	                ssize_t V3_stride1;
00376	                int V3_jump1_1;
00377	                
00378	        npy_float64* V5_iter;
00379	        
00380	                npy_intp V5_n0;
00381	                ssize_t V5_stride0;
00382	                int V5_jump0_0;
00383	                
00384	                npy_intp V5_n1;
00385	                ssize_t V5_stride1;
00386	                int V5_jump1_1;
00387	                
00388	        npy_float64* V7_iter;
00389	        
00390	                npy_intp V7_n0;
00391	                ssize_t V7_stride0;
00392	                int V7_jump0_0;
00393	                
00394	                npy_intp V7_n1;
00395	                ssize_t V7_stride1;
00396	                int V7_jump1_1;
00397	                
00398	
00399	            if (PyArray_NDIM(V3) < 2) {
00400	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00401	                {
00402	        __failure = 9;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_9;}
00409	            }
00410	            
00411	                V3_n1 = PyArray_DIMS(V3)[1];
00412	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00413	                V3_jump1_1 = (V3_stride1) - (0);
00414	                //printf("V3_jump1_1 is:");
00415	                //std::cout << V3_jump1_1 << std::endl;
00416	                
00417	                V3_n0 = PyArray_DIMS(V3)[0];
00418	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00419	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00420	                //printf("V3_jump0_0 is:");
00421	                //std::cout << V3_jump0_0 << std::endl;
00422	                
00423	            if (PyArray_NDIM(V5) < 2) {
00424	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00425	                {
00426	        __failure = 9;
00427	        if (!PyErr_Occurred()) {
00428	            PyErr_SetString(PyExc_RuntimeError,
00429	                "Unexpected error in an Op's C code. "
00430	                "No Python exception was set.");
00431	            }
00432	        goto __label_9;}
00433	            }
00434	            
00435	                V5_n1 = PyArray_DIMS(V5)[1];
00436	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00437	                V5_jump1_1 = (V5_stride1) - (0);
00438	                //printf("V5_jump1_1 is:");
00439	                //std::cout << V5_jump1_1 << std::endl;
00440	                
00441	                V5_n0 = PyArray_DIMS(V5)[0];
00442	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00443	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00444	                //printf("V5_jump0_0 is:");
00445	                //std::cout << V5_jump0_0 << std::endl;
00446	                
00447	            if (PyArray_NDIM(V7) < 2) {
00448	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00449	                {
00450	        __failure = 9;
00451	        if (!PyErr_Occurred()) {
00452	            PyErr_SetString(PyExc_RuntimeError,
00453	                "Unexpected error in an Op's C code. "
00454	                "No Python exception was set.");
00455	            }
00456	        goto __label_9;}
00457	            }
00458	            
00459	                V7_n1 = PyArray_DIMS(V7)[1];
00460	                V7_stride1 = PyArray_STRIDES(V7)[1] / sizeof(npy_float64);
00461	                V7_jump1_1 = (V7_stride1) - (0);
00462	                //printf("V7_jump1_1 is:");
00463	                //std::cout << V7_jump1_1 << std::endl;
00464	                
00465	                V7_n0 = PyArray_DIMS(V7)[0];
00466	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00467	                V7_jump0_0 = (V7_stride0) - (V7_n1*V7_stride1);
00468	                //printf("V7_jump0_0 is:");
00469	                //std::cout << V7_jump0_0 << std::endl;
00470	                
00471	            if (V3_n0 != V5_n0)
00472	            {
00473	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00474	                   0,
00475	                   0,
00476	                   V3_n0,
00477	                   1,
00478	                   0,
00479	                   V5_n0
00480	                );
00481	                {
00482	        __failure = 9;
00483	        if (!PyErr_Occurred()) {
00484	            PyErr_SetString(PyExc_RuntimeError,
00485	                "Unexpected error in an Op's C code. "
00486	                "No Python exception was set.");
00487	            }
00488	        goto __label_9;}
00489	            }
00490	            
00491	            if (V3_n0 != V7_n0)
00492	            {
00493	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00494	                   0,
00495	                   0,
00496	                   V3_n0,
00497	                   2,
00498	                   0,
00499	                   V7_n0
00500	                );
00501	                {
00502	        __failure = 9;
00503	        if (!PyErr_Occurred()) {
00504	            PyErr_SetString(PyExc_RuntimeError,
00505	                "Unexpected error in an Op's C code. "
00506	                "No Python exception was set.");
00507	            }
00508	        goto __label_9;}
00509	            }
00510	            
00511	            if (V3_n1 != V5_n1)
00512	            {
00513	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00514	                   0,
00515	                   1,
00516	                   V3_n1,
00517	                   1,
00518	                   1,
00519	                   V5_n1
00520	                );
00521	                {
00522	        __failure = 9;
00523	        if (!PyErr_Occurred()) {
00524	            PyErr_SetString(PyExc_RuntimeError,
00525	                "Unexpected error in an Op's C code. "
00526	                "No Python exception was set.");
00527	            }
00528	        goto __label_9;}
00529	            }
00530	            
00531	            if (V3_n1 != V7_n1)
00532	            {
00533	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00534	                   0,
00535	                   1,
00536	                   V3_n1,
00537	                   2,
00538	                   1,
00539	                   V7_n1
00540	                );
00541	                {
00542	        __failure = 9;
00543	        if (!PyErr_Occurred()) {
00544	            PyErr_SetString(PyExc_RuntimeError,
00545	                "Unexpected error in an Op's C code. "
00546	                "No Python exception was set.");
00547	            }
00548	        goto __label_9;}
00549	            }
00550	            
00551	
00552	        npy_float64* V1_iter;
00553	        
00554	                npy_intp V1_n0;
00555	                ssize_t V1_stride0;
00556	                int V1_jump0_0;
00557	                
00558	                npy_intp V1_n1;
00559	                ssize_t V1_stride1;
00560	                int V1_jump1_1;
00561	                
00562	    {
00563	        npy_intp dims[2];
00564	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00565	        dims[0] = V3_n0;
00566	dims[1] = V3_n1;
00567	
00568	        if (!V1) {
00569	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00570	                                                    NPY_FLOAT64,
00571	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7));
00572	        }
00573	        else {
00574	            PyArray_Dims new_dims;
00575	            new_dims.len = 2;
00576	            new_dims.ptr = dims;
00577	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00578	            if (!success) {
00579	                // If we can't resize the ndarray we have we can allocate a new one.
00580	                PyErr_Clear();
00581	                Py_XDECREF(V1);
00582	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00583	            }
00584	        }
00585	        if (!V1) {
00586	            {
00587	        __failure = 9;
00588	        if (!PyErr_Occurred()) {
00589	            PyErr_SetString(PyExc_RuntimeError,
00590	                "Unexpected error in an Op's C code. "
00591	                "No Python exception was set.");
00592	            }
00593	        goto __label_9;}
00594	        }
00595	    }
00596	    
00597	            if (PyArray_NDIM(V1) < 2) {
00598	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00599	                {
00600	        __failure = 9;
00601	        if (!PyErr_Occurred()) {
00602	            PyErr_SetString(PyExc_RuntimeError,
00603	                "Unexpected error in an Op's C code. "
00604	                "No Python exception was set.");
00605	            }
00606	        goto __label_9;}
00607	            }
00608	            
00609	                V1_n1 = PyArray_DIMS(V1)[1];
00610	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00611	                V1_jump1_1 = (V1_stride1) - (0);
00612	                //printf("V1_jump1_1 is:");
00613	                //std::cout << V1_jump1_1 << std::endl;
00614	                
00615	                V1_n0 = PyArray_DIMS(V1)[0];
00616	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00617	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00618	                //printf("V1_jump0_0 is:");
00619	                //std::cout << V1_jump0_0 << std::endl;
00620	                
00621	
00622	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V7) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V7) && PyArray_ISFORTRAN(V1))){
00623	                
00624	                    // All output have the same size
00625	                    npy_intp n = PyArray_SIZE(V1);
00626	                    
00627	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00628	                            
00629	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00630	                            
00631	            dtype_V7 * V7_ptr = (dtype_V7*) PyArray_DATA(V7);
00632	                            
00633	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00634	                            
00635	                    for(int i=0; i<n; i++){
00636	                        
00637	            dtype_V3& V3_i = V3_ptr[i];
00638	                            
00639	            dtype_V5& V5_i = V5_ptr[i];
00640	                            
00641	            dtype_V7& V7_i = V7_ptr[i];
00642	                            
00643	            dtype_V1& V1_i = V1_ptr[i];
00644	                            
00645	                        {
00646	npy_float64 V9_tmp1;
00647	V9_tmp1 = V7_i * V3_i;
00648	npy_float64 V9_tmp2;
00649	V9_tmp2 = V5_i * V7_i;
00650	npy_float64 V9_tmp3;
00651	V9_tmp3 = V5_i + V9_tmp1;
00652	npy_float64 V9_tmp4;
00653	V9_tmp4 = V3_i + V9_tmp2;
00654	V1_i = V9_tmp4 - V9_tmp3;
00655	}
00656	;
00657	                    }
00658	                    
00659	            }else{
00660	                {
00661	
00662	    std::vector< std::pair<int, int> > V1_loops(2);
00663	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00664	    
00665	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00666	            
00667	        V1_loops_it->second = 0;
00668	        ++V1_loops_it;
00669	        
00670	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00671	            
00672	        V1_loops_it->second = 1;
00673	        ++V1_loops_it;
00674	        
00675	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00676	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00677	    
00678	
00679	    int init_totals[2] = {V3_n0, V3_n1};
00680	    
00681	    V1_loops_it = V1_loops.begin();
00682	    
00683	        int TOTAL_0 = init_totals[V1_loops_it->second];
00684	        ++V1_loops_it;
00685	        
00686	        int TOTAL_1 = init_totals[V1_loops_it->second];
00687	        ++V1_loops_it;
00688	        
00689	
00690	    int init_strides[4][2] = {
00691	        V3_stride0, V3_stride1, 
00692	V5_stride0, V5_stride1, 
00693	V7_stride0, V7_stride1, 
00694	V1_stride0, V1_stride1
00695	    };
00696	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00697	    
00698	        V1_loops_rit = V1_loops.rbegin();
00699	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00700	            ++V1_loops_rit;
00701	            
00702	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00703	            ++V1_loops_rit;
00704	            
00705	        V1_loops_rit = V1_loops.rbegin();
00706	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00707	            ++V1_loops_rit;
00708	            
00709	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00710	            ++V1_loops_rit;
00711	            
00712	        V1_loops_rit = V1_loops.rbegin();
00713	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00714	            ++V1_loops_rit;
00715	            
00716	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00717	            ++V1_loops_rit;
00718	            
00719	        V1_loops_rit = V1_loops.rbegin();
00720	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00721	            ++V1_loops_rit;
00722	            
00723	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00724	            ++V1_loops_rit;
00725	            
00726	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00727	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00728	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00729	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00730	
00731	
00732	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00733	        { // begin loop 0
00734	            
00735	            
00736	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00737	        { // begin loop 1
00738	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00739	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00740	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00741	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00742	
00743	            
00744	        {
00745	            
00746	            {
00747	npy_float64 V9_tmp1;
00748	V9_tmp1 = V7_i * V3_i;
00749	npy_float64 V9_tmp2;
00750	V9_tmp2 = V5_i * V7_i;
00751	npy_float64 V9_tmp3;
00752	V9_tmp3 = V5_i + V9_tmp1;
00753	npy_float64 V9_tmp4;
00754	V9_tmp4 = V3_i + V9_tmp2;
00755	V1_i = V9_tmp4 - V9_tmp3;
00756	}
00757	
00758	            
00759	        }
00760	        
00761	        } // end loop 1
00762	        
00763	        } // end loop 0
00764	        
00765	}
00766	
00767	            }
00768	            __label_9:
00769	
00770	double __DUMMY_9;
00771	
00772	}
00773	__label_8:
00774	
00775	        if (V7) {
00776	            Py_XDECREF(V7);
00777	        }
00778	        
00779	    {Py_XDECREF(py_V7);}
00780	    
00781	double __DUMMY_8;
00782	
00783	}
00784	__label_6:
00785	
00786	        if (V5) {
00787	            Py_XDECREF(V5);
00788	        }
00789	        
00790	    {Py_XDECREF(py_V5);}
00791	    
00792	double __DUMMY_6;
00793	
00794	}
00795	__label_4:
00796	
00797	        if (V3) {
00798	            Py_XDECREF(V3);
00799	        }
00800	        
00801	    {Py_XDECREF(py_V3);}
00802	    
00803	double __DUMMY_4;
00804	
00805	}
00806	__label_2:
00807	
00808	    if (!__failure) {
00809	      
00810	        {Py_XDECREF(py_V1);}
00811	        if (!V1) {
00812	            Py_INCREF(Py_None);
00813	            py_V1 = Py_None;
00814	        }
00815	        else if ((void*)py_V1 != (void*)V1) {
00816	            py_V1 = (PyObject*)V1;
00817	        }
00818	
00819	        {Py_XINCREF(py_V1);}
00820	
00821	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00822	            PyErr_Format(PyExc_NotImplementedError,
00823	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00824	                         " with %ld dimensions, with 3 last dims "
00825	                         "%ld, %ld, %ld"
00826	                         " and 3 last strides %ld %ld, %ld.",
00827	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00828	                         (long int) PyArray_NDIM(V1),
00829	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00830	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00831	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00832	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00833	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00834	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00835	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00836	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00837	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00838	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00839	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00840	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00841	        );
00842	            {
00843	        __failure = 2;
00844	        if (!PyErr_Occurred()) {
00845	            PyErr_SetString(PyExc_RuntimeError,
00846	                "Unexpected error in an Op's C code. "
00847	                "No Python exception was set.");
00848	            }
00849	        goto __label_2;}
00850	        }
00851	        
00852	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00853	      {Py_XINCREF(py_V1);}
00854	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00855	      {Py_XDECREF(old);}
00856	    }
00857	    
00858	        if (V1) {
00859	            Py_XDECREF(V1);
00860	        }
00861	        
00862	    {Py_XDECREF(py_V1);}
00863	    
00864	double __DUMMY_2;
00865	
00866	}
00867	
00868	            
00869	        if (__failure) {
00870	            // When there is a failure, this code puts the exception
00871	            // in __ERROR.
00872	            PyObject* err_type = NULL;
00873	            PyObject* err_msg = NULL;
00874	            PyObject* err_traceback = NULL;
00875	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00876	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00877	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00878	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00879	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00880	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00881	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00882	            PyList_SET_ITEM(__ERROR, 0, err_type);
00883	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00884	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00885	            {Py_XDECREF(old_err_type);}
00886	            {Py_XDECREF(old_err_msg);}
00887	            {Py_XDECREF(old_err_traceback);}
00888	        }
00889	        // The failure code is returned to index what code block failed.
00890	        return __failure;
00891	        
00892	        }
00893	    };
00894	    }
00895	    
00896	
00897	        static int __struct_compiled_op_d207601a572b1835a75f349e2a6426bd_executor(__struct_compiled_op_d207601a572b1835a75f349e2a6426bd* self) {
00898	            return self->run();
00899	        }
00900	
00901	        static void __struct_compiled_op_d207601a572b1835a75f349e2a6426bd_destructor(void* executor, void* self) {
00902	            delete ((__struct_compiled_op_d207601a572b1835a75f349e2a6426bd*)self);
00903	        }
00904	        
00905	//////////////////////
00906	////  Functions
00907	//////////////////////
00908	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00909	  assert(PyTuple_Check(argtuple));
00910	  if (5 != PyTuple_Size(argtuple)){ 
00911	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
00912	     return NULL;
00913	  }
00914	  __struct_compiled_op_d207601a572b1835a75f349e2a6426bd* struct_ptr = new __struct_compiled_op_d207601a572b1835a75f349e2a6426bd();
00915	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
00916	    delete struct_ptr;
00917	    return NULL;
00918	  }
00919	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_d207601a572b1835a75f349e2a6426bd_executor), struct_ptr, __struct_compiled_op_d207601a572b1835a75f349e2a6426bd_destructor);
00920	  return thunk; }
00921	
00922	//////////////////////
00923	////  Module init
00924	//////////////////////
00925	static PyMethodDef MyMethods[] = {
00926		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00927		{NULL, NULL, 0, NULL}
00928	};
00929	PyMODINIT_FUNC initd207601a572b1835a75f349e2a6426bd(void){
00930	   import_array();
00931	   (void) Py_InitModule("d207601a572b1835a75f349e2a6426bd", MyMethods);
00932	}
00933	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmplkoIvK/d207601a572b1835a75f349e2a6426bd.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmplkoIvK/mod.cpp -lpython2.7
ERROR
test_aliased_outputs_bad (theano.compile.tests.test_debugmode.Test_ViewMap) ... ok
test_aliased_outputs_ok (theano.compile.tests.test_debugmode.Test_ViewMap) ... ok
test_aliased_outputs_ok_output (theano.compile.tests.test_debugmode.Test_ViewMap) ... ok
test_aliased_outputs_ok_shadow (theano.compile.tests.test_debugmode.Test_ViewMap) ... ok
test_badviewmap_c (theano.compile.tests.test_debugmode.Test_ViewMap) ... ok
test_badviewmap_ref (theano.compile.tests.test_debugmode.Test_ViewMap) ... ok
test_badviewmap_slice (theano.compile.tests.test_debugmode.Test_ViewMap) ... ok
test_goodviewmap (theano.compile.tests.test_debugmode.Test_ViewMap) ... ok
test_check_isfinite (theano.compile.tests.test_debugmode.Test_check_isfinite) ... ok
test_check_isfinite_disabled (theano.compile.tests.test_debugmode.Test_check_isfinite) ... ok
test_f_contiguous (theano.compile.tests.test_debugmode.Test_preallocated_output) ... ok
test_f_contiguous_out (theano.compile.tests.test_debugmode.Test_preallocated_output) ... ok
test_output_broadcast_cuda (theano.compile.tests.test_debugmode.Test_preallocated_output) ... SKIP: Optional package Cuda disabled
test_output_broadcast_tensor (theano.compile.tests.test_debugmode.Test_preallocated_output) ... ok
theano.compile.tests.test_debugmode.test0 ... ok
theano.compile.tests.test_debugmode.test_badthunkoutput ... ok
theano.compile.tests.test_debugmode.test_badoptimization ... ok
This variant of test_badoptimization() replace the working code ... ok
theano.compile.tests.test_debugmode.test_stochasticoptimization ... ok
theano.compile.tests.test_debugmode.test_just_c_code ... ok
theano.compile.tests.test_debugmode.test_baddestroymap ... ok
theano.compile.tests.test_debugmode.test_baddestroymap_c ... ok
test_explicit_shared_input (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_allow_downcast_floatX (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_allow_downcast_int (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_allow_downcast_vector_floatX (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_mutable (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_shared_variable (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_strict (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_update (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_update_shared (theano.compile.tests.test_function.TestFunctionIn) ... ok
test_in_update_wrong_dtype (theano.compile.tests.test_function.TestFunctionIn) ... ok
theano.compile.tests.test_function.test_function_dump ... ok
Tests that the contract for io.In is respected. When borrow=False, it should be ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_bd42ac06567dd948b69fbe988247ea66(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                int V3_jumpx_0;
00361	                
00362	                int V3_jumpx_1;
00363	                
00364	        npy_float64* V5_iter;
00365	        
00366	                npy_intp V5_n0;
00367	                ssize_t V5_stride0;
00368	                int V5_jump0_0;
00369	                
00370	                npy_intp V5_n1;
00371	                ssize_t V5_stride1;
00372	                int V5_jump1_1;
00373	                
00374	
00375	                V3_jumpx_1 = -(0);
00376	                //printf("V3_jumpx_1 is:");
00377	                //std::cout << V3_jumpx_1 << std::endl;
00378	                
00379	                V3_jumpx_0 = -(0);
00380	                //printf("V3_jumpx_0 is:");
00381	                //std::cout << V3_jumpx_0 << std::endl;
00382	                
00383	            if (PyArray_NDIM(V5) < 2) {
00384	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00385	                {
00386	        __failure = 7;
00387	        if (!PyErr_Occurred()) {
00388	            PyErr_SetString(PyExc_RuntimeError,
00389	                "Unexpected error in an Op's C code. "
00390	                "No Python exception was set.");
00391	            }
00392	        goto __label_7;}
00393	            }
00394	            
00395	                V5_n1 = PyArray_DIMS(V5)[1];
00396	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00397	                V5_jump1_1 = (V5_stride1) - (0);
00398	                //printf("V5_jump1_1 is:");
00399	                //std::cout << V5_jump1_1 << std::endl;
00400	                
00401	                V5_n0 = PyArray_DIMS(V5)[0];
00402	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00403	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00404	                //printf("V5_jump0_0 is:");
00405	                //std::cout << V5_jump0_0 << std::endl;
00406	                
00407	
00408	        npy_float64* V1_iter;
00409	        
00410	                npy_intp V1_n0;
00411	                ssize_t V1_stride0;
00412	                int V1_jump0_0;
00413	                
00414	                npy_intp V1_n1;
00415	                ssize_t V1_stride1;
00416	                int V1_jump1_1;
00417	                
00418	    {
00419	        npy_intp dims[2];
00420	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00421	        dims[0] = V5_n0;
00422	dims[1] = V5_n1;
00423	
00424	        if (!V1) {
00425	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00426	                                                    NPY_FLOAT64,
00427	                                                    PyArray_ISFORTRAN(V5));
00428	        }
00429	        else {
00430	            PyArray_Dims new_dims;
00431	            new_dims.len = 2;
00432	            new_dims.ptr = dims;
00433	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00434	            if (!success) {
00435	                // If we can't resize the ndarray we have we can allocate a new one.
00436	                PyErr_Clear();
00437	                Py_XDECREF(V1);
00438	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00439	            }
00440	        }
00441	        if (!V1) {
00442	            {
00443	        __failure = 7;
00444	        if (!PyErr_Occurred()) {
00445	            PyErr_SetString(PyExc_RuntimeError,
00446	                "Unexpected error in an Op's C code. "
00447	                "No Python exception was set.");
00448	            }
00449	        goto __label_7;}
00450	        }
00451	    }
00452	    
00453	            if (PyArray_NDIM(V1) < 2) {
00454	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00455	                {
00456	        __failure = 7;
00457	        if (!PyErr_Occurred()) {
00458	            PyErr_SetString(PyExc_RuntimeError,
00459	                "Unexpected error in an Op's C code. "
00460	                "No Python exception was set.");
00461	            }
00462	        goto __label_7;}
00463	            }
00464	            
00465	                V1_n1 = PyArray_DIMS(V1)[1];
00466	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00467	                V1_jump1_1 = (V1_stride1) - (0);
00468	                //printf("V1_jump1_1 is:");
00469	                //std::cout << V1_jump1_1 << std::endl;
00470	                
00471	                V1_n0 = PyArray_DIMS(V1)[0];
00472	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00473	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00474	                //printf("V1_jump0_0 is:");
00475	                //std::cout << V1_jump0_0 << std::endl;
00476	                
00477	
00478	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00479	                
00480	                    // All output have the same size
00481	                    npy_intp n = PyArray_SIZE(V1);
00482	                    
00483	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00484	                            
00485	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00486	                            
00487	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00488	                            
00489	                    for(int i=0; i<n; i++){
00490	                        
00491	            dtype_V5& V5_i = V5_ptr[i];
00492	                            
00493	            dtype_V1& V1_i = V1_ptr[i];
00494	                            
00495	                        V1_i = V3_i + V5_i;;
00496	                    }
00497	                    
00498	            }else{
00499	                {
00500	
00501	    std::vector< std::pair<int, int> > V1_loops(2);
00502	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00503	    
00504	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00505	            
00506	        V1_loops_it->second = 0;
00507	        ++V1_loops_it;
00508	        
00509	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00510	            
00511	        V1_loops_it->second = 1;
00512	        ++V1_loops_it;
00513	        
00514	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00515	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00516	    
00517	
00518	    int init_totals[2] = {V5_n0, V5_n1};
00519	    
00520	    V1_loops_it = V1_loops.begin();
00521	    
00522	        int TOTAL_0 = init_totals[V1_loops_it->second];
00523	        ++V1_loops_it;
00524	        
00525	        int TOTAL_1 = init_totals[V1_loops_it->second];
00526	        ++V1_loops_it;
00527	        
00528	
00529	    int init_strides[3][2] = {
00530	        0, 0, 
00531	V5_stride0, V5_stride1, 
00532	V1_stride0, V1_stride1
00533	    };
00534	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00535	    
00536	        V1_loops_rit = V1_loops.rbegin();
00537	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00538	            ++V1_loops_rit;
00539	            
00540	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00541	            ++V1_loops_rit;
00542	            
00543	        V1_loops_rit = V1_loops.rbegin();
00544	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00545	            ++V1_loops_rit;
00546	            
00547	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00548	            ++V1_loops_rit;
00549	            
00550	        V1_loops_rit = V1_loops.rbegin();
00551	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00552	            ++V1_loops_rit;
00553	            
00554	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00555	            ++V1_loops_rit;
00556	            
00557	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00558	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00559	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00560	
00561	
00562	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00563	        { // begin loop 0
00564	            
00565	            
00566	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00567	        { // begin loop 1
00568	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00569	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00570	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00571	
00572	            
00573	        {
00574	            
00575	            V1_i = V3_i + V5_i;
00576	            
00577	        }
00578	        
00579	        } // end loop 1
00580	        
00581	        } // end loop 0
00582	        
00583	}
00584	
00585	            }
00586	            __label_7:
00587	
00588	double __DUMMY_7;
00589	
00590	}
00591	__label_6:
00592	
00593	        if (V5) {
00594	            Py_XDECREF(V5);
00595	        }
00596	        
00597	    {Py_XDECREF(py_V5);}
00598	    
00599	double __DUMMY_6;
00600	
00601	}
00602	__label_4:
00603	
00604	        if (V3) {
00605	            Py_XDECREF(V3);
00606	        }
00607	        
00608	    {Py_XDECREF(py_V3);}
00609	    
00610	double __DUMMY_4;
00611	
00612	}
00613	__label_2:
00614	
00615	    if (!__failure) {
00616	      
00617	        {Py_XDECREF(py_V1);}
00618	        if (!V1) {
00619	            Py_INCREF(Py_None);
00620	            py_V1 = Py_None;
00621	        }
00622	        else if ((void*)py_V1 != (void*)V1) {
00623	            py_V1 = (PyObject*)V1;
00624	        }
00625	
00626	        {Py_XINCREF(py_V1);}
00627	
00628	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00629	            PyErr_Format(PyExc_NotImplementedError,
00630	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00631	                         " with %ld dimensions, with 3 last dims "
00632	                         "%ld, %ld, %ld"
00633	                         " and 3 last strides %ld %ld, %ld.",
00634	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00635	                         (long int) PyArray_NDIM(V1),
00636	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00637	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00638	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00639	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00640	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00641	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00642	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00643	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00644	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00645	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00646	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00647	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00648	        );
00649	            {
00650	        __failure = 2;
00651	        if (!PyErr_Occurred()) {
00652	            PyErr_SetString(PyExc_RuntimeError,
00653	                "Unexpected error in an Op's C code. "
00654	                "No Python exception was set.");
00655	            }
00656	        goto __label_2;}
00657	        }
00658	        
00659	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00660	      {Py_XINCREF(py_V1);}
00661	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00662	      {Py_XDECREF(old);}
00663	    }
00664	    
00665	        if (V1) {
00666	            Py_XDECREF(V1);
00667	        }
00668	        
00669	    {Py_XDECREF(py_V1);}
00670	    
00671	double __DUMMY_2;
00672	
00673	}
00674	
00675	            
00676	        if (__failure) {
00677	            // When there is a failure, this code puts the exception
00678	            // in __ERROR.
00679	            PyObject* err_type = NULL;
00680	            PyObject* err_msg = NULL;
00681	            PyObject* err_traceback = NULL;
00682	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00683	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00684	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00685	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00686	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00687	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00688	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00689	            PyList_SET_ITEM(__ERROR, 0, err_type);
00690	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00691	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00692	            {Py_XDECREF(old_err_type);}
00693	            {Py_XDECREF(old_err_msg);}
00694	            {Py_XDECREF(old_err_traceback);}
00695	        }
00696	        // The failure code is returned to index what code block failed.
00697	        return __failure;
00698	        
00699	        }
00700	    };
00701	    }
00702	    
00703	
00704	        static int __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66_executor(__struct_compiled_op_bd42ac06567dd948b69fbe988247ea66* self) {
00705	            return self->run();
00706	        }
00707	
00708	        static void __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66_destructor(void* executor, void* self) {
00709	            delete ((__struct_compiled_op_bd42ac06567dd948b69fbe988247ea66*)self);
00710	        }
00711	        
00712	//////////////////////
00713	////  Functions
00714	//////////////////////
00715	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00716	  assert(PyTuple_Check(argtuple));
00717	  if (4 != PyTuple_Size(argtuple)){ 
00718	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00719	     return NULL;
00720	  }
00721	  __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66* struct_ptr = new __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66();
00722	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00723	    delete struct_ptr;
00724	    return NULL;
00725	  }
00726	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_bd42ac06567dd948b69fbe988247ea66_executor), struct_ptr, __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66_destructor);
00727	  return thunk; }
00728	
00729	//////////////////////
00730	////  Module init
00731	//////////////////////
00732	static PyMethodDef MyMethods[] = {
00733		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00734		{NULL, NULL, 0, NULL}
00735	};
00736	PyMODINIT_FUNC initbd42ac06567dd948b69fbe988247ea66(void){
00737	   import_array();
00738	   (void) Py_InitModule("bd42ac06567dd948b69fbe988247ea66", MyMethods);
00739	}
00740	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpuUk43g/bd42ac06567dd948b69fbe988247ea66.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpuUk43g/mod.cpp -lpython2.7
ERROR
test_borrow_output (theano.compile.tests.test_function_module.T_function) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_7a616cf4ae9faff052715b3aac360385 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_7a616cf4ae9faff052715b3aac360385() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_7a616cf4ae9faff052715b3aac360385(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                int V3_jumpx_0;
00273	                
00274	                int V3_jumpx_1;
00275	                
00276	        npy_float64* V5_iter;
00277	        
00278	                npy_intp V5_n0;
00279	                ssize_t V5_stride0;
00280	                int V5_jump0_0;
00281	                
00282	                npy_intp V5_n1;
00283	                ssize_t V5_stride1;
00284	                int V5_jump1_1;
00285	                
00286	
00287	                V3_jumpx_1 = -(0);
00288	                //printf("V3_jumpx_1 is:");
00289	                //std::cout << V3_jumpx_1 << std::endl;
00290	                
00291	                V3_jumpx_0 = -(0);
00292	                //printf("V3_jumpx_0 is:");
00293	                //std::cout << V3_jumpx_0 << std::endl;
00294	                
00295	            if (PyArray_NDIM(V5) < 2) {
00296	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00297	                {
00298	        __failure = 7;
00299	        if (!PyErr_Occurred()) {
00300	            PyErr_SetString(PyExc_RuntimeError,
00301	                "Unexpected error in an Op's C code. "
00302	                "No Python exception was set.");
00303	            }
00304	        goto __label_7;}
00305	            }
00306	            
00307	                V5_n1 = PyArray_DIMS(V5)[1];
00308	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00309	                V5_jump1_1 = (V5_stride1) - (0);
00310	                //printf("V5_jump1_1 is:");
00311	                //std::cout << V5_jump1_1 << std::endl;
00312	                
00313	                V5_n0 = PyArray_DIMS(V5)[0];
00314	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00315	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00316	                //printf("V5_jump0_0 is:");
00317	                //std::cout << V5_jump0_0 << std::endl;
00318	                
00319	
00320	        npy_float64* V1_iter;
00321	        
00322	                npy_intp V1_n0;
00323	                ssize_t V1_stride0;
00324	                int V1_jump0_0;
00325	                
00326	                npy_intp V1_n1;
00327	                ssize_t V1_stride1;
00328	                int V1_jump1_1;
00329	                
00330	    {
00331	        npy_intp dims[2];
00332	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00333	        dims[0] = V5_n0;
00334	dims[1] = V5_n1;
00335	
00336	        if (!V1) {
00337	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00338	                                                    NPY_FLOAT64,
00339	                                                    PyArray_ISFORTRAN(V5));
00340	        }
00341	        else {
00342	            PyArray_Dims new_dims;
00343	            new_dims.len = 2;
00344	            new_dims.ptr = dims;
00345	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00346	            if (!success) {
00347	                // If we can't resize the ndarray we have we can allocate a new one.
00348	                PyErr_Clear();
00349	                Py_XDECREF(V1);
00350	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00351	            }
00352	        }
00353	        if (!V1) {
00354	            {
00355	        __failure = 7;
00356	        if (!PyErr_Occurred()) {
00357	            PyErr_SetString(PyExc_RuntimeError,
00358	                "Unexpected error in an Op's C code. "
00359	                "No Python exception was set.");
00360	            }
00361	        goto __label_7;}
00362	        }
00363	    }
00364	    
00365	            if (PyArray_NDIM(V1) < 2) {
00366	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00367	                {
00368	        __failure = 7;
00369	        if (!PyErr_Occurred()) {
00370	            PyErr_SetString(PyExc_RuntimeError,
00371	                "Unexpected error in an Op's C code. "
00372	                "No Python exception was set.");
00373	            }
00374	        goto __label_7;}
00375	            }
00376	            
00377	                V1_n1 = PyArray_DIMS(V1)[1];
00378	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00379	                V1_jump1_1 = (V1_stride1) - (0);
00380	                //printf("V1_jump1_1 is:");
00381	                //std::cout << V1_jump1_1 << std::endl;
00382	                
00383	                V1_n0 = PyArray_DIMS(V1)[0];
00384	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00385	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00386	                //printf("V1_jump0_0 is:");
00387	                //std::cout << V1_jump0_0 << std::endl;
00388	                
00389	
00390	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00391	                
00392	                    // All output have the same size
00393	                    npy_intp n = PyArray_SIZE(V1);
00394	                    
00395	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00396	                            
00397	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00398	                            
00399	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00400	                            
00401	                    for(int i=0; i<n; i++){
00402	                        
00403	            dtype_V5& V5_i = V5_ptr[i];
00404	                            
00405	            dtype_V1& V1_i = V1_ptr[i];
00406	                            
00407	                        V1_i = V3_i * V5_i;;
00408	                    }
00409	                    
00410	            }else{
00411	                {
00412	
00413	    std::vector< std::pair<int, int> > V1_loops(2);
00414	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00415	    
00416	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00417	            
00418	        V1_loops_it->second = 0;
00419	        ++V1_loops_it;
00420	        
00421	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00422	            
00423	        V1_loops_it->second = 1;
00424	        ++V1_loops_it;
00425	        
00426	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00427	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00428	    
00429	
00430	    int init_totals[2] = {V5_n0, V5_n1};
00431	    
00432	    V1_loops_it = V1_loops.begin();
00433	    
00434	        int TOTAL_0 = init_totals[V1_loops_it->second];
00435	        ++V1_loops_it;
00436	        
00437	        int TOTAL_1 = init_totals[V1_loops_it->second];
00438	        ++V1_loops_it;
00439	        
00440	
00441	    int init_strides[3][2] = {
00442	        0, 0, 
00443	V5_stride0, V5_stride1, 
00444	V1_stride0, V1_stride1
00445	    };
00446	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00447	    
00448	        V1_loops_rit = V1_loops.rbegin();
00449	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00450	            ++V1_loops_rit;
00451	            
00452	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00453	            ++V1_loops_rit;
00454	            
00455	        V1_loops_rit = V1_loops.rbegin();
00456	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00457	            ++V1_loops_rit;
00458	            
00459	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00460	            ++V1_loops_rit;
00461	            
00462	        V1_loops_rit = V1_loops.rbegin();
00463	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00464	            ++V1_loops_rit;
00465	            
00466	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00467	            ++V1_loops_rit;
00468	            
00469	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00470	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00471	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00472	
00473	
00474	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00475	        { // begin loop 0
00476	            
00477	            
00478	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00479	        { // begin loop 1
00480	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00481	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00482	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00483	
00484	            
00485	        {
00486	            
00487	            V1_i = V3_i * V5_i;
00488	            
00489	        }
00490	        
00491	        } // end loop 1
00492	        
00493	        } // end loop 0
00494	        
00495	}
00496	
00497	            }
00498	            __label_7:
00499	
00500	double __DUMMY_7;
00501	
00502	}
00503	__label_6:
00504	
00505	        if (V5) {
00506	            Py_XDECREF(V5);
00507	        }
00508	        
00509	    {Py_XDECREF(py_V5);}
00510	    
00511	double __DUMMY_6;
00512	
00513	}
00514	__label_4:
00515	
00516	        if (V3) {
00517	            Py_XDECREF(V3);
00518	        }
00519	        
00520	    {Py_XDECREF(py_V3);}
00521	    
00522	double __DUMMY_4;
00523	
00524	}
00525	__label_2:
00526	
00527	    if (!__failure) {
00528	      
00529	        {Py_XDECREF(py_V1);}
00530	        if (!V1) {
00531	            Py_INCREF(Py_None);
00532	            py_V1 = Py_None;
00533	        }
00534	        else if ((void*)py_V1 != (void*)V1) {
00535	            py_V1 = (PyObject*)V1;
00536	        }
00537	
00538	        {Py_XINCREF(py_V1);}
00539	
00540	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00541	            PyErr_Format(PyExc_NotImplementedError,
00542	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00543	                         " with %ld dimensions, with 3 last dims "
00544	                         "%ld, %ld, %ld"
00545	                         " and 3 last strides %ld %ld, %ld.",
00546	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00547	                         (long int) PyArray_NDIM(V1),
00548	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00549	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00550	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00551	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00552	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00553	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00554	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00555	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00556	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00557	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00558	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00559	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00560	        );
00561	            {
00562	        __failure = 2;
00563	        if (!PyErr_Occurred()) {
00564	            PyErr_SetString(PyExc_RuntimeError,
00565	                "Unexpected error in an Op's C code. "
00566	                "No Python exception was set.");
00567	            }
00568	        goto __label_2;}
00569	        }
00570	        
00571	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00572	      {Py_XINCREF(py_V1);}
00573	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00574	      {Py_XDECREF(old);}
00575	    }
00576	    
00577	        if (V1) {
00578	            Py_XDECREF(V1);
00579	        }
00580	        
00581	    {Py_XDECREF(py_V1);}
00582	    
00583	double __DUMMY_2;
00584	
00585	}
00586	
00587	            
00588	        if (__failure) {
00589	            // When there is a failure, this code puts the exception
00590	            // in __ERROR.
00591	            PyObject* err_type = NULL;
00592	            PyObject* err_msg = NULL;
00593	            PyObject* err_traceback = NULL;
00594	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00595	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00596	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00597	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00598	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00599	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00600	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00601	            PyList_SET_ITEM(__ERROR, 0, err_type);
00602	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00603	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00604	            {Py_XDECREF(old_err_type);}
00605	            {Py_XDECREF(old_err_msg);}
00606	            {Py_XDECREF(old_err_traceback);}
00607	        }
00608	        // The failure code is returned to index what code block failed.
00609	        return __failure;
00610	        
00611	        }
00612	    };
00613	    }
00614	    
00615	
00616	        static int __struct_compiled_op_7a616cf4ae9faff052715b3aac360385_executor(__struct_compiled_op_7a616cf4ae9faff052715b3aac360385* self) {
00617	            return self->run();
00618	        }
00619	
00620	        static void __struct_compiled_op_7a616cf4ae9faff052715b3aac360385_destructor(void* executor, void* self) {
00621	            delete ((__struct_compiled_op_7a616cf4ae9faff052715b3aac360385*)self);
00622	        }
00623	        
00624	//////////////////////
00625	////  Functions
00626	//////////////////////
00627	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00628	  assert(PyTuple_Check(argtuple));
00629	  if (4 != PyTuple_Size(argtuple)){ 
00630	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00631	     return NULL;
00632	  }
00633	  __struct_compiled_op_7a616cf4ae9faff052715b3aac360385* struct_ptr = new __struct_compiled_op_7a616cf4ae9faff052715b3aac360385();
00634	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00635	    delete struct_ptr;
00636	    return NULL;
00637	  }
00638	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_7a616cf4ae9faff052715b3aac360385_executor), struct_ptr, __struct_compiled_op_7a616cf4ae9faff052715b3aac360385_destructor);
00639	  return thunk; }
00640	
00641	//////////////////////
00642	////  Module init
00643	//////////////////////
00644	static PyMethodDef MyMethods[] = {
00645		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00646		{NULL, NULL, 0, NULL}
00647	};
00648	PyMODINIT_FUNC init7a616cf4ae9faff052715b3aac360385(void){
00649	   import_array();
00650	   (void) Py_InitModule("7a616cf4ae9faff052715b3aac360385", MyMethods);
00651	}
00652	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpfm0Hca/7a616cf4ae9faff052715b3aac360385.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpfm0Hca/mod.cpp -lpython2.7
ERROR
test_constant_output (theano.compile.tests.test_function_module.T_function) ... ok
test_copy (theano.compile.tests.test_function_module.T_function) ... ok
test_copy_delete_updates (theano.compile.tests.test_function_module.T_function) ... ok
test_copy_share_memory (theano.compile.tests.test_function_module.T_function) ... ok
Check that default values are restored ... ok
test_disconnected_input (theano.compile.tests.test_function_module.T_function) ... ok
test_empty (theano.compile.tests.test_function_module.T_function) ... ok
test_extra_inputs (theano.compile.tests.test_function_module.T_function) ... ok
Make test on free() function ... ok
Ensure error is raised when trying to replace an input variable. ... ok
test_input_anon_singleton (theano.compile.tests.test_function_module.T_function) ... ok
test_input_anon_unpack (theano.compile.tests.test_function_module.T_function) ... ok
test_masked_input (theano.compile.tests.test_function_module.T_function) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_7a616cf4ae9faff052715b3aac360385 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_7a616cf4ae9faff052715b3aac360385() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_7a616cf4ae9faff052715b3aac360385(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                int V3_jumpx_0;
00273	                
00274	                int V3_jumpx_1;
00275	                
00276	        npy_float64* V5_iter;
00277	        
00278	                npy_intp V5_n0;
00279	                ssize_t V5_stride0;
00280	                int V5_jump0_0;
00281	                
00282	                npy_intp V5_n1;
00283	                ssize_t V5_stride1;
00284	                int V5_jump1_1;
00285	                
00286	
00287	                V3_jumpx_1 = -(0);
00288	                //printf("V3_jumpx_1 is:");
00289	                //std::cout << V3_jumpx_1 << std::endl;
00290	                
00291	                V3_jumpx_0 = -(0);
00292	                //printf("V3_jumpx_0 is:");
00293	                //std::cout << V3_jumpx_0 << std::endl;
00294	                
00295	            if (PyArray_NDIM(V5) < 2) {
00296	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00297	                {
00298	        __failure = 7;
00299	        if (!PyErr_Occurred()) {
00300	            PyErr_SetString(PyExc_RuntimeError,
00301	                "Unexpected error in an Op's C code. "
00302	                "No Python exception was set.");
00303	            }
00304	        goto __label_7;}
00305	            }
00306	            
00307	                V5_n1 = PyArray_DIMS(V5)[1];
00308	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00309	                V5_jump1_1 = (V5_stride1) - (0);
00310	                //printf("V5_jump1_1 is:");
00311	                //std::cout << V5_jump1_1 << std::endl;
00312	                
00313	                V5_n0 = PyArray_DIMS(V5)[0];
00314	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00315	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00316	                //printf("V5_jump0_0 is:");
00317	                //std::cout << V5_jump0_0 << std::endl;
00318	                
00319	
00320	        npy_float64* V1_iter;
00321	        
00322	                npy_intp V1_n0;
00323	                ssize_t V1_stride0;
00324	                int V1_jump0_0;
00325	                
00326	                npy_intp V1_n1;
00327	                ssize_t V1_stride1;
00328	                int V1_jump1_1;
00329	                
00330	    {
00331	        npy_intp dims[2];
00332	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00333	        dims[0] = V5_n0;
00334	dims[1] = V5_n1;
00335	
00336	        if (!V1) {
00337	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00338	                                                    NPY_FLOAT64,
00339	                                                    PyArray_ISFORTRAN(V5));
00340	        }
00341	        else {
00342	            PyArray_Dims new_dims;
00343	            new_dims.len = 2;
00344	            new_dims.ptr = dims;
00345	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00346	            if (!success) {
00347	                // If we can't resize the ndarray we have we can allocate a new one.
00348	                PyErr_Clear();
00349	                Py_XDECREF(V1);
00350	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00351	            }
00352	        }
00353	        if (!V1) {
00354	            {
00355	        __failure = 7;
00356	        if (!PyErr_Occurred()) {
00357	            PyErr_SetString(PyExc_RuntimeError,
00358	                "Unexpected error in an Op's C code. "
00359	                "No Python exception was set.");
00360	            }
00361	        goto __label_7;}
00362	        }
00363	    }
00364	    
00365	            if (PyArray_NDIM(V1) < 2) {
00366	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00367	                {
00368	        __failure = 7;
00369	        if (!PyErr_Occurred()) {
00370	            PyErr_SetString(PyExc_RuntimeError,
00371	                "Unexpected error in an Op's C code. "
00372	                "No Python exception was set.");
00373	            }
00374	        goto __label_7;}
00375	            }
00376	            
00377	                V1_n1 = PyArray_DIMS(V1)[1];
00378	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00379	                V1_jump1_1 = (V1_stride1) - (0);
00380	                //printf("V1_jump1_1 is:");
00381	                //std::cout << V1_jump1_1 << std::endl;
00382	                
00383	                V1_n0 = PyArray_DIMS(V1)[0];
00384	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00385	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00386	                //printf("V1_jump0_0 is:");
00387	                //std::cout << V1_jump0_0 << std::endl;
00388	                
00389	
00390	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00391	                
00392	                    // All output have the same size
00393	                    npy_intp n = PyArray_SIZE(V1);
00394	                    
00395	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00396	                            
00397	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00398	                            
00399	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00400	                            
00401	                    for(int i=0; i<n; i++){
00402	                        
00403	            dtype_V5& V5_i = V5_ptr[i];
00404	                            
00405	            dtype_V1& V1_i = V1_ptr[i];
00406	                            
00407	                        V1_i = V3_i * V5_i;;
00408	                    }
00409	                    
00410	            }else{
00411	                {
00412	
00413	    std::vector< std::pair<int, int> > V1_loops(2);
00414	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00415	    
00416	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00417	            
00418	        V1_loops_it->second = 0;
00419	        ++V1_loops_it;
00420	        
00421	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00422	            
00423	        V1_loops_it->second = 1;
00424	        ++V1_loops_it;
00425	        
00426	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00427	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00428	    
00429	
00430	    int init_totals[2] = {V5_n0, V5_n1};
00431	    
00432	    V1_loops_it = V1_loops.begin();
00433	    
00434	        int TOTAL_0 = init_totals[V1_loops_it->second];
00435	        ++V1_loops_it;
00436	        
00437	        int TOTAL_1 = init_totals[V1_loops_it->second];
00438	        ++V1_loops_it;
00439	        
00440	
00441	    int init_strides[3][2] = {
00442	        0, 0, 
00443	V5_stride0, V5_stride1, 
00444	V1_stride0, V1_stride1
00445	    };
00446	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00447	    
00448	        V1_loops_rit = V1_loops.rbegin();
00449	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00450	            ++V1_loops_rit;
00451	            
00452	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00453	            ++V1_loops_rit;
00454	            
00455	        V1_loops_rit = V1_loops.rbegin();
00456	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00457	            ++V1_loops_rit;
00458	            
00459	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00460	            ++V1_loops_rit;
00461	            
00462	        V1_loops_rit = V1_loops.rbegin();
00463	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00464	            ++V1_loops_rit;
00465	            
00466	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00467	            ++V1_loops_rit;
00468	            
00469	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00470	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00471	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00472	
00473	
00474	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00475	        { // begin loop 0
00476	            
00477	            
00478	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00479	        { // begin loop 1
00480	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00481	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00482	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00483	
00484	            
00485	        {
00486	            
00487	            V1_i = V3_i * V5_i;
00488	            
00489	        }
00490	        
00491	        } // end loop 1
00492	        
00493	        } // end loop 0
00494	        
00495	}
00496	
00497	            }
00498	            __label_7:
00499	
00500	double __DUMMY_7;
00501	
00502	}
00503	__label_6:
00504	
00505	        if (V5) {
00506	            Py_XDECREF(V5);
00507	        }
00508	        
00509	    {Py_XDECREF(py_V5);}
00510	    
00511	double __DUMMY_6;
00512	
00513	}
00514	__label_4:
00515	
00516	        if (V3) {
00517	            Py_XDECREF(V3);
00518	        }
00519	        
00520	    {Py_XDECREF(py_V3);}
00521	    
00522	double __DUMMY_4;
00523	
00524	}
00525	__label_2:
00526	
00527	    if (!__failure) {
00528	      
00529	        {Py_XDECREF(py_V1);}
00530	        if (!V1) {
00531	            Py_INCREF(Py_None);
00532	            py_V1 = Py_None;
00533	        }
00534	        else if ((void*)py_V1 != (void*)V1) {
00535	            py_V1 = (PyObject*)V1;
00536	        }
00537	
00538	        {Py_XINCREF(py_V1);}
00539	
00540	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00541	            PyErr_Format(PyExc_NotImplementedError,
00542	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00543	                         " with %ld dimensions, with 3 last dims "
00544	                         "%ld, %ld, %ld"
00545	                         " and 3 last strides %ld %ld, %ld.",
00546	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00547	                         (long int) PyArray_NDIM(V1),
00548	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00549	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00550	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00551	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00552	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00553	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00554	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00555	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00556	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00557	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00558	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00559	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00560	        );
00561	            {
00562	        __failure = 2;
00563	        if (!PyErr_Occurred()) {
00564	            PyErr_SetString(PyExc_RuntimeError,
00565	                "Unexpected error in an Op's C code. "
00566	                "No Python exception was set.");
00567	            }
00568	        goto __label_2;}
00569	        }
00570	        
00571	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00572	      {Py_XINCREF(py_V1);}
00573	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00574	      {Py_XDECREF(old);}
00575	    }
00576	    
00577	        if (V1) {
00578	            Py_XDECREF(V1);
00579	        }
00580	        
00581	    {Py_XDECREF(py_V1);}
00582	    
00583	double __DUMMY_2;
00584	
00585	}
00586	
00587	            
00588	        if (__failure) {
00589	            // When there is a failure, this code puts the exception
00590	            // in __ERROR.
00591	            PyObject* err_type = NULL;
00592	            PyObject* err_msg = NULL;
00593	            PyObject* err_traceback = NULL;
00594	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00595	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00596	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00597	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00598	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00599	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00600	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00601	            PyList_SET_ITEM(__ERROR, 0, err_type);
00602	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00603	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00604	            {Py_XDECREF(old_err_type);}
00605	            {Py_XDECREF(old_err_msg);}
00606	            {Py_XDECREF(old_err_traceback);}
00607	        }
00608	        // The failure code is returned to index what code block failed.
00609	        return __failure;
00610	        
00611	        }
00612	    };
00613	    }
00614	    
00615	
00616	        static int __struct_compiled_op_7a616cf4ae9faff052715b3aac360385_executor(__struct_compiled_op_7a616cf4ae9faff052715b3aac360385* self) {
00617	            return self->run();
00618	        }
00619	
00620	        static void __struct_compiled_op_7a616cf4ae9faff052715b3aac360385_destructor(void* executor, void* self) {
00621	            delete ((__struct_compiled_op_7a616cf4ae9faff052715b3aac360385*)self);
00622	        }
00623	        
00624	//////////////////////
00625	////  Functions
00626	//////////////////////
00627	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00628	  assert(PyTuple_Check(argtuple));
00629	  if (4 != PyTuple_Size(argtuple)){ 
00630	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00631	     return NULL;
00632	  }
00633	  __struct_compiled_op_7a616cf4ae9faff052715b3aac360385* struct_ptr = new __struct_compiled_op_7a616cf4ae9faff052715b3aac360385();
00634	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00635	    delete struct_ptr;
00636	    return NULL;
00637	  }
00638	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_7a616cf4ae9faff052715b3aac360385_executor), struct_ptr, __struct_compiled_op_7a616cf4ae9faff052715b3aac360385_destructor);
00639	  return thunk; }
00640	
00641	//////////////////////
00642	////  Module init
00643	//////////////////////
00644	static PyMethodDef MyMethods[] = {
00645		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00646		{NULL, NULL, 0, NULL}
00647	};
00648	PyMODINIT_FUNC init7a616cf4ae9faff052715b3aac360385(void){
00649	   import_array();
00650	   (void) Py_InitModule("7a616cf4ae9faff052715b3aac360385", MyMethods);
00651	}
00652	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpbI8cmq/7a616cf4ae9faff052715b3aac360385.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpbI8cmq/mod.cpp -lpython2.7
ERROR
test_missing_inputs (theano.compile.tests.test_function_module.T_function) ... ok
test_naming_rule0 (theano.compile.tests.test_function_module.T_function) ... ok
test_naming_rule1 (theano.compile.tests.test_function_module.T_function) ... ok
test_naming_rule2 (theano.compile.tests.test_function_module.T_function) ... ok
test_naming_rule3 (theano.compile.tests.test_function_module.T_function) ... ok
test_naming_rule4 (theano.compile.tests.test_function_module.T_function) ... ok
test_none (theano.compile.tests.test_function_module.T_function) ... SKIP: See #254: Using None as function output leads to [] return value
test_same_names (theano.compile.tests.test_function_module.T_function) ... ok
test_shared_state0 (theano.compile.tests.test_function_module.T_function) ... ok
test_shared_state1 (theano.compile.tests.test_function_module.T_function) ... ok
test_shared_state2 (theano.compile.tests.test_function_module.T_function) ... ok
test_shared_state_not_implicit (theano.compile.tests.test_function_module.T_function) ... ok
test_state_access (theano.compile.tests.test_function_module.T_function) ... ok
test_swap_SharedVariable (theano.compile.tests.test_function_module.T_function) ... ok
A special testcase for logistic_sgd.py in Deep Learning Tutorial ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_107b86891113836f281fd3723a4d89b6 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_107b86891113836f281fd3723a4d89b6() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_107b86891113836f281fd3723a4d89b6(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                int V3_jumpx_0;
00273	                
00274	                int V3_jumpx_1;
00275	                
00276	        npy_float64* V5_iter;
00277	        
00278	                npy_intp V5_n0;
00279	                ssize_t V5_stride0;
00280	                int V5_jump0_0;
00281	                
00282	                npy_intp V5_n1;
00283	                ssize_t V5_stride1;
00284	                int V5_jump1_1;
00285	                
00286	
00287	                V3_jumpx_1 = -(0);
00288	                //printf("V3_jumpx_1 is:");
00289	                //std::cout << V3_jumpx_1 << std::endl;
00290	                
00291	                V3_jumpx_0 = -(0);
00292	                //printf("V3_jumpx_0 is:");
00293	                //std::cout << V3_jumpx_0 << std::endl;
00294	                
00295	            if (PyArray_NDIM(V5) < 2) {
00296	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00297	                {
00298	        __failure = 7;
00299	        if (!PyErr_Occurred()) {
00300	            PyErr_SetString(PyExc_RuntimeError,
00301	                "Unexpected error in an Op's C code. "
00302	                "No Python exception was set.");
00303	            }
00304	        goto __label_7;}
00305	            }
00306	            
00307	                V5_n1 = PyArray_DIMS(V5)[1];
00308	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00309	                V5_jump1_1 = (V5_stride1) - (0);
00310	                //printf("V5_jump1_1 is:");
00311	                //std::cout << V5_jump1_1 << std::endl;
00312	                
00313	                V5_n0 = PyArray_DIMS(V5)[0];
00314	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00315	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00316	                //printf("V5_jump0_0 is:");
00317	                //std::cout << V5_jump0_0 << std::endl;
00318	                
00319	
00320	            if (V1) {
00321	                Py_XDECREF(V1);
00322	            }
00323	            V1 = V5;
00324	            Py_XINCREF(V1);
00325	            
00326	
00327	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00328	                
00329	                    // All output have the same size
00330	                    npy_intp n = PyArray_SIZE(V1);
00331	                    
00332	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00333	                            
00334	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00335	                            
00336	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00337	                            
00338	                    for(int i=0; i<n; i++){
00339	                        
00340	            dtype_V5& V5_i = V5_ptr[i];
00341	                            
00342	            dtype_V1& V1_i = V1_ptr[i];
00343	                            
00344	                        V1_i = V3_i + V5_i;;
00345	                    }
00346	                    
00347	            }else{
00348	                {
00349	
00350	    std::vector< std::pair<int, int> > V5_loops(2);
00351	    std::vector< std::pair<int, int> >::iterator V5_loops_it = V5_loops.begin();
00352	    
00353	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[0]);
00354	            
00355	        V5_loops_it->second = 0;
00356	        ++V5_loops_it;
00357	        
00358	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[1]);
00359	            
00360	        V5_loops_it->second = 1;
00361	        ++V5_loops_it;
00362	        
00363	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00364	    std::sort(V5_loops.rbegin(), V5_loops.rend());
00365	    
00366	
00367	    int init_totals[2] = {V5_n0, V5_n1};
00368	    
00369	    V5_loops_it = V5_loops.begin();
00370	    
00371	        int TOTAL_0 = init_totals[V5_loops_it->second];
00372	        ++V5_loops_it;
00373	        
00374	        int TOTAL_1 = init_totals[V5_loops_it->second];
00375	        ++V5_loops_it;
00376	        
00377	
00378	    int init_strides[2][2] = {
00379	        0, 0, 
00380	V5_stride0, V5_stride1
00381	    };
00382	    std::vector< std::pair<int, int> >::reverse_iterator V5_loops_rit;
00383	    
00384	        V5_loops_rit = V5_loops.rbegin();
00385	            int V3_stride_l1 = init_strides[0][V5_loops_rit->second];
00386	            ++V5_loops_rit;
00387	            
00388	            int V3_stride_l0 = init_strides[0][V5_loops_rit->second];
00389	            ++V5_loops_rit;
00390	            
00391	        V5_loops_rit = V5_loops.rbegin();
00392	            int V5_stride_l1 = init_strides[1][V5_loops_rit->second];
00393	            ++V5_loops_rit;
00394	            
00395	            int V5_stride_l0 = init_strides[1][V5_loops_rit->second];
00396	            ++V5_loops_rit;
00397	            
00398	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00399	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00400	
00401	
00402	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00403	        { // begin loop 0
00404	            
00405	            
00406	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00407	        { // begin loop 1
00408	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00409	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00410	
00411	            
00412	        {
00413	            #define V1_i V5_i
00414	
00415	            V1_i = V3_i + V5_i;
00416	            #undef V1_i
00417	
00418	        }
00419	        
00420	        } // end loop 1
00421	        
00422	        } // end loop 0
00423	        
00424	}
00425	
00426	            }
00427	            __label_7:
00428	
00429	double __DUMMY_7;
00430	
00431	}
00432	__label_6:
00433	
00434	        if (V5) {
00435	            Py_XDECREF(V5);
00436	        }
00437	        
00438	    {Py_XDECREF(py_V5);}
00439	    
00440	double __DUMMY_6;
00441	
00442	}
00443	__label_4:
00444	
00445	        if (V3) {
00446	            Py_XDECREF(V3);
00447	        }
00448	        
00449	    {Py_XDECREF(py_V3);}
00450	    
00451	double __DUMMY_4;
00452	
00453	}
00454	__label_2:
00455	
00456	    if (!__failure) {
00457	      
00458	        {Py_XDECREF(py_V1);}
00459	        if (!V1) {
00460	            Py_INCREF(Py_None);
00461	            py_V1 = Py_None;
00462	        }
00463	        else if ((void*)py_V1 != (void*)V1) {
00464	            py_V1 = (PyObject*)V1;
00465	        }
00466	
00467	        {Py_XINCREF(py_V1);}
00468	
00469	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00470	            PyErr_Format(PyExc_NotImplementedError,
00471	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00472	                         " with %ld dimensions, with 3 last dims "
00473	                         "%ld, %ld, %ld"
00474	                         " and 3 last strides %ld %ld, %ld.",
00475	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00476	                         (long int) PyArray_NDIM(V1),
00477	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00478	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00479	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00480	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00481	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00482	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00483	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00484	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00485	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00486	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00487	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00488	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00489	        );
00490	            {
00491	        __failure = 2;
00492	        if (!PyErr_Occurred()) {
00493	            PyErr_SetString(PyExc_RuntimeError,
00494	                "Unexpected error in an Op's C code. "
00495	                "No Python exception was set.");
00496	            }
00497	        goto __label_2;}
00498	        }
00499	        
00500	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00501	      {Py_XINCREF(py_V1);}
00502	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00503	      {Py_XDECREF(old);}
00504	    }
00505	    
00506	        if (V1) {
00507	            Py_XDECREF(V1);
00508	        }
00509	        
00510	    {Py_XDECREF(py_V1);}
00511	    
00512	double __DUMMY_2;
00513	
00514	}
00515	
00516	            
00517	        if (__failure) {
00518	            // When there is a failure, this code puts the exception
00519	            // in __ERROR.
00520	            PyObject* err_type = NULL;
00521	            PyObject* err_msg = NULL;
00522	            PyObject* err_traceback = NULL;
00523	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00524	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00525	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00526	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00527	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00528	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00529	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00530	            PyList_SET_ITEM(__ERROR, 0, err_type);
00531	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00532	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00533	            {Py_XDECREF(old_err_type);}
00534	            {Py_XDECREF(old_err_msg);}
00535	            {Py_XDECREF(old_err_traceback);}
00536	        }
00537	        // The failure code is returned to index what code block failed.
00538	        return __failure;
00539	        
00540	        }
00541	    };
00542	    }
00543	    
00544	
00545	        static int __struct_compiled_op_107b86891113836f281fd3723a4d89b6_executor(__struct_compiled_op_107b86891113836f281fd3723a4d89b6* self) {
00546	            return self->run();
00547	        }
00548	
00549	        static void __struct_compiled_op_107b86891113836f281fd3723a4d89b6_destructor(void* executor, void* self) {
00550	            delete ((__struct_compiled_op_107b86891113836f281fd3723a4d89b6*)self);
00551	        }
00552	        
00553	//////////////////////
00554	////  Functions
00555	//////////////////////
00556	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00557	  assert(PyTuple_Check(argtuple));
00558	  if (4 != PyTuple_Size(argtuple)){ 
00559	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00560	     return NULL;
00561	  }
00562	  __struct_compiled_op_107b86891113836f281fd3723a4d89b6* struct_ptr = new __struct_compiled_op_107b86891113836f281fd3723a4d89b6();
00563	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00564	    delete struct_ptr;
00565	    return NULL;
00566	  }
00567	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_107b86891113836f281fd3723a4d89b6_executor), struct_ptr, __struct_compiled_op_107b86891113836f281fd3723a4d89b6_destructor);
00568	  return thunk; }
00569	
00570	//////////////////////
00571	////  Module init
00572	//////////////////////
00573	static PyMethodDef MyMethods[] = {
00574		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00575		{NULL, NULL, 0, NULL}
00576	};
00577	PyMODINIT_FUNC init107b86891113836f281fd3723a4d89b6(void){
00578	   import_array();
00579	   (void) Py_InitModule("107b86891113836f281fd3723a4d89b6", MyMethods);
00580	}
00581	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmprN2FEf/107b86891113836f281fd3723a4d89b6.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmprN2FEf/mod.cpp -lpython2.7
ERROR
test_weird_names (theano.compile.tests.test_function_module.T_function) ... ok
test_broken_pickle_with_shared (theano.compile.tests.test_function_module.T_picklefunction) ... ok
test_deepcopy (theano.compile.tests.test_function_module.T_picklefunction) ... ok
test_deepcopy_shared_container (theano.compile.tests.test_function_module.T_picklefunction) ... ok
test_multiple_functions (theano.compile.tests.test_function_module.T_picklefunction) ... ok
test_optimizations_preserved (theano.compile.tests.test_function_module.T_picklefunction) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V9;
00021	PyObject* storage_V1;
00022	        
00023	
00024	        __struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f() {
00025	            // This is only somewhat safe because we:
00026	            //  1) Are not a virtual class
00027	            //  2) Do not use any virtual classes in the members
00028	            //  3) Deal with mostly POD and pointers
00029	
00030	            // If this changes, we would have to revise this, but for
00031	            // now I am tired of chasing segfaults because
00032	            // initialization code had an error and some pointer has
00033	            // a junk value.
00034	            memset(this, 0, sizeof(*this));
00035	        }
00036	        ~__struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f(void) {
00037	            cleanup();
00038	        }
00039	
00040	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V9, PyObject* storage_V1) {
00041	            Py_XINCREF(storage_V3);
00042	Py_XINCREF(storage_V5);
00043	Py_XINCREF(storage_V7);
00044	Py_XINCREF(storage_V9);
00045	Py_XINCREF(storage_V1);
00046	            this->storage_V3 = storage_V3;
00047	this->storage_V5 = storage_V5;
00048	this->storage_V7 = storage_V7;
00049	this->storage_V9 = storage_V9;
00050	this->storage_V1 = storage_V1;
00051	            
00052	
00053	
00054	
00055	
00056	
00057	
00058	            this->__ERROR = __ERROR;
00059	            return 0;
00060	        }
00061	        void cleanup(void) {
00062	            __label_1:
00063	
00064	double __DUMMY_1;
00065	__label_3:
00066	
00067	double __DUMMY_3;
00068	__label_5:
00069	
00070	double __DUMMY_5;
00071	__label_7:
00072	
00073	double __DUMMY_7;
00074	__label_9:
00075	
00076	double __DUMMY_9;
00077	__label_12:
00078	
00079	double __DUMMY_12;
00080	
00081	            Py_XDECREF(this->storage_V3);
00082	Py_XDECREF(this->storage_V5);
00083	Py_XDECREF(this->storage_V7);
00084	Py_XDECREF(this->storage_V9);
00085	Py_XDECREF(this->storage_V1);
00086	        }
00087	        int run(void) {
00088	            int __failure = 0;
00089	            
00090	    PyObject* py_V1;
00091	    
00092	        PyArrayObject* V1;
00093	        
00094	            typedef npy_float64 dtype_V1;
00095	            
00096	    PyObject* py_V3;
00097	    
00098	        PyArrayObject* V3;
00099	        
00100	            typedef npy_float64 dtype_V3;
00101	            
00102	    PyObject* py_V5;
00103	    
00104	        PyArrayObject* V5;
00105	        
00106	            typedef npy_float64 dtype_V5;
00107	            
00108	    PyObject* py_V7;
00109	    
00110	        PyArrayObject* V7;
00111	        
00112	            typedef npy_float64 dtype_V7;
00113	            
00114	    PyObject* py_V9;
00115	    
00116	        PyArrayObject* V9;
00117	        
00118	            typedef npy_float64 dtype_V9;
00119	            
00120	{
00121	
00122	    py_V1 = Py_None;
00123	    {Py_XINCREF(py_V1);}
00124	    
00125	        V1 = NULL;
00126	        
00127	{
00128	
00129	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00130	    {Py_XINCREF(py_V3);}
00131	    
00132	            V3 = NULL;
00133	            if (py_V3 == Py_None) {
00134	                // We can either fail here or set V3 to NULL and rely on Ops
00135	                // using tensors to handle the NULL case, but if they fail to do so
00136	                // they'll end up with nasty segfaults, so this is public service.
00137	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00138	                {
00139	        __failure = 4;
00140	        if (!PyErr_Occurred()) {
00141	            PyErr_SetString(PyExc_RuntimeError,
00142	                "Unexpected error in an Op's C code. "
00143	                "No Python exception was set.");
00144	            }
00145	        goto __label_4;}
00146	            }
00147	            if (!PyArray_Check(py_V3)) {
00148	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00149	                {
00150	        __failure = 4;
00151	        if (!PyErr_Occurred()) {
00152	            PyErr_SetString(PyExc_RuntimeError,
00153	                "Unexpected error in an Op's C code. "
00154	                "No Python exception was set.");
00155	            }
00156	        goto __label_4;}
00157	            }
00158	            // We expect NPY_FLOAT64
00159	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00160	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00161	                PyErr_Format(PyExc_NotImplementedError,
00162	                             "expected an aligned array of type %ld "
00163	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00164	                             " with %ld dimensions, with 3 last dims "
00165	                             "%ld, %ld, %ld"
00166	                             " and 3 last strides %ld %ld, %ld.",
00167	                             (long int) NPY_FLOAT64,
00168	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00169	                             (long int) PyArray_NDIM(tmp),
00170	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00171	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00172	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00173	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00174	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00175	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00176	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00177	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00178	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00179	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00180	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00181	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00182	            );
00183	                {
00184	        __failure = 4;
00185	        if (!PyErr_Occurred()) {
00186	            PyErr_SetString(PyExc_RuntimeError,
00187	                "Unexpected error in an Op's C code. "
00188	                "No Python exception was set.");
00189	            }
00190	        goto __label_4;}
00191	            }
00192	            // This is a TypeError to be consistent with DEBUG_MODE
00193	            // Note: DEBUG_MODE also tells the name of the container
00194	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00195	                PyErr_Format(PyExc_TypeError,
00196	                             "expected type_num %d (NPY_FLOAT64) got %d",
00197	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            
00208	        V3 = (PyArrayObject*)(py_V3);
00209	        Py_XINCREF(V3);
00210	        
00211	{
00212	
00213	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00214	    {Py_XINCREF(py_V5);}
00215	    
00216	            V5 = NULL;
00217	            if (py_V5 == Py_None) {
00218	                // We can either fail here or set V5 to NULL and rely on Ops
00219	                // using tensors to handle the NULL case, but if they fail to do so
00220	                // they'll end up with nasty segfaults, so this is public service.
00221	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00222	                {
00223	        __failure = 6;
00224	        if (!PyErr_Occurred()) {
00225	            PyErr_SetString(PyExc_RuntimeError,
00226	                "Unexpected error in an Op's C code. "
00227	                "No Python exception was set.");
00228	            }
00229	        goto __label_6;}
00230	            }
00231	            if (!PyArray_Check(py_V5)) {
00232	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00233	                {
00234	        __failure = 6;
00235	        if (!PyErr_Occurred()) {
00236	            PyErr_SetString(PyExc_RuntimeError,
00237	                "Unexpected error in an Op's C code. "
00238	                "No Python exception was set.");
00239	            }
00240	        goto __label_6;}
00241	            }
00242	            // We expect NPY_FLOAT64
00243	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00244	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00245	                PyErr_Format(PyExc_NotImplementedError,
00246	                             "expected an aligned array of type %ld "
00247	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00248	                             " with %ld dimensions, with 3 last dims "
00249	                             "%ld, %ld, %ld"
00250	                             " and 3 last strides %ld %ld, %ld.",
00251	                             (long int) NPY_FLOAT64,
00252	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00253	                             (long int) PyArray_NDIM(tmp),
00254	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00255	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00256	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00257	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00258	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00259	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00260	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00261	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00262	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00263	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00264	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00265	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00266	            );
00267	                {
00268	        __failure = 6;
00269	        if (!PyErr_Occurred()) {
00270	            PyErr_SetString(PyExc_RuntimeError,
00271	                "Unexpected error in an Op's C code. "
00272	                "No Python exception was set.");
00273	            }
00274	        goto __label_6;}
00275	            }
00276	            // This is a TypeError to be consistent with DEBUG_MODE
00277	            // Note: DEBUG_MODE also tells the name of the container
00278	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00279	                PyErr_Format(PyExc_TypeError,
00280	                             "expected type_num %d (NPY_FLOAT64) got %d",
00281	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            
00292	        V5 = (PyArrayObject*)(py_V5);
00293	        Py_XINCREF(V5);
00294	        
00295	{
00296	
00297	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00298	    {Py_XINCREF(py_V7);}
00299	    
00300	            V7 = NULL;
00301	            if (py_V7 == Py_None) {
00302	                // We can either fail here or set V7 to NULL and rely on Ops
00303	                // using tensors to handle the NULL case, but if they fail to do so
00304	                // they'll end up with nasty segfaults, so this is public service.
00305	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00306	                {
00307	        __failure = 8;
00308	        if (!PyErr_Occurred()) {
00309	            PyErr_SetString(PyExc_RuntimeError,
00310	                "Unexpected error in an Op's C code. "
00311	                "No Python exception was set.");
00312	            }
00313	        goto __label_8;}
00314	            }
00315	            if (!PyArray_Check(py_V7)) {
00316	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00317	                {
00318	        __failure = 8;
00319	        if (!PyErr_Occurred()) {
00320	            PyErr_SetString(PyExc_RuntimeError,
00321	                "Unexpected error in an Op's C code. "
00322	                "No Python exception was set.");
00323	            }
00324	        goto __label_8;}
00325	            }
00326	            // We expect NPY_FLOAT64
00327	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00328	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00329	                PyErr_Format(PyExc_NotImplementedError,
00330	                             "expected an aligned array of type %ld "
00331	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00332	                             " with %ld dimensions, with 3 last dims "
00333	                             "%ld, %ld, %ld"
00334	                             " and 3 last strides %ld %ld, %ld.",
00335	                             (long int) NPY_FLOAT64,
00336	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00337	                             (long int) PyArray_NDIM(tmp),
00338	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00339	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00340	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00341	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00342	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00343	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00344	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00345	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00346	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00347	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00348	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00349	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00350	            );
00351	                {
00352	        __failure = 8;
00353	        if (!PyErr_Occurred()) {
00354	            PyErr_SetString(PyExc_RuntimeError,
00355	                "Unexpected error in an Op's C code. "
00356	                "No Python exception was set.");
00357	            }
00358	        goto __label_8;}
00359	            }
00360	            // This is a TypeError to be consistent with DEBUG_MODE
00361	            // Note: DEBUG_MODE also tells the name of the container
00362	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT64) {
00363	                PyErr_Format(PyExc_TypeError,
00364	                             "expected type_num %d (NPY_FLOAT64) got %d",
00365	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V7));
00366	                {
00367	        __failure = 8;
00368	        if (!PyErr_Occurred()) {
00369	            PyErr_SetString(PyExc_RuntimeError,
00370	                "Unexpected error in an Op's C code. "
00371	                "No Python exception was set.");
00372	            }
00373	        goto __label_8;}
00374	            }
00375	            
00376	        V7 = (PyArrayObject*)(py_V7);
00377	        Py_XINCREF(V7);
00378	        
00379	{
00380	
00381	    py_V9 = PyList_GET_ITEM(storage_V9, 0);
00382	    {Py_XINCREF(py_V9);}
00383	    
00384	            V9 = NULL;
00385	            if (py_V9 == Py_None) {
00386	                // We can either fail here or set V9 to NULL and rely on Ops
00387	                // using tensors to handle the NULL case, but if they fail to do so
00388	                // they'll end up with nasty segfaults, so this is public service.
00389	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00390	                {
00391	        __failure = 10;
00392	        if (!PyErr_Occurred()) {
00393	            PyErr_SetString(PyExc_RuntimeError,
00394	                "Unexpected error in an Op's C code. "
00395	                "No Python exception was set.");
00396	            }
00397	        goto __label_10;}
00398	            }
00399	            if (!PyArray_Check(py_V9)) {
00400	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00401	                {
00402	        __failure = 10;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_10;}
00409	            }
00410	            // We expect NPY_FLOAT64
00411	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V9)) {
00412	                PyArrayObject * tmp = (PyArrayObject*) py_V9;
00413	                PyErr_Format(PyExc_NotImplementedError,
00414	                             "expected an aligned array of type %ld "
00415	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00416	                             " with %ld dimensions, with 3 last dims "
00417	                             "%ld, %ld, %ld"
00418	                             " and 3 last strides %ld %ld, %ld.",
00419	                             (long int) NPY_FLOAT64,
00420	                             (long int) PyArray_TYPE((PyArrayObject*) py_V9),
00421	                             (long int) PyArray_NDIM(tmp),
00422	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00423	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00424	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00425	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00426	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00427	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00428	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00429	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00430	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00431	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00432	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00433	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00434	            );
00435	                {
00436	        __failure = 10;
00437	        if (!PyErr_Occurred()) {
00438	            PyErr_SetString(PyExc_RuntimeError,
00439	                "Unexpected error in an Op's C code. "
00440	                "No Python exception was set.");
00441	            }
00442	        goto __label_10;}
00443	            }
00444	            // This is a TypeError to be consistent with DEBUG_MODE
00445	            // Note: DEBUG_MODE also tells the name of the container
00446	            if (PyArray_TYPE((PyArrayObject*) py_V9) != NPY_FLOAT64) {
00447	                PyErr_Format(PyExc_TypeError,
00448	                             "expected type_num %d (NPY_FLOAT64) got %d",
00449	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V9));
00450	                {
00451	        __failure = 10;
00452	        if (!PyErr_Occurred()) {
00453	            PyErr_SetString(PyExc_RuntimeError,
00454	                "Unexpected error in an Op's C code. "
00455	                "No Python exception was set.");
00456	            }
00457	        goto __label_10;}
00458	            }
00459	            
00460	        V9 = (PyArrayObject*)(py_V9);
00461	        Py_XINCREF(V9);
00462	        
00463	{
00464	// Op class Elemwise
00465	
00466	        npy_float64* V3_iter;
00467	        
00468	                int V3_jumpx_0;
00469	                
00470	                npy_intp V3_n1;
00471	                ssize_t V3_stride1;
00472	                int V3_jump1_1;
00473	                
00474	        npy_float64* V5_iter;
00475	        
00476	                npy_intp V5_n0;
00477	                ssize_t V5_stride0;
00478	                int V5_jump0_0;
00479	                
00480	                npy_intp V5_n1;
00481	                ssize_t V5_stride1;
00482	                int V5_jump1_1;
00483	                
00484	        npy_float64* V7_iter;
00485	        
00486	                npy_intp V7_n0;
00487	                ssize_t V7_stride0;
00488	                int V7_jump0_0;
00489	                
00490	                int V7_jumpx_1;
00491	                
00492	        npy_float64* V9_iter;
00493	        
00494	                int V9_jumpx_0;
00495	                
00496	                npy_intp V9_n1;
00497	                ssize_t V9_stride1;
00498	                int V9_jump1_1;
00499	                
00500	
00501	            if (PyArray_NDIM(V3) < 2) {
00502	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00503	                {
00504	        __failure = 11;
00505	        if (!PyErr_Occurred()) {
00506	            PyErr_SetString(PyExc_RuntimeError,
00507	                "Unexpected error in an Op's C code. "
00508	                "No Python exception was set.");
00509	            }
00510	        goto __label_11;}
00511	            }
00512	            
00513	                V3_n1 = PyArray_DIMS(V3)[1];
00514	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00515	                V3_jump1_1 = (V3_stride1) - (0);
00516	                //printf("V3_jump1_1 is:");
00517	                //std::cout << V3_jump1_1 << std::endl;
00518	                
00519	                V3_jumpx_0 = -(V3_n1*V3_stride1);
00520	                //printf("V3_jumpx_0 is:");
00521	                //std::cout << V3_jumpx_0 << std::endl;
00522	                
00523	            if (PyArray_NDIM(V5) < 2) {
00524	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00525	                {
00526	        __failure = 11;
00527	        if (!PyErr_Occurred()) {
00528	            PyErr_SetString(PyExc_RuntimeError,
00529	                "Unexpected error in an Op's C code. "
00530	                "No Python exception was set.");
00531	            }
00532	        goto __label_11;}
00533	            }
00534	            
00535	                V5_n1 = PyArray_DIMS(V5)[1];
00536	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00537	                V5_jump1_1 = (V5_stride1) - (0);
00538	                //printf("V5_jump1_1 is:");
00539	                //std::cout << V5_jump1_1 << std::endl;
00540	                
00541	                V5_n0 = PyArray_DIMS(V5)[0];
00542	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00543	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00544	                //printf("V5_jump0_0 is:");
00545	                //std::cout << V5_jump0_0 << std::endl;
00546	                
00547	            if (PyArray_NDIM(V7) < 1) {
00548	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00549	                {
00550	        __failure = 11;
00551	        if (!PyErr_Occurred()) {
00552	            PyErr_SetString(PyExc_RuntimeError,
00553	                "Unexpected error in an Op's C code. "
00554	                "No Python exception was set.");
00555	            }
00556	        goto __label_11;}
00557	            }
00558	            
00559	                V7_jumpx_1 = -(0);
00560	                //printf("V7_jumpx_1 is:");
00561	                //std::cout << V7_jumpx_1 << std::endl;
00562	                
00563	                V7_n0 = PyArray_DIMS(V7)[0];
00564	                V7_stride0 = PyArray_STRIDES(V7)[0] / sizeof(npy_float64);
00565	                V7_jump0_0 = (V7_stride0) - (0);
00566	                //printf("V7_jump0_0 is:");
00567	                //std::cout << V7_jump0_0 << std::endl;
00568	                
00569	            if (PyArray_NDIM(V9) < 2) {
00570	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00571	                {
00572	        __failure = 11;
00573	        if (!PyErr_Occurred()) {
00574	            PyErr_SetString(PyExc_RuntimeError,
00575	                "Unexpected error in an Op's C code. "
00576	                "No Python exception was set.");
00577	            }
00578	        goto __label_11;}
00579	            }
00580	            
00581	                V9_n1 = PyArray_DIMS(V9)[1];
00582	                V9_stride1 = PyArray_STRIDES(V9)[1] / sizeof(npy_float64);
00583	                V9_jump1_1 = (V9_stride1) - (0);
00584	                //printf("V9_jump1_1 is:");
00585	                //std::cout << V9_jump1_1 << std::endl;
00586	                
00587	                V9_jumpx_0 = -(V9_n1*V9_stride1);
00588	                //printf("V9_jumpx_0 is:");
00589	                //std::cout << V9_jumpx_0 << std::endl;
00590	                
00591	            if (V5_n0 != V7_n0)
00592	            {
00593	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00594	                   1,
00595	                   0,
00596	                   V5_n0,
00597	                   2,
00598	                   0,
00599	                   V7_n0
00600	                );
00601	                {
00602	        __failure = 11;
00603	        if (!PyErr_Occurred()) {
00604	            PyErr_SetString(PyExc_RuntimeError,
00605	                "Unexpected error in an Op's C code. "
00606	                "No Python exception was set.");
00607	            }
00608	        goto __label_11;}
00609	            }
00610	            
00611	            if (V3_n1 != V5_n1)
00612	            {
00613	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00614	                   0,
00615	                   1,
00616	                   V3_n1,
00617	                   1,
00618	                   1,
00619	                   V5_n1
00620	                );
00621	                {
00622	        __failure = 11;
00623	        if (!PyErr_Occurred()) {
00624	            PyErr_SetString(PyExc_RuntimeError,
00625	                "Unexpected error in an Op's C code. "
00626	                "No Python exception was set.");
00627	            }
00628	        goto __label_11;}
00629	            }
00630	            
00631	            if (V3_n1 != V9_n1)
00632	            {
00633	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00634	                   0,
00635	                   1,
00636	                   V3_n1,
00637	                   3,
00638	                   1,
00639	                   V9_n1
00640	                );
00641	                {
00642	        __failure = 11;
00643	        if (!PyErr_Occurred()) {
00644	            PyErr_SetString(PyExc_RuntimeError,
00645	                "Unexpected error in an Op's C code. "
00646	                "No Python exception was set.");
00647	            }
00648	        goto __label_11;}
00649	            }
00650	            
00651	
00652	            if (V1) {
00653	                Py_XDECREF(V1);
00654	            }
00655	            V1 = V5;
00656	            Py_XINCREF(V1);
00657	            
00658	{
00659	
00660	    std::vector< std::pair<int, int> > V5_loops(2);
00661	    std::vector< std::pair<int, int> >::iterator V5_loops_it = V5_loops.begin();
00662	    
00663	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[0]);
00664	            
00665	        V5_loops_it->second = 0;
00666	        ++V5_loops_it;
00667	        
00668	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[1]);
00669	            
00670	        V5_loops_it->second = 1;
00671	        ++V5_loops_it;
00672	        
00673	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00674	    std::sort(V5_loops.rbegin(), V5_loops.rend());
00675	    
00676	
00677	    int init_totals[2] = {V5_n0, V3_n1};
00678	    
00679	    V5_loops_it = V5_loops.begin();
00680	    
00681	        int TOTAL_0 = init_totals[V5_loops_it->second];
00682	        ++V5_loops_it;
00683	        
00684	        int TOTAL_1 = init_totals[V5_loops_it->second];
00685	        ++V5_loops_it;
00686	        
00687	
00688	    int init_strides[4][2] = {
00689	        0, V3_stride1, 
00690	V5_stride0, V5_stride1, 
00691	V7_stride0, 0, 
00692	0, V9_stride1
00693	    };
00694	    std::vector< std::pair<int, int> >::reverse_iterator V5_loops_rit;
00695	    
00696	        V5_loops_rit = V5_loops.rbegin();
00697	            int V3_stride_l1 = init_strides[0][V5_loops_rit->second];
00698	            ++V5_loops_rit;
00699	            
00700	            int V3_stride_l0 = init_strides[0][V5_loops_rit->second];
00701	            ++V5_loops_rit;
00702	            
00703	        V5_loops_rit = V5_loops.rbegin();
00704	            int V5_stride_l1 = init_strides[1][V5_loops_rit->second];
00705	            ++V5_loops_rit;
00706	            
00707	            int V5_stride_l0 = init_strides[1][V5_loops_rit->second];
00708	            ++V5_loops_rit;
00709	            
00710	        V5_loops_rit = V5_loops.rbegin();
00711	            int V7_stride_l1 = init_strides[2][V5_loops_rit->second];
00712	            ++V5_loops_rit;
00713	            
00714	            int V7_stride_l0 = init_strides[2][V5_loops_rit->second];
00715	            ++V5_loops_rit;
00716	            
00717	        V5_loops_rit = V5_loops.rbegin();
00718	            int V9_stride_l1 = init_strides[3][V5_loops_rit->second];
00719	            ++V5_loops_rit;
00720	            
00721	            int V9_stride_l0 = init_strides[3][V5_loops_rit->second];
00722	            ++V5_loops_rit;
00723	            
00724	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00725	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00726	V7_iter = (npy_float64*)(PyArray_DATA(V7));
00727	V9_iter = (npy_float64*)(PyArray_DATA(V9));
00728	
00729	
00730	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00731	        { // begin loop 0
00732	            
00733	            
00734	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00735	        { // begin loop 1
00736	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00737	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00738	npy_float64 &V7_i = * ( V7_iter+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00739	npy_float64 &V9_i = * ( V9_iter+V9_stride_l1*ITER_1+V9_stride_l0*ITER_0);
00740	
00741	            
00742	        {
00743	            #define V1_i V5_i
00744	
00745	            {
00746	npy_float64 V11_tmp1;
00747	V11_tmp1 = V5_i + V7_i;
00748	npy_float64 V11_tmp2;
00749	V11_tmp2 = V3_i * V11_tmp1;
00750	V1_i = V11_tmp2 + V9_i;
00751	}
00752	
00753	            #undef V1_i
00754	
00755	        }
00756	        
00757	        } // end loop 1
00758	        
00759	        } // end loop 0
00760	        
00761	}
00762	__label_11:
00763	
00764	double __DUMMY_11;
00765	
00766	}
00767	__label_10:
00768	
00769	        if (V9) {
00770	            Py_XDECREF(V9);
00771	        }
00772	        
00773	    {Py_XDECREF(py_V9);}
00774	    
00775	double __DUMMY_10;
00776	
00777	}
00778	__label_8:
00779	
00780	        if (V7) {
00781	            Py_XDECREF(V7);
00782	        }
00783	        
00784	    {Py_XDECREF(py_V7);}
00785	    
00786	double __DUMMY_8;
00787	
00788	}
00789	__label_6:
00790	
00791	        if (V5) {
00792	            Py_XDECREF(V5);
00793	        }
00794	        
00795	    {Py_XDECREF(py_V5);}
00796	    
00797	double __DUMMY_6;
00798	
00799	}
00800	__label_4:
00801	
00802	        if (V3) {
00803	            Py_XDECREF(V3);
00804	        }
00805	        
00806	    {Py_XDECREF(py_V3);}
00807	    
00808	double __DUMMY_4;
00809	
00810	}
00811	__label_2:
00812	
00813	    if (!__failure) {
00814	      
00815	        {Py_XDECREF(py_V1);}
00816	        if (!V1) {
00817	            Py_INCREF(Py_None);
00818	            py_V1 = Py_None;
00819	        }
00820	        else if ((void*)py_V1 != (void*)V1) {
00821	            py_V1 = (PyObject*)V1;
00822	        }
00823	
00824	        {Py_XINCREF(py_V1);}
00825	
00826	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00827	            PyErr_Format(PyExc_NotImplementedError,
00828	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00829	                         " with %ld dimensions, with 3 last dims "
00830	                         "%ld, %ld, %ld"
00831	                         " and 3 last strides %ld %ld, %ld.",
00832	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00833	                         (long int) PyArray_NDIM(V1),
00834	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00835	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00836	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00837	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00838	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00839	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00840	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00841	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00842	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00843	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00844	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00845	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00846	        );
00847	            {
00848	        __failure = 2;
00849	        if (!PyErr_Occurred()) {
00850	            PyErr_SetString(PyExc_RuntimeError,
00851	                "Unexpected error in an Op's C code. "
00852	                "No Python exception was set.");
00853	            }
00854	        goto __label_2;}
00855	        }
00856	        
00857	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00858	      {Py_XINCREF(py_V1);}
00859	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00860	      {Py_XDECREF(old);}
00861	    }
00862	    
00863	        if (V1) {
00864	            Py_XDECREF(V1);
00865	        }
00866	        
00867	    {Py_XDECREF(py_V1);}
00868	    
00869	double __DUMMY_2;
00870	
00871	}
00872	
00873	            
00874	        if (__failure) {
00875	            // When there is a failure, this code puts the exception
00876	            // in __ERROR.
00877	            PyObject* err_type = NULL;
00878	            PyObject* err_msg = NULL;
00879	            PyObject* err_traceback = NULL;
00880	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00881	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00882	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00883	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00884	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00885	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00886	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00887	            PyList_SET_ITEM(__ERROR, 0, err_type);
00888	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00889	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00890	            {Py_XDECREF(old_err_type);}
00891	            {Py_XDECREF(old_err_msg);}
00892	            {Py_XDECREF(old_err_traceback);}
00893	        }
00894	        // The failure code is returned to index what code block failed.
00895	        return __failure;
00896	        
00897	        }
00898	    };
00899	    }
00900	    
00901	
00902	        static int __struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f_executor(__struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f* self) {
00903	            return self->run();
00904	        }
00905	
00906	        static void __struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f_destructor(void* executor, void* self) {
00907	            delete ((__struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f*)self);
00908	        }
00909	        
00910	//////////////////////
00911	////  Functions
00912	//////////////////////
00913	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00914	  assert(PyTuple_Check(argtuple));
00915	  if (6 != PyTuple_Size(argtuple)){ 
00916	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 6, got %i", (int)PyTuple_Size(argtuple));
00917	     return NULL;
00918	  }
00919	  __struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f* struct_ptr = new __struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f();
00920	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4),PyTuple_GET_ITEM(argtuple, 5) ) != 0) {
00921	    delete struct_ptr;
00922	    return NULL;
00923	  }
00924	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f_executor), struct_ptr, __struct_compiled_op_595168f9086b77527ed2e65c3e3dfd6f_destructor);
00925	  return thunk; }
00926	
00927	//////////////////////
00928	////  Module init
00929	//////////////////////
00930	static PyMethodDef MyMethods[] = {
00931		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00932		{NULL, NULL, 0, NULL}
00933	};
00934	PyMODINIT_FUNC init595168f9086b77527ed2e65c3e3dfd6f(void){
00935	   import_array();
00936	   (void) Py_InitModule("595168f9086b77527ed2e65c3e3dfd6f", MyMethods);
00937	}
00938	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpj1rxnD/595168f9086b77527ed2e65c3e3dfd6f.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpj1rxnD/mod.cpp -lpython2.7
ERROR
test_pickle (theano.compile.tests.test_function_module.T_picklefunction) ... ok
test_pickle_class_with_functions (theano.compile.tests.test_function_module.T_picklefunction) ... ok
Regression test for bug fixed in 8625e03. ... ok
test_function_name (theano.compile.tests.test_function_name.FunctionName) ... ok
test_nnet (theano.compile.tests.test_misc.TestNnet) ... INFO (theano.gof.compilelock): Refreshing lock /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/lock_dir/lock
ok
theano.compile.tests.test_mode.test_no_output_from_implace ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V1;
00019	        
00020	
00021	        __struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a() {
00022	            // This is only somewhat safe because we:
00023	            //  1) Are not a virtual class
00024	            //  2) Do not use any virtual classes in the members
00025	            //  3) Deal with mostly POD and pointers
00026	
00027	            // If this changes, we would have to revise this, but for
00028	            // now I am tired of chasing segfaults because
00029	            // initialization code had an error and some pointer has
00030	            // a junk value.
00031	            memset(this, 0, sizeof(*this));
00032	        }
00033	        ~__struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a(void) {
00034	            cleanup();
00035	        }
00036	
00037	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V1) {
00038	            Py_XINCREF(storage_V3);
00039	Py_XINCREF(storage_V1);
00040	            this->storage_V3 = storage_V3;
00041	this->storage_V1 = storage_V1;
00042	            
00043	
00044	
00045	
00046	            this->__ERROR = __ERROR;
00047	            return 0;
00048	        }
00049	        void cleanup(void) {
00050	            __label_1:
00051	
00052	double __DUMMY_1;
00053	__label_3:
00054	
00055	double __DUMMY_3;
00056	__label_6:
00057	
00058	double __DUMMY_6;
00059	
00060	            Py_XDECREF(this->storage_V3);
00061	Py_XDECREF(this->storage_V1);
00062	        }
00063	        int run(void) {
00064	            int __failure = 0;
00065	            
00066	    PyObject* py_V1;
00067	    
00068	        PyArrayObject* V1;
00069	        
00070	            typedef npy_float64 dtype_V1;
00071	            
00072	    PyObject* py_V3;
00073	    
00074	        PyArrayObject* V3;
00075	        
00076	            typedef npy_float64 dtype_V3;
00077	            
00078	{
00079	
00080	    py_V1 = Py_None;
00081	    {Py_XINCREF(py_V1);}
00082	    
00083	        V1 = NULL;
00084	        
00085	{
00086	
00087	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00088	    {Py_XINCREF(py_V3);}
00089	    
00090	            V3 = NULL;
00091	            if (py_V3 == Py_None) {
00092	                // We can either fail here or set V3 to NULL and rely on Ops
00093	                // using tensors to handle the NULL case, but if they fail to do so
00094	                // they'll end up with nasty segfaults, so this is public service.
00095	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00096	                {
00097	        __failure = 4;
00098	        if (!PyErr_Occurred()) {
00099	            PyErr_SetString(PyExc_RuntimeError,
00100	                "Unexpected error in an Op's C code. "
00101	                "No Python exception was set.");
00102	            }
00103	        goto __label_4;}
00104	            }
00105	            if (!PyArray_Check(py_V3)) {
00106	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00107	                {
00108	        __failure = 4;
00109	        if (!PyErr_Occurred()) {
00110	            PyErr_SetString(PyExc_RuntimeError,
00111	                "Unexpected error in an Op's C code. "
00112	                "No Python exception was set.");
00113	            }
00114	        goto __label_4;}
00115	            }
00116	            // We expect NPY_FLOAT64
00117	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00118	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00119	                PyErr_Format(PyExc_NotImplementedError,
00120	                             "expected an aligned array of type %ld "
00121	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00122	                             " with %ld dimensions, with 3 last dims "
00123	                             "%ld, %ld, %ld"
00124	                             " and 3 last strides %ld %ld, %ld.",
00125	                             (long int) NPY_FLOAT64,
00126	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00127	                             (long int) PyArray_NDIM(tmp),
00128	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00129	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00130	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00131	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00132	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00133	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00134	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00135	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00136	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00137	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00138	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00139	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00140	            );
00141	                {
00142	        __failure = 4;
00143	        if (!PyErr_Occurred()) {
00144	            PyErr_SetString(PyExc_RuntimeError,
00145	                "Unexpected error in an Op's C code. "
00146	                "No Python exception was set.");
00147	            }
00148	        goto __label_4;}
00149	            }
00150	            // This is a TypeError to be consistent with DEBUG_MODE
00151	            // Note: DEBUG_MODE also tells the name of the container
00152	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00153	                PyErr_Format(PyExc_TypeError,
00154	                             "expected type_num %d (NPY_FLOAT64) got %d",
00155	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00156	                {
00157	        __failure = 4;
00158	        if (!PyErr_Occurred()) {
00159	            PyErr_SetString(PyExc_RuntimeError,
00160	                "Unexpected error in an Op's C code. "
00161	                "No Python exception was set.");
00162	            }
00163	        goto __label_4;}
00164	            }
00165	            
00166	        V3 = (PyArrayObject*)(py_V3);
00167	        Py_XINCREF(V3);
00168	        
00169	{
00170	// Op class Elemwise
00171	
00172	        npy_float64* V3_iter;
00173	        
00174	                npy_intp V3_n0;
00175	                ssize_t V3_stride0;
00176	                int V3_jump0_0;
00177	                
00178	                npy_intp V3_n1;
00179	                ssize_t V3_stride1;
00180	                int V3_jump1_1;
00181	                
00182	
00183	            if (PyArray_NDIM(V3) < 2) {
00184	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00185	                {
00186	        __failure = 5;
00187	        if (!PyErr_Occurred()) {
00188	            PyErr_SetString(PyExc_RuntimeError,
00189	                "Unexpected error in an Op's C code. "
00190	                "No Python exception was set.");
00191	            }
00192	        goto __label_5;}
00193	            }
00194	            
00195	                V3_n1 = PyArray_DIMS(V3)[1];
00196	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00197	                V3_jump1_1 = (V3_stride1) - (0);
00198	                //printf("V3_jump1_1 is:");
00199	                //std::cout << V3_jump1_1 << std::endl;
00200	                
00201	                V3_n0 = PyArray_DIMS(V3)[0];
00202	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00203	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00204	                //printf("V3_jump0_0 is:");
00205	                //std::cout << V3_jump0_0 << std::endl;
00206	                
00207	
00208	            if (V1) {
00209	                Py_XDECREF(V1);
00210	            }
00211	            V1 = V3;
00212	            Py_XINCREF(V1);
00213	            
00214	
00215	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V1))){
00216	                
00217	                    // All output have the same size
00218	                    npy_intp n = PyArray_SIZE(V1);
00219	                    
00220	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00221	                            
00222	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00223	                            
00224	                    for(int i=0; i<n; i++){
00225	                        
00226	            dtype_V3& V3_i = V3_ptr[i];
00227	                            
00228	            dtype_V1& V1_i = V1_ptr[i];
00229	                            
00230	                        V1_i = tanh(V3_i);;
00231	                    }
00232	                    
00233	            }else{
00234	                {
00235	
00236	    std::vector< std::pair<int, int> > V3_loops(2);
00237	    std::vector< std::pair<int, int> >::iterator V3_loops_it = V3_loops.begin();
00238	    
00239	            V3_loops_it->first = abs(PyArray_STRIDES(V3)[0]);
00240	            
00241	        V3_loops_it->second = 0;
00242	        ++V3_loops_it;
00243	        
00244	            V3_loops_it->first = abs(PyArray_STRIDES(V3)[1]);
00245	            
00246	        V3_loops_it->second = 1;
00247	        ++V3_loops_it;
00248	        
00249	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00250	    std::sort(V3_loops.rbegin(), V3_loops.rend());
00251	    
00252	
00253	    int init_totals[2] = {V3_n0, V3_n1};
00254	    
00255	    V3_loops_it = V3_loops.begin();
00256	    
00257	        int TOTAL_0 = init_totals[V3_loops_it->second];
00258	        ++V3_loops_it;
00259	        
00260	        int TOTAL_1 = init_totals[V3_loops_it->second];
00261	        ++V3_loops_it;
00262	        
00263	
00264	    int init_strides[1][2] = {
00265	        V3_stride0, V3_stride1
00266	    };
00267	    std::vector< std::pair<int, int> >::reverse_iterator V3_loops_rit;
00268	    
00269	        V3_loops_rit = V3_loops.rbegin();
00270	            int V3_stride_l1 = init_strides[0][V3_loops_rit->second];
00271	            ++V3_loops_rit;
00272	            
00273	            int V3_stride_l0 = init_strides[0][V3_loops_rit->second];
00274	            ++V3_loops_rit;
00275	            
00276	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00277	
00278	
00279	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00280	        { // begin loop 0
00281	            
00282	            
00283	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00284	        { // begin loop 1
00285	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00286	
00287	            
00288	        {
00289	            #define V1_i V3_i
00290	
00291	            V1_i = tanh(V3_i);
00292	            #undef V1_i
00293	
00294	        }
00295	        
00296	        } // end loop 1
00297	        
00298	        } // end loop 0
00299	        
00300	}
00301	
00302	            }
00303	            __label_5:
00304	
00305	double __DUMMY_5;
00306	
00307	}
00308	__label_4:
00309	
00310	        if (V3) {
00311	            Py_XDECREF(V3);
00312	        }
00313	        
00314	    {Py_XDECREF(py_V3);}
00315	    
00316	double __DUMMY_4;
00317	
00318	}
00319	__label_2:
00320	
00321	    if (!__failure) {
00322	      
00323	        {Py_XDECREF(py_V1);}
00324	        if (!V1) {
00325	            Py_INCREF(Py_None);
00326	            py_V1 = Py_None;
00327	        }
00328	        else if ((void*)py_V1 != (void*)V1) {
00329	            py_V1 = (PyObject*)V1;
00330	        }
00331	
00332	        {Py_XINCREF(py_V1);}
00333	
00334	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00335	            PyErr_Format(PyExc_NotImplementedError,
00336	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00337	                         " with %ld dimensions, with 3 last dims "
00338	                         "%ld, %ld, %ld"
00339	                         " and 3 last strides %ld %ld, %ld.",
00340	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00341	                         (long int) PyArray_NDIM(V1),
00342	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00343	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00344	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00345	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00346	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00347	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00348	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00349	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00350	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00351	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00352	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00353	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00354	        );
00355	            {
00356	        __failure = 2;
00357	        if (!PyErr_Occurred()) {
00358	            PyErr_SetString(PyExc_RuntimeError,
00359	                "Unexpected error in an Op's C code. "
00360	                "No Python exception was set.");
00361	            }
00362	        goto __label_2;}
00363	        }
00364	        
00365	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00366	      {Py_XINCREF(py_V1);}
00367	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00368	      {Py_XDECREF(old);}
00369	    }
00370	    
00371	        if (V1) {
00372	            Py_XDECREF(V1);
00373	        }
00374	        
00375	    {Py_XDECREF(py_V1);}
00376	    
00377	double __DUMMY_2;
00378	
00379	}
00380	
00381	            
00382	        if (__failure) {
00383	            // When there is a failure, this code puts the exception
00384	            // in __ERROR.
00385	            PyObject* err_type = NULL;
00386	            PyObject* err_msg = NULL;
00387	            PyObject* err_traceback = NULL;
00388	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00389	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00390	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00391	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00392	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00393	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00394	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00395	            PyList_SET_ITEM(__ERROR, 0, err_type);
00396	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00397	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00398	            {Py_XDECREF(old_err_type);}
00399	            {Py_XDECREF(old_err_msg);}
00400	            {Py_XDECREF(old_err_traceback);}
00401	        }
00402	        // The failure code is returned to index what code block failed.
00403	        return __failure;
00404	        
00405	        }
00406	    };
00407	    }
00408	    
00409	
00410	        static int __struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a_executor(__struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a* self) {
00411	            return self->run();
00412	        }
00413	
00414	        static void __struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a_destructor(void* executor, void* self) {
00415	            delete ((__struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a*)self);
00416	        }
00417	        
00418	//////////////////////
00419	////  Functions
00420	//////////////////////
00421	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00422	  assert(PyTuple_Check(argtuple));
00423	  if (3 != PyTuple_Size(argtuple)){ 
00424	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 3, got %i", (int)PyTuple_Size(argtuple));
00425	     return NULL;
00426	  }
00427	  __struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a* struct_ptr = new __struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a();
00428	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2) ) != 0) {
00429	    delete struct_ptr;
00430	    return NULL;
00431	  }
00432	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a_executor), struct_ptr, __struct_compiled_op_cab6cd8eb6732e2886f7102c5721604a_destructor);
00433	  return thunk; }
00434	
00435	//////////////////////
00436	////  Module init
00437	//////////////////////
00438	static PyMethodDef MyMethods[] = {
00439		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00440		{NULL, NULL, 0, NULL}
00441	};
00442	PyMODINIT_FUNC initcab6cd8eb6732e2886f7102c5721604a(void){
00443	   import_array();
00444	   (void) Py_InitModule("cab6cd8eb6732e2886f7102c5721604a", MyMethods);
00445	}
00446	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpnbb0la/cab6cd8eb6732e2886f7102c5721604a.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpnbb0la/mod.cpp -lpython2.7
ERROR
theano.compile.tests.test_mode.test_including ... ok
test1 (theano.compile.tests.test_modes.T_bunch_of_modes) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                npy_intp V3_n0;
00273	                ssize_t V3_stride0;
00274	                int V3_jump0_0;
00275	                
00276	                npy_intp V3_n1;
00277	                ssize_t V3_stride1;
00278	                int V3_jump1_1;
00279	                
00280	        npy_float64* V5_iter;
00281	        
00282	                int V5_jumpx_0;
00283	                
00284	                npy_intp V5_n1;
00285	                ssize_t V5_stride1;
00286	                int V5_jump1_1;
00287	                
00288	
00289	            if (PyArray_NDIM(V3) < 2) {
00290	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00291	                {
00292	        __failure = 7;
00293	        if (!PyErr_Occurred()) {
00294	            PyErr_SetString(PyExc_RuntimeError,
00295	                "Unexpected error in an Op's C code. "
00296	                "No Python exception was set.");
00297	            }
00298	        goto __label_7;}
00299	            }
00300	            
00301	                V3_n1 = PyArray_DIMS(V3)[1];
00302	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00303	                V3_jump1_1 = (V3_stride1) - (0);
00304	                //printf("V3_jump1_1 is:");
00305	                //std::cout << V3_jump1_1 << std::endl;
00306	                
00307	                V3_n0 = PyArray_DIMS(V3)[0];
00308	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00309	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00310	                //printf("V3_jump0_0 is:");
00311	                //std::cout << V3_jump0_0 << std::endl;
00312	                
00313	            if (PyArray_NDIM(V5) < 2) {
00314	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00315	                {
00316	        __failure = 7;
00317	        if (!PyErr_Occurred()) {
00318	            PyErr_SetString(PyExc_RuntimeError,
00319	                "Unexpected error in an Op's C code. "
00320	                "No Python exception was set.");
00321	            }
00322	        goto __label_7;}
00323	            }
00324	            
00325	                V5_n1 = PyArray_DIMS(V5)[1];
00326	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00327	                V5_jump1_1 = (V5_stride1) - (0);
00328	                //printf("V5_jump1_1 is:");
00329	                //std::cout << V5_jump1_1 << std::endl;
00330	                
00331	                V5_jumpx_0 = -(V5_n1*V5_stride1);
00332	                //printf("V5_jumpx_0 is:");
00333	                //std::cout << V5_jumpx_0 << std::endl;
00334	                
00335	            if (V3_n1 != V5_n1)
00336	            {
00337	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00338	                   0,
00339	                   1,
00340	                   V3_n1,
00341	                   1,
00342	                   1,
00343	                   V5_n1
00344	                );
00345	                {
00346	        __failure = 7;
00347	        if (!PyErr_Occurred()) {
00348	            PyErr_SetString(PyExc_RuntimeError,
00349	                "Unexpected error in an Op's C code. "
00350	                "No Python exception was set.");
00351	            }
00352	        goto __label_7;}
00353	            }
00354	            
00355	
00356	        npy_float64* V1_iter;
00357	        
00358	                npy_intp V1_n0;
00359	                ssize_t V1_stride0;
00360	                int V1_jump0_0;
00361	                
00362	                npy_intp V1_n1;
00363	                ssize_t V1_stride1;
00364	                int V1_jump1_1;
00365	                
00366	    {
00367	        npy_intp dims[2];
00368	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00369	        dims[0] = V3_n0;
00370	dims[1] = V3_n1;
00371	
00372	        if (!V1) {
00373	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00374	                                                    NPY_FLOAT64,
00375	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00376	        }
00377	        else {
00378	            PyArray_Dims new_dims;
00379	            new_dims.len = 2;
00380	            new_dims.ptr = dims;
00381	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00382	            if (!success) {
00383	                // If we can't resize the ndarray we have we can allocate a new one.
00384	                PyErr_Clear();
00385	                Py_XDECREF(V1);
00386	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00387	            }
00388	        }
00389	        if (!V1) {
00390	            {
00391	        __failure = 7;
00392	        if (!PyErr_Occurred()) {
00393	            PyErr_SetString(PyExc_RuntimeError,
00394	                "Unexpected error in an Op's C code. "
00395	                "No Python exception was set.");
00396	            }
00397	        goto __label_7;}
00398	        }
00399	    }
00400	    
00401	            if (PyArray_NDIM(V1) < 2) {
00402	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00403	                {
00404	        __failure = 7;
00405	        if (!PyErr_Occurred()) {
00406	            PyErr_SetString(PyExc_RuntimeError,
00407	                "Unexpected error in an Op's C code. "
00408	                "No Python exception was set.");
00409	            }
00410	        goto __label_7;}
00411	            }
00412	            
00413	                V1_n1 = PyArray_DIMS(V1)[1];
00414	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00415	                V1_jump1_1 = (V1_stride1) - (0);
00416	                //printf("V1_jump1_1 is:");
00417	                //std::cout << V1_jump1_1 << std::endl;
00418	                
00419	                V1_n0 = PyArray_DIMS(V1)[0];
00420	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00421	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00422	                //printf("V1_jump0_0 is:");
00423	                //std::cout << V1_jump0_0 << std::endl;
00424	                
00425	{
00426	
00427	    std::vector< std::pair<int, int> > V1_loops(2);
00428	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00429	    
00430	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00431	            
00432	        V1_loops_it->second = 0;
00433	        ++V1_loops_it;
00434	        
00435	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00436	            
00437	        V1_loops_it->second = 1;
00438	        ++V1_loops_it;
00439	        
00440	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00441	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00442	    
00443	
00444	    int init_totals[2] = {V3_n0, V3_n1};
00445	    
00446	    V1_loops_it = V1_loops.begin();
00447	    
00448	        int TOTAL_0 = init_totals[V1_loops_it->second];
00449	        ++V1_loops_it;
00450	        
00451	        int TOTAL_1 = init_totals[V1_loops_it->second];
00452	        ++V1_loops_it;
00453	        
00454	
00455	    int init_strides[3][2] = {
00456	        V3_stride0, V3_stride1, 
00457	0, V5_stride1, 
00458	V1_stride0, V1_stride1
00459	    };
00460	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00461	    
00462	        V1_loops_rit = V1_loops.rbegin();
00463	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00464	            ++V1_loops_rit;
00465	            
00466	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00467	            ++V1_loops_rit;
00468	            
00469	        V1_loops_rit = V1_loops.rbegin();
00470	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00471	            ++V1_loops_rit;
00472	            
00473	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00474	            ++V1_loops_rit;
00475	            
00476	        V1_loops_rit = V1_loops.rbegin();
00477	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00478	            ++V1_loops_rit;
00479	            
00480	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00481	            ++V1_loops_rit;
00482	            
00483	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00484	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00485	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00486	
00487	
00488	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00489	        { // begin loop 0
00490	            
00491	            
00492	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00493	        { // begin loop 1
00494	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00495	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00496	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00497	
00498	            
00499	        {
00500	            
00501	            V1_i = V3_i + V5_i;
00502	            
00503	        }
00504	        
00505	        } // end loop 1
00506	        
00507	        } // end loop 0
00508	        
00509	}
00510	__label_7:
00511	
00512	double __DUMMY_7;
00513	
00514	}
00515	__label_6:
00516	
00517	        if (V5) {
00518	            Py_XDECREF(V5);
00519	        }
00520	        
00521	    {Py_XDECREF(py_V5);}
00522	    
00523	double __DUMMY_6;
00524	
00525	}
00526	__label_4:
00527	
00528	        if (V3) {
00529	            Py_XDECREF(V3);
00530	        }
00531	        
00532	    {Py_XDECREF(py_V3);}
00533	    
00534	double __DUMMY_4;
00535	
00536	}
00537	__label_2:
00538	
00539	    if (!__failure) {
00540	      
00541	        {Py_XDECREF(py_V1);}
00542	        if (!V1) {
00543	            Py_INCREF(Py_None);
00544	            py_V1 = Py_None;
00545	        }
00546	        else if ((void*)py_V1 != (void*)V1) {
00547	            py_V1 = (PyObject*)V1;
00548	        }
00549	
00550	        {Py_XINCREF(py_V1);}
00551	
00552	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00553	            PyErr_Format(PyExc_NotImplementedError,
00554	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00555	                         " with %ld dimensions, with 3 last dims "
00556	                         "%ld, %ld, %ld"
00557	                         " and 3 last strides %ld %ld, %ld.",
00558	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00559	                         (long int) PyArray_NDIM(V1),
00560	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00561	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00562	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00563	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00564	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00565	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00566	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00567	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00568	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00569	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00570	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00571	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00572	        );
00573	            {
00574	        __failure = 2;
00575	        if (!PyErr_Occurred()) {
00576	            PyErr_SetString(PyExc_RuntimeError,
00577	                "Unexpected error in an Op's C code. "
00578	                "No Python exception was set.");
00579	            }
00580	        goto __label_2;}
00581	        }
00582	        
00583	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00584	      {Py_XINCREF(py_V1);}
00585	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00586	      {Py_XDECREF(old);}
00587	    }
00588	    
00589	        if (V1) {
00590	            Py_XDECREF(V1);
00591	        }
00592	        
00593	    {Py_XDECREF(py_V1);}
00594	    
00595	double __DUMMY_2;
00596	
00597	}
00598	
00599	            
00600	        if (__failure) {
00601	            // When there is a failure, this code puts the exception
00602	            // in __ERROR.
00603	            PyObject* err_type = NULL;
00604	            PyObject* err_msg = NULL;
00605	            PyObject* err_traceback = NULL;
00606	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00607	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00608	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00609	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00610	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00611	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00612	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00613	            PyList_SET_ITEM(__ERROR, 0, err_type);
00614	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00615	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00616	            {Py_XDECREF(old_err_type);}
00617	            {Py_XDECREF(old_err_msg);}
00618	            {Py_XDECREF(old_err_traceback);}
00619	        }
00620	        // The failure code is returned to index what code block failed.
00621	        return __failure;
00622	        
00623	        }
00624	    };
00625	    }
00626	    
00627	
00628	        static int __struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4_executor(__struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4* self) {
00629	            return self->run();
00630	        }
00631	
00632	        static void __struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4_destructor(void* executor, void* self) {
00633	            delete ((__struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4*)self);
00634	        }
00635	        
00636	//////////////////////
00637	////  Functions
00638	//////////////////////
00639	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00640	  assert(PyTuple_Check(argtuple));
00641	  if (4 != PyTuple_Size(argtuple)){ 
00642	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00643	     return NULL;
00644	  }
00645	  __struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4* struct_ptr = new __struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4();
00646	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00647	    delete struct_ptr;
00648	    return NULL;
00649	  }
00650	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4_executor), struct_ptr, __struct_compiled_op_bf5683e7cf675fbd5b5ef3248bca06e4_destructor);
00651	  return thunk; }
00652	
00653	//////////////////////
00654	////  Module init
00655	//////////////////////
00656	static PyMethodDef MyMethods[] = {
00657		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00658		{NULL, NULL, 0, NULL}
00659	};
00660	PyMODINIT_FUNC initbf5683e7cf675fbd5b5ef3248bca06e4(void){
00661	   import_array();
00662	   (void) Py_InitModule("bf5683e7cf675fbd5b5ef3248bca06e4", MyMethods);
00663	}
00664	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp52IGKp/bf5683e7cf675fbd5b5ef3248bca06e4.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp52IGKp/mod.cpp -lpython2.7
ERROR
test_1 (theano.compile.tests.test_modes.T_old_problem) ... ok
Test the code snippet example that detects NaN values. ... ok
Test that we can remove optimizer ... ok
Test that we can remove optimizers including inplace optimizers ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V1;
00019	        
00020	
00021	        __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154() {
00022	            // This is only somewhat safe because we:
00023	            //  1) Are not a virtual class
00024	            //  2) Do not use any virtual classes in the members
00025	            //  3) Deal with mostly POD and pointers
00026	
00027	            // If this changes, we would have to revise this, but for
00028	            // now I am tired of chasing segfaults because
00029	            // initialization code had an error and some pointer has
00030	            // a junk value.
00031	            memset(this, 0, sizeof(*this));
00032	        }
00033	        ~__struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154(void) {
00034	            cleanup();
00035	        }
00036	
00037	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V1) {
00038	            Py_XINCREF(storage_V3);
00039	Py_XINCREF(storage_V1);
00040	            this->storage_V3 = storage_V3;
00041	this->storage_V1 = storage_V1;
00042	            
00043	
00044	
00045	
00046	            this->__ERROR = __ERROR;
00047	            return 0;
00048	        }
00049	        void cleanup(void) {
00050	            __label_1:
00051	
00052	double __DUMMY_1;
00053	__label_3:
00054	
00055	double __DUMMY_3;
00056	__label_6:
00057	
00058	double __DUMMY_6;
00059	
00060	            Py_XDECREF(this->storage_V3);
00061	Py_XDECREF(this->storage_V1);
00062	        }
00063	        int run(void) {
00064	            int __failure = 0;
00065	            
00066	    PyObject* py_V1;
00067	    
00068	        PyArrayObject* V1;
00069	        
00070	            typedef npy_float64 dtype_V1;
00071	            
00072	    PyObject* py_V3;
00073	    
00074	        PyArrayObject* V3;
00075	        
00076	            typedef npy_float64 dtype_V3;
00077	            
00078	{
00079	
00080	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00081	    {Py_XINCREF(py_V1);}
00082	    
00083	        if (py_V1 == Py_None)
00084	        {
00085	            
00086	        V1 = NULL;
00087	        
00088	        }
00089	        else
00090	        {
00091	            
00092	            V1 = NULL;
00093	            if (py_V1 == Py_None) {
00094	                // We can either fail here or set V1 to NULL and rely on Ops
00095	                // using tensors to handle the NULL case, but if they fail to do so
00096	                // they'll end up with nasty segfaults, so this is public service.
00097	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00098	                {
00099	        __failure = 2;
00100	        if (!PyErr_Occurred()) {
00101	            PyErr_SetString(PyExc_RuntimeError,
00102	                "Unexpected error in an Op's C code. "
00103	                "No Python exception was set.");
00104	            }
00105	        goto __label_2;}
00106	            }
00107	            if (!PyArray_Check(py_V1)) {
00108	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00109	                {
00110	        __failure = 2;
00111	        if (!PyErr_Occurred()) {
00112	            PyErr_SetString(PyExc_RuntimeError,
00113	                "Unexpected error in an Op's C code. "
00114	                "No Python exception was set.");
00115	            }
00116	        goto __label_2;}
00117	            }
00118	            // We expect NPY_FLOAT64
00119	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00120	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00121	                PyErr_Format(PyExc_NotImplementedError,
00122	                             "expected an aligned array of type %ld "
00123	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00124	                             " with %ld dimensions, with 3 last dims "
00125	                             "%ld, %ld, %ld"
00126	                             " and 3 last strides %ld %ld, %ld.",
00127	                             (long int) NPY_FLOAT64,
00128	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00129	                             (long int) PyArray_NDIM(tmp),
00130	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00131	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00132	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00133	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00134	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00135	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00136	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00137	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00138	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00139	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00140	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00141	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00142	            );
00143	                {
00144	        __failure = 2;
00145	        if (!PyErr_Occurred()) {
00146	            PyErr_SetString(PyExc_RuntimeError,
00147	                "Unexpected error in an Op's C code. "
00148	                "No Python exception was set.");
00149	            }
00150	        goto __label_2;}
00151	            }
00152	            // This is a TypeError to be consistent with DEBUG_MODE
00153	            // Note: DEBUG_MODE also tells the name of the container
00154	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00155	                PyErr_Format(PyExc_TypeError,
00156	                             "expected type_num %d (NPY_FLOAT64) got %d",
00157	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00158	                {
00159	        __failure = 2;
00160	        if (!PyErr_Occurred()) {
00161	            PyErr_SetString(PyExc_RuntimeError,
00162	                "Unexpected error in an Op's C code. "
00163	                "No Python exception was set.");
00164	            }
00165	        goto __label_2;}
00166	            }
00167	            
00168	        V1 = (PyArrayObject*)(py_V1);
00169	        Py_XINCREF(V1);
00170	        
00171	        }
00172	        
00173	{
00174	
00175	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00176	    {Py_XINCREF(py_V3);}
00177	    
00178	            V3 = NULL;
00179	            if (py_V3 == Py_None) {
00180	                // We can either fail here or set V3 to NULL and rely on Ops
00181	                // using tensors to handle the NULL case, but if they fail to do so
00182	                // they'll end up with nasty segfaults, so this is public service.
00183	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            if (!PyArray_Check(py_V3)) {
00194	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00195	                {
00196	        __failure = 4;
00197	        if (!PyErr_Occurred()) {
00198	            PyErr_SetString(PyExc_RuntimeError,
00199	                "Unexpected error in an Op's C code. "
00200	                "No Python exception was set.");
00201	            }
00202	        goto __label_4;}
00203	            }
00204	            // We expect NPY_FLOAT64
00205	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00206	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00207	                PyErr_Format(PyExc_NotImplementedError,
00208	                             "expected an aligned array of type %ld "
00209	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00210	                             " with %ld dimensions, with 3 last dims "
00211	                             "%ld, %ld, %ld"
00212	                             " and 3 last strides %ld %ld, %ld.",
00213	                             (long int) NPY_FLOAT64,
00214	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00215	                             (long int) PyArray_NDIM(tmp),
00216	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00217	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00218	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00219	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00220	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00221	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00222	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00223	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00224	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00225	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00226	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00227	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00228	            );
00229	                {
00230	        __failure = 4;
00231	        if (!PyErr_Occurred()) {
00232	            PyErr_SetString(PyExc_RuntimeError,
00233	                "Unexpected error in an Op's C code. "
00234	                "No Python exception was set.");
00235	            }
00236	        goto __label_4;}
00237	            }
00238	            // This is a TypeError to be consistent with DEBUG_MODE
00239	            // Note: DEBUG_MODE also tells the name of the container
00240	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00241	                PyErr_Format(PyExc_TypeError,
00242	                             "expected type_num %d (NPY_FLOAT64) got %d",
00243	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00244	                {
00245	        __failure = 4;
00246	        if (!PyErr_Occurred()) {
00247	            PyErr_SetString(PyExc_RuntimeError,
00248	                "Unexpected error in an Op's C code. "
00249	                "No Python exception was set.");
00250	            }
00251	        goto __label_4;}
00252	            }
00253	            
00254	        V3 = (PyArrayObject*)(py_V3);
00255	        Py_XINCREF(V3);
00256	        
00257	{
00258	// Op class Elemwise
00259	
00260	        npy_float64* V3_iter;
00261	        
00262	                npy_intp V3_n0;
00263	                ssize_t V3_stride0;
00264	                int V3_jump0_0;
00265	                
00266	                npy_intp V3_n1;
00267	                ssize_t V3_stride1;
00268	                int V3_jump1_1;
00269	                
00270	
00271	            if (PyArray_NDIM(V3) < 2) {
00272	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00273	                {
00274	        __failure = 5;
00275	        if (!PyErr_Occurred()) {
00276	            PyErr_SetString(PyExc_RuntimeError,
00277	                "Unexpected error in an Op's C code. "
00278	                "No Python exception was set.");
00279	            }
00280	        goto __label_5;}
00281	            }
00282	            
00283	                V3_n1 = PyArray_DIMS(V3)[1];
00284	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00285	                V3_jump1_1 = (V3_stride1) - (0);
00286	                //printf("V3_jump1_1 is:");
00287	                //std::cout << V3_jump1_1 << std::endl;
00288	                
00289	                V3_n0 = PyArray_DIMS(V3)[0];
00290	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00291	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00292	                //printf("V3_jump0_0 is:");
00293	                //std::cout << V3_jump0_0 << std::endl;
00294	                
00295	
00296	        npy_float64* V1_iter;
00297	        
00298	                npy_intp V1_n0;
00299	                ssize_t V1_stride0;
00300	                int V1_jump0_0;
00301	                
00302	                npy_intp V1_n1;
00303	                ssize_t V1_stride1;
00304	                int V1_jump1_1;
00305	                
00306	    {
00307	        npy_intp dims[2];
00308	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00309	        dims[0] = V3_n0;
00310	dims[1] = V3_n1;
00311	
00312	        if (!V1) {
00313	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00314	                                                    NPY_FLOAT64,
00315	                                                    PyArray_ISFORTRAN(V3));
00316	        }
00317	        else {
00318	            PyArray_Dims new_dims;
00319	            new_dims.len = 2;
00320	            new_dims.ptr = dims;
00321	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00322	            if (!success) {
00323	                // If we can't resize the ndarray we have we can allocate a new one.
00324	                PyErr_Clear();
00325	                Py_XDECREF(V1);
00326	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00327	            }
00328	        }
00329	        if (!V1) {
00330	            {
00331	        __failure = 5;
00332	        if (!PyErr_Occurred()) {
00333	            PyErr_SetString(PyExc_RuntimeError,
00334	                "Unexpected error in an Op's C code. "
00335	                "No Python exception was set.");
00336	            }
00337	        goto __label_5;}
00338	        }
00339	    }
00340	    
00341	            if (PyArray_NDIM(V1) < 2) {
00342	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00343	                {
00344	        __failure = 5;
00345	        if (!PyErr_Occurred()) {
00346	            PyErr_SetString(PyExc_RuntimeError,
00347	                "Unexpected error in an Op's C code. "
00348	                "No Python exception was set.");
00349	            }
00350	        goto __label_5;}
00351	            }
00352	            
00353	                V1_n1 = PyArray_DIMS(V1)[1];
00354	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00355	                V1_jump1_1 = (V1_stride1) - (0);
00356	                //printf("V1_jump1_1 is:");
00357	                //std::cout << V1_jump1_1 << std::endl;
00358	                
00359	                V1_n0 = PyArray_DIMS(V1)[0];
00360	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00361	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00362	                //printf("V1_jump0_0 is:");
00363	                //std::cout << V1_jump0_0 << std::endl;
00364	                
00365	
00366	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V1))){
00367	                
00368	                    // All output have the same size
00369	                    npy_intp n = PyArray_SIZE(V1);
00370	                    
00371	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00372	                            
00373	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00374	                            
00375	                    for(int i=0; i<n; i++){
00376	                        
00377	            dtype_V3& V3_i = V3_ptr[i];
00378	                            
00379	            dtype_V1& V1_i = V1_ptr[i];
00380	                            
00381	                        V1_i = log(V3_i);;
00382	                    }
00383	                    
00384	            }else{
00385	                {
00386	
00387	    std::vector< std::pair<int, int> > V1_loops(2);
00388	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00389	    
00390	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00391	            
00392	        V1_loops_it->second = 0;
00393	        ++V1_loops_it;
00394	        
00395	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00396	            
00397	        V1_loops_it->second = 1;
00398	        ++V1_loops_it;
00399	        
00400	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00401	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00402	    
00403	
00404	    int init_totals[2] = {V3_n0, V3_n1};
00405	    
00406	    V1_loops_it = V1_loops.begin();
00407	    
00408	        int TOTAL_0 = init_totals[V1_loops_it->second];
00409	        ++V1_loops_it;
00410	        
00411	        int TOTAL_1 = init_totals[V1_loops_it->second];
00412	        ++V1_loops_it;
00413	        
00414	
00415	    int init_strides[2][2] = {
00416	        V3_stride0, V3_stride1, 
00417	V1_stride0, V1_stride1
00418	    };
00419	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00420	    
00421	        V1_loops_rit = V1_loops.rbegin();
00422	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00423	            ++V1_loops_rit;
00424	            
00425	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00426	            ++V1_loops_rit;
00427	            
00428	        V1_loops_rit = V1_loops.rbegin();
00429	            int V1_stride_l1 = init_strides[1][V1_loops_rit->second];
00430	            ++V1_loops_rit;
00431	            
00432	            int V1_stride_l0 = init_strides[1][V1_loops_rit->second];
00433	            ++V1_loops_rit;
00434	            
00435	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00436	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00437	
00438	
00439	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00440	        { // begin loop 0
00441	            
00442	            
00443	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00444	        { // begin loop 1
00445	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00446	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00447	
00448	            
00449	        {
00450	            
00451	            V1_i = log(V3_i);
00452	            
00453	        }
00454	        
00455	        } // end loop 1
00456	        
00457	        } // end loop 0
00458	        
00459	}
00460	
00461	            }
00462	            __label_5:
00463	
00464	double __DUMMY_5;
00465	
00466	}
00467	__label_4:
00468	
00469	        if (V3) {
00470	            Py_XDECREF(V3);
00471	        }
00472	        
00473	    {Py_XDECREF(py_V3);}
00474	    
00475	double __DUMMY_4;
00476	
00477	}
00478	__label_2:
00479	
00480	    if (!__failure) {
00481	      
00482	        {Py_XDECREF(py_V1);}
00483	        if (!V1) {
00484	            Py_INCREF(Py_None);
00485	            py_V1 = Py_None;
00486	        }
00487	        else if ((void*)py_V1 != (void*)V1) {
00488	            py_V1 = (PyObject*)V1;
00489	        }
00490	
00491	        {Py_XINCREF(py_V1);}
00492	
00493	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00494	            PyErr_Format(PyExc_NotImplementedError,
00495	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00496	                         " with %ld dimensions, with 3 last dims "
00497	                         "%ld, %ld, %ld"
00498	                         " and 3 last strides %ld %ld, %ld.",
00499	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00500	                         (long int) PyArray_NDIM(V1),
00501	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00502	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00503	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00504	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00505	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00506	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00507	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00508	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00509	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00510	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00511	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00512	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00513	        );
00514	            {
00515	        __failure = 2;
00516	        if (!PyErr_Occurred()) {
00517	            PyErr_SetString(PyExc_RuntimeError,
00518	                "Unexpected error in an Op's C code. "
00519	                "No Python exception was set.");
00520	            }
00521	        goto __label_2;}
00522	        }
00523	        
00524	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00525	      {Py_XINCREF(py_V1);}
00526	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00527	      {Py_XDECREF(old);}
00528	    }
00529	    
00530	        if (V1) {
00531	            Py_XDECREF(V1);
00532	        }
00533	        
00534	    {Py_XDECREF(py_V1);}
00535	    
00536	double __DUMMY_2;
00537	
00538	}
00539	
00540	            
00541	        if (__failure) {
00542	            // When there is a failure, this code puts the exception
00543	            // in __ERROR.
00544	            PyObject* err_type = NULL;
00545	            PyObject* err_msg = NULL;
00546	            PyObject* err_traceback = NULL;
00547	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00548	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00549	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00550	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00551	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00552	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00553	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00554	            PyList_SET_ITEM(__ERROR, 0, err_type);
00555	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00556	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00557	            {Py_XDECREF(old_err_type);}
00558	            {Py_XDECREF(old_err_msg);}
00559	            {Py_XDECREF(old_err_traceback);}
00560	        }
00561	        // The failure code is returned to index what code block failed.
00562	        return __failure;
00563	        
00564	        }
00565	    };
00566	    }
00567	    
00568	
00569	        static int __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154_executor(__struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154* self) {
00570	            return self->run();
00571	        }
00572	
00573	        static void __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154_destructor(void* executor, void* self) {
00574	            delete ((__struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154*)self);
00575	        }
00576	        
00577	//////////////////////
00578	////  Functions
00579	//////////////////////
00580	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00581	  assert(PyTuple_Check(argtuple));
00582	  if (3 != PyTuple_Size(argtuple)){ 
00583	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 3, got %i", (int)PyTuple_Size(argtuple));
00584	     return NULL;
00585	  }
00586	  __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154* struct_ptr = new __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154();
00587	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2) ) != 0) {
00588	    delete struct_ptr;
00589	    return NULL;
00590	  }
00591	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154_executor), struct_ptr, __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154_destructor);
00592	  return thunk; }
00593	
00594	//////////////////////
00595	////  Module init
00596	//////////////////////
00597	static PyMethodDef MyMethods[] = {
00598		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00599		{NULL, NULL, 0, NULL}
00600	};
00601	PyMODINIT_FUNC initaebb6fadc52c9a62c8fc5c2d16c76154(void){
00602	   import_array();
00603	   (void) Py_InitModule("aebb6fadc52c9a62c8fc5c2d16c76154", MyMethods);
00604	}
00605	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpgMCJlM/aebb6fadc52c9a62c8fc5c2d16c76154.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpgMCJlM/mod.cpp -lpython2.7
ERROR
theano.compile.tests.test_nanguardmode.test_NanGuardMode ... /<<BUILDDIR>>/theano-0.9.0+dfsg/theano/compile/nanguardmode.py:168: RuntimeWarning: All-NaN slice encountered
  return np.isinf(np.nanmax(arr)) or np.isinf(np.nanmin(arr))
/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/compile/nanguardmode.py:168: RuntimeWarning: All-NaN axis encountered
  return np.isinf(np.nanmax(arr)) or np.isinf(np.nanmin(arr))
ok
test_1arg (theano.compile.tests.test_ops.OpDecoratorTests) ... ok
test_2arg (theano.compile.tests.test_ops.OpDecoratorTests) ... ok
test_infer_shape (theano.compile.tests.test_ops.OpDecoratorTests) ... ok
test_pickle (theano.compile.tests.test_ops.OpDecoratorTests) ... ok
theano.compile.tests.test_ops.test_shape_i_hash ... ok
test_input_aliasing_affecting_inplace_operations (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... ok
test_no_aliasing_0 (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... ok
test_no_aliasing_1 (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... ok
test_no_aliasing_2 (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... ok
test_no_aliasing_2b (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... ok
test_partial_input_aliasing_affecting_inplace_operations (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... ok
test_potential_output_aliasing_induced_by_updates (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_a4c07a04bf0767d3a33702daad982088 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_a4c07a04bf0767d3a33702daad982088() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_a4c07a04bf0767d3a33702daad982088(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                int V3_jumpx_0;
00273	                
00274	                int V3_jumpx_1;
00275	                
00276	        npy_float64* V5_iter;
00277	        
00278	                npy_intp V5_n0;
00279	                ssize_t V5_stride0;
00280	                int V5_jump0_0;
00281	                
00282	                npy_intp V5_n1;
00283	                ssize_t V5_stride1;
00284	                int V5_jump1_1;
00285	                
00286	
00287	                V3_jumpx_1 = -(0);
00288	                //printf("V3_jumpx_1 is:");
00289	                //std::cout << V3_jumpx_1 << std::endl;
00290	                
00291	                V3_jumpx_0 = -(0);
00292	                //printf("V3_jumpx_0 is:");
00293	                //std::cout << V3_jumpx_0 << std::endl;
00294	                
00295	            if (PyArray_NDIM(V5) < 2) {
00296	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00297	                {
00298	        __failure = 7;
00299	        if (!PyErr_Occurred()) {
00300	            PyErr_SetString(PyExc_RuntimeError,
00301	                "Unexpected error in an Op's C code. "
00302	                "No Python exception was set.");
00303	            }
00304	        goto __label_7;}
00305	            }
00306	            
00307	                V5_n1 = PyArray_DIMS(V5)[1];
00308	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00309	                V5_jump1_1 = (V5_stride1) - (0);
00310	                //printf("V5_jump1_1 is:");
00311	                //std::cout << V5_jump1_1 << std::endl;
00312	                
00313	                V5_n0 = PyArray_DIMS(V5)[0];
00314	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00315	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00316	                //printf("V5_jump0_0 is:");
00317	                //std::cout << V5_jump0_0 << std::endl;
00318	                
00319	
00320	        npy_float64* V1_iter;
00321	        
00322	                npy_intp V1_n0;
00323	                ssize_t V1_stride0;
00324	                int V1_jump0_0;
00325	                
00326	                npy_intp V1_n1;
00327	                ssize_t V1_stride1;
00328	                int V1_jump1_1;
00329	                
00330	    {
00331	        npy_intp dims[2];
00332	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00333	        dims[0] = V5_n0;
00334	dims[1] = V5_n1;
00335	
00336	        if (!V1) {
00337	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00338	                                                    NPY_FLOAT64,
00339	                                                    PyArray_ISFORTRAN(V5));
00340	        }
00341	        else {
00342	            PyArray_Dims new_dims;
00343	            new_dims.len = 2;
00344	            new_dims.ptr = dims;
00345	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00346	            if (!success) {
00347	                // If we can't resize the ndarray we have we can allocate a new one.
00348	                PyErr_Clear();
00349	                Py_XDECREF(V1);
00350	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00351	            }
00352	        }
00353	        if (!V1) {
00354	            {
00355	        __failure = 7;
00356	        if (!PyErr_Occurred()) {
00357	            PyErr_SetString(PyExc_RuntimeError,
00358	                "Unexpected error in an Op's C code. "
00359	                "No Python exception was set.");
00360	            }
00361	        goto __label_7;}
00362	        }
00363	    }
00364	    
00365	            if (PyArray_NDIM(V1) < 2) {
00366	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00367	                {
00368	        __failure = 7;
00369	        if (!PyErr_Occurred()) {
00370	            PyErr_SetString(PyExc_RuntimeError,
00371	                "Unexpected error in an Op's C code. "
00372	                "No Python exception was set.");
00373	            }
00374	        goto __label_7;}
00375	            }
00376	            
00377	                V1_n1 = PyArray_DIMS(V1)[1];
00378	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00379	                V1_jump1_1 = (V1_stride1) - (0);
00380	                //printf("V1_jump1_1 is:");
00381	                //std::cout << V1_jump1_1 << std::endl;
00382	                
00383	                V1_n0 = PyArray_DIMS(V1)[0];
00384	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00385	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00386	                //printf("V1_jump0_0 is:");
00387	                //std::cout << V1_jump0_0 << std::endl;
00388	                
00389	
00390	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00391	                
00392	                    // All output have the same size
00393	                    npy_intp n = PyArray_SIZE(V1);
00394	                    
00395	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00396	                            
00397	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00398	                            
00399	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00400	                            
00401	                    for(int i=0; i<n; i++){
00402	                        
00403	            dtype_V5& V5_i = V5_ptr[i];
00404	                            
00405	            dtype_V1& V1_i = V1_ptr[i];
00406	                            
00407	                        V1_i = V3_i + V5_i;;
00408	                    }
00409	                    
00410	            }else{
00411	                {
00412	
00413	    std::vector< std::pair<int, int> > V1_loops(2);
00414	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00415	    
00416	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00417	            
00418	        V1_loops_it->second = 0;
00419	        ++V1_loops_it;
00420	        
00421	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00422	            
00423	        V1_loops_it->second = 1;
00424	        ++V1_loops_it;
00425	        
00426	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00427	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00428	    
00429	
00430	    int init_totals[2] = {V5_n0, V5_n1};
00431	    
00432	    V1_loops_it = V1_loops.begin();
00433	    
00434	        int TOTAL_0 = init_totals[V1_loops_it->second];
00435	        ++V1_loops_it;
00436	        
00437	        int TOTAL_1 = init_totals[V1_loops_it->second];
00438	        ++V1_loops_it;
00439	        
00440	
00441	    int init_strides[3][2] = {
00442	        0, 0, 
00443	V5_stride0, V5_stride1, 
00444	V1_stride0, V1_stride1
00445	    };
00446	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00447	    
00448	        V1_loops_rit = V1_loops.rbegin();
00449	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00450	            ++V1_loops_rit;
00451	            
00452	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00453	            ++V1_loops_rit;
00454	            
00455	        V1_loops_rit = V1_loops.rbegin();
00456	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00457	            ++V1_loops_rit;
00458	            
00459	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00460	            ++V1_loops_rit;
00461	            
00462	        V1_loops_rit = V1_loops.rbegin();
00463	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00464	            ++V1_loops_rit;
00465	            
00466	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00467	            ++V1_loops_rit;
00468	            
00469	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00470	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00471	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00472	
00473	
00474	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00475	        { // begin loop 0
00476	            
00477	            
00478	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00479	        { // begin loop 1
00480	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00481	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00482	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00483	
00484	            
00485	        {
00486	            
00487	            V1_i = V3_i + V5_i;
00488	            
00489	        }
00490	        
00491	        } // end loop 1
00492	        
00493	        } // end loop 0
00494	        
00495	}
00496	
00497	            }
00498	            __label_7:
00499	
00500	double __DUMMY_7;
00501	
00502	}
00503	__label_6:
00504	
00505	        if (V5) {
00506	            Py_XDECREF(V5);
00507	        }
00508	        
00509	    {Py_XDECREF(py_V5);}
00510	    
00511	double __DUMMY_6;
00512	
00513	}
00514	__label_4:
00515	
00516	        if (V3) {
00517	            Py_XDECREF(V3);
00518	        }
00519	        
00520	    {Py_XDECREF(py_V3);}
00521	    
00522	double __DUMMY_4;
00523	
00524	}
00525	__label_2:
00526	
00527	    if (!__failure) {
00528	      
00529	        {Py_XDECREF(py_V1);}
00530	        if (!V1) {
00531	            Py_INCREF(Py_None);
00532	            py_V1 = Py_None;
00533	        }
00534	        else if ((void*)py_V1 != (void*)V1) {
00535	            py_V1 = (PyObject*)V1;
00536	        }
00537	
00538	        {Py_XINCREF(py_V1);}
00539	
00540	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00541	            PyErr_Format(PyExc_NotImplementedError,
00542	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00543	                         " with %ld dimensions, with 3 last dims "
00544	                         "%ld, %ld, %ld"
00545	                         " and 3 last strides %ld %ld, %ld.",
00546	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00547	                         (long int) PyArray_NDIM(V1),
00548	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00549	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00550	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00551	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00552	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00553	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00554	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00555	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00556	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00557	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00558	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00559	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00560	        );
00561	            {
00562	        __failure = 2;
00563	        if (!PyErr_Occurred()) {
00564	            PyErr_SetString(PyExc_RuntimeError,
00565	                "Unexpected error in an Op's C code. "
00566	                "No Python exception was set.");
00567	            }
00568	        goto __label_2;}
00569	        }
00570	        
00571	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00572	      {Py_XINCREF(py_V1);}
00573	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00574	      {Py_XDECREF(old);}
00575	    }
00576	    
00577	        if (V1) {
00578	            Py_XDECREF(V1);
00579	        }
00580	        
00581	    {Py_XDECREF(py_V1);}
00582	    
00583	double __DUMMY_2;
00584	
00585	}
00586	
00587	            
00588	        if (__failure) {
00589	            // When there is a failure, this code puts the exception
00590	            // in __ERROR.
00591	            PyObject* err_type = NULL;
00592	            PyObject* err_msg = NULL;
00593	            PyObject* err_traceback = NULL;
00594	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00595	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00596	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00597	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00598	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00599	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00600	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00601	            PyList_SET_ITEM(__ERROR, 0, err_type);
00602	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00603	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00604	            {Py_XDECREF(old_err_type);}
00605	            {Py_XDECREF(old_err_msg);}
00606	            {Py_XDECREF(old_err_traceback);}
00607	        }
00608	        // The failure code is returned to index what code block failed.
00609	        return __failure;
00610	        
00611	        }
00612	    };
00613	    }
00614	    
00615	
00616	        static int __struct_compiled_op_a4c07a04bf0767d3a33702daad982088_executor(__struct_compiled_op_a4c07a04bf0767d3a33702daad982088* self) {
00617	            return self->run();
00618	        }
00619	
00620	        static void __struct_compiled_op_a4c07a04bf0767d3a33702daad982088_destructor(void* executor, void* self) {
00621	            delete ((__struct_compiled_op_a4c07a04bf0767d3a33702daad982088*)self);
00622	        }
00623	        
00624	//////////////////////
00625	////  Functions
00626	//////////////////////
00627	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00628	  assert(PyTuple_Check(argtuple));
00629	  if (4 != PyTuple_Size(argtuple)){ 
00630	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00631	     return NULL;
00632	  }
00633	  __struct_compiled_op_a4c07a04bf0767d3a33702daad982088* struct_ptr = new __struct_compiled_op_a4c07a04bf0767d3a33702daad982088();
00634	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00635	    delete struct_ptr;
00636	    return NULL;
00637	  }
00638	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_a4c07a04bf0767d3a33702daad982088_executor), struct_ptr, __struct_compiled_op_a4c07a04bf0767d3a33702daad982088_destructor);
00639	  return thunk; }
00640	
00641	//////////////////////
00642	////  Module init
00643	//////////////////////
00644	static PyMethodDef MyMethods[] = {
00645		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00646		{NULL, NULL, 0, NULL}
00647	};
00648	PyMODINIT_FUNC inita4c07a04bf0767d3a33702daad982088(void){
00649	   import_array();
00650	   (void) Py_InitModule("a4c07a04bf0767d3a33702daad982088", MyMethods);
00651	}
00652	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpm3Dp4b/a4c07a04bf0767d3a33702daad982088.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpm3Dp4b/mod.cpp -lpython2.7
ERROR
test_shared_constructor_copies (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... ok
test_sparse_input_aliasing_affecting_inplace_operations (theano.compile.tests.test_pfunc.Test_aliasing_rules) ... ok
test_allow_downcast_floatX (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_allow_input_downcast_int (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_clone0 (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_default_container (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_default_scalar_container (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_default_updates (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_default_updates_chained (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_default_updates_expressions (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_default_updates_input (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_default_updates_multiple (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_default_updates_partial_graph (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
Ensure the code given in pfunc.txt works as expected ... ok
test_duplicate_inputs (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_duplicate_updates (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_givens (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_givens_replaces_shared_variable (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_givens_replaces_shared_variable2 (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_no_default_updates (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
Test that shared variables cannot be used as function inputs. ... ok
test_param_allow_downcast_floatX (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_param_allow_downcast_int (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_param_allow_downcast_vector_floatX (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_param_mutable (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_param_strict (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_shared (theano.compile.tests.test_pfunc.Test_pfunc) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_6e9e270365af2003ff5c26520fa86c75 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_6e9e270365af2003ff5c26520fa86c75() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_6e9e270365af2003ff5c26520fa86c75(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                npy_intp V3_n0;
00273	                ssize_t V3_stride0;
00274	                int V3_jump0_0;
00275	                
00276	                npy_intp V3_n1;
00277	                ssize_t V3_stride1;
00278	                int V3_jump1_1;
00279	                
00280	        npy_float64* V5_iter;
00281	        
00282	                npy_intp V5_n0;
00283	                ssize_t V5_stride0;
00284	                int V5_jump0_0;
00285	                
00286	                npy_intp V5_n1;
00287	                ssize_t V5_stride1;
00288	                int V5_jump1_1;
00289	                
00290	
00291	            if (PyArray_NDIM(V3) < 2) {
00292	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00293	                {
00294	        __failure = 7;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_7;}
00301	            }
00302	            
00303	                V3_n1 = PyArray_DIMS(V3)[1];
00304	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00305	                V3_jump1_1 = (V3_stride1) - (0);
00306	                //printf("V3_jump1_1 is:");
00307	                //std::cout << V3_jump1_1 << std::endl;
00308	                
00309	                V3_n0 = PyArray_DIMS(V3)[0];
00310	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00311	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00312	                //printf("V3_jump0_0 is:");
00313	                //std::cout << V3_jump0_0 << std::endl;
00314	                
00315	            if (PyArray_NDIM(V5) < 2) {
00316	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00317	                {
00318	        __failure = 7;
00319	        if (!PyErr_Occurred()) {
00320	            PyErr_SetString(PyExc_RuntimeError,
00321	                "Unexpected error in an Op's C code. "
00322	                "No Python exception was set.");
00323	            }
00324	        goto __label_7;}
00325	            }
00326	            
00327	                V5_n1 = PyArray_DIMS(V5)[1];
00328	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00329	                V5_jump1_1 = (V5_stride1) - (0);
00330	                //printf("V5_jump1_1 is:");
00331	                //std::cout << V5_jump1_1 << std::endl;
00332	                
00333	                V5_n0 = PyArray_DIMS(V5)[0];
00334	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00335	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00336	                //printf("V5_jump0_0 is:");
00337	                //std::cout << V5_jump0_0 << std::endl;
00338	                
00339	            if (V3_n0 != V5_n0)
00340	            {
00341	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00342	                   0,
00343	                   0,
00344	                   V3_n0,
00345	                   1,
00346	                   0,
00347	                   V5_n0
00348	                );
00349	                {
00350	        __failure = 7;
00351	        if (!PyErr_Occurred()) {
00352	            PyErr_SetString(PyExc_RuntimeError,
00353	                "Unexpected error in an Op's C code. "
00354	                "No Python exception was set.");
00355	            }
00356	        goto __label_7;}
00357	            }
00358	            
00359	            if (V3_n1 != V5_n1)
00360	            {
00361	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00362	                   0,
00363	                   1,
00364	                   V3_n1,
00365	                   1,
00366	                   1,
00367	                   V5_n1
00368	                );
00369	                {
00370	        __failure = 7;
00371	        if (!PyErr_Occurred()) {
00372	            PyErr_SetString(PyExc_RuntimeError,
00373	                "Unexpected error in an Op's C code. "
00374	                "No Python exception was set.");
00375	            }
00376	        goto __label_7;}
00377	            }
00378	            
00379	
00380	        npy_float64* V1_iter;
00381	        
00382	                npy_intp V1_n0;
00383	                ssize_t V1_stride0;
00384	                int V1_jump0_0;
00385	                
00386	                npy_intp V1_n1;
00387	                ssize_t V1_stride1;
00388	                int V1_jump1_1;
00389	                
00390	    {
00391	        npy_intp dims[2];
00392	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00393	        dims[0] = V3_n0;
00394	dims[1] = V3_n1;
00395	
00396	        if (!V1) {
00397	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00398	                                                    NPY_FLOAT64,
00399	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00400	        }
00401	        else {
00402	            PyArray_Dims new_dims;
00403	            new_dims.len = 2;
00404	            new_dims.ptr = dims;
00405	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00406	            if (!success) {
00407	                // If we can't resize the ndarray we have we can allocate a new one.
00408	                PyErr_Clear();
00409	                Py_XDECREF(V1);
00410	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00411	            }
00412	        }
00413	        if (!V1) {
00414	            {
00415	        __failure = 7;
00416	        if (!PyErr_Occurred()) {
00417	            PyErr_SetString(PyExc_RuntimeError,
00418	                "Unexpected error in an Op's C code. "
00419	                "No Python exception was set.");
00420	            }
00421	        goto __label_7;}
00422	        }
00423	    }
00424	    
00425	            if (PyArray_NDIM(V1) < 2) {
00426	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00427	                {
00428	        __failure = 7;
00429	        if (!PyErr_Occurred()) {
00430	            PyErr_SetString(PyExc_RuntimeError,
00431	                "Unexpected error in an Op's C code. "
00432	                "No Python exception was set.");
00433	            }
00434	        goto __label_7;}
00435	            }
00436	            
00437	                V1_n1 = PyArray_DIMS(V1)[1];
00438	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00439	                V1_jump1_1 = (V1_stride1) - (0);
00440	                //printf("V1_jump1_1 is:");
00441	                //std::cout << V1_jump1_1 << std::endl;
00442	                
00443	                V1_n0 = PyArray_DIMS(V1)[0];
00444	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00445	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00446	                //printf("V1_jump0_0 is:");
00447	                //std::cout << V1_jump0_0 << std::endl;
00448	                
00449	
00450	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00451	                
00452	                    // All output have the same size
00453	                    npy_intp n = PyArray_SIZE(V1);
00454	                    
00455	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00456	                            
00457	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00458	                            
00459	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00460	                            
00461	                    for(int i=0; i<n; i++){
00462	                        
00463	            dtype_V3& V3_i = V3_ptr[i];
00464	                            
00465	            dtype_V5& V5_i = V5_ptr[i];
00466	                            
00467	            dtype_V1& V1_i = V1_ptr[i];
00468	                            
00469	                        V1_i = V3_i + V5_i;;
00470	                    }
00471	                    
00472	            }else{
00473	                {
00474	
00475	    std::vector< std::pair<int, int> > V1_loops(2);
00476	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00477	    
00478	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00479	            
00480	        V1_loops_it->second = 0;
00481	        ++V1_loops_it;
00482	        
00483	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00484	            
00485	        V1_loops_it->second = 1;
00486	        ++V1_loops_it;
00487	        
00488	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00489	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00490	    
00491	
00492	    int init_totals[2] = {V3_n0, V3_n1};
00493	    
00494	    V1_loops_it = V1_loops.begin();
00495	    
00496	        int TOTAL_0 = init_totals[V1_loops_it->second];
00497	        ++V1_loops_it;
00498	        
00499	        int TOTAL_1 = init_totals[V1_loops_it->second];
00500	        ++V1_loops_it;
00501	        
00502	
00503	    int init_strides[3][2] = {
00504	        V3_stride0, V3_stride1, 
00505	V5_stride0, V5_stride1, 
00506	V1_stride0, V1_stride1
00507	    };
00508	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00509	    
00510	        V1_loops_rit = V1_loops.rbegin();
00511	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00512	            ++V1_loops_rit;
00513	            
00514	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00515	            ++V1_loops_rit;
00516	            
00517	        V1_loops_rit = V1_loops.rbegin();
00518	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00519	            ++V1_loops_rit;
00520	            
00521	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00522	            ++V1_loops_rit;
00523	            
00524	        V1_loops_rit = V1_loops.rbegin();
00525	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00526	            ++V1_loops_rit;
00527	            
00528	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00529	            ++V1_loops_rit;
00530	            
00531	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00532	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00533	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00534	
00535	
00536	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00537	        { // begin loop 0
00538	            
00539	            
00540	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00541	        { // begin loop 1
00542	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00543	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00544	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00545	
00546	            
00547	        {
00548	            
00549	            V1_i = V3_i + V5_i;
00550	            
00551	        }
00552	        
00553	        } // end loop 1
00554	        
00555	        } // end loop 0
00556	        
00557	}
00558	
00559	            }
00560	            __label_7:
00561	
00562	double __DUMMY_7;
00563	
00564	}
00565	__label_6:
00566	
00567	        if (V5) {
00568	            Py_XDECREF(V5);
00569	        }
00570	        
00571	    {Py_XDECREF(py_V5);}
00572	    
00573	double __DUMMY_6;
00574	
00575	}
00576	__label_4:
00577	
00578	        if (V3) {
00579	            Py_XDECREF(V3);
00580	        }
00581	        
00582	    {Py_XDECREF(py_V3);}
00583	    
00584	double __DUMMY_4;
00585	
00586	}
00587	__label_2:
00588	
00589	    if (!__failure) {
00590	      
00591	        {Py_XDECREF(py_V1);}
00592	        if (!V1) {
00593	            Py_INCREF(Py_None);
00594	            py_V1 = Py_None;
00595	        }
00596	        else if ((void*)py_V1 != (void*)V1) {
00597	            py_V1 = (PyObject*)V1;
00598	        }
00599	
00600	        {Py_XINCREF(py_V1);}
00601	
00602	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00603	            PyErr_Format(PyExc_NotImplementedError,
00604	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00605	                         " with %ld dimensions, with 3 last dims "
00606	                         "%ld, %ld, %ld"
00607	                         " and 3 last strides %ld %ld, %ld.",
00608	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00609	                         (long int) PyArray_NDIM(V1),
00610	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00611	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00612	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00613	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00614	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00615	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00616	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00617	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00618	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00619	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00620	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00621	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00622	        );
00623	            {
00624	        __failure = 2;
00625	        if (!PyErr_Occurred()) {
00626	            PyErr_SetString(PyExc_RuntimeError,
00627	                "Unexpected error in an Op's C code. "
00628	                "No Python exception was set.");
00629	            }
00630	        goto __label_2;}
00631	        }
00632	        
00633	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00634	      {Py_XINCREF(py_V1);}
00635	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00636	      {Py_XDECREF(old);}
00637	    }
00638	    
00639	        if (V1) {
00640	            Py_XDECREF(V1);
00641	        }
00642	        
00643	    {Py_XDECREF(py_V1);}
00644	    
00645	double __DUMMY_2;
00646	
00647	}
00648	
00649	            
00650	        if (__failure) {
00651	            // When there is a failure, this code puts the exception
00652	            // in __ERROR.
00653	            PyObject* err_type = NULL;
00654	            PyObject* err_msg = NULL;
00655	            PyObject* err_traceback = NULL;
00656	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00657	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00658	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00659	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00660	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00661	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00662	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00663	            PyList_SET_ITEM(__ERROR, 0, err_type);
00664	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00665	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00666	            {Py_XDECREF(old_err_type);}
00667	            {Py_XDECREF(old_err_msg);}
00668	            {Py_XDECREF(old_err_traceback);}
00669	        }
00670	        // The failure code is returned to index what code block failed.
00671	        return __failure;
00672	        
00673	        }
00674	    };
00675	    }
00676	    
00677	
00678	        static int __struct_compiled_op_6e9e270365af2003ff5c26520fa86c75_executor(__struct_compiled_op_6e9e270365af2003ff5c26520fa86c75* self) {
00679	            return self->run();
00680	        }
00681	
00682	        static void __struct_compiled_op_6e9e270365af2003ff5c26520fa86c75_destructor(void* executor, void* self) {
00683	            delete ((__struct_compiled_op_6e9e270365af2003ff5c26520fa86c75*)self);
00684	        }
00685	        
00686	//////////////////////
00687	////  Functions
00688	//////////////////////
00689	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00690	  assert(PyTuple_Check(argtuple));
00691	  if (4 != PyTuple_Size(argtuple)){ 
00692	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00693	     return NULL;
00694	  }
00695	  __struct_compiled_op_6e9e270365af2003ff5c26520fa86c75* struct_ptr = new __struct_compiled_op_6e9e270365af2003ff5c26520fa86c75();
00696	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00697	    delete struct_ptr;
00698	    return NULL;
00699	  }
00700	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_6e9e270365af2003ff5c26520fa86c75_executor), struct_ptr, __struct_compiled_op_6e9e270365af2003ff5c26520fa86c75_destructor);
00701	  return thunk; }
00702	
00703	//////////////////////
00704	////  Module init
00705	//////////////////////
00706	static PyMethodDef MyMethods[] = {
00707		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00708		{NULL, NULL, 0, NULL}
00709	};
00710	PyMODINIT_FUNC init6e9e270365af2003ff5c26520fa86c75(void){
00711	   import_array();
00712	   (void) Py_InitModule("6e9e270365af2003ff5c26520fa86c75", MyMethods);
00713	}
00714	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmppLf_gK/6e9e270365af2003ff5c26520fa86c75.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmppLf_gK/mod.cpp -lpython2.7
ERROR
test_shared_mutable (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
Test update mechanism in different settings. ... ok
test_update_equiv (theano.compile.tests.test_pfunc.Test_pfunc) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                int V3_jumpx_0;
00273	                
00274	                int V3_jumpx_1;
00275	                
00276	        npy_float64* V5_iter;
00277	        
00278	                npy_intp V5_n0;
00279	                ssize_t V5_stride0;
00280	                int V5_jump0_0;
00281	                
00282	                npy_intp V5_n1;
00283	                ssize_t V5_stride1;
00284	                int V5_jump1_1;
00285	                
00286	
00287	                V3_jumpx_1 = -(0);
00288	                //printf("V3_jumpx_1 is:");
00289	                //std::cout << V3_jumpx_1 << std::endl;
00290	                
00291	                V3_jumpx_0 = -(0);
00292	                //printf("V3_jumpx_0 is:");
00293	                //std::cout << V3_jumpx_0 << std::endl;
00294	                
00295	            if (PyArray_NDIM(V5) < 2) {
00296	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00297	                {
00298	        __failure = 7;
00299	        if (!PyErr_Occurred()) {
00300	            PyErr_SetString(PyExc_RuntimeError,
00301	                "Unexpected error in an Op's C code. "
00302	                "No Python exception was set.");
00303	            }
00304	        goto __label_7;}
00305	            }
00306	            
00307	                V5_n1 = PyArray_DIMS(V5)[1];
00308	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00309	                V5_jump1_1 = (V5_stride1) - (0);
00310	                //printf("V5_jump1_1 is:");
00311	                //std::cout << V5_jump1_1 << std::endl;
00312	                
00313	                V5_n0 = PyArray_DIMS(V5)[0];
00314	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00315	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00316	                //printf("V5_jump0_0 is:");
00317	                //std::cout << V5_jump0_0 << std::endl;
00318	                
00319	
00320	            if (V1) {
00321	                Py_XDECREF(V1);
00322	            }
00323	            V1 = V5;
00324	            Py_XINCREF(V1);
00325	            
00326	
00327	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00328	                
00329	                    // All output have the same size
00330	                    npy_intp n = PyArray_SIZE(V1);
00331	                    
00332	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00333	                            
00334	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00335	                            
00336	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00337	                            
00338	                    for(int i=0; i<n; i++){
00339	                        
00340	            dtype_V5& V5_i = V5_ptr[i];
00341	                            
00342	            dtype_V1& V1_i = V1_ptr[i];
00343	                            
00344	                        {
00345	npy_float64 V7_tmp1;
00346	V7_tmp1 = V3_i * V5_i;
00347	V1_i = V7_tmp1 - V5_i;
00348	}
00349	;
00350	                    }
00351	                    
00352	            }else{
00353	                {
00354	
00355	    std::vector< std::pair<int, int> > V5_loops(2);
00356	    std::vector< std::pair<int, int> >::iterator V5_loops_it = V5_loops.begin();
00357	    
00358	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[0]);
00359	            
00360	        V5_loops_it->second = 0;
00361	        ++V5_loops_it;
00362	        
00363	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[1]);
00364	            
00365	        V5_loops_it->second = 1;
00366	        ++V5_loops_it;
00367	        
00368	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00369	    std::sort(V5_loops.rbegin(), V5_loops.rend());
00370	    
00371	
00372	    int init_totals[2] = {V5_n0, V5_n1};
00373	    
00374	    V5_loops_it = V5_loops.begin();
00375	    
00376	        int TOTAL_0 = init_totals[V5_loops_it->second];
00377	        ++V5_loops_it;
00378	        
00379	        int TOTAL_1 = init_totals[V5_loops_it->second];
00380	        ++V5_loops_it;
00381	        
00382	
00383	    int init_strides[2][2] = {
00384	        0, 0, 
00385	V5_stride0, V5_stride1
00386	    };
00387	    std::vector< std::pair<int, int> >::reverse_iterator V5_loops_rit;
00388	    
00389	        V5_loops_rit = V5_loops.rbegin();
00390	            int V3_stride_l1 = init_strides[0][V5_loops_rit->second];
00391	            ++V5_loops_rit;
00392	            
00393	            int V3_stride_l0 = init_strides[0][V5_loops_rit->second];
00394	            ++V5_loops_rit;
00395	            
00396	        V5_loops_rit = V5_loops.rbegin();
00397	            int V5_stride_l1 = init_strides[1][V5_loops_rit->second];
00398	            ++V5_loops_rit;
00399	            
00400	            int V5_stride_l0 = init_strides[1][V5_loops_rit->second];
00401	            ++V5_loops_rit;
00402	            
00403	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00404	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00405	
00406	
00407	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00408	        { // begin loop 0
00409	            
00410	            
00411	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00412	        { // begin loop 1
00413	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00414	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00415	
00416	            
00417	        {
00418	            #define V1_i V5_i
00419	
00420	            {
00421	npy_float64 V7_tmp1;
00422	V7_tmp1 = V3_i * V5_i;
00423	V1_i = V7_tmp1 - V5_i;
00424	}
00425	
00426	            #undef V1_i
00427	
00428	        }
00429	        
00430	        } // end loop 1
00431	        
00432	        } // end loop 0
00433	        
00434	}
00435	
00436	            }
00437	            __label_7:
00438	
00439	double __DUMMY_7;
00440	
00441	}
00442	__label_6:
00443	
00444	        if (V5) {
00445	            Py_XDECREF(V5);
00446	        }
00447	        
00448	    {Py_XDECREF(py_V5);}
00449	    
00450	double __DUMMY_6;
00451	
00452	}
00453	__label_4:
00454	
00455	        if (V3) {
00456	            Py_XDECREF(V3);
00457	        }
00458	        
00459	    {Py_XDECREF(py_V3);}
00460	    
00461	double __DUMMY_4;
00462	
00463	}
00464	__label_2:
00465	
00466	    if (!__failure) {
00467	      
00468	        {Py_XDECREF(py_V1);}
00469	        if (!V1) {
00470	            Py_INCREF(Py_None);
00471	            py_V1 = Py_None;
00472	        }
00473	        else if ((void*)py_V1 != (void*)V1) {
00474	            py_V1 = (PyObject*)V1;
00475	        }
00476	
00477	        {Py_XINCREF(py_V1);}
00478	
00479	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00480	            PyErr_Format(PyExc_NotImplementedError,
00481	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00482	                         " with %ld dimensions, with 3 last dims "
00483	                         "%ld, %ld, %ld"
00484	                         " and 3 last strides %ld %ld, %ld.",
00485	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00486	                         (long int) PyArray_NDIM(V1),
00487	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00488	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00489	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00490	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00491	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00492	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00493	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00494	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00495	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00496	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00497	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00498	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00499	        );
00500	            {
00501	        __failure = 2;
00502	        if (!PyErr_Occurred()) {
00503	            PyErr_SetString(PyExc_RuntimeError,
00504	                "Unexpected error in an Op's C code. "
00505	                "No Python exception was set.");
00506	            }
00507	        goto __label_2;}
00508	        }
00509	        
00510	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00511	      {Py_XINCREF(py_V1);}
00512	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00513	      {Py_XDECREF(old);}
00514	    }
00515	    
00516	        if (V1) {
00517	            Py_XDECREF(V1);
00518	        }
00519	        
00520	    {Py_XDECREF(py_V1);}
00521	    
00522	double __DUMMY_2;
00523	
00524	}
00525	
00526	            
00527	        if (__failure) {
00528	            // When there is a failure, this code puts the exception
00529	            // in __ERROR.
00530	            PyObject* err_type = NULL;
00531	            PyObject* err_msg = NULL;
00532	            PyObject* err_traceback = NULL;
00533	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00534	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00535	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00536	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00537	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00538	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00539	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00540	            PyList_SET_ITEM(__ERROR, 0, err_type);
00541	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00542	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00543	            {Py_XDECREF(old_err_type);}
00544	            {Py_XDECREF(old_err_msg);}
00545	            {Py_XDECREF(old_err_traceback);}
00546	        }
00547	        // The failure code is returned to index what code block failed.
00548	        return __failure;
00549	        
00550	        }
00551	    };
00552	    }
00553	    
00554	
00555	        static int __struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa_executor(__struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa* self) {
00556	            return self->run();
00557	        }
00558	
00559	        static void __struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa_destructor(void* executor, void* self) {
00560	            delete ((__struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa*)self);
00561	        }
00562	        
00563	//////////////////////
00564	////  Functions
00565	//////////////////////
00566	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00567	  assert(PyTuple_Check(argtuple));
00568	  if (4 != PyTuple_Size(argtuple)){ 
00569	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00570	     return NULL;
00571	  }
00572	  __struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa* struct_ptr = new __struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa();
00573	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00574	    delete struct_ptr;
00575	    return NULL;
00576	  }
00577	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa_executor), struct_ptr, __struct_compiled_op_5f1f64c0bd9d0cc6c588b5cdfe934eaa_destructor);
00578	  return thunk; }
00579	
00580	//////////////////////
00581	////  Module init
00582	//////////////////////
00583	static PyMethodDef MyMethods[] = {
00584		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00585		{NULL, NULL, 0, NULL}
00586	};
00587	PyMODINIT_FUNC init5f1f64c0bd9d0cc6c588b5cdfe934eaa(void){
00588	   import_array();
00589	   (void) Py_InitModule("5f1f64c0bd9d0cc6c588b5cdfe934eaa", MyMethods);
00590	}
00591	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmphgrybn/5f1f64c0bd9d0cc6c588b5cdfe934eaa.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmphgrybn/mod.cpp -lpython2.7
ERROR
test_update_err_broadcast (theano.compile.tests.test_pfunc.Test_pfunc) ... ok
test_update_same (theano.compile.tests.test_pfunc.Test_pfunc) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_5f53f69a0e77ae670e964314997b0168 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_5f53f69a0e77ae670e964314997b0168() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_5f53f69a0e77ae670e964314997b0168(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT64
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT64,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT64) got %d",
00169	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT64
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT64,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT64) got %d",
00253	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float64* V3_iter;
00271	        
00272	                int V3_jumpx_0;
00273	                
00274	                int V3_jumpx_1;
00275	                
00276	        npy_float64* V5_iter;
00277	        
00278	                npy_intp V5_n0;
00279	                ssize_t V5_stride0;
00280	                int V5_jump0_0;
00281	                
00282	                npy_intp V5_n1;
00283	                ssize_t V5_stride1;
00284	                int V5_jump1_1;
00285	                
00286	
00287	                V3_jumpx_1 = -(0);
00288	                //printf("V3_jumpx_1 is:");
00289	                //std::cout << V3_jumpx_1 << std::endl;
00290	                
00291	                V3_jumpx_0 = -(0);
00292	                //printf("V3_jumpx_0 is:");
00293	                //std::cout << V3_jumpx_0 << std::endl;
00294	                
00295	            if (PyArray_NDIM(V5) < 2) {
00296	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00297	                {
00298	        __failure = 7;
00299	        if (!PyErr_Occurred()) {
00300	            PyErr_SetString(PyExc_RuntimeError,
00301	                "Unexpected error in an Op's C code. "
00302	                "No Python exception was set.");
00303	            }
00304	        goto __label_7;}
00305	            }
00306	            
00307	                V5_n1 = PyArray_DIMS(V5)[1];
00308	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00309	                V5_jump1_1 = (V5_stride1) - (0);
00310	                //printf("V5_jump1_1 is:");
00311	                //std::cout << V5_jump1_1 << std::endl;
00312	                
00313	                V5_n0 = PyArray_DIMS(V5)[0];
00314	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00315	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00316	                //printf("V5_jump0_0 is:");
00317	                //std::cout << V5_jump0_0 << std::endl;
00318	                
00319	
00320	            if (V1) {
00321	                Py_XDECREF(V1);
00322	            }
00323	            V1 = V5;
00324	            Py_XINCREF(V1);
00325	            
00326	
00327	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00328	                
00329	                    // All output have the same size
00330	                    npy_intp n = PyArray_SIZE(V1);
00331	                    
00332	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00333	                            
00334	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00335	                            
00336	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00337	                            
00338	                    for(int i=0; i<n; i++){
00339	                        
00340	            dtype_V5& V5_i = V5_ptr[i];
00341	                            
00342	            dtype_V1& V1_i = V1_ptr[i];
00343	                            
00344	                        V1_i = V3_i * V5_i;;
00345	                    }
00346	                    
00347	            }else{
00348	                {
00349	
00350	    std::vector< std::pair<int, int> > V5_loops(2);
00351	    std::vector< std::pair<int, int> >::iterator V5_loops_it = V5_loops.begin();
00352	    
00353	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[0]);
00354	            
00355	        V5_loops_it->second = 0;
00356	        ++V5_loops_it;
00357	        
00358	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[1]);
00359	            
00360	        V5_loops_it->second = 1;
00361	        ++V5_loops_it;
00362	        
00363	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00364	    std::sort(V5_loops.rbegin(), V5_loops.rend());
00365	    
00366	
00367	    int init_totals[2] = {V5_n0, V5_n1};
00368	    
00369	    V5_loops_it = V5_loops.begin();
00370	    
00371	        int TOTAL_0 = init_totals[V5_loops_it->second];
00372	        ++V5_loops_it;
00373	        
00374	        int TOTAL_1 = init_totals[V5_loops_it->second];
00375	        ++V5_loops_it;
00376	        
00377	
00378	    int init_strides[2][2] = {
00379	        0, 0, 
00380	V5_stride0, V5_stride1
00381	    };
00382	    std::vector< std::pair<int, int> >::reverse_iterator V5_loops_rit;
00383	    
00384	        V5_loops_rit = V5_loops.rbegin();
00385	            int V3_stride_l1 = init_strides[0][V5_loops_rit->second];
00386	            ++V5_loops_rit;
00387	            
00388	            int V3_stride_l0 = init_strides[0][V5_loops_rit->second];
00389	            ++V5_loops_rit;
00390	            
00391	        V5_loops_rit = V5_loops.rbegin();
00392	            int V5_stride_l1 = init_strides[1][V5_loops_rit->second];
00393	            ++V5_loops_rit;
00394	            
00395	            int V5_stride_l0 = init_strides[1][V5_loops_rit->second];
00396	            ++V5_loops_rit;
00397	            
00398	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00399	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00400	
00401	
00402	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00403	        { // begin loop 0
00404	            
00405	            
00406	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00407	        { // begin loop 1
00408	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00409	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00410	
00411	            
00412	        {
00413	            #define V1_i V5_i
00414	
00415	            V1_i = V3_i * V5_i;
00416	            #undef V1_i
00417	
00418	        }
00419	        
00420	        } // end loop 1
00421	        
00422	        } // end loop 0
00423	        
00424	}
00425	
00426	            }
00427	            __label_7:
00428	
00429	double __DUMMY_7;
00430	
00431	}
00432	__label_6:
00433	
00434	        if (V5) {
00435	            Py_XDECREF(V5);
00436	        }
00437	        
00438	    {Py_XDECREF(py_V5);}
00439	    
00440	double __DUMMY_6;
00441	
00442	}
00443	__label_4:
00444	
00445	        if (V3) {
00446	            Py_XDECREF(V3);
00447	        }
00448	        
00449	    {Py_XDECREF(py_V3);}
00450	    
00451	double __DUMMY_4;
00452	
00453	}
00454	__label_2:
00455	
00456	    if (!__failure) {
00457	      
00458	        {Py_XDECREF(py_V1);}
00459	        if (!V1) {
00460	            Py_INCREF(Py_None);
00461	            py_V1 = Py_None;
00462	        }
00463	        else if ((void*)py_V1 != (void*)V1) {
00464	            py_V1 = (PyObject*)V1;
00465	        }
00466	
00467	        {Py_XINCREF(py_V1);}
00468	
00469	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00470	            PyErr_Format(PyExc_NotImplementedError,
00471	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00472	                         " with %ld dimensions, with 3 last dims "
00473	                         "%ld, %ld, %ld"
00474	                         " and 3 last strides %ld %ld, %ld.",
00475	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00476	                         (long int) PyArray_NDIM(V1),
00477	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00478	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00479	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00480	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00481	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00482	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00483	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00484	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00485	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00486	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00487	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00488	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00489	        );
00490	            {
00491	        __failure = 2;
00492	        if (!PyErr_Occurred()) {
00493	            PyErr_SetString(PyExc_RuntimeError,
00494	                "Unexpected error in an Op's C code. "
00495	                "No Python exception was set.");
00496	            }
00497	        goto __label_2;}
00498	        }
00499	        
00500	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00501	      {Py_XINCREF(py_V1);}
00502	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00503	      {Py_XDECREF(old);}
00504	    }
00505	    
00506	        if (V1) {
00507	            Py_XDECREF(V1);
00508	        }
00509	        
00510	    {Py_XDECREF(py_V1);}
00511	    
00512	double __DUMMY_2;
00513	
00514	}
00515	
00516	            
00517	        if (__failure) {
00518	            // When there is a failure, this code puts the exception
00519	            // in __ERROR.
00520	            PyObject* err_type = NULL;
00521	            PyObject* err_msg = NULL;
00522	            PyObject* err_traceback = NULL;
00523	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00524	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00525	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00526	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00527	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00528	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00529	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00530	            PyList_SET_ITEM(__ERROR, 0, err_type);
00531	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00532	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00533	            {Py_XDECREF(old_err_type);}
00534	            {Py_XDECREF(old_err_msg);}
00535	            {Py_XDECREF(old_err_traceback);}
00536	        }
00537	        // The failure code is returned to index what code block failed.
00538	        return __failure;
00539	        
00540	        }
00541	    };
00542	    }
00543	    
00544	
00545	        static int __struct_compiled_op_5f53f69a0e77ae670e964314997b0168_executor(__struct_compiled_op_5f53f69a0e77ae670e964314997b0168* self) {
00546	            return self->run();
00547	        }
00548	
00549	        static void __struct_compiled_op_5f53f69a0e77ae670e964314997b0168_destructor(void* executor, void* self) {
00550	            delete ((__struct_compiled_op_5f53f69a0e77ae670e964314997b0168*)self);
00551	        }
00552	        
00553	//////////////////////
00554	////  Functions
00555	//////////////////////
00556	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00557	  assert(PyTuple_Check(argtuple));
00558	  if (4 != PyTuple_Size(argtuple)){ 
00559	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00560	     return NULL;
00561	  }
00562	  __struct_compiled_op_5f53f69a0e77ae670e964314997b0168* struct_ptr = new __struct_compiled_op_5f53f69a0e77ae670e964314997b0168();
00563	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00564	    delete struct_ptr;
00565	    return NULL;
00566	  }
00567	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_5f53f69a0e77ae670e964314997b0168_executor), struct_ptr, __struct_compiled_op_5f53f69a0e77ae670e964314997b0168_destructor);
00568	  return thunk; }
00569	
00570	//////////////////////
00571	////  Module init
00572	//////////////////////
00573	static PyMethodDef MyMethods[] = {
00574		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00575		{NULL, NULL, 0, NULL}
00576	};
00577	PyMODINIT_FUNC init5f53f69a0e77ae670e964314997b0168(void){
00578	   import_array();
00579	   (void) Py_InitModule("5f53f69a0e77ae670e964314997b0168", MyMethods);
00580	}
00581	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpOLWX7X/5f53f69a0e77ae670e964314997b0168.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpOLWX7X/mod.cpp -lpython2.7
ERROR
test1 (theano.compile.tests.test_pfunc.Test_rebuild_strict) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_int32 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_int32 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_int32 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_INT32
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_INT32), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_INT32,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_INT32) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_INT32) got %d",
00169	                             NPY_INT32, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_INT32
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_INT32), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_INT32,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_INT32) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_INT32) got %d",
00253	                             NPY_INT32, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_int32* V3_iter;
00271	        
00272	                npy_intp V3_n0;
00273	                ssize_t V3_stride0;
00274	                int V3_jump0_0;
00275	                
00276	                npy_intp V3_n1;
00277	                ssize_t V3_stride1;
00278	                int V3_jump1_1;
00279	                
00280	        npy_int32* V5_iter;
00281	        
00282	                int V5_jumpx_0;
00283	                
00284	                npy_intp V5_n1;
00285	                ssize_t V5_stride1;
00286	                int V5_jump1_1;
00287	                
00288	
00289	            if (PyArray_NDIM(V3) < 2) {
00290	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00291	                {
00292	        __failure = 7;
00293	        if (!PyErr_Occurred()) {
00294	            PyErr_SetString(PyExc_RuntimeError,
00295	                "Unexpected error in an Op's C code. "
00296	                "No Python exception was set.");
00297	            }
00298	        goto __label_7;}
00299	            }
00300	            
00301	                V3_n1 = PyArray_DIMS(V3)[1];
00302	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_int32);
00303	                V3_jump1_1 = (V3_stride1) - (0);
00304	                //printf("V3_jump1_1 is:");
00305	                //std::cout << V3_jump1_1 << std::endl;
00306	                
00307	                V3_n0 = PyArray_DIMS(V3)[0];
00308	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_int32);
00309	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00310	                //printf("V3_jump0_0 is:");
00311	                //std::cout << V3_jump0_0 << std::endl;
00312	                
00313	            if (PyArray_NDIM(V5) < 2) {
00314	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00315	                {
00316	        __failure = 7;
00317	        if (!PyErr_Occurred()) {
00318	            PyErr_SetString(PyExc_RuntimeError,
00319	                "Unexpected error in an Op's C code. "
00320	                "No Python exception was set.");
00321	            }
00322	        goto __label_7;}
00323	            }
00324	            
00325	                V5_n1 = PyArray_DIMS(V5)[1];
00326	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_int32);
00327	                V5_jump1_1 = (V5_stride1) - (0);
00328	                //printf("V5_jump1_1 is:");
00329	                //std::cout << V5_jump1_1 << std::endl;
00330	                
00331	                V5_jumpx_0 = -(V5_n1*V5_stride1);
00332	                //printf("V5_jumpx_0 is:");
00333	                //std::cout << V5_jumpx_0 << std::endl;
00334	                
00335	            if (V3_n1 != V5_n1)
00336	            {
00337	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00338	                   0,
00339	                   1,
00340	                   V3_n1,
00341	                   1,
00342	                   1,
00343	                   V5_n1
00344	                );
00345	                {
00346	        __failure = 7;
00347	        if (!PyErr_Occurred()) {
00348	            PyErr_SetString(PyExc_RuntimeError,
00349	                "Unexpected error in an Op's C code. "
00350	                "No Python exception was set.");
00351	            }
00352	        goto __label_7;}
00353	            }
00354	            
00355	
00356	        npy_int32* V1_iter;
00357	        
00358	                npy_intp V1_n0;
00359	                ssize_t V1_stride0;
00360	                int V1_jump0_0;
00361	                
00362	                npy_intp V1_n1;
00363	                ssize_t V1_stride1;
00364	                int V1_jump1_1;
00365	                
00366	    {
00367	        npy_intp dims[2];
00368	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00369	        dims[0] = V3_n0;
00370	dims[1] = V3_n1;
00371	
00372	        if (!V1) {
00373	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00374	                                                    NPY_INT32,
00375	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00376	        }
00377	        else {
00378	            PyArray_Dims new_dims;
00379	            new_dims.len = 2;
00380	            new_dims.ptr = dims;
00381	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00382	            if (!success) {
00383	                // If we can't resize the ndarray we have we can allocate a new one.
00384	                PyErr_Clear();
00385	                Py_XDECREF(V1);
00386	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_INT32, 0);
00387	            }
00388	        }
00389	        if (!V1) {
00390	            {
00391	        __failure = 7;
00392	        if (!PyErr_Occurred()) {
00393	            PyErr_SetString(PyExc_RuntimeError,
00394	                "Unexpected error in an Op's C code. "
00395	                "No Python exception was set.");
00396	            }
00397	        goto __label_7;}
00398	        }
00399	    }
00400	    
00401	            if (PyArray_NDIM(V1) < 2) {
00402	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00403	                {
00404	        __failure = 7;
00405	        if (!PyErr_Occurred()) {
00406	            PyErr_SetString(PyExc_RuntimeError,
00407	                "Unexpected error in an Op's C code. "
00408	                "No Python exception was set.");
00409	            }
00410	        goto __label_7;}
00411	            }
00412	            
00413	                V1_n1 = PyArray_DIMS(V1)[1];
00414	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_int32);
00415	                V1_jump1_1 = (V1_stride1) - (0);
00416	                //printf("V1_jump1_1 is:");
00417	                //std::cout << V1_jump1_1 << std::endl;
00418	                
00419	                V1_n0 = PyArray_DIMS(V1)[0];
00420	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_int32);
00421	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00422	                //printf("V1_jump0_0 is:");
00423	                //std::cout << V1_jump0_0 << std::endl;
00424	                
00425	{
00426	
00427	    std::vector< std::pair<int, int> > V1_loops(2);
00428	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00429	    
00430	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00431	            
00432	        V1_loops_it->second = 0;
00433	        ++V1_loops_it;
00434	        
00435	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00436	            
00437	        V1_loops_it->second = 1;
00438	        ++V1_loops_it;
00439	        
00440	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00441	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00442	    
00443	
00444	    int init_totals[2] = {V3_n0, V3_n1};
00445	    
00446	    V1_loops_it = V1_loops.begin();
00447	    
00448	        int TOTAL_0 = init_totals[V1_loops_it->second];
00449	        ++V1_loops_it;
00450	        
00451	        int TOTAL_1 = init_totals[V1_loops_it->second];
00452	        ++V1_loops_it;
00453	        
00454	
00455	    int init_strides[3][2] = {
00456	        V3_stride0, V3_stride1, 
00457	0, V5_stride1, 
00458	V1_stride0, V1_stride1
00459	    };
00460	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00461	    
00462	        V1_loops_rit = V1_loops.rbegin();
00463	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00464	            ++V1_loops_rit;
00465	            
00466	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00467	            ++V1_loops_rit;
00468	            
00469	        V1_loops_rit = V1_loops.rbegin();
00470	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00471	            ++V1_loops_rit;
00472	            
00473	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00474	            ++V1_loops_rit;
00475	            
00476	        V1_loops_rit = V1_loops.rbegin();
00477	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00478	            ++V1_loops_rit;
00479	            
00480	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00481	            ++V1_loops_rit;
00482	            
00483	V3_iter = (npy_int32*)(PyArray_DATA(V3));
00484	V5_iter = (npy_int32*)(PyArray_DATA(V5));
00485	V1_iter = (npy_int32*)(PyArray_DATA(V1));
00486	
00487	
00488	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00489	        { // begin loop 0
00490	            
00491	            
00492	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00493	        { // begin loop 1
00494	            npy_int32 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00495	npy_int32 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00496	npy_int32 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00497	
00498	            
00499	        {
00500	            
00501	            V1_i = V3_i * V5_i;
00502	            
00503	        }
00504	        
00505	        } // end loop 1
00506	        
00507	        } // end loop 0
00508	        
00509	}
00510	__label_7:
00511	
00512	double __DUMMY_7;
00513	
00514	}
00515	__label_6:
00516	
00517	        if (V5) {
00518	            Py_XDECREF(V5);
00519	        }
00520	        
00521	    {Py_XDECREF(py_V5);}
00522	    
00523	double __DUMMY_6;
00524	
00525	}
00526	__label_4:
00527	
00528	        if (V3) {
00529	            Py_XDECREF(V3);
00530	        }
00531	        
00532	    {Py_XDECREF(py_V3);}
00533	    
00534	double __DUMMY_4;
00535	
00536	}
00537	__label_2:
00538	
00539	    if (!__failure) {
00540	      
00541	        {Py_XDECREF(py_V1);}
00542	        if (!V1) {
00543	            Py_INCREF(Py_None);
00544	            py_V1 = Py_None;
00545	        }
00546	        else if ((void*)py_V1 != (void*)V1) {
00547	            py_V1 = (PyObject*)V1;
00548	        }
00549	
00550	        {Py_XINCREF(py_V1);}
00551	
00552	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00553	            PyErr_Format(PyExc_NotImplementedError,
00554	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00555	                         " with %ld dimensions, with 3 last dims "
00556	                         "%ld, %ld, %ld"
00557	                         " and 3 last strides %ld %ld, %ld.",
00558	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00559	                         (long int) PyArray_NDIM(V1),
00560	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00561	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00562	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00563	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00564	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00565	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00566	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00567	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00568	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00569	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00570	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00571	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00572	        );
00573	            {
00574	        __failure = 2;
00575	        if (!PyErr_Occurred()) {
00576	            PyErr_SetString(PyExc_RuntimeError,
00577	                "Unexpected error in an Op's C code. "
00578	                "No Python exception was set.");
00579	            }
00580	        goto __label_2;}
00581	        }
00582	        
00583	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00584	      {Py_XINCREF(py_V1);}
00585	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00586	      {Py_XDECREF(old);}
00587	    }
00588	    
00589	        if (V1) {
00590	            Py_XDECREF(V1);
00591	        }
00592	        
00593	    {Py_XDECREF(py_V1);}
00594	    
00595	double __DUMMY_2;
00596	
00597	}
00598	
00599	            
00600	        if (__failure) {
00601	            // When there is a failure, this code puts the exception
00602	            // in __ERROR.
00603	            PyObject* err_type = NULL;
00604	            PyObject* err_msg = NULL;
00605	            PyObject* err_traceback = NULL;
00606	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00607	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00608	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00609	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00610	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00611	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00612	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00613	            PyList_SET_ITEM(__ERROR, 0, err_type);
00614	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00615	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00616	            {Py_XDECREF(old_err_type);}
00617	            {Py_XDECREF(old_err_msg);}
00618	            {Py_XDECREF(old_err_traceback);}
00619	        }
00620	        // The failure code is returned to index what code block failed.
00621	        return __failure;
00622	        
00623	        }
00624	    };
00625	    }
00626	    
00627	
00628	        static int __struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0_executor(__struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0* self) {
00629	            return self->run();
00630	        }
00631	
00632	        static void __struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0_destructor(void* executor, void* self) {
00633	            delete ((__struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0*)self);
00634	        }
00635	        
00636	//////////////////////
00637	////  Functions
00638	//////////////////////
00639	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00640	  assert(PyTuple_Check(argtuple));
00641	  if (4 != PyTuple_Size(argtuple)){ 
00642	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00643	     return NULL;
00644	  }
00645	  __struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0* struct_ptr = new __struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0();
00646	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00647	    delete struct_ptr;
00648	    return NULL;
00649	  }
00650	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0_executor), struct_ptr, __struct_compiled_op_3ec2872b1aa70979f3ccf99795e8c5e0_destructor);
00651	  return thunk; }
00652	
00653	//////////////////////
00654	////  Module init
00655	//////////////////////
00656	static PyMethodDef MyMethods[] = {
00657		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00658		{NULL, NULL, 0, NULL}
00659	};
00660	PyMODINIT_FUNC init3ec2872b1aa70979f3ccf99795e8c5e0(void){
00661	   import_array();
00662	   (void) Py_InitModule("3ec2872b1aa70979f3ccf99795e8c5e0", MyMethods);
00663	}
00664	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpweNcXp/3ec2872b1aa70979f3ccf99795e8c5e0.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpweNcXp/mod.cpp -lpython2.7
ERROR
test_ifelse (theano.compile.tests.test_profiling.Test_profiling) ... /<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/vm.py:851: UserWarning: CVM does not support memory profile, using Stack VM.
  'CVM does not support memory profile, using Stack VM.')
ok
test_profiling (theano.compile.tests.test_profiling.Test_profiling) ... ok
test_create_numpy_strict_false (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
test_ctors (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
test_err_symbolic_variable (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
test_scalar_floatX (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
test_scalar_strict (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
test_strict_generic (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
test_tensor_floatX (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
test_tensor_strict (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
test_use_numpy_strict_false (theano.compile.tests.test_shared.Test_SharedVariable) ... ok
Failure: SkipTest (pydot not available: Install the python package pydot or pydot-ng. Install graphviz.) ... SKIP: pydot not available: Install the python package pydot or pydot-ng. Install graphviz.
Failure: SkipTest (pydot not available: Install the python package pydot or pydot-ng. Install graphviz.) ... SKIP: pydot not available: Install the python package pydot or pydot-ng. Install graphviz.
theano.gof.tests.test_cc.test_clinker_straightforward ... ok
theano.gof.tests.test_cc.test_clinker_literal_inlining ... ok
theano.gof.tests.test_cc.test_clinker_literal_cache ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V9;
00019	PyObject* storage_V1;
00020	PyObject* storage_V11;
00021	        
00022	    PyObject* py_V5;
00023	    
00024	        PyArrayObject* V5;
00025	        
00026	            typedef npy_float64 dtype_V5;
00027	            
00028	    PyObject* py_V7;
00029	    
00030	        PyArrayObject* V7;
00031	        
00032	    PyObject* py_V11;
00033	    
00034	        PyArrayObject* V11;
00035	        
00036	            typedef npy_float64 dtype_V11;
00037	            
00038	
00039	        __struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518() {
00040	            // This is only somewhat safe because we:
00041	            //  1) Are not a virtual class
00042	            //  2) Do not use any virtual classes in the members
00043	            //  3) Deal with mostly POD and pointers
00044	
00045	            // If this changes, we would have to revise this, but for
00046	            // now I am tired of chasing segfaults because
00047	            // initialization code had an error and some pointer has
00048	            // a junk value.
00049	            memset(this, 0, sizeof(*this));
00050	        }
00051	        ~__struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518(void) {
00052	            cleanup();
00053	        }
00054	
00055	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V9, PyObject* storage_V1, PyObject* storage_V11) {
00056	            Py_XINCREF(storage_V3);
00057	Py_XINCREF(storage_V9);
00058	Py_XINCREF(storage_V1);
00059	Py_XINCREF(storage_V11);
00060	            this->storage_V3 = storage_V3;
00061	this->storage_V9 = storage_V9;
00062	this->storage_V1 = storage_V1;
00063	this->storage_V11 = storage_V11;
00064	            
00065	
00066	
00067	
00068	    py_V5 = Py_None;
00069	    {Py_XINCREF(py_V5);}
00070	    
00071	        V5 = NULL;
00072	        
00073	
00074	    py_V7 = Py_None;
00075	    {Py_XINCREF(py_V7);}
00076	    
00077	        V7 = NULL;
00078	        
00079	
00080	
00081	    py_V11 = PyList_GET_ITEM(storage_V11, 0);
00082	    {Py_XINCREF(py_V11);}
00083	    
00084	            V11 = NULL;
00085	            if (py_V11 == Py_None) {
00086	                // We can either fail here or set V11 to NULL and rely on Ops
00087	                // using tensors to handle the NULL case, but if they fail to do so
00088	                // they'll end up with nasty segfaults, so this is public service.
00089	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00090	                {
00091	        if (!PyErr_Occurred()) {
00092	            PyErr_SetString(PyExc_RuntimeError,
00093	                "Unexpected error in an Op's C code. "
00094	                "No Python exception was set.");
00095	            }
00096	        return 11;
00097	}
00098	            }
00099	            if (!PyArray_Check(py_V11)) {
00100	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00101	                {
00102	        if (!PyErr_Occurred()) {
00103	            PyErr_SetString(PyExc_RuntimeError,
00104	                "Unexpected error in an Op's C code. "
00105	                "No Python exception was set.");
00106	            }
00107	        return 11;
00108	}
00109	            }
00110	            // We expect NPY_FLOAT64
00111	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V11)) {
00112	                PyArrayObject * tmp = (PyArrayObject*) py_V11;
00113	                PyErr_Format(PyExc_NotImplementedError,
00114	                             "expected an aligned array of type %ld "
00115	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00116	                             " with %ld dimensions, with 3 last dims "
00117	                             "%ld, %ld, %ld"
00118	                             " and 3 last strides %ld %ld, %ld.",
00119	                             (long int) NPY_FLOAT64,
00120	                             (long int) PyArray_TYPE((PyArrayObject*) py_V11),
00121	                             (long int) PyArray_NDIM(tmp),
00122	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00123	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00124	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00125	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00126	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00127	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00128	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00129	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00130	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00131	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00132	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00133	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00134	            );
00135	                {
00136	        if (!PyErr_Occurred()) {
00137	            PyErr_SetString(PyExc_RuntimeError,
00138	                "Unexpected error in an Op's C code. "
00139	                "No Python exception was set.");
00140	            }
00141	        return 11;
00142	}
00143	            }
00144	            // This is a TypeError to be consistent with DEBUG_MODE
00145	            // Note: DEBUG_MODE also tells the name of the container
00146	            if (PyArray_TYPE((PyArrayObject*) py_V11) != NPY_FLOAT64) {
00147	                PyErr_Format(PyExc_TypeError,
00148	                             "expected type_num %d (NPY_FLOAT64) got %d",
00149	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V11));
00150	                {
00151	        if (!PyErr_Occurred()) {
00152	            PyErr_SetString(PyExc_RuntimeError,
00153	                "Unexpected error in an Op's C code. "
00154	                "No Python exception was set.");
00155	            }
00156	        return 11;
00157	}
00158	            }
00159	            
00160	        V11 = (PyArrayObject*)(py_V11);
00161	        Py_XINCREF(V11);
00162	        
00163	
00164	
00165	
00166	            this->__ERROR = __ERROR;
00167	            return 0;
00168	        }
00169	        void cleanup(void) {
00170	            __label_1:
00171	
00172	double __DUMMY_1;
00173	__label_3:
00174	
00175	double __DUMMY_3;
00176	__label_5:
00177	
00178	        if (V5) {
00179	            Py_XDECREF(V5);
00180	        }
00181	        
00182	    {Py_XDECREF(py_V5);}
00183	    
00184	double __DUMMY_5;
00185	__label_7:
00186	
00187	        if (V7) {
00188	            Py_XDECREF(V7);
00189	        }
00190	        
00191	    {Py_XDECREF(py_V7);}
00192	    
00193	double __DUMMY_7;
00194	__label_9:
00195	
00196	double __DUMMY_9;
00197	__label_11:
00198	
00199	        if (V11) {
00200	            Py_XDECREF(V11);
00201	        }
00202	        
00203	    {Py_XDECREF(py_V11);}
00204	    
00205	double __DUMMY_11;
00206	__label_14:
00207	
00208	double __DUMMY_14;
00209	__label_16:
00210	
00211	double __DUMMY_16;
00212	__label_18:
00213	
00214	double __DUMMY_18;
00215	
00216	            Py_XDECREF(this->storage_V3);
00217	Py_XDECREF(this->storage_V9);
00218	Py_XDECREF(this->storage_V1);
00219	Py_XDECREF(this->storage_V11);
00220	        }
00221	        int run(void) {
00222	            int __failure = 0;
00223	            
00224	    PyObject* py_V1;
00225	    
00226	        PyArrayObject* V1;
00227	        
00228	            typedef npy_float64 dtype_V1;
00229	            
00230	    PyObject* py_V3;
00231	    
00232	        PyArrayObject* V3;
00233	        
00234	            typedef npy_float64 dtype_V3;
00235	            
00236	    PyObject* py_V9;
00237	    
00238	        PyArrayObject* V9;
00239	        
00240	{
00241	
00242	    py_V1 = Py_None;
00243	    {Py_XINCREF(py_V1);}
00244	    
00245	        V1 = NULL;
00246	        
00247	{
00248	
00249	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00250	    {Py_XINCREF(py_V3);}
00251	    
00252	            V3 = NULL;
00253	            if (py_V3 == Py_None) {
00254	                // We can either fail here or set V3 to NULL and rely on Ops
00255	                // using tensors to handle the NULL case, but if they fail to do so
00256	                // they'll end up with nasty segfaults, so this is public service.
00257	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            if (!PyArray_Check(py_V3)) {
00268	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00269	                {
00270	        __failure = 4;
00271	        if (!PyErr_Occurred()) {
00272	            PyErr_SetString(PyExc_RuntimeError,
00273	                "Unexpected error in an Op's C code. "
00274	                "No Python exception was set.");
00275	            }
00276	        goto __label_4;}
00277	            }
00278	            // We expect NPY_FLOAT64
00279	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00280	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00281	                PyErr_Format(PyExc_NotImplementedError,
00282	                             "expected an aligned array of type %ld "
00283	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00284	                             " with %ld dimensions, with 3 last dims "
00285	                             "%ld, %ld, %ld"
00286	                             " and 3 last strides %ld %ld, %ld.",
00287	                             (long int) NPY_FLOAT64,
00288	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00289	                             (long int) PyArray_NDIM(tmp),
00290	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00291	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00292	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00293	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00294	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00295	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00296	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00297	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00298	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00299	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00300	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00301	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00302	            );
00303	                {
00304	        __failure = 4;
00305	        if (!PyErr_Occurred()) {
00306	            PyErr_SetString(PyExc_RuntimeError,
00307	                "Unexpected error in an Op's C code. "
00308	                "No Python exception was set.");
00309	            }
00310	        goto __label_4;}
00311	            }
00312	            // This is a TypeError to be consistent with DEBUG_MODE
00313	            // Note: DEBUG_MODE also tells the name of the container
00314	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00315	                PyErr_Format(PyExc_TypeError,
00316	                             "expected type_num %d (NPY_FLOAT64) got %d",
00317	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00318	                {
00319	        __failure = 4;
00320	        if (!PyErr_Occurred()) {
00321	            PyErr_SetString(PyExc_RuntimeError,
00322	                "Unexpected error in an Op's C code. "
00323	                "No Python exception was set.");
00324	            }
00325	        goto __label_4;}
00326	            }
00327	            
00328	        V3 = (PyArrayObject*)(py_V3);
00329	        Py_XINCREF(V3);
00330	        
00331	{
00332	
00333	{
00334	
00335	{
00336	
00337	    py_V9 = PyList_GET_ITEM(storage_V9, 0);
00338	    {Py_XINCREF(py_V9);}
00339	    
00340	        V9 = (PyArrayObject*)(py_V9);
00341	        Py_XINCREF(V9);
00342	        
00343	{
00344	
00345	{
00346	// Op class Subtensor
00347	PyArrayObject * xview = NULL;
00348	        if (PyArray_NDIM(V9) != 1){
00349	            PyErr_SetString(PyExc_ValueError,
00350	                                     "Expected 1 dimensions input"
00351	                                        );
00352	            {
00353	        __failure = 13;
00354	        if (!PyErr_Occurred()) {
00355	            PyErr_SetString(PyExc_RuntimeError,
00356	                "Unexpected error in an Op's C code. "
00357	                "No Python exception was set.");
00358	            }
00359	        goto __label_13;}
00360	        }
00361	        {
00362	        // Argument of the view
00363	        npy_intp* xview_dims = NULL;
00364	        npy_intp* xview_strides = NULL;
00365	
00366	        
00367	        // One more argument of the view
00368	        npy_intp xview_offset = 0;
00369	
00370	        // The subtensor is created by iterating over the dimensions
00371	        // and updating stride, shape, and data pointers
00372	
00373	        int is_slice[] = {0};
00374	        npy_intp subtensor_spec[1];
00375	        subtensor_spec[0] = (0);;
00376	        int spec_pos = 0; //position in subtensor_spec
00377	        int inner_ii = 0; // the current dimension of zview
00378	        int outer_ii = 0; // current dimension of z
00379	
00380	
00381	        for (; outer_ii < 1; ++outer_ii)
00382	        {
00383	            if (is_slice[outer_ii])
00384	            {
00385	                npy_intp length = PyArray_DIMS(V9)[outer_ii];
00386	                npy_intp slicelength;
00387	                npy_intp start = subtensor_spec[spec_pos+0];
00388	                npy_intp stop  = subtensor_spec[spec_pos+1];
00389	                npy_intp step  = subtensor_spec[spec_pos+2];
00390	                if (step == 9223372036854775806) step = 1;
00391	
00392	                npy_intp defstart = step < 0 ? length-1 : 0;
00393	                npy_intp defstop = step < 0 ? -1 : length;
00394	
00395	                // logic adapted from
00396	                // PySlice_GetIndicesEx in python source
00397	                if (!step)
00398	                {
00399	                    PyErr_Format(PyExc_ValueError,
00400	                                 "slice step cannot be zero");
00401	                    {
00402	        __failure = 13;
00403	        if (!PyErr_Occurred()) {
00404	            PyErr_SetString(PyExc_RuntimeError,
00405	                "Unexpected error in an Op's C code. "
00406	                "No Python exception was set.");
00407	            }
00408	        goto __label_13;};
00409	                }
00410	
00411	                if (start == 9223372036854775806)
00412	                {
00413	                    start = defstart;
00414	                }
00415	                else
00416	                {
00417	                    if (start < 0) start += length;
00418	                    if (start < 0) start = (step < 0) ? -1 : 0;
00419	                    if (start >= length)
00420	                        start = (step < 0) ? length - 1 : length;
00421	                }
00422	
00423	                if (stop == 9223372036854775806)
00424	                {
00425	                    stop = defstop;
00426	                }
00427	                else
00428	                {
00429	                    if (stop < 0) stop += length;
00430	                    if (stop < 0) stop = (step < 0) ? -1 : 0;
00431	                    if (stop >= length)
00432	                        stop = (step < 0) ? length - 1 : length;
00433	                }
00434	
00435	                if ((step < 0 && stop >= start)
00436	                    || (step > 0 && start >= stop)) {
00437	                    slicelength = 0;
00438	                }
00439	                else if (step < 0) {
00440	                    slicelength = (stop-start+1)/step+1;
00441	                }
00442	                else {
00443	                    slicelength = (stop-start-1)/step+1;
00444	                }
00445	
00446	                if (0){
00447	                    fprintf(stdout, "start %zi\n", start);
00448	                    fprintf(stdout, "stop %zi\n", stop);
00449	                    fprintf(stdout, "step %zi\n", step);
00450	                    fprintf(stdout, "length %zi\n", length);
00451	                    fprintf(stdout, "slicelength %zi\n", slicelength);
00452	                }
00453	
00454	                assert (slicelength <= length);
00455	
00456	                xview_offset += (npy_intp)PyArray_STRIDES(V9)[outer_ii]
00457	                    * start * 1;
00458	                xview_dims[inner_ii] = slicelength;
00459	                xview_strides[inner_ii] = (npy_intp)PyArray_STRIDES(V9)[outer_ii] * step;
00460	
00461	                inner_ii += 1;
00462	                spec_pos += 3;
00463	            }
00464	            else // tuple coord `outer_ii` is an int
00465	            {
00466	                int idx = subtensor_spec[spec_pos];
00467	                if (idx < 0) idx += PyArray_DIMS(V9)[outer_ii];
00468	                if (idx >= 0)
00469	                {
00470	                    if (idx < PyArray_DIMS(V9)[outer_ii])
00471	                    {
00472	                        xview_offset += (npy_intp)PyArray_STRIDES(V9)[outer_ii] * idx *
00473	                               1;
00474	                    }
00475	                    else
00476	                    {
00477	                        PyErr_Format(PyExc_IndexError,"index out of bounds");
00478	                        {
00479	        __failure = 13;
00480	        if (!PyErr_Occurred()) {
00481	            PyErr_SetString(PyExc_RuntimeError,
00482	                "Unexpected error in an Op's C code. "
00483	                "No Python exception was set.");
00484	            }
00485	        goto __label_13;};
00486	                    }
00487	                }
00488	                else
00489	                {
00490	                    PyErr_Format(PyExc_IndexError,"index out of bounds");
00491	                    {
00492	        __failure = 13;
00493	        if (!PyErr_Occurred()) {
00494	            PyErr_SetString(PyExc_RuntimeError,
00495	                "Unexpected error in an Op's C code. "
00496	                "No Python exception was set.");
00497	            }
00498	        goto __label_13;};
00499	                }
00500	
00501	                spec_pos += 1;
00502	            }
00503	        }
00504	        assert (inner_ii <= 0);
00505	        while (inner_ii < 0)
00506	        {
00507	            assert (outer_ii < PyArray_NDIM(V9));
00508	            xview_dims[inner_ii] = PyArray_DIMS(V9)[outer_ii];
00509	            xview_strides[inner_ii] = PyArray_STRIDES(V9)[outer_ii];
00510	
00511	            inner_ii += 1;
00512	            outer_ii += 1;
00513	        }
00514	        
00515	        //TODO: give this Op a second output so that this view can be cached
00516	        //TODO: alternatively, fix the memory leak on failure
00517	        Py_INCREF(PyArray_DESCR(V9));
00518	        xview = (PyArrayObject*)PyArray_NewFromDescr(
00519	                &PyArray_Type,
00520	                PyArray_DESCR(V9),
00521	                0,
00522	                xview_dims,
00523	                xview_strides,
00524	                PyArray_BYTES(V9) + xview_offset,
00525	                PyArray_FLAGS(V9),
00526	                NULL);
00527	        assert (PyArray_NDIM(xview) == 0);
00528	        if (!xview)
00529	        {
00530	            {
00531	        __failure = 13;
00532	        if (!PyErr_Occurred()) {
00533	            PyErr_SetString(PyExc_RuntimeError,
00534	                "Unexpected error in an Op's C code. "
00535	                "No Python exception was set.");
00536	            }
00537	        goto __label_13;};
00538	        }
00539	        
00540	        Py_XDECREF(V7);
00541	        Py_INCREF(py_V9);
00542	        PyArray_SetBaseObject(xview, py_V9);
00543	        assert(py_V9 == (PyObject*)V9);
00544	        V7 = xview;
00545	        }
00546	{
00547	// Op class DimShuffle
00548	if (PyArray_NDIM(V7) != 0){PyErr_SetString(PyExc_NotImplementedError, "input nd"); {
00549	        __failure = 15;
00550	        if (!PyErr_Occurred()) {
00551	            PyErr_SetString(PyExc_RuntimeError,
00552	                "Unexpected error in an Op's C code. "
00553	                "No Python exception was set.");
00554	            }
00555	        goto __label_15;};};
00556	if (V5) {Py_XDECREF(V5);};
00557	{ PyArrayObject * V7__view_or_copy = V7;
00558	Py_INCREF((PyObject*)V7__view_or_copy);
00559	npy_intp dimensions[2];
00560	dimensions[0] = 1;
00561	dimensions[1] = 1;
00562	npy_intp strides[2];
00563	strides[0] = 0;
00564	strides[1] = 0;
00565	if (strides[2-1] == 0) strides[2-1] = PyArray_DESCR(V7__view_or_copy)->elsize;
00566	if (strides[0] == 0) strides[0] = strides[0+1] * dimensions[0+1];
00567	V5 = (PyArrayObject*)PyArray_New(&PyArray_Type, 2, dimensions, PyArray_TYPE(V7__view_or_copy), strides, PyArray_DATA(V7__view_or_copy), PyArray_ITEMSIZE(V7__view_or_copy), (NPY_ARRAY_WRITEABLE*PyArray_ISWRITEABLE(V7__view_or_copy)), NULL);
00568	if (V5 == NULL) {
00569	        __failure = 15;
00570	        if (!PyErr_Occurred()) {
00571	            PyErr_SetString(PyExc_RuntimeError,
00572	                "Unexpected error in an Op's C code. "
00573	                "No Python exception was set.");
00574	            }
00575	        goto __label_15;};;
00576	PyArray_UpdateFlags(V5, NPY_ARRAY_UPDATE_ALL);
00577	
00578	PyArray_SetBaseObject(V5, (PyObject*)V7__view_or_copy);
00579	};
00580	{
00581	// Op class Elemwise
00582	
00583	        npy_float64* V3_iter;
00584	        
00585	                npy_intp V3_n0;
00586	                ssize_t V3_stride0;
00587	                int V3_jump0_0;
00588	                
00589	                npy_intp V3_n1;
00590	                ssize_t V3_stride1;
00591	                int V3_jump1_1;
00592	                
00593	        npy_float64* V5_iter;
00594	        
00595	                int V5_jumpx_0;
00596	                
00597	                int V5_jumpx_1;
00598	                
00599	        npy_float64* V11_iter;
00600	        
00601	                npy_intp V11_n0;
00602	                ssize_t V11_stride0;
00603	                int V11_jump0_0;
00604	                
00605	                npy_intp V11_n1;
00606	                ssize_t V11_stride1;
00607	                int V11_jump1_1;
00608	                
00609	
00610	            if (PyArray_NDIM(V3) < 2) {
00611	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00612	                {
00613	        __failure = 17;
00614	        if (!PyErr_Occurred()) {
00615	            PyErr_SetString(PyExc_RuntimeError,
00616	                "Unexpected error in an Op's C code. "
00617	                "No Python exception was set.");
00618	            }
00619	        goto __label_17;}
00620	            }
00621	            
00622	                V3_n1 = PyArray_DIMS(V3)[1];
00623	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00624	                V3_jump1_1 = (V3_stride1) - (0);
00625	                //printf("V3_jump1_1 is:");
00626	                //std::cout << V3_jump1_1 << std::endl;
00627	                
00628	                V3_n0 = PyArray_DIMS(V3)[0];
00629	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00630	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00631	                //printf("V3_jump0_0 is:");
00632	                //std::cout << V3_jump0_0 << std::endl;
00633	                
00634	                V5_jumpx_1 = -(0);
00635	                //printf("V5_jumpx_1 is:");
00636	                //std::cout << V5_jumpx_1 << std::endl;
00637	                
00638	                V5_jumpx_0 = -(0);
00639	                //printf("V5_jumpx_0 is:");
00640	                //std::cout << V5_jumpx_0 << std::endl;
00641	                
00642	            if (PyArray_NDIM(V11) < 2) {
00643	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00644	                {
00645	        __failure = 17;
00646	        if (!PyErr_Occurred()) {
00647	            PyErr_SetString(PyExc_RuntimeError,
00648	                "Unexpected error in an Op's C code. "
00649	                "No Python exception was set.");
00650	            }
00651	        goto __label_17;}
00652	            }
00653	            
00654	                V11_n1 = PyArray_DIMS(V11)[1];
00655	                V11_stride1 = PyArray_STRIDES(V11)[1] / sizeof(npy_float64);
00656	                V11_jump1_1 = (V11_stride1) - (0);
00657	                //printf("V11_jump1_1 is:");
00658	                //std::cout << V11_jump1_1 << std::endl;
00659	                
00660	                V11_n0 = PyArray_DIMS(V11)[0];
00661	                V11_stride0 = PyArray_STRIDES(V11)[0] / sizeof(npy_float64);
00662	                V11_jump0_0 = (V11_stride0) - (V11_n1*V11_stride1);
00663	                //printf("V11_jump0_0 is:");
00664	                //std::cout << V11_jump0_0 << std::endl;
00665	                
00666	            if (V3_n0 != V11_n0)
00667	            {
00668	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00669	                   0,
00670	                   0,
00671	                   V3_n0,
00672	                   2,
00673	                   0,
00674	                   V11_n0
00675	                );
00676	                {
00677	        __failure = 17;
00678	        if (!PyErr_Occurred()) {
00679	            PyErr_SetString(PyExc_RuntimeError,
00680	                "Unexpected error in an Op's C code. "
00681	                "No Python exception was set.");
00682	            }
00683	        goto __label_17;}
00684	            }
00685	            
00686	            if (V3_n1 != V11_n1)
00687	            {
00688	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00689	                   0,
00690	                   1,
00691	                   V3_n1,
00692	                   2,
00693	                   1,
00694	                   V11_n1
00695	                );
00696	                {
00697	        __failure = 17;
00698	        if (!PyErr_Occurred()) {
00699	            PyErr_SetString(PyExc_RuntimeError,
00700	                "Unexpected error in an Op's C code. "
00701	                "No Python exception was set.");
00702	            }
00703	        goto __label_17;}
00704	            }
00705	            
00706	
00707	        npy_float64* V1_iter;
00708	        
00709	                npy_intp V1_n0;
00710	                ssize_t V1_stride0;
00711	                int V1_jump0_0;
00712	                
00713	                npy_intp V1_n1;
00714	                ssize_t V1_stride1;
00715	                int V1_jump1_1;
00716	                
00717	    {
00718	        npy_intp dims[2];
00719	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00720	        dims[0] = V3_n0;
00721	dims[1] = V3_n1;
00722	
00723	        if (!V1) {
00724	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00725	                                                    NPY_FLOAT64,
00726	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V11));
00727	        }
00728	        else {
00729	            PyArray_Dims new_dims;
00730	            new_dims.len = 2;
00731	            new_dims.ptr = dims;
00732	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00733	            if (!success) {
00734	                // If we can't resize the ndarray we have we can allocate a new one.
00735	                PyErr_Clear();
00736	                Py_XDECREF(V1);
00737	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00738	            }
00739	        }
00740	        if (!V1) {
00741	            {
00742	        __failure = 17;
00743	        if (!PyErr_Occurred()) {
00744	            PyErr_SetString(PyExc_RuntimeError,
00745	                "Unexpected error in an Op's C code. "
00746	                "No Python exception was set.");
00747	            }
00748	        goto __label_17;}
00749	        }
00750	    }
00751	    
00752	            if (PyArray_NDIM(V1) < 2) {
00753	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00754	                {
00755	        __failure = 17;
00756	        if (!PyErr_Occurred()) {
00757	            PyErr_SetString(PyExc_RuntimeError,
00758	                "Unexpected error in an Op's C code. "
00759	                "No Python exception was set.");
00760	            }
00761	        goto __label_17;}
00762	            }
00763	            
00764	                V1_n1 = PyArray_DIMS(V1)[1];
00765	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00766	                V1_jump1_1 = (V1_stride1) - (0);
00767	                //printf("V1_jump1_1 is:");
00768	                //std::cout << V1_jump1_1 << std::endl;
00769	                
00770	                V1_n0 = PyArray_DIMS(V1)[0];
00771	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00772	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00773	                //printf("V1_jump0_0 is:");
00774	                //std::cout << V1_jump0_0 << std::endl;
00775	                
00776	
00777	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V11) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V11) && PyArray_ISFORTRAN(V1))){
00778	                
00779	                    // All output have the same size
00780	                    npy_intp n = PyArray_SIZE(V1);
00781	                    
00782	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00783	                            
00784	            dtype_V5& V5_i = ((dtype_V5*) PyArray_DATA(V5))[0];
00785	                            
00786	            dtype_V11 * V11_ptr = (dtype_V11*) PyArray_DATA(V11);
00787	                            
00788	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00789	                            
00790	                    for(int i=0; i<n; i++){
00791	                        
00792	            dtype_V3& V3_i = V3_ptr[i];
00793	                            
00794	            dtype_V11& V11_i = V11_ptr[i];
00795	                            
00796	            dtype_V1& V1_i = V1_ptr[i];
00797	                            
00798	                        {
00799	npy_float64 V17_tmp1;
00800	V17_tmp1 = V5_i * V11_i;
00801	V1_i = V3_i - V17_tmp1;
00802	}
00803	;
00804	                    }
00805	                    
00806	            }else{
00807	                {
00808	
00809	    std::vector< std::pair<int, int> > V1_loops(2);
00810	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00811	    
00812	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00813	            
00814	        V1_loops_it->second = 0;
00815	        ++V1_loops_it;
00816	        
00817	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00818	            
00819	        V1_loops_it->second = 1;
00820	        ++V1_loops_it;
00821	        
00822	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00823	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00824	    
00825	
00826	    int init_totals[2] = {V3_n0, V3_n1};
00827	    
00828	    V1_loops_it = V1_loops.begin();
00829	    
00830	        int TOTAL_0 = init_totals[V1_loops_it->second];
00831	        ++V1_loops_it;
00832	        
00833	        int TOTAL_1 = init_totals[V1_loops_it->second];
00834	        ++V1_loops_it;
00835	        
00836	
00837	    int init_strides[4][2] = {
00838	        V3_stride0, V3_stride1, 
00839	0, 0, 
00840	V11_stride0, V11_stride1, 
00841	V1_stride0, V1_stride1
00842	    };
00843	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00844	    
00845	        V1_loops_rit = V1_loops.rbegin();
00846	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00847	            ++V1_loops_rit;
00848	            
00849	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00850	            ++V1_loops_rit;
00851	            
00852	        V1_loops_rit = V1_loops.rbegin();
00853	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00854	            ++V1_loops_rit;
00855	            
00856	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00857	            ++V1_loops_rit;
00858	            
00859	        V1_loops_rit = V1_loops.rbegin();
00860	            int V11_stride_l1 = init_strides[2][V1_loops_rit->second];
00861	            ++V1_loops_rit;
00862	            
00863	            int V11_stride_l0 = init_strides[2][V1_loops_rit->second];
00864	            ++V1_loops_rit;
00865	            
00866	        V1_loops_rit = V1_loops.rbegin();
00867	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00868	            ++V1_loops_rit;
00869	            
00870	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00871	            ++V1_loops_rit;
00872	            
00873	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00874	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00875	V11_iter = (npy_float64*)(PyArray_DATA(V11));
00876	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00877	
00878	
00879	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00880	        { // begin loop 0
00881	            
00882	            
00883	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00884	        { // begin loop 1
00885	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00886	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00887	npy_float64 &V11_i = * ( V11_iter+V11_stride_l1*ITER_1+V11_stride_l0*ITER_0);
00888	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00889	
00890	            
00891	        {
00892	            
00893	            {
00894	npy_float64 V17_tmp1;
00895	V17_tmp1 = V5_i * V11_i;
00896	V1_i = V3_i - V17_tmp1;
00897	}
00898	
00899	            
00900	        }
00901	        
00902	        } // end loop 1
00903	        
00904	        } // end loop 0
00905	        
00906	}
00907	
00908	            }
00909	            __label_17:
00910	
00911	double __DUMMY_17;
00912	
00913	}
00914	__label_15:
00915	
00916	double __DUMMY_15;
00917	
00918	}
00919	__label_13:
00920	
00921	double __DUMMY_13;
00922	
00923	}
00924	__label_12:
00925	
00926	double __DUMMY_12;
00927	
00928	}
00929	__label_10:
00930	
00931	        if (V9) {
00932	            Py_XDECREF(V9);
00933	        }
00934	        
00935	    {Py_XDECREF(py_V9);}
00936	    
00937	double __DUMMY_10;
00938	
00939	}
00940	__label_8:
00941	
00942	double __DUMMY_8;
00943	
00944	}
00945	__label_6:
00946	
00947	double __DUMMY_6;
00948	
00949	}
00950	__label_4:
00951	
00952	        if (V3) {
00953	            Py_XDECREF(V3);
00954	        }
00955	        
00956	    {Py_XDECREF(py_V3);}
00957	    
00958	double __DUMMY_4;
00959	
00960	}
00961	__label_2:
00962	
00963	    if (!__failure) {
00964	      
00965	        {Py_XDECREF(py_V1);}
00966	        if (!V1) {
00967	            Py_INCREF(Py_None);
00968	            py_V1 = Py_None;
00969	        }
00970	        else if ((void*)py_V1 != (void*)V1) {
00971	            py_V1 = (PyObject*)V1;
00972	        }
00973	
00974	        {Py_XINCREF(py_V1);}
00975	
00976	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00977	            PyErr_Format(PyExc_NotImplementedError,
00978	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00979	                         " with %ld dimensions, with 3 last dims "
00980	                         "%ld, %ld, %ld"
00981	                         " and 3 last strides %ld %ld, %ld.",
00982	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00983	                         (long int) PyArray_NDIM(V1),
00984	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00985	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00986	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00987	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00988	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00989	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00990	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00991	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00992	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00993	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00994	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00995	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00996	        );
00997	            {
00998	        __failure = 2;
00999	        if (!PyErr_Occurred()) {
01000	            PyErr_SetString(PyExc_RuntimeError,
01001	                "Unexpected error in an Op's C code. "
01002	                "No Python exception was set.");
01003	            }
01004	        goto __label_2;}
01005	        }
01006	        
01007	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
01008	      {Py_XINCREF(py_V1);}
01009	      PyList_SET_ITEM(storage_V1, 0, py_V1);
01010	      {Py_XDECREF(old);}
01011	    }
01012	    
01013	        if (V1) {
01014	            Py_XDECREF(V1);
01015	        }
01016	        
01017	    {Py_XDECREF(py_V1);}
01018	    
01019	double __DUMMY_2;
01020	
01021	}
01022	
01023	            
01024	        if (__failure) {
01025	            // When there is a failure, this code puts the exception
01026	            // in __ERROR.
01027	            PyObject* err_type = NULL;
01028	            PyObject* err_msg = NULL;
01029	            PyObject* err_traceback = NULL;
01030	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
01031	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
01032	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
01033	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
01034	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
01035	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
01036	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
01037	            PyList_SET_ITEM(__ERROR, 0, err_type);
01038	            PyList_SET_ITEM(__ERROR, 1, err_msg);
01039	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
01040	            {Py_XDECREF(old_err_type);}
01041	            {Py_XDECREF(old_err_msg);}
01042	            {Py_XDECREF(old_err_traceback);}
01043	        }
01044	        // The failure code is returned to index what code block failed.
01045	        return __failure;
01046	        
01047	        }
01048	    };
01049	    }
01050	    
01051	
01052	        static int __struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518_executor(__struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518* self) {
01053	            return self->run();
01054	        }
01055	
01056	        static void __struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518_destructor(void* executor, void* self) {
01057	            delete ((__struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518*)self);
01058	        }
01059	        
01060	//////////////////////
01061	////  Functions
01062	//////////////////////
01063	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
01064	  assert(PyTuple_Check(argtuple));
01065	  if (5 != PyTuple_Size(argtuple)){ 
01066	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
01067	     return NULL;
01068	  }
01069	  __struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518* struct_ptr = new __struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518();
01070	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
01071	    delete struct_ptr;
01072	    return NULL;
01073	  }
01074	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518_executor), struct_ptr, __struct_compiled_op_a1fc02c6fec6539044b847b11e6a3518_destructor);
01075	  return thunk; }
01076	
01077	//////////////////////
01078	////  Module init
01079	//////////////////////
01080	static PyMethodDef MyMethods[] = {
01081		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
01082		{NULL, NULL, 0, NULL}
01083	};
01084	PyMODINIT_FUNC inita1fc02c6fec6539044b847b11e6a3518(void){
01085	   import_array();
01086	   (void) Py_InitModule("a1fc02c6fec6539044b847b11e6a3518", MyMethods);
01087	}
01088	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpe_zSr2/a1fc02c6fec6539044b847b11e6a3518.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpe_zSr2/mod.cpp -lpython2.7
ERROR
theano.gof.tests.test_cc.test_clinker_single_node ... ok
theano.gof.tests.test_cc.test_clinker_dups ... ok
theano.gof.tests.test_cc.test_clinker_not_used_inputs ... ok
theano.gof.tests.test_cc.test_clinker_dups_inner ... ok
theano.gof.tests.test_cc.test_opwiseclinker_straightforward ... ok
theano.gof.tests.test_cc.test_opwiseclinker_constant ... ok
theano.gof.tests.test_cc.test_duallinker_straightforward ... ok
theano.gof.tests.test_cc.test_duallinker_mismatch ... ok
theano.gof.tests.test_cc.test_c_fail_error ... ok
theano.gof.tests.test_cc.test_shared_input_output ... ok
When an op with c_code, but no version. If we have 2 apply node ... ok
theano.gof.tests.test_cmodule.test_flag_detection ... ok
theano.gof.tests.test_compiledir.test_short_platform ... ok
test_compute_flag (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_constant (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_disabled_during_compilation (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_empty_elemwise (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_5790821083985fc05f694ca1d2f8242d {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_5790821083985fc05f694ca1d2f8242d() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_5790821083985fc05f694ca1d2f8242d(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_int8 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_INT8
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_INT8), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_INT8,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_INT8) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_INT8) got %d",
00341	                             NPY_INT8, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_int8* V5_iter;
00369	        
00370	                int V5_jumpx_0;
00371	                
00372	                int V5_jumpx_1;
00373	                
00374	
00375	            if (PyArray_NDIM(V3) < 2) {
00376	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00377	                {
00378	        __failure = 7;
00379	        if (!PyErr_Occurred()) {
00380	            PyErr_SetString(PyExc_RuntimeError,
00381	                "Unexpected error in an Op's C code. "
00382	                "No Python exception was set.");
00383	            }
00384	        goto __label_7;}
00385	            }
00386	            
00387	                V3_n1 = PyArray_DIMS(V3)[1];
00388	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00389	                V3_jump1_1 = (V3_stride1) - (0);
00390	                //printf("V3_jump1_1 is:");
00391	                //std::cout << V3_jump1_1 << std::endl;
00392	                
00393	                V3_n0 = PyArray_DIMS(V3)[0];
00394	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00395	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00396	                //printf("V3_jump0_0 is:");
00397	                //std::cout << V3_jump0_0 << std::endl;
00398	                
00399	                V5_jumpx_1 = -(0);
00400	                //printf("V5_jumpx_1 is:");
00401	                //std::cout << V5_jumpx_1 << std::endl;
00402	                
00403	                V5_jumpx_0 = -(0);
00404	                //printf("V5_jumpx_0 is:");
00405	                //std::cout << V5_jumpx_0 << std::endl;
00406	                
00407	
00408	        npy_float64* V1_iter;
00409	        
00410	                npy_intp V1_n0;
00411	                ssize_t V1_stride0;
00412	                int V1_jump0_0;
00413	                
00414	                npy_intp V1_n1;
00415	                ssize_t V1_stride1;
00416	                int V1_jump1_1;
00417	                
00418	    {
00419	        npy_intp dims[2];
00420	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00421	        dims[0] = V3_n0;
00422	dims[1] = V3_n1;
00423	
00424	        if (!V1) {
00425	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00426	                                                    NPY_FLOAT64,
00427	                                                    PyArray_ISFORTRAN(V3));
00428	        }
00429	        else {
00430	            PyArray_Dims new_dims;
00431	            new_dims.len = 2;
00432	            new_dims.ptr = dims;
00433	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00434	            if (!success) {
00435	                // If we can't resize the ndarray we have we can allocate a new one.
00436	                PyErr_Clear();
00437	                Py_XDECREF(V1);
00438	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00439	            }
00440	        }
00441	        if (!V1) {
00442	            {
00443	        __failure = 7;
00444	        if (!PyErr_Occurred()) {
00445	            PyErr_SetString(PyExc_RuntimeError,
00446	                "Unexpected error in an Op's C code. "
00447	                "No Python exception was set.");
00448	            }
00449	        goto __label_7;}
00450	        }
00451	    }
00452	    
00453	            if (PyArray_NDIM(V1) < 2) {
00454	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00455	                {
00456	        __failure = 7;
00457	        if (!PyErr_Occurred()) {
00458	            PyErr_SetString(PyExc_RuntimeError,
00459	                "Unexpected error in an Op's C code. "
00460	                "No Python exception was set.");
00461	            }
00462	        goto __label_7;}
00463	            }
00464	            
00465	                V1_n1 = PyArray_DIMS(V1)[1];
00466	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00467	                V1_jump1_1 = (V1_stride1) - (0);
00468	                //printf("V1_jump1_1 is:");
00469	                //std::cout << V1_jump1_1 << std::endl;
00470	                
00471	                V1_n0 = PyArray_DIMS(V1)[0];
00472	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00473	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00474	                //printf("V1_jump0_0 is:");
00475	                //std::cout << V1_jump0_0 << std::endl;
00476	                
00477	
00478	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V1))){
00479	                
00480	                    // All output have the same size
00481	                    npy_intp n = PyArray_SIZE(V1);
00482	                    
00483	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00484	                            
00485	            dtype_V5& V5_i = ((dtype_V5*) PyArray_DATA(V5))[0];
00486	                            
00487	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00488	                            
00489	                    for(int i=0; i<n; i++){
00490	                        
00491	            dtype_V3& V3_i = V3_ptr[i];
00492	                            
00493	            dtype_V1& V1_i = V1_ptr[i];
00494	                            
00495	                        V1_i = V3_i + V5_i;;
00496	                    }
00497	                    
00498	            }else{
00499	                {
00500	
00501	    std::vector< std::pair<int, int> > V1_loops(2);
00502	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00503	    
00504	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00505	            
00506	        V1_loops_it->second = 0;
00507	        ++V1_loops_it;
00508	        
00509	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00510	            
00511	        V1_loops_it->second = 1;
00512	        ++V1_loops_it;
00513	        
00514	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00515	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00516	    
00517	
00518	    int init_totals[2] = {V3_n0, V3_n1};
00519	    
00520	    V1_loops_it = V1_loops.begin();
00521	    
00522	        int TOTAL_0 = init_totals[V1_loops_it->second];
00523	        ++V1_loops_it;
00524	        
00525	        int TOTAL_1 = init_totals[V1_loops_it->second];
00526	        ++V1_loops_it;
00527	        
00528	
00529	    int init_strides[3][2] = {
00530	        V3_stride0, V3_stride1, 
00531	0, 0, 
00532	V1_stride0, V1_stride1
00533	    };
00534	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00535	    
00536	        V1_loops_rit = V1_loops.rbegin();
00537	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00538	            ++V1_loops_rit;
00539	            
00540	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00541	            ++V1_loops_rit;
00542	            
00543	        V1_loops_rit = V1_loops.rbegin();
00544	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00545	            ++V1_loops_rit;
00546	            
00547	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00548	            ++V1_loops_rit;
00549	            
00550	        V1_loops_rit = V1_loops.rbegin();
00551	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00552	            ++V1_loops_rit;
00553	            
00554	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00555	            ++V1_loops_rit;
00556	            
00557	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00558	V5_iter = (npy_int8*)(PyArray_DATA(V5));
00559	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00560	
00561	
00562	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00563	        { // begin loop 0
00564	            
00565	            
00566	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00567	        { // begin loop 1
00568	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00569	npy_int8 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00570	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00571	
00572	            
00573	        {
00574	            
00575	            V1_i = V3_i + V5_i;
00576	            
00577	        }
00578	        
00579	        } // end loop 1
00580	        
00581	        } // end loop 0
00582	        
00583	}
00584	
00585	            }
00586	            __label_7:
00587	
00588	double __DUMMY_7;
00589	
00590	}
00591	__label_6:
00592	
00593	        if (V5) {
00594	            Py_XDECREF(V5);
00595	        }
00596	        
00597	    {Py_XDECREF(py_V5);}
00598	    
00599	double __DUMMY_6;
00600	
00601	}
00602	__label_4:
00603	
00604	        if (V3) {
00605	            Py_XDECREF(V3);
00606	        }
00607	        
00608	    {Py_XDECREF(py_V3);}
00609	    
00610	double __DUMMY_4;
00611	
00612	}
00613	__label_2:
00614	
00615	    if (!__failure) {
00616	      
00617	        {Py_XDECREF(py_V1);}
00618	        if (!V1) {
00619	            Py_INCREF(Py_None);
00620	            py_V1 = Py_None;
00621	        }
00622	        else if ((void*)py_V1 != (void*)V1) {
00623	            py_V1 = (PyObject*)V1;
00624	        }
00625	
00626	        {Py_XINCREF(py_V1);}
00627	
00628	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00629	            PyErr_Format(PyExc_NotImplementedError,
00630	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00631	                         " with %ld dimensions, with 3 last dims "
00632	                         "%ld, %ld, %ld"
00633	                         " and 3 last strides %ld %ld, %ld.",
00634	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00635	                         (long int) PyArray_NDIM(V1),
00636	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00637	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00638	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00639	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00640	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00641	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00642	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00643	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00644	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00645	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00646	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00647	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00648	        );
00649	            {
00650	        __failure = 2;
00651	        if (!PyErr_Occurred()) {
00652	            PyErr_SetString(PyExc_RuntimeError,
00653	                "Unexpected error in an Op's C code. "
00654	                "No Python exception was set.");
00655	            }
00656	        goto __label_2;}
00657	        }
00658	        
00659	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00660	      {Py_XINCREF(py_V1);}
00661	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00662	      {Py_XDECREF(old);}
00663	    }
00664	    
00665	        if (V1) {
00666	            Py_XDECREF(V1);
00667	        }
00668	        
00669	    {Py_XDECREF(py_V1);}
00670	    
00671	double __DUMMY_2;
00672	
00673	}
00674	
00675	            
00676	        if (__failure) {
00677	            // When there is a failure, this code puts the exception
00678	            // in __ERROR.
00679	            PyObject* err_type = NULL;
00680	            PyObject* err_msg = NULL;
00681	            PyObject* err_traceback = NULL;
00682	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00683	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00684	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00685	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00686	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00687	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00688	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00689	            PyList_SET_ITEM(__ERROR, 0, err_type);
00690	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00691	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00692	            {Py_XDECREF(old_err_type);}
00693	            {Py_XDECREF(old_err_msg);}
00694	            {Py_XDECREF(old_err_traceback);}
00695	        }
00696	        // The failure code is returned to index what code block failed.
00697	        return __failure;
00698	        
00699	        }
00700	    };
00701	    }
00702	    
00703	
00704	        static int __struct_compiled_op_5790821083985fc05f694ca1d2f8242d_executor(__struct_compiled_op_5790821083985fc05f694ca1d2f8242d* self) {
00705	            return self->run();
00706	        }
00707	
00708	        static void __struct_compiled_op_5790821083985fc05f694ca1d2f8242d_destructor(void* executor, void* self) {
00709	            delete ((__struct_compiled_op_5790821083985fc05f694ca1d2f8242d*)self);
00710	        }
00711	        
00712	//////////////////////
00713	////  Functions
00714	//////////////////////
00715	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00716	  assert(PyTuple_Check(argtuple));
00717	  if (4 != PyTuple_Size(argtuple)){ 
00718	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00719	     return NULL;
00720	  }
00721	  __struct_compiled_op_5790821083985fc05f694ca1d2f8242d* struct_ptr = new __struct_compiled_op_5790821083985fc05f694ca1d2f8242d();
00722	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00723	    delete struct_ptr;
00724	    return NULL;
00725	  }
00726	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_5790821083985fc05f694ca1d2f8242d_executor), struct_ptr, __struct_compiled_op_5790821083985fc05f694ca1d2f8242d_destructor);
00727	  return thunk; }
00728	
00729	//////////////////////
00730	////  Module init
00731	//////////////////////
00732	static PyMethodDef MyMethods[] = {
00733		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00734		{NULL, NULL, 0, NULL}
00735	};
00736	PyMODINIT_FUNC init5790821083985fc05f694ca1d2f8242d(void){
00737	   import_array();
00738	   (void) Py_InitModule("5790821083985fc05f694ca1d2f8242d", MyMethods);
00739	}
00740	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpWxDYSA/5790821083985fc05f694ca1d2f8242d.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpWxDYSA/mod.cpp -lpython2.7
ERROR
test_incorrect_type (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_ndarray (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_no_c_code (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_no_perform (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_overided_function (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float64* V5_iter;
00369	        
00370	                npy_intp V5_n0;
00371	                ssize_t V5_stride0;
00372	                int V5_jump0_0;
00373	                
00374	                npy_intp V5_n1;
00375	                ssize_t V5_stride1;
00376	                int V5_jump1_1;
00377	                
00378	
00379	            if (PyArray_NDIM(V3) < 2) {
00380	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00381	                {
00382	        __failure = 7;
00383	        if (!PyErr_Occurred()) {
00384	            PyErr_SetString(PyExc_RuntimeError,
00385	                "Unexpected error in an Op's C code. "
00386	                "No Python exception was set.");
00387	            }
00388	        goto __label_7;}
00389	            }
00390	            
00391	                V3_n1 = PyArray_DIMS(V3)[1];
00392	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00393	                V3_jump1_1 = (V3_stride1) - (0);
00394	                //printf("V3_jump1_1 is:");
00395	                //std::cout << V3_jump1_1 << std::endl;
00396	                
00397	                V3_n0 = PyArray_DIMS(V3)[0];
00398	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00399	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00400	                //printf("V3_jump0_0 is:");
00401	                //std::cout << V3_jump0_0 << std::endl;
00402	                
00403	            if (PyArray_NDIM(V5) < 2) {
00404	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00405	                {
00406	        __failure = 7;
00407	        if (!PyErr_Occurred()) {
00408	            PyErr_SetString(PyExc_RuntimeError,
00409	                "Unexpected error in an Op's C code. "
00410	                "No Python exception was set.");
00411	            }
00412	        goto __label_7;}
00413	            }
00414	            
00415	                V5_n1 = PyArray_DIMS(V5)[1];
00416	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00417	                V5_jump1_1 = (V5_stride1) - (0);
00418	                //printf("V5_jump1_1 is:");
00419	                //std::cout << V5_jump1_1 << std::endl;
00420	                
00421	                V5_n0 = PyArray_DIMS(V5)[0];
00422	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00423	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00424	                //printf("V5_jump0_0 is:");
00425	                //std::cout << V5_jump0_0 << std::endl;
00426	                
00427	            if (V3_n0 != V5_n0)
00428	            {
00429	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00430	                   0,
00431	                   0,
00432	                   V3_n0,
00433	                   1,
00434	                   0,
00435	                   V5_n0
00436	                );
00437	                {
00438	        __failure = 7;
00439	        if (!PyErr_Occurred()) {
00440	            PyErr_SetString(PyExc_RuntimeError,
00441	                "Unexpected error in an Op's C code. "
00442	                "No Python exception was set.");
00443	            }
00444	        goto __label_7;}
00445	            }
00446	            
00447	            if (V3_n1 != V5_n1)
00448	            {
00449	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00450	                   0,
00451	                   1,
00452	                   V3_n1,
00453	                   1,
00454	                   1,
00455	                   V5_n1
00456	                );
00457	                {
00458	        __failure = 7;
00459	        if (!PyErr_Occurred()) {
00460	            PyErr_SetString(PyExc_RuntimeError,
00461	                "Unexpected error in an Op's C code. "
00462	                "No Python exception was set.");
00463	            }
00464	        goto __label_7;}
00465	            }
00466	            
00467	
00468	        npy_float64* V1_iter;
00469	        
00470	                npy_intp V1_n0;
00471	                ssize_t V1_stride0;
00472	                int V1_jump0_0;
00473	                
00474	                npy_intp V1_n1;
00475	                ssize_t V1_stride1;
00476	                int V1_jump1_1;
00477	                
00478	    {
00479	        npy_intp dims[2];
00480	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00481	        dims[0] = V3_n0;
00482	dims[1] = V3_n1;
00483	
00484	        if (!V1) {
00485	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00486	                                                    NPY_FLOAT64,
00487	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00488	        }
00489	        else {
00490	            PyArray_Dims new_dims;
00491	            new_dims.len = 2;
00492	            new_dims.ptr = dims;
00493	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00494	            if (!success) {
00495	                // If we can't resize the ndarray we have we can allocate a new one.
00496	                PyErr_Clear();
00497	                Py_XDECREF(V1);
00498	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00499	            }
00500	        }
00501	        if (!V1) {
00502	            {
00503	        __failure = 7;
00504	        if (!PyErr_Occurred()) {
00505	            PyErr_SetString(PyExc_RuntimeError,
00506	                "Unexpected error in an Op's C code. "
00507	                "No Python exception was set.");
00508	            }
00509	        goto __label_7;}
00510	        }
00511	    }
00512	    
00513	            if (PyArray_NDIM(V1) < 2) {
00514	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00515	                {
00516	        __failure = 7;
00517	        if (!PyErr_Occurred()) {
00518	            PyErr_SetString(PyExc_RuntimeError,
00519	                "Unexpected error in an Op's C code. "
00520	                "No Python exception was set.");
00521	            }
00522	        goto __label_7;}
00523	            }
00524	            
00525	                V1_n1 = PyArray_DIMS(V1)[1];
00526	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00527	                V1_jump1_1 = (V1_stride1) - (0);
00528	                //printf("V1_jump1_1 is:");
00529	                //std::cout << V1_jump1_1 << std::endl;
00530	                
00531	                V1_n0 = PyArray_DIMS(V1)[0];
00532	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00533	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00534	                //printf("V1_jump0_0 is:");
00535	                //std::cout << V1_jump0_0 << std::endl;
00536	                
00537	
00538	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00539	                
00540	                    // All output have the same size
00541	                    npy_intp n = PyArray_SIZE(V1);
00542	                    
00543	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00544	                            
00545	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00546	                            
00547	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00548	                            
00549	                    for(int i=0; i<n; i++){
00550	                        
00551	            dtype_V3& V3_i = V3_ptr[i];
00552	                            
00553	            dtype_V5& V5_i = V5_ptr[i];
00554	                            
00555	            dtype_V1& V1_i = V1_ptr[i];
00556	                            
00557	                        V1_i = V3_i * V5_i;;
00558	                    }
00559	                    
00560	            }else{
00561	                {
00562	
00563	    std::vector< std::pair<int, int> > V1_loops(2);
00564	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00565	    
00566	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00567	            
00568	        V1_loops_it->second = 0;
00569	        ++V1_loops_it;
00570	        
00571	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00572	            
00573	        V1_loops_it->second = 1;
00574	        ++V1_loops_it;
00575	        
00576	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00577	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00578	    
00579	
00580	    int init_totals[2] = {V3_n0, V3_n1};
00581	    
00582	    V1_loops_it = V1_loops.begin();
00583	    
00584	        int TOTAL_0 = init_totals[V1_loops_it->second];
00585	        ++V1_loops_it;
00586	        
00587	        int TOTAL_1 = init_totals[V1_loops_it->second];
00588	        ++V1_loops_it;
00589	        
00590	
00591	    int init_strides[3][2] = {
00592	        V3_stride0, V3_stride1, 
00593	V5_stride0, V5_stride1, 
00594	V1_stride0, V1_stride1
00595	    };
00596	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00597	    
00598	        V1_loops_rit = V1_loops.rbegin();
00599	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00600	            ++V1_loops_rit;
00601	            
00602	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00603	            ++V1_loops_rit;
00604	            
00605	        V1_loops_rit = V1_loops.rbegin();
00606	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00607	            ++V1_loops_rit;
00608	            
00609	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00610	            ++V1_loops_rit;
00611	            
00612	        V1_loops_rit = V1_loops.rbegin();
00613	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00614	            ++V1_loops_rit;
00615	            
00616	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00617	            ++V1_loops_rit;
00618	            
00619	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00620	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00621	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00622	
00623	
00624	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00625	        { // begin loop 0
00626	            
00627	            
00628	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00629	        { // begin loop 1
00630	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00631	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00632	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00633	
00634	            
00635	        {
00636	            
00637	            V1_i = V3_i * V5_i;
00638	            
00639	        }
00640	        
00641	        } // end loop 1
00642	        
00643	        } // end loop 0
00644	        
00645	}
00646	
00647	            }
00648	            __label_7:
00649	
00650	double __DUMMY_7;
00651	
00652	}
00653	__label_6:
00654	
00655	        if (V5) {
00656	            Py_XDECREF(V5);
00657	        }
00658	        
00659	    {Py_XDECREF(py_V5);}
00660	    
00661	double __DUMMY_6;
00662	
00663	}
00664	__label_4:
00665	
00666	        if (V3) {
00667	            Py_XDECREF(V3);
00668	        }
00669	        
00670	    {Py_XDECREF(py_V3);}
00671	    
00672	double __DUMMY_4;
00673	
00674	}
00675	__label_2:
00676	
00677	    if (!__failure) {
00678	      
00679	        {Py_XDECREF(py_V1);}
00680	        if (!V1) {
00681	            Py_INCREF(Py_None);
00682	            py_V1 = Py_None;
00683	        }
00684	        else if ((void*)py_V1 != (void*)V1) {
00685	            py_V1 = (PyObject*)V1;
00686	        }
00687	
00688	        {Py_XINCREF(py_V1);}
00689	
00690	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00691	            PyErr_Format(PyExc_NotImplementedError,
00692	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00693	                         " with %ld dimensions, with 3 last dims "
00694	                         "%ld, %ld, %ld"
00695	                         " and 3 last strides %ld %ld, %ld.",
00696	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00697	                         (long int) PyArray_NDIM(V1),
00698	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00699	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00700	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00701	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00702	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00703	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00704	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00705	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00706	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00707	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00708	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00709	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00710	        );
00711	            {
00712	        __failure = 2;
00713	        if (!PyErr_Occurred()) {
00714	            PyErr_SetString(PyExc_RuntimeError,
00715	                "Unexpected error in an Op's C code. "
00716	                "No Python exception was set.");
00717	            }
00718	        goto __label_2;}
00719	        }
00720	        
00721	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00722	      {Py_XINCREF(py_V1);}
00723	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00724	      {Py_XDECREF(old);}
00725	    }
00726	    
00727	        if (V1) {
00728	            Py_XDECREF(V1);
00729	        }
00730	        
00731	    {Py_XDECREF(py_V1);}
00732	    
00733	double __DUMMY_2;
00734	
00735	}
00736	
00737	            
00738	        if (__failure) {
00739	            // When there is a failure, this code puts the exception
00740	            // in __ERROR.
00741	            PyObject* err_type = NULL;
00742	            PyObject* err_msg = NULL;
00743	            PyObject* err_traceback = NULL;
00744	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00745	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00746	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00747	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00748	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00749	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00750	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00751	            PyList_SET_ITEM(__ERROR, 0, err_type);
00752	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00753	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00754	            {Py_XDECREF(old_err_type);}
00755	            {Py_XDECREF(old_err_msg);}
00756	            {Py_XDECREF(old_err_traceback);}
00757	        }
00758	        // The failure code is returned to index what code block failed.
00759	        return __failure;
00760	        
00761	        }
00762	    };
00763	    }
00764	    
00765	
00766	        static int __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09_executor(__struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09* self) {
00767	            return self->run();
00768	        }
00769	
00770	        static void __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09_destructor(void* executor, void* self) {
00771	            delete ((__struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09*)self);
00772	        }
00773	        
00774	//////////////////////
00775	////  Functions
00776	//////////////////////
00777	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00778	  assert(PyTuple_Check(argtuple));
00779	  if (4 != PyTuple_Size(argtuple)){ 
00780	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00781	     return NULL;
00782	  }
00783	  __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09* struct_ptr = new __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09();
00784	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00785	    delete struct_ptr;
00786	    return NULL;
00787	  }
00788	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09_executor), struct_ptr, __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09_destructor);
00789	  return thunk; }
00790	
00791	//////////////////////
00792	////  Module init
00793	//////////////////////
00794	static PyMethodDef MyMethods[] = {
00795		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00796		{NULL, NULL, 0, NULL}
00797	};
00798	PyMODINIT_FUNC initc12c19f770b4f8bc513a48412d2bea09(void){
00799	   import_array();
00800	   (void) Py_InitModule("c12c19f770b4f8bc513a48412d2bea09", MyMethods);
00801	}
00802	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxkT_tf/c12c19f770b4f8bc513a48412d2bea09.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxkT_tf/mod.cpp -lpython2.7
ERROR
Test the compute_test_value mechanism Scan. ... ok
test_scan_err1 (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float64* V5_iter;
00369	        
00370	                int V5_jumpx_0;
00371	                
00372	                int V5_jumpx_1;
00373	                
00374	
00375	            if (PyArray_NDIM(V3) < 2) {
00376	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00377	                {
00378	        __failure = 7;
00379	        if (!PyErr_Occurred()) {
00380	            PyErr_SetString(PyExc_RuntimeError,
00381	                "Unexpected error in an Op's C code. "
00382	                "No Python exception was set.");
00383	            }
00384	        goto __label_7;}
00385	            }
00386	            
00387	                V3_n1 = PyArray_DIMS(V3)[1];
00388	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00389	                V3_jump1_1 = (V3_stride1) - (0);
00390	                //printf("V3_jump1_1 is:");
00391	                //std::cout << V3_jump1_1 << std::endl;
00392	                
00393	                V3_n0 = PyArray_DIMS(V3)[0];
00394	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00395	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00396	                //printf("V3_jump0_0 is:");
00397	                //std::cout << V3_jump0_0 << std::endl;
00398	                
00399	                V5_jumpx_1 = -(0);
00400	                //printf("V5_jumpx_1 is:");
00401	                //std::cout << V5_jumpx_1 << std::endl;
00402	                
00403	                V5_jumpx_0 = -(0);
00404	                //printf("V5_jumpx_0 is:");
00405	                //std::cout << V5_jumpx_0 << std::endl;
00406	                
00407	
00408	        npy_float64* V1_iter;
00409	        
00410	                npy_intp V1_n0;
00411	                ssize_t V1_stride0;
00412	                int V1_jump0_0;
00413	                
00414	                npy_intp V1_n1;
00415	                ssize_t V1_stride1;
00416	                int V1_jump1_1;
00417	                
00418	    {
00419	        npy_intp dims[2];
00420	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00421	        dims[0] = V3_n0;
00422	dims[1] = V3_n1;
00423	
00424	        if (!V1) {
00425	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00426	                                                    NPY_FLOAT64,
00427	                                                    PyArray_ISFORTRAN(V3));
00428	        }
00429	        else {
00430	            PyArray_Dims new_dims;
00431	            new_dims.len = 2;
00432	            new_dims.ptr = dims;
00433	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00434	            if (!success) {
00435	                // If we can't resize the ndarray we have we can allocate a new one.
00436	                PyErr_Clear();
00437	                Py_XDECREF(V1);
00438	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00439	            }
00440	        }
00441	        if (!V1) {
00442	            {
00443	        __failure = 7;
00444	        if (!PyErr_Occurred()) {
00445	            PyErr_SetString(PyExc_RuntimeError,
00446	                "Unexpected error in an Op's C code. "
00447	                "No Python exception was set.");
00448	            }
00449	        goto __label_7;}
00450	        }
00451	    }
00452	    
00453	            if (PyArray_NDIM(V1) < 2) {
00454	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00455	                {
00456	        __failure = 7;
00457	        if (!PyErr_Occurred()) {
00458	            PyErr_SetString(PyExc_RuntimeError,
00459	                "Unexpected error in an Op's C code. "
00460	                "No Python exception was set.");
00461	            }
00462	        goto __label_7;}
00463	            }
00464	            
00465	                V1_n1 = PyArray_DIMS(V1)[1];
00466	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00467	                V1_jump1_1 = (V1_stride1) - (0);
00468	                //printf("V1_jump1_1 is:");
00469	                //std::cout << V1_jump1_1 << std::endl;
00470	                
00471	                V1_n0 = PyArray_DIMS(V1)[0];
00472	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00473	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00474	                //printf("V1_jump0_0 is:");
00475	                //std::cout << V1_jump0_0 << std::endl;
00476	                
00477	
00478	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V1))){
00479	                
00480	                    // All output have the same size
00481	                    npy_intp n = PyArray_SIZE(V1);
00482	                    
00483	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00484	                            
00485	            dtype_V5& V5_i = ((dtype_V5*) PyArray_DATA(V5))[0];
00486	                            
00487	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00488	                            
00489	                    for(int i=0; i<n; i++){
00490	                        
00491	            dtype_V3& V3_i = V3_ptr[i];
00492	                            
00493	            dtype_V1& V1_i = V1_ptr[i];
00494	                            
00495	                        V1_i = V5_i;;
00496	                    }
00497	                    
00498	            }else{
00499	                {
00500	
00501	    std::vector< std::pair<int, int> > V1_loops(2);
00502	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00503	    
00504	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00505	            
00506	        V1_loops_it->second = 0;
00507	        ++V1_loops_it;
00508	        
00509	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00510	            
00511	        V1_loops_it->second = 1;
00512	        ++V1_loops_it;
00513	        
00514	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00515	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00516	    
00517	
00518	    int init_totals[2] = {V3_n0, V3_n1};
00519	    
00520	    V1_loops_it = V1_loops.begin();
00521	    
00522	        int TOTAL_0 = init_totals[V1_loops_it->second];
00523	        ++V1_loops_it;
00524	        
00525	        int TOTAL_1 = init_totals[V1_loops_it->second];
00526	        ++V1_loops_it;
00527	        
00528	
00529	    int init_strides[3][2] = {
00530	        V3_stride0, V3_stride1, 
00531	0, 0, 
00532	V1_stride0, V1_stride1
00533	    };
00534	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00535	    
00536	        V1_loops_rit = V1_loops.rbegin();
00537	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00538	            ++V1_loops_rit;
00539	            
00540	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00541	            ++V1_loops_rit;
00542	            
00543	        V1_loops_rit = V1_loops.rbegin();
00544	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00545	            ++V1_loops_rit;
00546	            
00547	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00548	            ++V1_loops_rit;
00549	            
00550	        V1_loops_rit = V1_loops.rbegin();
00551	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00552	            ++V1_loops_rit;
00553	            
00554	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00555	            ++V1_loops_rit;
00556	            
00557	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00558	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00559	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00560	
00561	
00562	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00563	        { // begin loop 0
00564	            
00565	            
00566	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00567	        { // begin loop 1
00568	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00569	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00570	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00571	
00572	            
00573	        {
00574	            
00575	            V1_i = V5_i;
00576	            
00577	        }
00578	        
00579	        } // end loop 1
00580	        
00581	        } // end loop 0
00582	        
00583	}
00584	
00585	            }
00586	            __label_7:
00587	
00588	double __DUMMY_7;
00589	
00590	}
00591	__label_6:
00592	
00593	        if (V5) {
00594	            Py_XDECREF(V5);
00595	        }
00596	        
00597	    {Py_XDECREF(py_V5);}
00598	    
00599	double __DUMMY_6;
00600	
00601	}
00602	__label_4:
00603	
00604	        if (V3) {
00605	            Py_XDECREF(V3);
00606	        }
00607	        
00608	    {Py_XDECREF(py_V3);}
00609	    
00610	double __DUMMY_4;
00611	
00612	}
00613	__label_2:
00614	
00615	    if (!__failure) {
00616	      
00617	        {Py_XDECREF(py_V1);}
00618	        if (!V1) {
00619	            Py_INCREF(Py_None);
00620	            py_V1 = Py_None;
00621	        }
00622	        else if ((void*)py_V1 != (void*)V1) {
00623	            py_V1 = (PyObject*)V1;
00624	        }
00625	
00626	        {Py_XINCREF(py_V1);}
00627	
00628	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00629	            PyErr_Format(PyExc_NotImplementedError,
00630	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00631	                         " with %ld dimensions, with 3 last dims "
00632	                         "%ld, %ld, %ld"
00633	                         " and 3 last strides %ld %ld, %ld.",
00634	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00635	                         (long int) PyArray_NDIM(V1),
00636	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00637	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00638	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00639	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00640	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00641	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00642	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00643	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00644	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00645	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00646	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00647	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00648	        );
00649	            {
00650	        __failure = 2;
00651	        if (!PyErr_Occurred()) {
00652	            PyErr_SetString(PyExc_RuntimeError,
00653	                "Unexpected error in an Op's C code. "
00654	                "No Python exception was set.");
00655	            }
00656	        goto __label_2;}
00657	        }
00658	        
00659	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00660	      {Py_XINCREF(py_V1);}
00661	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00662	      {Py_XDECREF(old);}
00663	    }
00664	    
00665	        if (V1) {
00666	            Py_XDECREF(V1);
00667	        }
00668	        
00669	    {Py_XDECREF(py_V1);}
00670	    
00671	double __DUMMY_2;
00672	
00673	}
00674	
00675	            
00676	        if (__failure) {
00677	            // When there is a failure, this code puts the exception
00678	            // in __ERROR.
00679	            PyObject* err_type = NULL;
00680	            PyObject* err_msg = NULL;
00681	            PyObject* err_traceback = NULL;
00682	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00683	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00684	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00685	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00686	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00687	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00688	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00689	            PyList_SET_ITEM(__ERROR, 0, err_type);
00690	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00691	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00692	            {Py_XDECREF(old_err_type);}
00693	            {Py_XDECREF(old_err_msg);}
00694	            {Py_XDECREF(old_err_traceback);}
00695	        }
00696	        // The failure code is returned to index what code block failed.
00697	        return __failure;
00698	        
00699	        }
00700	    };
00701	    }
00702	    
00703	
00704	        static int __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05_executor(__struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05* self) {
00705	            return self->run();
00706	        }
00707	
00708	        static void __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05_destructor(void* executor, void* self) {
00709	            delete ((__struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05*)self);
00710	        }
00711	        
00712	//////////////////////
00713	////  Functions
00714	//////////////////////
00715	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00716	  assert(PyTuple_Check(argtuple));
00717	  if (4 != PyTuple_Size(argtuple)){ 
00718	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00719	     return NULL;
00720	  }
00721	  __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05* struct_ptr = new __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05();
00722	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00723	    delete struct_ptr;
00724	    return NULL;
00725	  }
00726	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05_executor), struct_ptr, __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05_destructor);
00727	  return thunk; }
00728	
00729	//////////////////////
00730	////  Module init
00731	//////////////////////
00732	static PyMethodDef MyMethods[] = {
00733		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00734		{NULL, NULL, 0, NULL}
00735	};
00736	PyMODINIT_FUNC initc1ed95c6911b2af8661a664ce38e1c05(void){
00737	   import_array();
00738	   (void) Py_InitModule("c1ed95c6911b2af8661a664ce38e1c05", MyMethods);
00739	}
00740	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpaV8kyx/c1ed95c6911b2af8661a664ce38e1c05.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpaV8kyx/mod.cpp -lpython2.7
ERROR
test_scan_err2 (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float64* V5_iter;
00369	        
00370	                int V5_jumpx_0;
00371	                
00372	                int V5_jumpx_1;
00373	                
00374	
00375	            if (PyArray_NDIM(V3) < 2) {
00376	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00377	                {
00378	        __failure = 7;
00379	        if (!PyErr_Occurred()) {
00380	            PyErr_SetString(PyExc_RuntimeError,
00381	                "Unexpected error in an Op's C code. "
00382	                "No Python exception was set.");
00383	            }
00384	        goto __label_7;}
00385	            }
00386	            
00387	                V3_n1 = PyArray_DIMS(V3)[1];
00388	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00389	                V3_jump1_1 = (V3_stride1) - (0);
00390	                //printf("V3_jump1_1 is:");
00391	                //std::cout << V3_jump1_1 << std::endl;
00392	                
00393	                V3_n0 = PyArray_DIMS(V3)[0];
00394	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00395	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00396	                //printf("V3_jump0_0 is:");
00397	                //std::cout << V3_jump0_0 << std::endl;
00398	                
00399	                V5_jumpx_1 = -(0);
00400	                //printf("V5_jumpx_1 is:");
00401	                //std::cout << V5_jumpx_1 << std::endl;
00402	                
00403	                V5_jumpx_0 = -(0);
00404	                //printf("V5_jumpx_0 is:");
00405	                //std::cout << V5_jumpx_0 << std::endl;
00406	                
00407	
00408	        npy_float64* V1_iter;
00409	        
00410	                npy_intp V1_n0;
00411	                ssize_t V1_stride0;
00412	                int V1_jump0_0;
00413	                
00414	                npy_intp V1_n1;
00415	                ssize_t V1_stride1;
00416	                int V1_jump1_1;
00417	                
00418	    {
00419	        npy_intp dims[2];
00420	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00421	        dims[0] = V3_n0;
00422	dims[1] = V3_n1;
00423	
00424	        if (!V1) {
00425	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00426	                                                    NPY_FLOAT64,
00427	                                                    PyArray_ISFORTRAN(V3));
00428	        }
00429	        else {
00430	            PyArray_Dims new_dims;
00431	            new_dims.len = 2;
00432	            new_dims.ptr = dims;
00433	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00434	            if (!success) {
00435	                // If we can't resize the ndarray we have we can allocate a new one.
00436	                PyErr_Clear();
00437	                Py_XDECREF(V1);
00438	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00439	            }
00440	        }
00441	        if (!V1) {
00442	            {
00443	        __failure = 7;
00444	        if (!PyErr_Occurred()) {
00445	            PyErr_SetString(PyExc_RuntimeError,
00446	                "Unexpected error in an Op's C code. "
00447	                "No Python exception was set.");
00448	            }
00449	        goto __label_7;}
00450	        }
00451	    }
00452	    
00453	            if (PyArray_NDIM(V1) < 2) {
00454	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00455	                {
00456	        __failure = 7;
00457	        if (!PyErr_Occurred()) {
00458	            PyErr_SetString(PyExc_RuntimeError,
00459	                "Unexpected error in an Op's C code. "
00460	                "No Python exception was set.");
00461	            }
00462	        goto __label_7;}
00463	            }
00464	            
00465	                V1_n1 = PyArray_DIMS(V1)[1];
00466	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00467	                V1_jump1_1 = (V1_stride1) - (0);
00468	                //printf("V1_jump1_1 is:");
00469	                //std::cout << V1_jump1_1 << std::endl;
00470	                
00471	                V1_n0 = PyArray_DIMS(V1)[0];
00472	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00473	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00474	                //printf("V1_jump0_0 is:");
00475	                //std::cout << V1_jump0_0 << std::endl;
00476	                
00477	
00478	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V1))){
00479	                
00480	                    // All output have the same size
00481	                    npy_intp n = PyArray_SIZE(V1);
00482	                    
00483	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00484	                            
00485	            dtype_V5& V5_i = ((dtype_V5*) PyArray_DATA(V5))[0];
00486	                            
00487	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00488	                            
00489	                    for(int i=0; i<n; i++){
00490	                        
00491	            dtype_V3& V3_i = V3_ptr[i];
00492	                            
00493	            dtype_V1& V1_i = V1_ptr[i];
00494	                            
00495	                        V1_i = V5_i;;
00496	                    }
00497	                    
00498	            }else{
00499	                {
00500	
00501	    std::vector< std::pair<int, int> > V1_loops(2);
00502	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00503	    
00504	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00505	            
00506	        V1_loops_it->second = 0;
00507	        ++V1_loops_it;
00508	        
00509	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00510	            
00511	        V1_loops_it->second = 1;
00512	        ++V1_loops_it;
00513	        
00514	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00515	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00516	    
00517	
00518	    int init_totals[2] = {V3_n0, V3_n1};
00519	    
00520	    V1_loops_it = V1_loops.begin();
00521	    
00522	        int TOTAL_0 = init_totals[V1_loops_it->second];
00523	        ++V1_loops_it;
00524	        
00525	        int TOTAL_1 = init_totals[V1_loops_it->second];
00526	        ++V1_loops_it;
00527	        
00528	
00529	    int init_strides[3][2] = {
00530	        V3_stride0, V3_stride1, 
00531	0, 0, 
00532	V1_stride0, V1_stride1
00533	    };
00534	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00535	    
00536	        V1_loops_rit = V1_loops.rbegin();
00537	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00538	            ++V1_loops_rit;
00539	            
00540	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00541	            ++V1_loops_rit;
00542	            
00543	        V1_loops_rit = V1_loops.rbegin();
00544	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00545	            ++V1_loops_rit;
00546	            
00547	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00548	            ++V1_loops_rit;
00549	            
00550	        V1_loops_rit = V1_loops.rbegin();
00551	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00552	            ++V1_loops_rit;
00553	            
00554	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00555	            ++V1_loops_rit;
00556	            
00557	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00558	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00559	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00560	
00561	
00562	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00563	        { // begin loop 0
00564	            
00565	            
00566	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00567	        { // begin loop 1
00568	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00569	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00570	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00571	
00572	            
00573	        {
00574	            
00575	            V1_i = V5_i;
00576	            
00577	        }
00578	        
00579	        } // end loop 1
00580	        
00581	        } // end loop 0
00582	        
00583	}
00584	
00585	            }
00586	            __label_7:
00587	
00588	double __DUMMY_7;
00589	
00590	}
00591	__label_6:
00592	
00593	        if (V5) {
00594	            Py_XDECREF(V5);
00595	        }
00596	        
00597	    {Py_XDECREF(py_V5);}
00598	    
00599	double __DUMMY_6;
00600	
00601	}
00602	__label_4:
00603	
00604	        if (V3) {
00605	            Py_XDECREF(V3);
00606	        }
00607	        
00608	    {Py_XDECREF(py_V3);}
00609	    
00610	double __DUMMY_4;
00611	
00612	}
00613	__label_2:
00614	
00615	    if (!__failure) {
00616	      
00617	        {Py_XDECREF(py_V1);}
00618	        if (!V1) {
00619	            Py_INCREF(Py_None);
00620	            py_V1 = Py_None;
00621	        }
00622	        else if ((void*)py_V1 != (void*)V1) {
00623	            py_V1 = (PyObject*)V1;
00624	        }
00625	
00626	        {Py_XINCREF(py_V1);}
00627	
00628	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00629	            PyErr_Format(PyExc_NotImplementedError,
00630	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00631	                         " with %ld dimensions, with 3 last dims "
00632	                         "%ld, %ld, %ld"
00633	                         " and 3 last strides %ld %ld, %ld.",
00634	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00635	                         (long int) PyArray_NDIM(V1),
00636	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00637	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00638	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00639	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00640	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00641	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00642	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00643	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00644	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00645	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00646	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00647	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00648	        );
00649	            {
00650	        __failure = 2;
00651	        if (!PyErr_Occurred()) {
00652	            PyErr_SetString(PyExc_RuntimeError,
00653	                "Unexpected error in an Op's C code. "
00654	                "No Python exception was set.");
00655	            }
00656	        goto __label_2;}
00657	        }
00658	        
00659	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00660	      {Py_XINCREF(py_V1);}
00661	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00662	      {Py_XDECREF(old);}
00663	    }
00664	    
00665	        if (V1) {
00666	            Py_XDECREF(V1);
00667	        }
00668	        
00669	    {Py_XDECREF(py_V1);}
00670	    
00671	double __DUMMY_2;
00672	
00673	}
00674	
00675	            
00676	        if (__failure) {
00677	            // When there is a failure, this code puts the exception
00678	            // in __ERROR.
00679	            PyObject* err_type = NULL;
00680	            PyObject* err_msg = NULL;
00681	            PyObject* err_traceback = NULL;
00682	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00683	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00684	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00685	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00686	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00687	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00688	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00689	            PyList_SET_ITEM(__ERROR, 0, err_type);
00690	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00691	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00692	            {Py_XDECREF(old_err_type);}
00693	            {Py_XDECREF(old_err_msg);}
00694	            {Py_XDECREF(old_err_traceback);}
00695	        }
00696	        // The failure code is returned to index what code block failed.
00697	        return __failure;
00698	        
00699	        }
00700	    };
00701	    }
00702	    
00703	
00704	        static int __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05_executor(__struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05* self) {
00705	            return self->run();
00706	        }
00707	
00708	        static void __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05_destructor(void* executor, void* self) {
00709	            delete ((__struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05*)self);
00710	        }
00711	        
00712	//////////////////////
00713	////  Functions
00714	//////////////////////
00715	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00716	  assert(PyTuple_Check(argtuple));
00717	  if (4 != PyTuple_Size(argtuple)){ 
00718	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00719	     return NULL;
00720	  }
00721	  __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05* struct_ptr = new __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05();
00722	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00723	    delete struct_ptr;
00724	    return NULL;
00725	  }
00726	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05_executor), struct_ptr, __struct_compiled_op_c1ed95c6911b2af8661a664ce38e1c05_destructor);
00727	  return thunk; }
00728	
00729	//////////////////////
00730	////  Module init
00731	//////////////////////
00732	static PyMethodDef MyMethods[] = {
00733		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00734		{NULL, NULL, 0, NULL}
00735	};
00736	PyMODINIT_FUNC initc1ed95c6911b2af8661a664ce38e1c05(void){
00737	   import_array();
00738	   (void) Py_InitModule("c1ed95c6911b2af8661a664ce38e1c05", MyMethods);
00739	}
00740	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp7hmAnK/c1ed95c6911b2af8661a664ce38e1c05.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp7hmAnK/mod.cpp -lpython2.7
ERROR
test_shared (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_string_var (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
test_variable_only (theano.gof.tests.test_compute_test_value.TestComputeTestValue) ... ok
theano.gof.tests.test_destroyhandler.test_misc ... ok
theano.gof.tests.test_destroyhandler.test_aliased_inputs_replacement ... ok
theano.gof.tests.test_destroyhandler.test_indestructible ... ok
theano.gof.tests.test_destroyhandler.test_usage_loop_through_views_2 ... ok
theano.gof.tests.test_destroyhandler.test_destroyers_loop ... ok
theano.gof.tests.test_destroyhandler.test_aliased_inputs ... ok
theano.gof.tests.test_destroyhandler.test_aliased_inputs2 ... ok
theano.gof.tests.test_destroyhandler.test_aliased_inputs_tolerate ... ok
theano.gof.tests.test_destroyhandler.test_aliased_inputs_tolerate2 ... ok
theano.gof.tests.test_destroyhandler.test_same_aliased_inputs_ignored ... ok
theano.gof.tests.test_destroyhandler.test_different_aliased_inputs_ignored ... ok
theano.gof.tests.test_destroyhandler.test_indestructible_through_views ... ok
theano.gof.tests.test_destroyhandler.test_indirect ... ok
theano.gof.tests.test_destroyhandler.test_indirect_2 ... ok
theano.gof.tests.test_destroyhandler.test_long_destroyers_loop ... ok
theano.gof.tests.test_destroyhandler.test_misc_2 ... ok
theano.gof.tests.test_destroyhandler.test_multi_destroyers ... ok
theano.gof.tests.test_destroyhandler.test_multi_destroyers_through_views ... ok
theano.gof.tests.test_destroyhandler.test_repair_destroy_path ... ok
theano.gof.tests.test_destroyhandler.test_usage_loop ... ok
theano.gof.tests.test_destroyhandler.test_usage_loop_through_views ... ok
theano.gof.tests.test_destroyhandler.test_usage_loop_insert_views ... ok
theano.gof.tests.test_destroyhandler.test_value_repl ... ok
theano.gof.tests.test_destroyhandler.test_value_repl_2 ... ok
theano.gof.tests.test_destroyhandler.test_multiple_inplace ... ok
test_clone (theano.gof.tests.test_fg.TFunctionGraph) ... ok
test_constant_cache_error (theano.gof.tests.test_fg.TFunctionGraph) ... ok
test_node_outputs_not_used (theano.gof.tests.test_fg.TFunctionGraph) ... INFO (theano.gof.compilelock): Refreshing lock /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/lock_dir/lock
00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                int V3_jumpx_0;
00361	                
00362	                int V3_jumpx_1;
00363	                
00364	        npy_float64* V5_iter;
00365	        
00366	                npy_intp V5_n0;
00367	                ssize_t V5_stride0;
00368	                int V5_jump0_0;
00369	                
00370	                npy_intp V5_n1;
00371	                ssize_t V5_stride1;
00372	                int V5_jump1_1;
00373	                
00374	
00375	                V3_jumpx_1 = -(0);
00376	                //printf("V3_jumpx_1 is:");
00377	                //std::cout << V3_jumpx_1 << std::endl;
00378	                
00379	                V3_jumpx_0 = -(0);
00380	                //printf("V3_jumpx_0 is:");
00381	                //std::cout << V3_jumpx_0 << std::endl;
00382	                
00383	            if (PyArray_NDIM(V5) < 2) {
00384	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00385	                {
00386	        __failure = 7;
00387	        if (!PyErr_Occurred()) {
00388	            PyErr_SetString(PyExc_RuntimeError,
00389	                "Unexpected error in an Op's C code. "
00390	                "No Python exception was set.");
00391	            }
00392	        goto __label_7;}
00393	            }
00394	            
00395	                V5_n1 = PyArray_DIMS(V5)[1];
00396	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00397	                V5_jump1_1 = (V5_stride1) - (0);
00398	                //printf("V5_jump1_1 is:");
00399	                //std::cout << V5_jump1_1 << std::endl;
00400	                
00401	                V5_n0 = PyArray_DIMS(V5)[0];
00402	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00403	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00404	                //printf("V5_jump0_0 is:");
00405	                //std::cout << V5_jump0_0 << std::endl;
00406	                
00407	
00408	        npy_float64* V1_iter;
00409	        
00410	                npy_intp V1_n0;
00411	                ssize_t V1_stride0;
00412	                int V1_jump0_0;
00413	                
00414	                npy_intp V1_n1;
00415	                ssize_t V1_stride1;
00416	                int V1_jump1_1;
00417	                
00418	    {
00419	        npy_intp dims[2];
00420	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00421	        dims[0] = V5_n0;
00422	dims[1] = V5_n1;
00423	
00424	        if (!V1) {
00425	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00426	                                                    NPY_FLOAT64,
00427	                                                    PyArray_ISFORTRAN(V5));
00428	        }
00429	        else {
00430	            PyArray_Dims new_dims;
00431	            new_dims.len = 2;
00432	            new_dims.ptr = dims;
00433	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00434	            if (!success) {
00435	                // If we can't resize the ndarray we have we can allocate a new one.
00436	                PyErr_Clear();
00437	                Py_XDECREF(V1);
00438	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00439	            }
00440	        }
00441	        if (!V1) {
00442	            {
00443	        __failure = 7;
00444	        if (!PyErr_Occurred()) {
00445	            PyErr_SetString(PyExc_RuntimeError,
00446	                "Unexpected error in an Op's C code. "
00447	                "No Python exception was set.");
00448	            }
00449	        goto __label_7;}
00450	        }
00451	    }
00452	    
00453	            if (PyArray_NDIM(V1) < 2) {
00454	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00455	                {
00456	        __failure = 7;
00457	        if (!PyErr_Occurred()) {
00458	            PyErr_SetString(PyExc_RuntimeError,
00459	                "Unexpected error in an Op's C code. "
00460	                "No Python exception was set.");
00461	            }
00462	        goto __label_7;}
00463	            }
00464	            
00465	                V1_n1 = PyArray_DIMS(V1)[1];
00466	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00467	                V1_jump1_1 = (V1_stride1) - (0);
00468	                //printf("V1_jump1_1 is:");
00469	                //std::cout << V1_jump1_1 << std::endl;
00470	                
00471	                V1_n0 = PyArray_DIMS(V1)[0];
00472	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00473	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00474	                //printf("V1_jump0_0 is:");
00475	                //std::cout << V1_jump0_0 << std::endl;
00476	                
00477	
00478	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00479	                
00480	                    // All output have the same size
00481	                    npy_intp n = PyArray_SIZE(V1);
00482	                    
00483	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00484	                            
00485	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00486	                            
00487	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00488	                            
00489	                    for(int i=0; i<n; i++){
00490	                        
00491	            dtype_V5& V5_i = V5_ptr[i];
00492	                            
00493	            dtype_V1& V1_i = V1_ptr[i];
00494	                            
00495	                        V1_i = V3_i * V5_i;;
00496	                    }
00497	                    
00498	            }else{
00499	                {
00500	
00501	    std::vector< std::pair<int, int> > V1_loops(2);
00502	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00503	    
00504	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00505	            
00506	        V1_loops_it->second = 0;
00507	        ++V1_loops_it;
00508	        
00509	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00510	            
00511	        V1_loops_it->second = 1;
00512	        ++V1_loops_it;
00513	        
00514	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00515	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00516	    
00517	
00518	    int init_totals[2] = {V5_n0, V5_n1};
00519	    
00520	    V1_loops_it = V1_loops.begin();
00521	    
00522	        int TOTAL_0 = init_totals[V1_loops_it->second];
00523	        ++V1_loops_it;
00524	        
00525	        int TOTAL_1 = init_totals[V1_loops_it->second];
00526	        ++V1_loops_it;
00527	        
00528	
00529	    int init_strides[3][2] = {
00530	        0, 0, 
00531	V5_stride0, V5_stride1, 
00532	V1_stride0, V1_stride1
00533	    };
00534	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00535	    
00536	        V1_loops_rit = V1_loops.rbegin();
00537	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00538	            ++V1_loops_rit;
00539	            
00540	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00541	            ++V1_loops_rit;
00542	            
00543	        V1_loops_rit = V1_loops.rbegin();
00544	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00545	            ++V1_loops_rit;
00546	            
00547	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00548	            ++V1_loops_rit;
00549	            
00550	        V1_loops_rit = V1_loops.rbegin();
00551	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00552	            ++V1_loops_rit;
00553	            
00554	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00555	            ++V1_loops_rit;
00556	            
00557	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00558	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00559	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00560	
00561	
00562	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00563	        { // begin loop 0
00564	            
00565	            
00566	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00567	        { // begin loop 1
00568	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00569	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00570	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00571	
00572	            
00573	        {
00574	            
00575	            V1_i = V3_i * V5_i;
00576	            
00577	        }
00578	        
00579	        } // end loop 1
00580	        
00581	        } // end loop 0
00582	        
00583	}
00584	
00585	            }
00586	            __label_7:
00587	
00588	double __DUMMY_7;
00589	
00590	}
00591	__label_6:
00592	
00593	        if (V5) {
00594	            Py_XDECREF(V5);
00595	        }
00596	        
00597	    {Py_XDECREF(py_V5);}
00598	    
00599	double __DUMMY_6;
00600	
00601	}
00602	__label_4:
00603	
00604	        if (V3) {
00605	            Py_XDECREF(V3);
00606	        }
00607	        
00608	    {Py_XDECREF(py_V3);}
00609	    
00610	double __DUMMY_4;
00611	
00612	}
00613	__label_2:
00614	
00615	    if (!__failure) {
00616	      
00617	        {Py_XDECREF(py_V1);}
00618	        if (!V1) {
00619	            Py_INCREF(Py_None);
00620	            py_V1 = Py_None;
00621	        }
00622	        else if ((void*)py_V1 != (void*)V1) {
00623	            py_V1 = (PyObject*)V1;
00624	        }
00625	
00626	        {Py_XINCREF(py_V1);}
00627	
00628	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00629	            PyErr_Format(PyExc_NotImplementedError,
00630	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00631	                         " with %ld dimensions, with 3 last dims "
00632	                         "%ld, %ld, %ld"
00633	                         " and 3 last strides %ld %ld, %ld.",
00634	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00635	                         (long int) PyArray_NDIM(V1),
00636	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00637	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00638	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00639	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00640	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00641	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00642	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00643	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00644	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00645	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00646	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00647	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00648	        );
00649	            {
00650	        __failure = 2;
00651	        if (!PyErr_Occurred()) {
00652	            PyErr_SetString(PyExc_RuntimeError,
00653	                "Unexpected error in an Op's C code. "
00654	                "No Python exception was set.");
00655	            }
00656	        goto __label_2;}
00657	        }
00658	        
00659	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00660	      {Py_XINCREF(py_V1);}
00661	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00662	      {Py_XDECREF(old);}
00663	    }
00664	    
00665	        if (V1) {
00666	            Py_XDECREF(V1);
00667	        }
00668	        
00669	    {Py_XDECREF(py_V1);}
00670	    
00671	double __DUMMY_2;
00672	
00673	}
00674	
00675	            
00676	        if (__failure) {
00677	            // When there is a failure, this code puts the exception
00678	            // in __ERROR.
00679	            PyObject* err_type = NULL;
00680	            PyObject* err_msg = NULL;
00681	            PyObject* err_traceback = NULL;
00682	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00683	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00684	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00685	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00686	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00687	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00688	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00689	            PyList_SET_ITEM(__ERROR, 0, err_type);
00690	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00691	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00692	            {Py_XDECREF(old_err_type);}
00693	            {Py_XDECREF(old_err_msg);}
00694	            {Py_XDECREF(old_err_traceback);}
00695	        }
00696	        // The failure code is returned to index what code block failed.
00697	        return __failure;
00698	        
00699	        }
00700	    };
00701	    }
00702	    
00703	
00704	        static int __struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92_executor(__struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92* self) {
00705	            return self->run();
00706	        }
00707	
00708	        static void __struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92_destructor(void* executor, void* self) {
00709	            delete ((__struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92*)self);
00710	        }
00711	        
00712	//////////////////////
00713	////  Functions
00714	//////////////////////
00715	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00716	  assert(PyTuple_Check(argtuple));
00717	  if (4 != PyTuple_Size(argtuple)){ 
00718	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00719	     return NULL;
00720	  }
00721	  __struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92* struct_ptr = new __struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92();
00722	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00723	    delete struct_ptr;
00724	    return NULL;
00725	  }
00726	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92_executor), struct_ptr, __struct_compiled_op_468b414d7d7b02cf93ec613e6d322c92_destructor);
00727	  return thunk; }
00728	
00729	//////////////////////
00730	////  Module init
00731	//////////////////////
00732	static PyMethodDef MyMethods[] = {
00733		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00734		{NULL, NULL, 0, NULL}
00735	};
00736	PyMODINIT_FUNC init468b414d7d7b02cf93ec613e6d322c92(void){
00737	   import_array();
00738	   (void) Py_InitModule("468b414d7d7b02cf93ec613e6d322c92", MyMethods);
00739	}
00740	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpD4qpxd/468b414d7d7b02cf93ec613e6d322c92.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpD4qpxd/mod.cpp -lpython2.7
ERROR
test_pickle (theano.gof.tests.test_fg.TFunctionGraph) ... ok
theano.gof.tests.test_graph.TestAutoName.test_auto_name ... ok
theano.gof.tests.test_graph.TestAutoName.test_clone ... ok
theano.gof.tests.test_graph.TestAutoName.test_constant ... ok
theano.gof.tests.test_graph.TestAutoName.test_cudandarrayvariable ... ok
theano.gof.tests.test_graph.TestAutoName.test_randomvariable ... ok
theano.gof.tests.test_graph.TestAutoName.test_sparsevariable ... ok
theano.gof.tests.test_graph.TestAutoName.test_tensorvariable ... ok
theano.gof.tests.test_graph.TestClone.test_accurate ... ok
theano.gof.tests.test_graph.TestClone.test_copy ... ok
theano.gof.tests.test_graph.TestClone.test_not_destructive ... ok
test_eval (theano.gof.tests.test_graph.TestEval) ... ok
theano.gof.tests.test_graph.TestInputs.test_inputs ... ok
theano.gof.tests.test_graph.TestInputs.test_inputs_deep ... ok
Test `is_same_graph` with more complex graphs. ... ok
Test `is_same_graph` when `equal_computations` cannot be used. ... ok
Test `is_same_graph` with some trivial graphs (one Variable). ... ok
theano.gof.tests.test_graph.TestStr.test_as_string ... ok
theano.gof.tests.test_graph.TestStr.test_as_string_deep ... ok
theano.gof.tests.test_graph.TestStr.test_cutoff ... ok
theano.gof.tests.test_graph.TestStr.test_multiple_references ... ok
Test a simple graph ... ok
Test a graph with double dependencies ... ok
Test a graph where the inputs have owners ... ok
Test a graph which is not connected ... ok
Test inputs and outputs mixed together in a chain graph ... ok
Test when outputs have clients ... ok
theano.gof.tests.test_graph_opt_caching.test_graph_opt_caching ... rm: cannot remove '/<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/optimized_graphs.pkl': No such file or directory
00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_e3692c0f1b54cb9204558755248fea0d {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_e3692c0f1b54cb9204558755248fea0d() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_e3692c0f1b54cb9204558755248fea0d(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float32 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float32 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float32 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT32
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT32,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT32) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT32) got %d",
00171	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT32
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT32,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT32) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT32) got %d",
00257	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT32
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT32,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT32) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT32) got %d",
00341	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float32* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float32* V5_iter;
00369	        
00370	                npy_intp V5_n0;
00371	                ssize_t V5_stride0;
00372	                int V5_jump0_0;
00373	                
00374	                npy_intp V5_n1;
00375	                ssize_t V5_stride1;
00376	                int V5_jump1_1;
00377	                
00378	
00379	            if (PyArray_NDIM(V3) < 2) {
00380	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00381	                {
00382	        __failure = 7;
00383	        if (!PyErr_Occurred()) {
00384	            PyErr_SetString(PyExc_RuntimeError,
00385	                "Unexpected error in an Op's C code. "
00386	                "No Python exception was set.");
00387	            }
00388	        goto __label_7;}
00389	            }
00390	            
00391	                V3_n1 = PyArray_DIMS(V3)[1];
00392	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float32);
00393	                V3_jump1_1 = (V3_stride1) - (0);
00394	                //printf("V3_jump1_1 is:");
00395	                //std::cout << V3_jump1_1 << std::endl;
00396	                
00397	                V3_n0 = PyArray_DIMS(V3)[0];
00398	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float32);
00399	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00400	                //printf("V3_jump0_0 is:");
00401	                //std::cout << V3_jump0_0 << std::endl;
00402	                
00403	            if (PyArray_NDIM(V5) < 2) {
00404	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00405	                {
00406	        __failure = 7;
00407	        if (!PyErr_Occurred()) {
00408	            PyErr_SetString(PyExc_RuntimeError,
00409	                "Unexpected error in an Op's C code. "
00410	                "No Python exception was set.");
00411	            }
00412	        goto __label_7;}
00413	            }
00414	            
00415	                V5_n1 = PyArray_DIMS(V5)[1];
00416	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float32);
00417	                V5_jump1_1 = (V5_stride1) - (0);
00418	                //printf("V5_jump1_1 is:");
00419	                //std::cout << V5_jump1_1 << std::endl;
00420	                
00421	                V5_n0 = PyArray_DIMS(V5)[0];
00422	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float32);
00423	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00424	                //printf("V5_jump0_0 is:");
00425	                //std::cout << V5_jump0_0 << std::endl;
00426	                
00427	            if (V3_n0 != V5_n0)
00428	            {
00429	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00430	                   0,
00431	                   0,
00432	                   V3_n0,
00433	                   1,
00434	                   0,
00435	                   V5_n0
00436	                );
00437	                {
00438	        __failure = 7;
00439	        if (!PyErr_Occurred()) {
00440	            PyErr_SetString(PyExc_RuntimeError,
00441	                "Unexpected error in an Op's C code. "
00442	                "No Python exception was set.");
00443	            }
00444	        goto __label_7;}
00445	            }
00446	            
00447	            if (V3_n1 != V5_n1)
00448	            {
00449	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00450	                   0,
00451	                   1,
00452	                   V3_n1,
00453	                   1,
00454	                   1,
00455	                   V5_n1
00456	                );
00457	                {
00458	        __failure = 7;
00459	        if (!PyErr_Occurred()) {
00460	            PyErr_SetString(PyExc_RuntimeError,
00461	                "Unexpected error in an Op's C code. "
00462	                "No Python exception was set.");
00463	            }
00464	        goto __label_7;}
00465	            }
00466	            
00467	
00468	        npy_float32* V1_iter;
00469	        
00470	                npy_intp V1_n0;
00471	                ssize_t V1_stride0;
00472	                int V1_jump0_0;
00473	                
00474	                npy_intp V1_n1;
00475	                ssize_t V1_stride1;
00476	                int V1_jump1_1;
00477	                
00478	    {
00479	        npy_intp dims[2];
00480	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00481	        dims[0] = V3_n0;
00482	dims[1] = V3_n1;
00483	
00484	        if (!V1) {
00485	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00486	                                                    NPY_FLOAT32,
00487	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00488	        }
00489	        else {
00490	            PyArray_Dims new_dims;
00491	            new_dims.len = 2;
00492	            new_dims.ptr = dims;
00493	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00494	            if (!success) {
00495	                // If we can't resize the ndarray we have we can allocate a new one.
00496	                PyErr_Clear();
00497	                Py_XDECREF(V1);
00498	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT32, 0);
00499	            }
00500	        }
00501	        if (!V1) {
00502	            {
00503	        __failure = 7;
00504	        if (!PyErr_Occurred()) {
00505	            PyErr_SetString(PyExc_RuntimeError,
00506	                "Unexpected error in an Op's C code. "
00507	                "No Python exception was set.");
00508	            }
00509	        goto __label_7;}
00510	        }
00511	    }
00512	    
00513	            if (PyArray_NDIM(V1) < 2) {
00514	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00515	                {
00516	        __failure = 7;
00517	        if (!PyErr_Occurred()) {
00518	            PyErr_SetString(PyExc_RuntimeError,
00519	                "Unexpected error in an Op's C code. "
00520	                "No Python exception was set.");
00521	            }
00522	        goto __label_7;}
00523	            }
00524	            
00525	                V1_n1 = PyArray_DIMS(V1)[1];
00526	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float32);
00527	                V1_jump1_1 = (V1_stride1) - (0);
00528	                //printf("V1_jump1_1 is:");
00529	                //std::cout << V1_jump1_1 << std::endl;
00530	                
00531	                V1_n0 = PyArray_DIMS(V1)[0];
00532	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float32);
00533	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00534	                //printf("V1_jump0_0 is:");
00535	                //std::cout << V1_jump0_0 << std::endl;
00536	                
00537	
00538	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00539	                
00540	                    // All output have the same size
00541	                    npy_intp n = PyArray_SIZE(V1);
00542	                    
00543	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00544	                            
00545	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00546	                            
00547	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00548	                            
00549	                    for(int i=0; i<n; i++){
00550	                        
00551	            dtype_V3& V3_i = V3_ptr[i];
00552	                            
00553	            dtype_V5& V5_i = V5_ptr[i];
00554	                            
00555	            dtype_V1& V1_i = V1_ptr[i];
00556	                            
00557	                        {
00558	npy_float32 V7_tmp1;
00559	V7_tmp1 = V3_i * V3_i;
00560	V1_i = V7_tmp1 + V5_i;
00561	}
00562	;
00563	                    }
00564	                    
00565	            }else{
00566	                {
00567	
00568	    std::vector< std::pair<int, int> > V1_loops(2);
00569	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00570	    
00571	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00572	            
00573	        V1_loops_it->second = 0;
00574	        ++V1_loops_it;
00575	        
00576	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00577	            
00578	        V1_loops_it->second = 1;
00579	        ++V1_loops_it;
00580	        
00581	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00582	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00583	    
00584	
00585	    int init_totals[2] = {V3_n0, V3_n1};
00586	    
00587	    V1_loops_it = V1_loops.begin();
00588	    
00589	        int TOTAL_0 = init_totals[V1_loops_it->second];
00590	        ++V1_loops_it;
00591	        
00592	        int TOTAL_1 = init_totals[V1_loops_it->second];
00593	        ++V1_loops_it;
00594	        
00595	
00596	    int init_strides[3][2] = {
00597	        V3_stride0, V3_stride1, 
00598	V5_stride0, V5_stride1, 
00599	V1_stride0, V1_stride1
00600	    };
00601	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00602	    
00603	        V1_loops_rit = V1_loops.rbegin();
00604	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00605	            ++V1_loops_rit;
00606	            
00607	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00608	            ++V1_loops_rit;
00609	            
00610	        V1_loops_rit = V1_loops.rbegin();
00611	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00612	            ++V1_loops_rit;
00613	            
00614	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00615	            ++V1_loops_rit;
00616	            
00617	        V1_loops_rit = V1_loops.rbegin();
00618	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00619	            ++V1_loops_rit;
00620	            
00621	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00622	            ++V1_loops_rit;
00623	            
00624	V3_iter = (npy_float32*)(PyArray_DATA(V3));
00625	V5_iter = (npy_float32*)(PyArray_DATA(V5));
00626	V1_iter = (npy_float32*)(PyArray_DATA(V1));
00627	
00628	
00629	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00630	        { // begin loop 0
00631	            
00632	            
00633	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00634	        { // begin loop 1
00635	            npy_float32 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00636	npy_float32 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00637	npy_float32 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00638	
00639	            
00640	        {
00641	            
00642	            {
00643	npy_float32 V7_tmp1;
00644	V7_tmp1 = V3_i * V3_i;
00645	V1_i = V7_tmp1 + V5_i;
00646	}
00647	
00648	            
00649	        }
00650	        
00651	        } // end loop 1
00652	        
00653	        } // end loop 0
00654	        
00655	}
00656	
00657	            }
00658	            __label_7:
00659	
00660	double __DUMMY_7;
00661	
00662	}
00663	__label_6:
00664	
00665	        if (V5) {
00666	            Py_XDECREF(V5);
00667	        }
00668	        
00669	    {Py_XDECREF(py_V5);}
00670	    
00671	double __DUMMY_6;
00672	
00673	}
00674	__label_4:
00675	
00676	        if (V3) {
00677	            Py_XDECREF(V3);
00678	        }
00679	        
00680	    {Py_XDECREF(py_V3);}
00681	    
00682	double __DUMMY_4;
00683	
00684	}
00685	__label_2:
00686	
00687	    if (!__failure) {
00688	      
00689	        {Py_XDECREF(py_V1);}
00690	        if (!V1) {
00691	            Py_INCREF(Py_None);
00692	            py_V1 = Py_None;
00693	        }
00694	        else if ((void*)py_V1 != (void*)V1) {
00695	            py_V1 = (PyObject*)V1;
00696	        }
00697	
00698	        {Py_XINCREF(py_V1);}
00699	
00700	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00701	            PyErr_Format(PyExc_NotImplementedError,
00702	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00703	                         " with %ld dimensions, with 3 last dims "
00704	                         "%ld, %ld, %ld"
00705	                         " and 3 last strides %ld %ld, %ld.",
00706	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00707	                         (long int) PyArray_NDIM(V1),
00708	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00709	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00710	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00711	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00712	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00713	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00714	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00715	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00716	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00717	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00718	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00719	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00720	        );
00721	            {
00722	        __failure = 2;
00723	        if (!PyErr_Occurred()) {
00724	            PyErr_SetString(PyExc_RuntimeError,
00725	                "Unexpected error in an Op's C code. "
00726	                "No Python exception was set.");
00727	            }
00728	        goto __label_2;}
00729	        }
00730	        
00731	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00732	      {Py_XINCREF(py_V1);}
00733	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00734	      {Py_XDECREF(old);}
00735	    }
00736	    
00737	        if (V1) {
00738	            Py_XDECREF(V1);
00739	        }
00740	        
00741	    {Py_XDECREF(py_V1);}
00742	    
00743	double __DUMMY_2;
00744	
00745	}
00746	
00747	            
00748	        if (__failure) {
00749	            // When there is a failure, this code puts the exception
00750	            // in __ERROR.
00751	            PyObject* err_type = NULL;
00752	            PyObject* err_msg = NULL;
00753	            PyObject* err_traceback = NULL;
00754	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00755	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00756	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00757	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00758	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00759	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00760	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00761	            PyList_SET_ITEM(__ERROR, 0, err_type);
00762	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00763	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00764	            {Py_XDECREF(old_err_type);}
00765	            {Py_XDECREF(old_err_msg);}
00766	            {Py_XDECREF(old_err_traceback);}
00767	        }
00768	        // The failure code is returned to index what code block failed.
00769	        return __failure;
00770	        
00771	        }
00772	    };
00773	    }
00774	    
00775	
00776	        static int __struct_compiled_op_e3692c0f1b54cb9204558755248fea0d_executor(__struct_compiled_op_e3692c0f1b54cb9204558755248fea0d* self) {
00777	            return self->run();
00778	        }
00779	
00780	        static void __struct_compiled_op_e3692c0f1b54cb9204558755248fea0d_destructor(void* executor, void* self) {
00781	            delete ((__struct_compiled_op_e3692c0f1b54cb9204558755248fea0d*)self);
00782	        }
00783	        
00784	//////////////////////
00785	////  Functions
00786	//////////////////////
00787	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00788	  assert(PyTuple_Check(argtuple));
00789	  if (4 != PyTuple_Size(argtuple)){ 
00790	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00791	     return NULL;
00792	  }
00793	  __struct_compiled_op_e3692c0f1b54cb9204558755248fea0d* struct_ptr = new __struct_compiled_op_e3692c0f1b54cb9204558755248fea0d();
00794	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00795	    delete struct_ptr;
00796	    return NULL;
00797	  }
00798	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_e3692c0f1b54cb9204558755248fea0d_executor), struct_ptr, __struct_compiled_op_e3692c0f1b54cb9204558755248fea0d_destructor);
00799	  return thunk; }
00800	
00801	//////////////////////
00802	////  Module init
00803	//////////////////////
00804	static PyMethodDef MyMethods[] = {
00805		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00806		{NULL, NULL, 0, NULL}
00807	};
00808	PyMODINIT_FUNC inite3692c0f1b54cb9204558755248fea0d(void){
00809	   import_array();
00810	   (void) Py_InitModule("e3692c0f1b54cb9204558755248fea0d", MyMethods);
00811	}
00812	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp4ndBYK/e3692c0f1b54cb9204558755248fea0d.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp4ndBYK/mod.cpp -lpython2.7
ERROR
theano.gof.tests.test_lazy.test_ifelse ... ok
theano.gof.tests.test_lazy.more_complex_test ... ok
test_constant (theano.gof.tests.test_link.TestPerformLinker) ... ok
test_function (theano.gof.tests.test_link.TestPerformLinker) ... ok
test_input_dependency0 (theano.gof.tests.test_link.TestPerformLinker) ... ok
test_input_output_same (theano.gof.tests.test_link.TestPerformLinker) ... ok
test_skiphole (theano.gof.tests.test_link.TestPerformLinker) ... ok
test_thunk (theano.gof.tests.test_link.TestPerformLinker) ... ok
test_0 (theano.gof.tests.test_link.TestWrapLinker) ... ok
test_1 (theano.gof.tests.test_link.TestWrapLinker) ... ok
theano.gof.tests.test_link.test_sort_schedule_fn ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_bd42ac06567dd948b69fbe988247ea66(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                int V3_jumpx_0;
00361	                
00362	                int V3_jumpx_1;
00363	                
00364	        npy_float64* V5_iter;
00365	        
00366	                npy_intp V5_n0;
00367	                ssize_t V5_stride0;
00368	                int V5_jump0_0;
00369	                
00370	                npy_intp V5_n1;
00371	                ssize_t V5_stride1;
00372	                int V5_jump1_1;
00373	                
00374	
00375	                V3_jumpx_1 = -(0);
00376	                //printf("V3_jumpx_1 is:");
00377	                //std::cout << V3_jumpx_1 << std::endl;
00378	                
00379	                V3_jumpx_0 = -(0);
00380	                //printf("V3_jumpx_0 is:");
00381	                //std::cout << V3_jumpx_0 << std::endl;
00382	                
00383	            if (PyArray_NDIM(V5) < 2) {
00384	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00385	                {
00386	        __failure = 7;
00387	        if (!PyErr_Occurred()) {
00388	            PyErr_SetString(PyExc_RuntimeError,
00389	                "Unexpected error in an Op's C code. "
00390	                "No Python exception was set.");
00391	            }
00392	        goto __label_7;}
00393	            }
00394	            
00395	                V5_n1 = PyArray_DIMS(V5)[1];
00396	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00397	                V5_jump1_1 = (V5_stride1) - (0);
00398	                //printf("V5_jump1_1 is:");
00399	                //std::cout << V5_jump1_1 << std::endl;
00400	                
00401	                V5_n0 = PyArray_DIMS(V5)[0];
00402	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00403	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00404	                //printf("V5_jump0_0 is:");
00405	                //std::cout << V5_jump0_0 << std::endl;
00406	                
00407	
00408	        npy_float64* V1_iter;
00409	        
00410	                npy_intp V1_n0;
00411	                ssize_t V1_stride0;
00412	                int V1_jump0_0;
00413	                
00414	                npy_intp V1_n1;
00415	                ssize_t V1_stride1;
00416	                int V1_jump1_1;
00417	                
00418	    {
00419	        npy_intp dims[2];
00420	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00421	        dims[0] = V5_n0;
00422	dims[1] = V5_n1;
00423	
00424	        if (!V1) {
00425	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00426	                                                    NPY_FLOAT64,
00427	                                                    PyArray_ISFORTRAN(V5));
00428	        }
00429	        else {
00430	            PyArray_Dims new_dims;
00431	            new_dims.len = 2;
00432	            new_dims.ptr = dims;
00433	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00434	            if (!success) {
00435	                // If we can't resize the ndarray we have we can allocate a new one.
00436	                PyErr_Clear();
00437	                Py_XDECREF(V1);
00438	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00439	            }
00440	        }
00441	        if (!V1) {
00442	            {
00443	        __failure = 7;
00444	        if (!PyErr_Occurred()) {
00445	            PyErr_SetString(PyExc_RuntimeError,
00446	                "Unexpected error in an Op's C code. "
00447	                "No Python exception was set.");
00448	            }
00449	        goto __label_7;}
00450	        }
00451	    }
00452	    
00453	            if (PyArray_NDIM(V1) < 2) {
00454	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00455	                {
00456	        __failure = 7;
00457	        if (!PyErr_Occurred()) {
00458	            PyErr_SetString(PyExc_RuntimeError,
00459	                "Unexpected error in an Op's C code. "
00460	                "No Python exception was set.");
00461	            }
00462	        goto __label_7;}
00463	            }
00464	            
00465	                V1_n1 = PyArray_DIMS(V1)[1];
00466	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00467	                V1_jump1_1 = (V1_stride1) - (0);
00468	                //printf("V1_jump1_1 is:");
00469	                //std::cout << V1_jump1_1 << std::endl;
00470	                
00471	                V1_n0 = PyArray_DIMS(V1)[0];
00472	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00473	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00474	                //printf("V1_jump0_0 is:");
00475	                //std::cout << V1_jump0_0 << std::endl;
00476	                
00477	
00478	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00479	                
00480	                    // All output have the same size
00481	                    npy_intp n = PyArray_SIZE(V1);
00482	                    
00483	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00484	                            
00485	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00486	                            
00487	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00488	                            
00489	                    for(int i=0; i<n; i++){
00490	                        
00491	            dtype_V5& V5_i = V5_ptr[i];
00492	                            
00493	            dtype_V1& V1_i = V1_ptr[i];
00494	                            
00495	                        V1_i = V3_i + V5_i;;
00496	                    }
00497	                    
00498	            }else{
00499	                {
00500	
00501	    std::vector< std::pair<int, int> > V1_loops(2);
00502	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00503	    
00504	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00505	            
00506	        V1_loops_it->second = 0;
00507	        ++V1_loops_it;
00508	        
00509	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00510	            
00511	        V1_loops_it->second = 1;
00512	        ++V1_loops_it;
00513	        
00514	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00515	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00516	    
00517	
00518	    int init_totals[2] = {V5_n0, V5_n1};
00519	    
00520	    V1_loops_it = V1_loops.begin();
00521	    
00522	        int TOTAL_0 = init_totals[V1_loops_it->second];
00523	        ++V1_loops_it;
00524	        
00525	        int TOTAL_1 = init_totals[V1_loops_it->second];
00526	        ++V1_loops_it;
00527	        
00528	
00529	    int init_strides[3][2] = {
00530	        0, 0, 
00531	V5_stride0, V5_stride1, 
00532	V1_stride0, V1_stride1
00533	    };
00534	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00535	    
00536	        V1_loops_rit = V1_loops.rbegin();
00537	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00538	            ++V1_loops_rit;
00539	            
00540	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00541	            ++V1_loops_rit;
00542	            
00543	        V1_loops_rit = V1_loops.rbegin();
00544	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00545	            ++V1_loops_rit;
00546	            
00547	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00548	            ++V1_loops_rit;
00549	            
00550	        V1_loops_rit = V1_loops.rbegin();
00551	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00552	            ++V1_loops_rit;
00553	            
00554	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00555	            ++V1_loops_rit;
00556	            
00557	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00558	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00559	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00560	
00561	
00562	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00563	        { // begin loop 0
00564	            
00565	            
00566	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00567	        { // begin loop 1
00568	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00569	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00570	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00571	
00572	            
00573	        {
00574	            
00575	            V1_i = V3_i + V5_i;
00576	            
00577	        }
00578	        
00579	        } // end loop 1
00580	        
00581	        } // end loop 0
00582	        
00583	}
00584	
00585	            }
00586	            __label_7:
00587	
00588	double __DUMMY_7;
00589	
00590	}
00591	__label_6:
00592	
00593	        if (V5) {
00594	            Py_XDECREF(V5);
00595	        }
00596	        
00597	    {Py_XDECREF(py_V5);}
00598	    
00599	double __DUMMY_6;
00600	
00601	}
00602	__label_4:
00603	
00604	        if (V3) {
00605	            Py_XDECREF(V3);
00606	        }
00607	        
00608	    {Py_XDECREF(py_V3);}
00609	    
00610	double __DUMMY_4;
00611	
00612	}
00613	__label_2:
00614	
00615	    if (!__failure) {
00616	      
00617	        {Py_XDECREF(py_V1);}
00618	        if (!V1) {
00619	            Py_INCREF(Py_None);
00620	            py_V1 = Py_None;
00621	        }
00622	        else if ((void*)py_V1 != (void*)V1) {
00623	            py_V1 = (PyObject*)V1;
00624	        }
00625	
00626	        {Py_XINCREF(py_V1);}
00627	
00628	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00629	            PyErr_Format(PyExc_NotImplementedError,
00630	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00631	                         " with %ld dimensions, with 3 last dims "
00632	                         "%ld, %ld, %ld"
00633	                         " and 3 last strides %ld %ld, %ld.",
00634	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00635	                         (long int) PyArray_NDIM(V1),
00636	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00637	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00638	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00639	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00640	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00641	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00642	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00643	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00644	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00645	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00646	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00647	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00648	        );
00649	            {
00650	        __failure = 2;
00651	        if (!PyErr_Occurred()) {
00652	            PyErr_SetString(PyExc_RuntimeError,
00653	                "Unexpected error in an Op's C code. "
00654	                "No Python exception was set.");
00655	            }
00656	        goto __label_2;}
00657	        }
00658	        
00659	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00660	      {Py_XINCREF(py_V1);}
00661	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00662	      {Py_XDECREF(old);}
00663	    }
00664	    
00665	        if (V1) {
00666	            Py_XDECREF(V1);
00667	        }
00668	        
00669	    {Py_XDECREF(py_V1);}
00670	    
00671	double __DUMMY_2;
00672	
00673	}
00674	
00675	            
00676	        if (__failure) {
00677	            // When there is a failure, this code puts the exception
00678	            // in __ERROR.
00679	            PyObject* err_type = NULL;
00680	            PyObject* err_msg = NULL;
00681	            PyObject* err_traceback = NULL;
00682	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00683	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00684	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00685	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00686	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00687	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00688	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00689	            PyList_SET_ITEM(__ERROR, 0, err_type);
00690	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00691	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00692	            {Py_XDECREF(old_err_type);}
00693	            {Py_XDECREF(old_err_msg);}
00694	            {Py_XDECREF(old_err_traceback);}
00695	        }
00696	        // The failure code is returned to index what code block failed.
00697	        return __failure;
00698	        
00699	        }
00700	    };
00701	    }
00702	    
00703	
00704	        static int __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66_executor(__struct_compiled_op_bd42ac06567dd948b69fbe988247ea66* self) {
00705	            return self->run();
00706	        }
00707	
00708	        static void __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66_destructor(void* executor, void* self) {
00709	            delete ((__struct_compiled_op_bd42ac06567dd948b69fbe988247ea66*)self);
00710	        }
00711	        
00712	//////////////////////
00713	////  Functions
00714	//////////////////////
00715	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00716	  assert(PyTuple_Check(argtuple));
00717	  if (4 != PyTuple_Size(argtuple)){ 
00718	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00719	     return NULL;
00720	  }
00721	  __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66* struct_ptr = new __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66();
00722	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00723	    delete struct_ptr;
00724	    return NULL;
00725	  }
00726	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_bd42ac06567dd948b69fbe988247ea66_executor), struct_ptr, __struct_compiled_op_bd42ac06567dd948b69fbe988247ea66_destructor);
00727	  return thunk; }
00728	
00729	//////////////////////
00730	////  Module init
00731	//////////////////////
00732	static PyMethodDef MyMethods[] = {
00733		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00734		{NULL, NULL, 0, NULL}
00735	};
00736	PyMODINIT_FUNC initbd42ac06567dd948b69fbe988247ea66(void){
00737	   import_array();
00738	   (void) Py_InitModule("bd42ac06567dd948b69fbe988247ea66", MyMethods);
00739	}
00740	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpp2BvFC/bd42ac06567dd948b69fbe988247ea66.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpp2BvFC/mod.cpp -lpython2.7
ERROR
This is a test to a work around a NumPy bug. ... ok
test_no_c_code (theano.gof.tests.test_op.TestMakeThunk) ... ok
test_no_make_node (theano.gof.tests.test_op.TestMakeThunk) ... ok
test_no_perform (theano.gof.tests.test_op.TestMakeThunk) ... ok
theano.gof.tests.test_op.TestOp.test_op_no_input ... ok
theano.gof.tests.test_op.TestOp.test_op_struct ... ok
theano.gof.tests.test_op.TestOp.test_sanity_0 ... ok
theano.gof.tests.test_op.TestOp.test_validate ... ok
theano.gof.tests.test_op.test_test_value_python_objects ... ok
theano.gof.tests.test_op.test_test_value_ndarray ... ok
theano.gof.tests.test_op.test_test_value_constant ... ok
theano.gof.tests.test_op.test_test_value_shared ... ok
theano.gof.tests.test_op.test_test_value_op ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V1;
00019	        
00020	
00021	        __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154() {
00022	            // This is only somewhat safe because we:
00023	            //  1) Are not a virtual class
00024	            //  2) Do not use any virtual classes in the members
00025	            //  3) Deal with mostly POD and pointers
00026	
00027	            // If this changes, we would have to revise this, but for
00028	            // now I am tired of chasing segfaults because
00029	            // initialization code had an error and some pointer has
00030	            // a junk value.
00031	            memset(this, 0, sizeof(*this));
00032	        }
00033	        ~__struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154(void) {
00034	            cleanup();
00035	        }
00036	
00037	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V1) {
00038	            Py_XINCREF(storage_V3);
00039	Py_XINCREF(storage_V1);
00040	            this->storage_V3 = storage_V3;
00041	this->storage_V1 = storage_V1;
00042	            
00043	
00044	
00045	
00046	            this->__ERROR = __ERROR;
00047	            return 0;
00048	        }
00049	        void cleanup(void) {
00050	            __label_1:
00051	
00052	double __DUMMY_1;
00053	__label_3:
00054	
00055	double __DUMMY_3;
00056	__label_6:
00057	
00058	double __DUMMY_6;
00059	
00060	            Py_XDECREF(this->storage_V3);
00061	Py_XDECREF(this->storage_V1);
00062	        }
00063	        int run(void) {
00064	            int __failure = 0;
00065	            
00066	    PyObject* py_V1;
00067	    
00068	        PyArrayObject* V1;
00069	        
00070	            typedef npy_float64 dtype_V1;
00071	            
00072	    PyObject* py_V3;
00073	    
00074	        PyArrayObject* V3;
00075	        
00076	            typedef npy_float64 dtype_V3;
00077	            
00078	{
00079	
00080	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00081	    {Py_XINCREF(py_V1);}
00082	    
00083	        if (py_V1 == Py_None)
00084	        {
00085	            
00086	        V1 = NULL;
00087	        
00088	        }
00089	        else
00090	        {
00091	            
00092	            V1 = NULL;
00093	            if (py_V1 == Py_None) {
00094	                // We can either fail here or set V1 to NULL and rely on Ops
00095	                // using tensors to handle the NULL case, but if they fail to do so
00096	                // they'll end up with nasty segfaults, so this is public service.
00097	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00098	                {
00099	        __failure = 2;
00100	        if (!PyErr_Occurred()) {
00101	            PyErr_SetString(PyExc_RuntimeError,
00102	                "Unexpected error in an Op's C code. "
00103	                "No Python exception was set.");
00104	            }
00105	        goto __label_2;}
00106	            }
00107	            if (!PyArray_Check(py_V1)) {
00108	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00109	                {
00110	        __failure = 2;
00111	        if (!PyErr_Occurred()) {
00112	            PyErr_SetString(PyExc_RuntimeError,
00113	                "Unexpected error in an Op's C code. "
00114	                "No Python exception was set.");
00115	            }
00116	        goto __label_2;}
00117	            }
00118	            // We expect NPY_FLOAT64
00119	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00120	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00121	                PyErr_Format(PyExc_NotImplementedError,
00122	                             "expected an aligned array of type %ld "
00123	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00124	                             " with %ld dimensions, with 3 last dims "
00125	                             "%ld, %ld, %ld"
00126	                             " and 3 last strides %ld %ld, %ld.",
00127	                             (long int) NPY_FLOAT64,
00128	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00129	                             (long int) PyArray_NDIM(tmp),
00130	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00131	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00132	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00133	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00134	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00135	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00136	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00137	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00138	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00139	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00140	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00141	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00142	            );
00143	                {
00144	        __failure = 2;
00145	        if (!PyErr_Occurred()) {
00146	            PyErr_SetString(PyExc_RuntimeError,
00147	                "Unexpected error in an Op's C code. "
00148	                "No Python exception was set.");
00149	            }
00150	        goto __label_2;}
00151	            }
00152	            // This is a TypeError to be consistent with DEBUG_MODE
00153	            // Note: DEBUG_MODE also tells the name of the container
00154	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00155	                PyErr_Format(PyExc_TypeError,
00156	                             "expected type_num %d (NPY_FLOAT64) got %d",
00157	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00158	                {
00159	        __failure = 2;
00160	        if (!PyErr_Occurred()) {
00161	            PyErr_SetString(PyExc_RuntimeError,
00162	                "Unexpected error in an Op's C code. "
00163	                "No Python exception was set.");
00164	            }
00165	        goto __label_2;}
00166	            }
00167	            
00168	        V1 = (PyArrayObject*)(py_V1);
00169	        Py_XINCREF(V1);
00170	        
00171	        }
00172	        
00173	{
00174	
00175	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00176	    {Py_XINCREF(py_V3);}
00177	    
00178	            V3 = NULL;
00179	            if (py_V3 == Py_None) {
00180	                // We can either fail here or set V3 to NULL and rely on Ops
00181	                // using tensors to handle the NULL case, but if they fail to do so
00182	                // they'll end up with nasty segfaults, so this is public service.
00183	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            if (!PyArray_Check(py_V3)) {
00194	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00195	                {
00196	        __failure = 4;
00197	        if (!PyErr_Occurred()) {
00198	            PyErr_SetString(PyExc_RuntimeError,
00199	                "Unexpected error in an Op's C code. "
00200	                "No Python exception was set.");
00201	            }
00202	        goto __label_4;}
00203	            }
00204	            // We expect NPY_FLOAT64
00205	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00206	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00207	                PyErr_Format(PyExc_NotImplementedError,
00208	                             "expected an aligned array of type %ld "
00209	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00210	                             " with %ld dimensions, with 3 last dims "
00211	                             "%ld, %ld, %ld"
00212	                             " and 3 last strides %ld %ld, %ld.",
00213	                             (long int) NPY_FLOAT64,
00214	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00215	                             (long int) PyArray_NDIM(tmp),
00216	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00217	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00218	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00219	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00220	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00221	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00222	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00223	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00224	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00225	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00226	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00227	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00228	            );
00229	                {
00230	        __failure = 4;
00231	        if (!PyErr_Occurred()) {
00232	            PyErr_SetString(PyExc_RuntimeError,
00233	                "Unexpected error in an Op's C code. "
00234	                "No Python exception was set.");
00235	            }
00236	        goto __label_4;}
00237	            }
00238	            // This is a TypeError to be consistent with DEBUG_MODE
00239	            // Note: DEBUG_MODE also tells the name of the container
00240	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00241	                PyErr_Format(PyExc_TypeError,
00242	                             "expected type_num %d (NPY_FLOAT64) got %d",
00243	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00244	                {
00245	        __failure = 4;
00246	        if (!PyErr_Occurred()) {
00247	            PyErr_SetString(PyExc_RuntimeError,
00248	                "Unexpected error in an Op's C code. "
00249	                "No Python exception was set.");
00250	            }
00251	        goto __label_4;}
00252	            }
00253	            
00254	        V3 = (PyArrayObject*)(py_V3);
00255	        Py_XINCREF(V3);
00256	        
00257	{
00258	// Op class Elemwise
00259	
00260	        npy_float64* V3_iter;
00261	        
00262	                npy_intp V3_n0;
00263	                ssize_t V3_stride0;
00264	                int V3_jump0_0;
00265	                
00266	                npy_intp V3_n1;
00267	                ssize_t V3_stride1;
00268	                int V3_jump1_1;
00269	                
00270	
00271	            if (PyArray_NDIM(V3) < 2) {
00272	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00273	                {
00274	        __failure = 5;
00275	        if (!PyErr_Occurred()) {
00276	            PyErr_SetString(PyExc_RuntimeError,
00277	                "Unexpected error in an Op's C code. "
00278	                "No Python exception was set.");
00279	            }
00280	        goto __label_5;}
00281	            }
00282	            
00283	                V3_n1 = PyArray_DIMS(V3)[1];
00284	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00285	                V3_jump1_1 = (V3_stride1) - (0);
00286	                //printf("V3_jump1_1 is:");
00287	                //std::cout << V3_jump1_1 << std::endl;
00288	                
00289	                V3_n0 = PyArray_DIMS(V3)[0];
00290	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00291	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00292	                //printf("V3_jump0_0 is:");
00293	                //std::cout << V3_jump0_0 << std::endl;
00294	                
00295	
00296	        npy_float64* V1_iter;
00297	        
00298	                npy_intp V1_n0;
00299	                ssize_t V1_stride0;
00300	                int V1_jump0_0;
00301	                
00302	                npy_intp V1_n1;
00303	                ssize_t V1_stride1;
00304	                int V1_jump1_1;
00305	                
00306	    {
00307	        npy_intp dims[2];
00308	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00309	        dims[0] = V3_n0;
00310	dims[1] = V3_n1;
00311	
00312	        if (!V1) {
00313	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00314	                                                    NPY_FLOAT64,
00315	                                                    PyArray_ISFORTRAN(V3));
00316	        }
00317	        else {
00318	            PyArray_Dims new_dims;
00319	            new_dims.len = 2;
00320	            new_dims.ptr = dims;
00321	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00322	            if (!success) {
00323	                // If we can't resize the ndarray we have we can allocate a new one.
00324	                PyErr_Clear();
00325	                Py_XDECREF(V1);
00326	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00327	            }
00328	        }
00329	        if (!V1) {
00330	            {
00331	        __failure = 5;
00332	        if (!PyErr_Occurred()) {
00333	            PyErr_SetString(PyExc_RuntimeError,
00334	                "Unexpected error in an Op's C code. "
00335	                "No Python exception was set.");
00336	            }
00337	        goto __label_5;}
00338	        }
00339	    }
00340	    
00341	            if (PyArray_NDIM(V1) < 2) {
00342	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00343	                {
00344	        __failure = 5;
00345	        if (!PyErr_Occurred()) {
00346	            PyErr_SetString(PyExc_RuntimeError,
00347	                "Unexpected error in an Op's C code. "
00348	                "No Python exception was set.");
00349	            }
00350	        goto __label_5;}
00351	            }
00352	            
00353	                V1_n1 = PyArray_DIMS(V1)[1];
00354	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00355	                V1_jump1_1 = (V1_stride1) - (0);
00356	                //printf("V1_jump1_1 is:");
00357	                //std::cout << V1_jump1_1 << std::endl;
00358	                
00359	                V1_n0 = PyArray_DIMS(V1)[0];
00360	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00361	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00362	                //printf("V1_jump0_0 is:");
00363	                //std::cout << V1_jump0_0 << std::endl;
00364	                
00365	
00366	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V1))){
00367	                
00368	                    // All output have the same size
00369	                    npy_intp n = PyArray_SIZE(V1);
00370	                    
00371	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00372	                            
00373	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00374	                            
00375	                    for(int i=0; i<n; i++){
00376	                        
00377	            dtype_V3& V3_i = V3_ptr[i];
00378	                            
00379	            dtype_V1& V1_i = V1_ptr[i];
00380	                            
00381	                        V1_i = log(V3_i);;
00382	                    }
00383	                    
00384	            }else{
00385	                {
00386	
00387	    std::vector< std::pair<int, int> > V1_loops(2);
00388	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00389	    
00390	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00391	            
00392	        V1_loops_it->second = 0;
00393	        ++V1_loops_it;
00394	        
00395	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00396	            
00397	        V1_loops_it->second = 1;
00398	        ++V1_loops_it;
00399	        
00400	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00401	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00402	    
00403	
00404	    int init_totals[2] = {V3_n0, V3_n1};
00405	    
00406	    V1_loops_it = V1_loops.begin();
00407	    
00408	        int TOTAL_0 = init_totals[V1_loops_it->second];
00409	        ++V1_loops_it;
00410	        
00411	        int TOTAL_1 = init_totals[V1_loops_it->second];
00412	        ++V1_loops_it;
00413	        
00414	
00415	    int init_strides[2][2] = {
00416	        V3_stride0, V3_stride1, 
00417	V1_stride0, V1_stride1
00418	    };
00419	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00420	    
00421	        V1_loops_rit = V1_loops.rbegin();
00422	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00423	            ++V1_loops_rit;
00424	            
00425	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00426	            ++V1_loops_rit;
00427	            
00428	        V1_loops_rit = V1_loops.rbegin();
00429	            int V1_stride_l1 = init_strides[1][V1_loops_rit->second];
00430	            ++V1_loops_rit;
00431	            
00432	            int V1_stride_l0 = init_strides[1][V1_loops_rit->second];
00433	            ++V1_loops_rit;
00434	            
00435	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00436	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00437	
00438	
00439	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00440	        { // begin loop 0
00441	            
00442	            
00443	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00444	        { // begin loop 1
00445	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00446	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00447	
00448	            
00449	        {
00450	            
00451	            V1_i = log(V3_i);
00452	            
00453	        }
00454	        
00455	        } // end loop 1
00456	        
00457	        } // end loop 0
00458	        
00459	}
00460	
00461	            }
00462	            __label_5:
00463	
00464	double __DUMMY_5;
00465	
00466	}
00467	__label_4:
00468	
00469	        if (V3) {
00470	            Py_XDECREF(V3);
00471	        }
00472	        
00473	    {Py_XDECREF(py_V3);}
00474	    
00475	double __DUMMY_4;
00476	
00477	}
00478	__label_2:
00479	
00480	    if (!__failure) {
00481	      
00482	        {Py_XDECREF(py_V1);}
00483	        if (!V1) {
00484	            Py_INCREF(Py_None);
00485	            py_V1 = Py_None;
00486	        }
00487	        else if ((void*)py_V1 != (void*)V1) {
00488	            py_V1 = (PyObject*)V1;
00489	        }
00490	
00491	        {Py_XINCREF(py_V1);}
00492	
00493	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00494	            PyErr_Format(PyExc_NotImplementedError,
00495	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00496	                         " with %ld dimensions, with 3 last dims "
00497	                         "%ld, %ld, %ld"
00498	                         " and 3 last strides %ld %ld, %ld.",
00499	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00500	                         (long int) PyArray_NDIM(V1),
00501	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00502	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00503	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00504	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00505	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00506	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00507	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00508	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00509	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00510	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00511	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00512	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00513	        );
00514	            {
00515	        __failure = 2;
00516	        if (!PyErr_Occurred()) {
00517	            PyErr_SetString(PyExc_RuntimeError,
00518	                "Unexpected error in an Op's C code. "
00519	                "No Python exception was set.");
00520	            }
00521	        goto __label_2;}
00522	        }
00523	        
00524	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00525	      {Py_XINCREF(py_V1);}
00526	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00527	      {Py_XDECREF(old);}
00528	    }
00529	    
00530	        if (V1) {
00531	            Py_XDECREF(V1);
00532	        }
00533	        
00534	    {Py_XDECREF(py_V1);}
00535	    
00536	double __DUMMY_2;
00537	
00538	}
00539	
00540	            
00541	        if (__failure) {
00542	            // When there is a failure, this code puts the exception
00543	            // in __ERROR.
00544	            PyObject* err_type = NULL;
00545	            PyObject* err_msg = NULL;
00546	            PyObject* err_traceback = NULL;
00547	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00548	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00549	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00550	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00551	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00552	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00553	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00554	            PyList_SET_ITEM(__ERROR, 0, err_type);
00555	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00556	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00557	            {Py_XDECREF(old_err_type);}
00558	            {Py_XDECREF(old_err_msg);}
00559	            {Py_XDECREF(old_err_traceback);}
00560	        }
00561	        // The failure code is returned to index what code block failed.
00562	        return __failure;
00563	        
00564	        }
00565	    };
00566	    }
00567	    
00568	
00569	        static int __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154_executor(__struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154* self) {
00570	            return self->run();
00571	        }
00572	
00573	        static void __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154_destructor(void* executor, void* self) {
00574	            delete ((__struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154*)self);
00575	        }
00576	        
00577	//////////////////////
00578	////  Functions
00579	//////////////////////
00580	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00581	  assert(PyTuple_Check(argtuple));
00582	  if (3 != PyTuple_Size(argtuple)){ 
00583	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 3, got %i", (int)PyTuple_Size(argtuple));
00584	     return NULL;
00585	  }
00586	  __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154* struct_ptr = new __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154();
00587	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2) ) != 0) {
00588	    delete struct_ptr;
00589	    return NULL;
00590	  }
00591	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154_executor), struct_ptr, __struct_compiled_op_aebb6fadc52c9a62c8fc5c2d16c76154_destructor);
00592	  return thunk; }
00593	
00594	//////////////////////
00595	////  Module init
00596	//////////////////////
00597	static PyMethodDef MyMethods[] = {
00598		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00599		{NULL, NULL, 0, NULL}
00600	};
00601	PyMODINIT_FUNC initaebb6fadc52c9a62c8fc5c2d16c76154(void){
00602	   import_array();
00603	   (void) Py_InitModule("aebb6fadc52c9a62c8fc5c2d16c76154", MyMethods);
00604	}
00605	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpFZ29d7/aebb6fadc52c9a62c8fc5c2d16c76154.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpFZ29d7/mod.cpp -lpython2.7
ERROR
get_debug_values should return [] when debugger is off ... ok
get_debug_values should return [] when debugger is ignore ... ok
tests that get_debug_value returns values when available ... ok
tests that get_debug_value raises an exception when ... ok
tests that debug_error_message raises an ... ok
theano.gof.tests.test_opt.TestEquilibrium.test_1 ... ok
theano.gof.tests.test_opt.TestEquilibrium.test_2 ... ok
theano.gof.tests.test_opt.TestEquilibrium.test_low_use_ratio ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_both_assert_merge_identical ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_constant_merging ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_deep_merge ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_identical_constant_args ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_merge_noinput ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_merge_outputs ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_multiple_merges ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_no_merge ... ok
theano.gof.tests.test_opt.TestMergeOptimizer.test_straightforward ... ok
theano.gof.tests.test_opt.TestOpSubOptimizer.test_straightforward ... ok
theano.gof.tests.test_opt.TestOpSubOptimizer.test_straightforward_2 ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_ambiguous ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_constant_unification ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_constraints ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_eq ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_expand ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_match_same ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_match_same_illegal ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_multi ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_multiple ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_nested_even ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_nested_odd ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_nested_out_pattern ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_no_recurse ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_replace_output ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_replace_subgraph ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_unification_1 ... ok
theano.gof.tests.test_opt.TestPatternOptimizer.test_unification_2 ... ok
theano.gof.tests.test_opt.test_pre_constant_merge_slice ... ok
test_0 (theano.gof.tests.test_optdb.Test_DB) ... ok
theano.gof.tests.test_sched.test_dependence ... ok
theano.gof.tests.test_sched.test_sort_apply_nodes ... ok
theano.gof.tests.test_sched.test_reverse_dict ... ok
theano.gof.tests.test_sched.test__toposort ... ok
theano.gof.tests.test_sched.test_posort_easy ... ok
theano.gof.tests.test_sched.test_posort ... ok
theano.gof.tests.test_toolbox.TestNodeFinder.test_straightforward ... ok
theano.gof.tests.test_types.test_cdata ... ok
theano.gof.tests.test_utils.test_give_variables_names ... ok
theano.gof.tests.test_utils.test_give_variables_names_idempotence ... ok
theano.gof.tests.test_utils.test_give_variables_names_small ... ok
theano.gof.tests.test_utils.test_remove ... ok
theano.gof.tests.test_utils.test_stack_trace ... ok
test_callback (theano.gof.tests.test_vm.TestCallbacks) ... ok
test_callback_with_ifelse (theano.gof.tests.test_vm.TestCallbacks) ... ok
theano.gof.tests.test_vm.test_c_thunks ... ok
theano.gof.tests.test_vm.test_speed ... ok
theano.gof.tests.test_vm.test_speed_lazy ... ok
theano.gof.tests.test_vm.test_partial_function ... /<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/vm.py:854: UserWarning: LoopGC does not support partial evaluation, using Stack VM.
  'LoopGC does not support partial evaluation, '
ok
theano.gof.tests.test_vm.test_partial_function_with_output_keys ... ok
theano.gof.tests.test_vm.test_partial_function_with_updates ... ok
theano.gof.tests.test_vm.test_allow_gc_cvm ... ok
This already caused a bug in the trunk of Theano. ... ok
theano.gof.tests.test_vm.test_reallocation ... ok
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
theano.gpuarray.tests.test_pickle.test_unpickle_gpuarray_as_numpy_ndarray_flag1 ... ok
theano.gpuarray.tests.test_pickle.test_unpickle_gpuarray_as_numpy_ndarray_flag2 ... /<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gpuarray/type.py:829: UserWarning: config.experimental.unpickle_gpu_on_cpu is set to True. Unpickling GpuArray as numpy.ndarray
  "config.experimental.unpickle_gpu_on_cpu is set to True. "
ok
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
Failure: SkipTest (gnumpy not installed. Skip test of theano op with pycuda code.) ... SKIP: gnumpy not installed. Skip test of theano op with pycuda code.
Failure: SkipTest (gnumpy not installed. Skip test related to it.) ... SKIP: gnumpy not installed. Skip test related to it.
theano.misc.tests.test_may_share_memory.test_may_share_memory ... ok
theano.misc.tests.test_may_share_memory.test_may_share_memory_scipy ... ok
test_dump_load (theano.misc.tests.test_pkl_utils.T_dump_load) ... SKIP: Optional package cuda disabled
test_dump_load_mrg (theano.misc.tests.test_pkl_utils.T_dump_load) ... ok
test_dump_zip_names (theano.misc.tests.test_pkl_utils.T_dump_load) ... ok
test0 (theano.misc.tests.test_pkl_utils.TestStripPickler) ... ok
Failure: SkipTest (Pycuda not installed. Skip test of theano op with pycuda code.) ... SKIP: Pycuda not installed. Skip test of theano op with pycuda code.
Failure: SkipTest (Pycuda not installed. We skip tests of Theano Ops with pycuda code.) ... SKIP: Pycuda not installed. We skip tests of Theano Ops with pycuda code.
Failure: SkipTest (Pycuda not installed. Skip test of theano op with pycuda code.) ... SKIP: Pycuda not installed. Skip test of theano op with pycuda code.
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda not available) ... SKIP: Optional package cuda not available
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda not available) ... SKIP: Optional package cuda not available
Failure: SkipTest (Optional package cuda not available) ... SKIP: Optional package cuda not available
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
Failure: SkipTest (Optional package cuda disabled) ... SKIP: Optional package cuda disabled
theano.sandbox.cuda.tests.test_viewop.test_viewop_gpu ... SKIP: Optional package cuda disabled
theano.sandbox.linalg.tests.test_linalg.test_rop_lop ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_00ddd87b3207a941dda892013e5f4775 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_00ddd87b3207a941dda892013e5f4775() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_00ddd87b3207a941dda892013e5f4775(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float64* V5_iter;
00369	        
00370	                npy_intp V5_n0;
00371	                ssize_t V5_stride0;
00372	                int V5_jump0_0;
00373	                
00374	                npy_intp V5_n1;
00375	                ssize_t V5_stride1;
00376	                int V5_jump1_1;
00377	                
00378	
00379	            if (PyArray_NDIM(V3) < 2) {
00380	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00381	                {
00382	        __failure = 7;
00383	        if (!PyErr_Occurred()) {
00384	            PyErr_SetString(PyExc_RuntimeError,
00385	                "Unexpected error in an Op's C code. "
00386	                "No Python exception was set.");
00387	            }
00388	        goto __label_7;}
00389	            }
00390	            
00391	                V3_n1 = PyArray_DIMS(V3)[1];
00392	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00393	                V3_jump1_1 = (V3_stride1) - (0);
00394	                //printf("V3_jump1_1 is:");
00395	                //std::cout << V3_jump1_1 << std::endl;
00396	                
00397	                V3_n0 = PyArray_DIMS(V3)[0];
00398	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00399	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00400	                //printf("V3_jump0_0 is:");
00401	                //std::cout << V3_jump0_0 << std::endl;
00402	                
00403	            if (PyArray_NDIM(V5) < 2) {
00404	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00405	                {
00406	        __failure = 7;
00407	        if (!PyErr_Occurred()) {
00408	            PyErr_SetString(PyExc_RuntimeError,
00409	                "Unexpected error in an Op's C code. "
00410	                "No Python exception was set.");
00411	            }
00412	        goto __label_7;}
00413	            }
00414	            
00415	                V5_n1 = PyArray_DIMS(V5)[1];
00416	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00417	                V5_jump1_1 = (V5_stride1) - (0);
00418	                //printf("V5_jump1_1 is:");
00419	                //std::cout << V5_jump1_1 << std::endl;
00420	                
00421	                V5_n0 = PyArray_DIMS(V5)[0];
00422	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00423	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00424	                //printf("V5_jump0_0 is:");
00425	                //std::cout << V5_jump0_0 << std::endl;
00426	                
00427	            if (V3_n0 != V5_n0)
00428	            {
00429	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00430	                   0,
00431	                   0,
00432	                   V3_n0,
00433	                   1,
00434	                   0,
00435	                   V5_n0
00436	                );
00437	                {
00438	        __failure = 7;
00439	        if (!PyErr_Occurred()) {
00440	            PyErr_SetString(PyExc_RuntimeError,
00441	                "Unexpected error in an Op's C code. "
00442	                "No Python exception was set.");
00443	            }
00444	        goto __label_7;}
00445	            }
00446	            
00447	            if (V3_n1 != V5_n1)
00448	            {
00449	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00450	                   0,
00451	                   1,
00452	                   V3_n1,
00453	                   1,
00454	                   1,
00455	                   V5_n1
00456	                );
00457	                {
00458	        __failure = 7;
00459	        if (!PyErr_Occurred()) {
00460	            PyErr_SetString(PyExc_RuntimeError,
00461	                "Unexpected error in an Op's C code. "
00462	                "No Python exception was set.");
00463	            }
00464	        goto __label_7;}
00465	            }
00466	            
00467	
00468	            if (V1) {
00469	                Py_XDECREF(V1);
00470	            }
00471	            V1 = V3;
00472	            Py_XINCREF(V1);
00473	            
00474	
00475	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00476	                
00477	                    // All output have the same size
00478	                    npy_intp n = PyArray_SIZE(V1);
00479	                    
00480	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00481	                            
00482	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00483	                            
00484	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00485	                            
00486	                    for(int i=0; i<n; i++){
00487	                        
00488	            dtype_V3& V3_i = V3_ptr[i];
00489	                            
00490	            dtype_V5& V5_i = V5_ptr[i];
00491	                            
00492	            dtype_V1& V1_i = V1_ptr[i];
00493	                            
00494	                        V1_i = V3_i * V5_i;;
00495	                    }
00496	                    
00497	            }else{
00498	                {
00499	
00500	    std::vector< std::pair<int, int> > V3_loops(2);
00501	    std::vector< std::pair<int, int> >::iterator V3_loops_it = V3_loops.begin();
00502	    
00503	            V3_loops_it->first = abs(PyArray_STRIDES(V3)[0]);
00504	            
00505	        V3_loops_it->second = 0;
00506	        ++V3_loops_it;
00507	        
00508	            V3_loops_it->first = abs(PyArray_STRIDES(V3)[1]);
00509	            
00510	        V3_loops_it->second = 1;
00511	        ++V3_loops_it;
00512	        
00513	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00514	    std::sort(V3_loops.rbegin(), V3_loops.rend());
00515	    
00516	
00517	    int init_totals[2] = {V3_n0, V3_n1};
00518	    
00519	    V3_loops_it = V3_loops.begin();
00520	    
00521	        int TOTAL_0 = init_totals[V3_loops_it->second];
00522	        ++V3_loops_it;
00523	        
00524	        int TOTAL_1 = init_totals[V3_loops_it->second];
00525	        ++V3_loops_it;
00526	        
00527	
00528	    int init_strides[2][2] = {
00529	        V3_stride0, V3_stride1, 
00530	V5_stride0, V5_stride1
00531	    };
00532	    std::vector< std::pair<int, int> >::reverse_iterator V3_loops_rit;
00533	    
00534	        V3_loops_rit = V3_loops.rbegin();
00535	            int V3_stride_l1 = init_strides[0][V3_loops_rit->second];
00536	            ++V3_loops_rit;
00537	            
00538	            int V3_stride_l0 = init_strides[0][V3_loops_rit->second];
00539	            ++V3_loops_rit;
00540	            
00541	        V3_loops_rit = V3_loops.rbegin();
00542	            int V5_stride_l1 = init_strides[1][V3_loops_rit->second];
00543	            ++V3_loops_rit;
00544	            
00545	            int V5_stride_l0 = init_strides[1][V3_loops_rit->second];
00546	            ++V3_loops_rit;
00547	            
00548	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00549	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00550	
00551	
00552	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00553	        { // begin loop 0
00554	            
00555	            
00556	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00557	        { // begin loop 1
00558	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00559	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00560	
00561	            
00562	        {
00563	            #define V1_i V3_i
00564	
00565	            V1_i = V3_i * V5_i;
00566	            #undef V1_i
00567	
00568	        }
00569	        
00570	        } // end loop 1
00571	        
00572	        } // end loop 0
00573	        
00574	}
00575	
00576	            }
00577	            __label_7:
00578	
00579	double __DUMMY_7;
00580	
00581	}
00582	__label_6:
00583	
00584	        if (V5) {
00585	            Py_XDECREF(V5);
00586	        }
00587	        
00588	    {Py_XDECREF(py_V5);}
00589	    
00590	double __DUMMY_6;
00591	
00592	}
00593	__label_4:
00594	
00595	        if (V3) {
00596	            Py_XDECREF(V3);
00597	        }
00598	        
00599	    {Py_XDECREF(py_V3);}
00600	    
00601	double __DUMMY_4;
00602	
00603	}
00604	__label_2:
00605	
00606	    if (!__failure) {
00607	      
00608	        {Py_XDECREF(py_V1);}
00609	        if (!V1) {
00610	            Py_INCREF(Py_None);
00611	            py_V1 = Py_None;
00612	        }
00613	        else if ((void*)py_V1 != (void*)V1) {
00614	            py_V1 = (PyObject*)V1;
00615	        }
00616	
00617	        {Py_XINCREF(py_V1);}
00618	
00619	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00620	            PyErr_Format(PyExc_NotImplementedError,
00621	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00622	                         " with %ld dimensions, with 3 last dims "
00623	                         "%ld, %ld, %ld"
00624	                         " and 3 last strides %ld %ld, %ld.",
00625	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00626	                         (long int) PyArray_NDIM(V1),
00627	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00628	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00629	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00630	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00631	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00632	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00633	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00634	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00635	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00636	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00637	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00638	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00639	        );
00640	            {
00641	        __failure = 2;
00642	        if (!PyErr_Occurred()) {
00643	            PyErr_SetString(PyExc_RuntimeError,
00644	                "Unexpected error in an Op's C code. "
00645	                "No Python exception was set.");
00646	            }
00647	        goto __label_2;}
00648	        }
00649	        
00650	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00651	      {Py_XINCREF(py_V1);}
00652	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00653	      {Py_XDECREF(old);}
00654	    }
00655	    
00656	        if (V1) {
00657	            Py_XDECREF(V1);
00658	        }
00659	        
00660	    {Py_XDECREF(py_V1);}
00661	    
00662	double __DUMMY_2;
00663	
00664	}
00665	
00666	            
00667	        if (__failure) {
00668	            // When there is a failure, this code puts the exception
00669	            // in __ERROR.
00670	            PyObject* err_type = NULL;
00671	            PyObject* err_msg = NULL;
00672	            PyObject* err_traceback = NULL;
00673	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00674	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00675	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00676	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00677	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00678	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00679	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00680	            PyList_SET_ITEM(__ERROR, 0, err_type);
00681	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00682	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00683	            {Py_XDECREF(old_err_type);}
00684	            {Py_XDECREF(old_err_msg);}
00685	            {Py_XDECREF(old_err_traceback);}
00686	        }
00687	        // The failure code is returned to index what code block failed.
00688	        return __failure;
00689	        
00690	        }
00691	    };
00692	    }
00693	    
00694	
00695	        static int __struct_compiled_op_00ddd87b3207a941dda892013e5f4775_executor(__struct_compiled_op_00ddd87b3207a941dda892013e5f4775* self) {
00696	            return self->run();
00697	        }
00698	
00699	        static void __struct_compiled_op_00ddd87b3207a941dda892013e5f4775_destructor(void* executor, void* self) {
00700	            delete ((__struct_compiled_op_00ddd87b3207a941dda892013e5f4775*)self);
00701	        }
00702	        
00703	//////////////////////
00704	////  Functions
00705	//////////////////////
00706	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00707	  assert(PyTuple_Check(argtuple));
00708	  if (4 != PyTuple_Size(argtuple)){ 
00709	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00710	     return NULL;
00711	  }
00712	  __struct_compiled_op_00ddd87b3207a941dda892013e5f4775* struct_ptr = new __struct_compiled_op_00ddd87b3207a941dda892013e5f4775();
00713	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00714	    delete struct_ptr;
00715	    return NULL;
00716	  }
00717	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_00ddd87b3207a941dda892013e5f4775_executor), struct_ptr, __struct_compiled_op_00ddd87b3207a941dda892013e5f4775_destructor);
00718	  return thunk; }
00719	
00720	//////////////////////
00721	////  Module init
00722	//////////////////////
00723	static PyMethodDef MyMethods[] = {
00724		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00725		{NULL, NULL, 0, NULL}
00726	};
00727	PyMODINIT_FUNC init00ddd87b3207a941dda892013e5f4775(void){
00728	   import_array();
00729	   (void) Py_InitModule("00ddd87b3207a941dda892013e5f4775", MyMethods);
00730	}
00731	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp2rMkP0/00ddd87b3207a941dda892013e5f4775.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmp2rMkP0/mod.cpp -lpython2.7
ERROR
theano.sandbox.linalg.tests.test_linalg.test_spectral_radius_bound ... ok
theano.sandbox.linalg.tests.test_linalg.test_transinv_to_invtrans ... ok
theano.sandbox.linalg.tests.test_linalg.test_tag_solve_triangular ... ok
theano.sandbox.linalg.tests.test_linalg.test_matrix_inverse_solve ... ok
theano.sandbox.tests.test_multinomial.test_n_samples_1 ... ok
theano.sandbox.tests.test_multinomial.test_n_samples_2 ... ok
This test checks if the new change to MultinomialFromUniform is still compatible ... ok
theano.sandbox.tests.test_multinomial.test_multinomial_0 ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float32 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float32 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float32 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT32
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT32,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT32) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT32) got %d",
00169	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT32
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT32,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT32) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT32) got %d",
00253	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float32* V3_iter;
00271	        
00272	                int V3_jumpx_0;
00273	                
00274	                int V3_jumpx_1;
00275	                
00276	        npy_float32* V5_iter;
00277	        
00278	                npy_intp V5_n0;
00279	                ssize_t V5_stride0;
00280	                int V5_jump0_0;
00281	                
00282	                npy_intp V5_n1;
00283	                ssize_t V5_stride1;
00284	                int V5_jump1_1;
00285	                
00286	
00287	                V3_jumpx_1 = -(0);
00288	                //printf("V3_jumpx_1 is:");
00289	                //std::cout << V3_jumpx_1 << std::endl;
00290	                
00291	                V3_jumpx_0 = -(0);
00292	                //printf("V3_jumpx_0 is:");
00293	                //std::cout << V3_jumpx_0 << std::endl;
00294	                
00295	            if (PyArray_NDIM(V5) < 2) {
00296	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00297	                {
00298	        __failure = 7;
00299	        if (!PyErr_Occurred()) {
00300	            PyErr_SetString(PyExc_RuntimeError,
00301	                "Unexpected error in an Op's C code. "
00302	                "No Python exception was set.");
00303	            }
00304	        goto __label_7;}
00305	            }
00306	            
00307	                V5_n1 = PyArray_DIMS(V5)[1];
00308	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float32);
00309	                V5_jump1_1 = (V5_stride1) - (0);
00310	                //printf("V5_jump1_1 is:");
00311	                //std::cout << V5_jump1_1 << std::endl;
00312	                
00313	                V5_n0 = PyArray_DIMS(V5)[0];
00314	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float32);
00315	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00316	                //printf("V5_jump0_0 is:");
00317	                //std::cout << V5_jump0_0 << std::endl;
00318	                
00319	
00320	            if (V1) {
00321	                Py_XDECREF(V1);
00322	            }
00323	            V1 = V5;
00324	            Py_XINCREF(V1);
00325	            
00326	
00327	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00328	                
00329	                    // All output have the same size
00330	                    npy_intp n = PyArray_SIZE(V1);
00331	                    
00332	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00333	                            
00334	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00335	                            
00336	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00337	                            
00338	                    for(int i=0; i<n; i++){
00339	                        
00340	            dtype_V5& V5_i = V5_ptr[i];
00341	                            
00342	            dtype_V1& V1_i = V1_ptr[i];
00343	                            
00344	                        V1_i = V3_i * V5_i;;
00345	                    }
00346	                    
00347	            }else{
00348	                {
00349	
00350	    std::vector< std::pair<int, int> > V5_loops(2);
00351	    std::vector< std::pair<int, int> >::iterator V5_loops_it = V5_loops.begin();
00352	    
00353	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[0]);
00354	            
00355	        V5_loops_it->second = 0;
00356	        ++V5_loops_it;
00357	        
00358	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[1]);
00359	            
00360	        V5_loops_it->second = 1;
00361	        ++V5_loops_it;
00362	        
00363	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00364	    std::sort(V5_loops.rbegin(), V5_loops.rend());
00365	    
00366	
00367	    int init_totals[2] = {V5_n0, V5_n1};
00368	    
00369	    V5_loops_it = V5_loops.begin();
00370	    
00371	        int TOTAL_0 = init_totals[V5_loops_it->second];
00372	        ++V5_loops_it;
00373	        
00374	        int TOTAL_1 = init_totals[V5_loops_it->second];
00375	        ++V5_loops_it;
00376	        
00377	
00378	    int init_strides[2][2] = {
00379	        0, 0, 
00380	V5_stride0, V5_stride1
00381	    };
00382	    std::vector< std::pair<int, int> >::reverse_iterator V5_loops_rit;
00383	    
00384	        V5_loops_rit = V5_loops.rbegin();
00385	            int V3_stride_l1 = init_strides[0][V5_loops_rit->second];
00386	            ++V5_loops_rit;
00387	            
00388	            int V3_stride_l0 = init_strides[0][V5_loops_rit->second];
00389	            ++V5_loops_rit;
00390	            
00391	        V5_loops_rit = V5_loops.rbegin();
00392	            int V5_stride_l1 = init_strides[1][V5_loops_rit->second];
00393	            ++V5_loops_rit;
00394	            
00395	            int V5_stride_l0 = init_strides[1][V5_loops_rit->second];
00396	            ++V5_loops_rit;
00397	            
00398	V3_iter = (npy_float32*)(PyArray_DATA(V3));
00399	V5_iter = (npy_float32*)(PyArray_DATA(V5));
00400	
00401	
00402	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00403	        { // begin loop 0
00404	            
00405	            
00406	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00407	        { // begin loop 1
00408	            npy_float32 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00409	npy_float32 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00410	
00411	            
00412	        {
00413	            #define V1_i V5_i
00414	
00415	            V1_i = V3_i * V5_i;
00416	            #undef V1_i
00417	
00418	        }
00419	        
00420	        } // end loop 1
00421	        
00422	        } // end loop 0
00423	        
00424	}
00425	
00426	            }
00427	            __label_7:
00428	
00429	double __DUMMY_7;
00430	
00431	}
00432	__label_6:
00433	
00434	        if (V5) {
00435	            Py_XDECREF(V5);
00436	        }
00437	        
00438	    {Py_XDECREF(py_V5);}
00439	    
00440	double __DUMMY_6;
00441	
00442	}
00443	__label_4:
00444	
00445	        if (V3) {
00446	            Py_XDECREF(V3);
00447	        }
00448	        
00449	    {Py_XDECREF(py_V3);}
00450	    
00451	double __DUMMY_4;
00452	
00453	}
00454	__label_2:
00455	
00456	    if (!__failure) {
00457	      
00458	        {Py_XDECREF(py_V1);}
00459	        if (!V1) {
00460	            Py_INCREF(Py_None);
00461	            py_V1 = Py_None;
00462	        }
00463	        else if ((void*)py_V1 != (void*)V1) {
00464	            py_V1 = (PyObject*)V1;
00465	        }
00466	
00467	        {Py_XINCREF(py_V1);}
00468	
00469	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00470	            PyErr_Format(PyExc_NotImplementedError,
00471	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00472	                         " with %ld dimensions, with 3 last dims "
00473	                         "%ld, %ld, %ld"
00474	                         " and 3 last strides %ld %ld, %ld.",
00475	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00476	                         (long int) PyArray_NDIM(V1),
00477	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00478	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00479	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00480	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00481	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00482	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00483	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00484	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00485	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00486	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00487	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00488	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00489	        );
00490	            {
00491	        __failure = 2;
00492	        if (!PyErr_Occurred()) {
00493	            PyErr_SetString(PyExc_RuntimeError,
00494	                "Unexpected error in an Op's C code. "
00495	                "No Python exception was set.");
00496	            }
00497	        goto __label_2;}
00498	        }
00499	        
00500	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00501	      {Py_XINCREF(py_V1);}
00502	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00503	      {Py_XDECREF(old);}
00504	    }
00505	    
00506	        if (V1) {
00507	            Py_XDECREF(V1);
00508	        }
00509	        
00510	    {Py_XDECREF(py_V1);}
00511	    
00512	double __DUMMY_2;
00513	
00514	}
00515	
00516	            
00517	        if (__failure) {
00518	            // When there is a failure, this code puts the exception
00519	            // in __ERROR.
00520	            PyObject* err_type = NULL;
00521	            PyObject* err_msg = NULL;
00522	            PyObject* err_traceback = NULL;
00523	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00524	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00525	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00526	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00527	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00528	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00529	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00530	            PyList_SET_ITEM(__ERROR, 0, err_type);
00531	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00532	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00533	            {Py_XDECREF(old_err_type);}
00534	            {Py_XDECREF(old_err_msg);}
00535	            {Py_XDECREF(old_err_traceback);}
00536	        }
00537	        // The failure code is returned to index what code block failed.
00538	        return __failure;
00539	        
00540	        }
00541	    };
00542	    }
00543	    
00544	
00545	        static int __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac_executor(__struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac* self) {
00546	            return self->run();
00547	        }
00548	
00549	        static void __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac_destructor(void* executor, void* self) {
00550	            delete ((__struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac*)self);
00551	        }
00552	        
00553	//////////////////////
00554	////  Functions
00555	//////////////////////
00556	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00557	  assert(PyTuple_Check(argtuple));
00558	  if (4 != PyTuple_Size(argtuple)){ 
00559	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00560	     return NULL;
00561	  }
00562	  __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac* struct_ptr = new __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac();
00563	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00564	    delete struct_ptr;
00565	    return NULL;
00566	  }
00567	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac_executor), struct_ptr, __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac_destructor);
00568	  return thunk; }
00569	
00570	//////////////////////
00571	////  Module init
00572	//////////////////////
00573	static PyMethodDef MyMethods[] = {
00574		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00575		{NULL, NULL, 0, NULL}
00576	};
00577	PyMODINIT_FUNC init1dba23c5e96e3f69a781c8dd7154ebac(void){
00578	   import_array();
00579	   (void) Py_InitModule("1dba23c5e96e3f69a781c8dd7154ebac", MyMethods);
00580	}
00581	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpchBcRk/1dba23c5e96e3f69a781c8dd7154ebac.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpchBcRk/mod.cpp -lpython2.7
ERROR
theano.sandbox.tests.test_multinomial.test_multinomial_large ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float32 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float32 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float32 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = Py_None;
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        V1 = NULL;
00098	        
00099	{
00100	
00101	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00102	    {Py_XINCREF(py_V3);}
00103	    
00104	            V3 = NULL;
00105	            if (py_V3 == Py_None) {
00106	                // We can either fail here or set V3 to NULL and rely on Ops
00107	                // using tensors to handle the NULL case, but if they fail to do so
00108	                // they'll end up with nasty segfaults, so this is public service.
00109	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00110	                {
00111	        __failure = 4;
00112	        if (!PyErr_Occurred()) {
00113	            PyErr_SetString(PyExc_RuntimeError,
00114	                "Unexpected error in an Op's C code. "
00115	                "No Python exception was set.");
00116	            }
00117	        goto __label_4;}
00118	            }
00119	            if (!PyArray_Check(py_V3)) {
00120	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00121	                {
00122	        __failure = 4;
00123	        if (!PyErr_Occurred()) {
00124	            PyErr_SetString(PyExc_RuntimeError,
00125	                "Unexpected error in an Op's C code. "
00126	                "No Python exception was set.");
00127	            }
00128	        goto __label_4;}
00129	            }
00130	            // We expect NPY_FLOAT32
00131	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00132	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00133	                PyErr_Format(PyExc_NotImplementedError,
00134	                             "expected an aligned array of type %ld "
00135	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00136	                             " with %ld dimensions, with 3 last dims "
00137	                             "%ld, %ld, %ld"
00138	                             " and 3 last strides %ld %ld, %ld.",
00139	                             (long int) NPY_FLOAT32,
00140	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00141	                             (long int) PyArray_NDIM(tmp),
00142	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00143	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00144	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00149	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00154	            );
00155	                {
00156	        __failure = 4;
00157	        if (!PyErr_Occurred()) {
00158	            PyErr_SetString(PyExc_RuntimeError,
00159	                "Unexpected error in an Op's C code. "
00160	                "No Python exception was set.");
00161	            }
00162	        goto __label_4;}
00163	            }
00164	            // This is a TypeError to be consistent with DEBUG_MODE
00165	            // Note: DEBUG_MODE also tells the name of the container
00166	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT32) {
00167	                PyErr_Format(PyExc_TypeError,
00168	                             "expected type_num %d (NPY_FLOAT32) got %d",
00169	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V3));
00170	                {
00171	        __failure = 4;
00172	        if (!PyErr_Occurred()) {
00173	            PyErr_SetString(PyExc_RuntimeError,
00174	                "Unexpected error in an Op's C code. "
00175	                "No Python exception was set.");
00176	            }
00177	        goto __label_4;}
00178	            }
00179	            
00180	        V3 = (PyArrayObject*)(py_V3);
00181	        Py_XINCREF(V3);
00182	        
00183	{
00184	
00185	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00186	    {Py_XINCREF(py_V5);}
00187	    
00188	            V5 = NULL;
00189	            if (py_V5 == Py_None) {
00190	                // We can either fail here or set V5 to NULL and rely on Ops
00191	                // using tensors to handle the NULL case, but if they fail to do so
00192	                // they'll end up with nasty segfaults, so this is public service.
00193	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00194	                {
00195	        __failure = 6;
00196	        if (!PyErr_Occurred()) {
00197	            PyErr_SetString(PyExc_RuntimeError,
00198	                "Unexpected error in an Op's C code. "
00199	                "No Python exception was set.");
00200	            }
00201	        goto __label_6;}
00202	            }
00203	            if (!PyArray_Check(py_V5)) {
00204	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00205	                {
00206	        __failure = 6;
00207	        if (!PyErr_Occurred()) {
00208	            PyErr_SetString(PyExc_RuntimeError,
00209	                "Unexpected error in an Op's C code. "
00210	                "No Python exception was set.");
00211	            }
00212	        goto __label_6;}
00213	            }
00214	            // We expect NPY_FLOAT32
00215	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00216	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00217	                PyErr_Format(PyExc_NotImplementedError,
00218	                             "expected an aligned array of type %ld "
00219	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00220	                             " with %ld dimensions, with 3 last dims "
00221	                             "%ld, %ld, %ld"
00222	                             " and 3 last strides %ld %ld, %ld.",
00223	                             (long int) NPY_FLOAT32,
00224	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00225	                             (long int) PyArray_NDIM(tmp),
00226	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00227	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00228	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00229	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00230	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00233	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00235	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00238	            );
00239	                {
00240	        __failure = 6;
00241	        if (!PyErr_Occurred()) {
00242	            PyErr_SetString(PyExc_RuntimeError,
00243	                "Unexpected error in an Op's C code. "
00244	                "No Python exception was set.");
00245	            }
00246	        goto __label_6;}
00247	            }
00248	            // This is a TypeError to be consistent with DEBUG_MODE
00249	            // Note: DEBUG_MODE also tells the name of the container
00250	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT32) {
00251	                PyErr_Format(PyExc_TypeError,
00252	                             "expected type_num %d (NPY_FLOAT32) got %d",
00253	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V5));
00254	                {
00255	        __failure = 6;
00256	        if (!PyErr_Occurred()) {
00257	            PyErr_SetString(PyExc_RuntimeError,
00258	                "Unexpected error in an Op's C code. "
00259	                "No Python exception was set.");
00260	            }
00261	        goto __label_6;}
00262	            }
00263	            
00264	        V5 = (PyArrayObject*)(py_V5);
00265	        Py_XINCREF(V5);
00266	        
00267	{
00268	// Op class Elemwise
00269	
00270	        npy_float32* V3_iter;
00271	        
00272	                int V3_jumpx_0;
00273	                
00274	                int V3_jumpx_1;
00275	                
00276	        npy_float32* V5_iter;
00277	        
00278	                npy_intp V5_n0;
00279	                ssize_t V5_stride0;
00280	                int V5_jump0_0;
00281	                
00282	                npy_intp V5_n1;
00283	                ssize_t V5_stride1;
00284	                int V5_jump1_1;
00285	                
00286	
00287	                V3_jumpx_1 = -(0);
00288	                //printf("V3_jumpx_1 is:");
00289	                //std::cout << V3_jumpx_1 << std::endl;
00290	                
00291	                V3_jumpx_0 = -(0);
00292	                //printf("V3_jumpx_0 is:");
00293	                //std::cout << V3_jumpx_0 << std::endl;
00294	                
00295	            if (PyArray_NDIM(V5) < 2) {
00296	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00297	                {
00298	        __failure = 7;
00299	        if (!PyErr_Occurred()) {
00300	            PyErr_SetString(PyExc_RuntimeError,
00301	                "Unexpected error in an Op's C code. "
00302	                "No Python exception was set.");
00303	            }
00304	        goto __label_7;}
00305	            }
00306	            
00307	                V5_n1 = PyArray_DIMS(V5)[1];
00308	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float32);
00309	                V5_jump1_1 = (V5_stride1) - (0);
00310	                //printf("V5_jump1_1 is:");
00311	                //std::cout << V5_jump1_1 << std::endl;
00312	                
00313	                V5_n0 = PyArray_DIMS(V5)[0];
00314	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float32);
00315	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00316	                //printf("V5_jump0_0 is:");
00317	                //std::cout << V5_jump0_0 << std::endl;
00318	                
00319	
00320	            if (V1) {
00321	                Py_XDECREF(V1);
00322	            }
00323	            V1 = V5;
00324	            Py_XINCREF(V1);
00325	            
00326	
00327	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00328	                
00329	                    // All output have the same size
00330	                    npy_intp n = PyArray_SIZE(V1);
00331	                    
00332	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00333	                            
00334	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00335	                            
00336	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00337	                            
00338	                    for(int i=0; i<n; i++){
00339	                        
00340	            dtype_V5& V5_i = V5_ptr[i];
00341	                            
00342	            dtype_V1& V1_i = V1_ptr[i];
00343	                            
00344	                        V1_i = V3_i * V5_i;;
00345	                    }
00346	                    
00347	            }else{
00348	                {
00349	
00350	    std::vector< std::pair<int, int> > V5_loops(2);
00351	    std::vector< std::pair<int, int> >::iterator V5_loops_it = V5_loops.begin();
00352	    
00353	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[0]);
00354	            
00355	        V5_loops_it->second = 0;
00356	        ++V5_loops_it;
00357	        
00358	            V5_loops_it->first = abs(PyArray_STRIDES(V5)[1]);
00359	            
00360	        V5_loops_it->second = 1;
00361	        ++V5_loops_it;
00362	        
00363	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00364	    std::sort(V5_loops.rbegin(), V5_loops.rend());
00365	    
00366	
00367	    int init_totals[2] = {V5_n0, V5_n1};
00368	    
00369	    V5_loops_it = V5_loops.begin();
00370	    
00371	        int TOTAL_0 = init_totals[V5_loops_it->second];
00372	        ++V5_loops_it;
00373	        
00374	        int TOTAL_1 = init_totals[V5_loops_it->second];
00375	        ++V5_loops_it;
00376	        
00377	
00378	    int init_strides[2][2] = {
00379	        0, 0, 
00380	V5_stride0, V5_stride1
00381	    };
00382	    std::vector< std::pair<int, int> >::reverse_iterator V5_loops_rit;
00383	    
00384	        V5_loops_rit = V5_loops.rbegin();
00385	            int V3_stride_l1 = init_strides[0][V5_loops_rit->second];
00386	            ++V5_loops_rit;
00387	            
00388	            int V3_stride_l0 = init_strides[0][V5_loops_rit->second];
00389	            ++V5_loops_rit;
00390	            
00391	        V5_loops_rit = V5_loops.rbegin();
00392	            int V5_stride_l1 = init_strides[1][V5_loops_rit->second];
00393	            ++V5_loops_rit;
00394	            
00395	            int V5_stride_l0 = init_strides[1][V5_loops_rit->second];
00396	            ++V5_loops_rit;
00397	            
00398	V3_iter = (npy_float32*)(PyArray_DATA(V3));
00399	V5_iter = (npy_float32*)(PyArray_DATA(V5));
00400	
00401	
00402	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00403	        { // begin loop 0
00404	            
00405	            
00406	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00407	        { // begin loop 1
00408	            npy_float32 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00409	npy_float32 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00410	
00411	            
00412	        {
00413	            #define V1_i V5_i
00414	
00415	            V1_i = V3_i * V5_i;
00416	            #undef V1_i
00417	
00418	        }
00419	        
00420	        } // end loop 1
00421	        
00422	        } // end loop 0
00423	        
00424	}
00425	
00426	            }
00427	            __label_7:
00428	
00429	double __DUMMY_7;
00430	
00431	}
00432	__label_6:
00433	
00434	        if (V5) {
00435	            Py_XDECREF(V5);
00436	        }
00437	        
00438	    {Py_XDECREF(py_V5);}
00439	    
00440	double __DUMMY_6;
00441	
00442	}
00443	__label_4:
00444	
00445	        if (V3) {
00446	            Py_XDECREF(V3);
00447	        }
00448	        
00449	    {Py_XDECREF(py_V3);}
00450	    
00451	double __DUMMY_4;
00452	
00453	}
00454	__label_2:
00455	
00456	    if (!__failure) {
00457	      
00458	        {Py_XDECREF(py_V1);}
00459	        if (!V1) {
00460	            Py_INCREF(Py_None);
00461	            py_V1 = Py_None;
00462	        }
00463	        else if ((void*)py_V1 != (void*)V1) {
00464	            py_V1 = (PyObject*)V1;
00465	        }
00466	
00467	        {Py_XINCREF(py_V1);}
00468	
00469	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00470	            PyErr_Format(PyExc_NotImplementedError,
00471	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00472	                         " with %ld dimensions, with 3 last dims "
00473	                         "%ld, %ld, %ld"
00474	                         " and 3 last strides %ld %ld, %ld.",
00475	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00476	                         (long int) PyArray_NDIM(V1),
00477	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00478	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00479	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00480	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00481	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00482	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00483	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00484	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00485	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00486	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00487	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00488	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00489	        );
00490	            {
00491	        __failure = 2;
00492	        if (!PyErr_Occurred()) {
00493	            PyErr_SetString(PyExc_RuntimeError,
00494	                "Unexpected error in an Op's C code. "
00495	                "No Python exception was set.");
00496	            }
00497	        goto __label_2;}
00498	        }
00499	        
00500	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00501	      {Py_XINCREF(py_V1);}
00502	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00503	      {Py_XDECREF(old);}
00504	    }
00505	    
00506	        if (V1) {
00507	            Py_XDECREF(V1);
00508	        }
00509	        
00510	    {Py_XDECREF(py_V1);}
00511	    
00512	double __DUMMY_2;
00513	
00514	}
00515	
00516	            
00517	        if (__failure) {
00518	            // When there is a failure, this code puts the exception
00519	            // in __ERROR.
00520	            PyObject* err_type = NULL;
00521	            PyObject* err_msg = NULL;
00522	            PyObject* err_traceback = NULL;
00523	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00524	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00525	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00526	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00527	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00528	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00529	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00530	            PyList_SET_ITEM(__ERROR, 0, err_type);
00531	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00532	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00533	            {Py_XDECREF(old_err_type);}
00534	            {Py_XDECREF(old_err_msg);}
00535	            {Py_XDECREF(old_err_traceback);}
00536	        }
00537	        // The failure code is returned to index what code block failed.
00538	        return __failure;
00539	        
00540	        }
00541	    };
00542	    }
00543	    
00544	
00545	        static int __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac_executor(__struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac* self) {
00546	            return self->run();
00547	        }
00548	
00549	        static void __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac_destructor(void* executor, void* self) {
00550	            delete ((__struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac*)self);
00551	        }
00552	        
00553	//////////////////////
00554	////  Functions
00555	//////////////////////
00556	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00557	  assert(PyTuple_Check(argtuple));
00558	  if (4 != PyTuple_Size(argtuple)){ 
00559	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00560	     return NULL;
00561	  }
00562	  __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac* struct_ptr = new __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac();
00563	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00564	    delete struct_ptr;
00565	    return NULL;
00566	  }
00567	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac_executor), struct_ptr, __struct_compiled_op_1dba23c5e96e3f69a781c8dd7154ebac_destructor);
00568	  return thunk; }
00569	
00570	//////////////////////
00571	////  Module init
00572	//////////////////////
00573	static PyMethodDef MyMethods[] = {
00574		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00575		{NULL, NULL, 0, NULL}
00576	};
00577	PyMODINIT_FUNC init1dba23c5e96e3f69a781c8dd7154ebac(void){
00578	   import_array();
00579	   (void) Py_InitModule("1dba23c5e96e3f69a781c8dd7154ebac", MyMethods);
00580	}
00581	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmphJJhJJ/1dba23c5e96e3f69a781c8dd7154ebac.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmphJJhJJ/mod.cpp -lpython2.7
ERROR
theano.sandbox.tests.test_multinomial.test_multinomial_dtypes ... ok
theano.sandbox.tests.test_multinomial.test_gpu_opt ... SKIP: Optional package cuda not available
Tests that MultinomialWOReplacementFromUniform fails when asked to sample more ... ok
Tests that MultinomialWOReplacementFromUniform always selects distinct elements ... ok
Tests that MultinomialWOReplacementFromUniform selects elements, on average, ... ok
Tests that multinomial_wo_replacement fails when asked to sample more ... /<<BUILDDIR>>/theano-0.9.0+dfsg/theano/sandbox/rng_mrg.py:1522: UserWarning: MRG_RandomStreams.multinomial_wo_replacement() is deprecated and will be removed in the next release of Theano. Please use MRG_RandomStreams.choice() instead.
  warnings.warn('MRG_RandomStreams.multinomial_wo_replacement() is '
ok
Tests that multinomial_wo_replacement always selects distinct elements ... ok
Tests that multinomial_wo_replacement selects elements, on average, ... ok
Failure: SkipTest (pygpu not installed) ... SKIP: pygpu not installed
test_straightforward (theano.scalar.tests.test_basic.test_ScalarOps) ... ok
test_fail (theano.scalar.tests.test_basic.test_complex_mod) ... ok
test_composite_clone_float32 (theano.scalar.tests.test_basic.test_composite) ... ok
test_composite_printing (theano.scalar.tests.test_basic.test_composite) ... ok
test_flatten (theano.scalar.tests.test_basic.test_composite) ... ok
test_make_node_continue_graph (theano.scalar.tests.test_basic.test_composite) ... ok
test_many_outputs (theano.scalar.tests.test_basic.test_composite) ... ok
test_straightforward (theano.scalar.tests.test_basic.test_composite) ... ok
test_with_constants (theano.scalar.tests.test_basic.test_composite) ... ok
test_0 (theano.scalar.tests.test_basic.test_div) ... ok
test_and (theano.scalar.tests.test_basic.test_logical) ... ok
test_eq (theano.scalar.tests.test_basic.test_logical) ... ok
test_ge (theano.scalar.tests.test_basic.test_logical) ... ok
test_gt (theano.scalar.tests.test_basic.test_logical) ... ok
test_le (theano.scalar.tests.test_basic.test_logical) ... ok
test_lt (theano.scalar.tests.test_basic.test_logical) ... ok
test_neq (theano.scalar.tests.test_basic.test_logical) ... ok
test_not (theano.scalar.tests.test_basic.test_logical) ... ok
test_or (theano.scalar.tests.test_basic.test_logical) ... ok
test_xor (theano.scalar.tests.test_basic.test_logical) ... ok
test_arctan2 ... ok
theano.scalar.tests.test_basic.test_upgrade_to_float.test_true_div ... ok
test_inv ... INFO (theano.gof.compilelock): Refreshing lock /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/lock_dir/lock
ok
test_sqrt ... ok
test_log ... ok
test_log2 ... ok
test_log10 ... ok
test_log1p ... ok
test_exp ... ok
test_exp2 ... ok
test_expm1 ... ok
test_deg2rad ... ok
test_rad2deg ... ok
test_cos ... ok
test_arccos ... ok
test_cosh ... ok
test_arccosh ... ok
test_sin ... ok
test_arcsin ... ok
test_sinh ... ok
test_arcsinh ... ok
test_tan ... ok
test_arctan ... ok
test_tanh ... ok
test_arctanh ... ok
theano.scalar.tests.test_basic.test_grad_gt ... ok
theano.scalar.tests.test_basic.test_grad_switch ... ok
theano.scalar.tests.test_basic.test_grad_identity ... ok
theano.scalar.tests.test_basic.test_grad_inrange ... ok
theano.scalar.tests.test_basic.test_grad_abs ... ok
theano.scalar.tests.test_basic.test_constant ... ok
Failure: SkipTest (optional package sympy disabled) ... SKIP: optional package sympy disabled
test_divide_floats (theano.scalar.tests.test_div_future.test_FutureDiv) ... ok
test_divide_floats (theano.scalar.tests.test_div_no_future.test_FutureDiv) ... ok
test_alloc_inputs1 (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_alloc_inputs2 (theano.scan_module.tests.test_scan.T_Scan) ... SKIP: This tests depends on an optimization for scan that has not been implemented yet.
test_alloc_inputs3 (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_backwards (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_borrow_bug_jeremiah (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_bugFunctioProvidesIntermediateNodesAsInputs (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V7;
00020	PyObject* storage_V1;
00021	        
00022	
00023	        __struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb() {
00024	            // This is only somewhat safe because we:
00025	            //  1) Are not a virtual class
00026	            //  2) Do not use any virtual classes in the members
00027	            //  3) Deal with mostly POD and pointers
00028	
00029	            // If this changes, we would have to revise this, but for
00030	            // now I am tired of chasing segfaults because
00031	            // initialization code had an error and some pointer has
00032	            // a junk value.
00033	            memset(this, 0, sizeof(*this));
00034	        }
00035	        ~__struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb(void) {
00036	            cleanup();
00037	        }
00038	
00039	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V7, PyObject* storage_V1) {
00040	            Py_XINCREF(storage_V3);
00041	Py_XINCREF(storage_V5);
00042	Py_XINCREF(storage_V7);
00043	Py_XINCREF(storage_V1);
00044	            this->storage_V3 = storage_V3;
00045	this->storage_V5 = storage_V5;
00046	this->storage_V7 = storage_V7;
00047	this->storage_V1 = storage_V1;
00048	            
00049	
00050	
00051	
00052	
00053	
00054	            this->__ERROR = __ERROR;
00055	            return 0;
00056	        }
00057	        void cleanup(void) {
00058	            __label_1:
00059	
00060	double __DUMMY_1;
00061	__label_3:
00062	
00063	double __DUMMY_3;
00064	__label_5:
00065	
00066	double __DUMMY_5;
00067	__label_7:
00068	
00069	double __DUMMY_7;
00070	__label_10:
00071	
00072	double __DUMMY_10;
00073	
00074	            Py_XDECREF(this->storage_V3);
00075	Py_XDECREF(this->storage_V5);
00076	Py_XDECREF(this->storage_V7);
00077	Py_XDECREF(this->storage_V1);
00078	        }
00079	        int run(void) {
00080	            int __failure = 0;
00081	            
00082	    PyObject* py_V1;
00083	    
00084	        PyArrayObject* V1;
00085	        
00086	            typedef npy_float32 dtype_V1;
00087	            
00088	    PyObject* py_V3;
00089	    
00090	        PyArrayObject* V3;
00091	        
00092	            typedef npy_float32 dtype_V3;
00093	            
00094	    PyObject* py_V5;
00095	    
00096	        PyArrayObject* V5;
00097	        
00098	            typedef npy_float32 dtype_V5;
00099	            
00100	    PyObject* py_V7;
00101	    
00102	        PyArrayObject* V7;
00103	        
00104	            typedef npy_float32 dtype_V7;
00105	            
00106	{
00107	
00108	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00109	    {Py_XINCREF(py_V1);}
00110	    
00111	        if (py_V1 == Py_None)
00112	        {
00113	            
00114	        V1 = NULL;
00115	        
00116	        }
00117	        else
00118	        {
00119	            
00120	            V1 = NULL;
00121	            if (py_V1 == Py_None) {
00122	                // We can either fail here or set V1 to NULL and rely on Ops
00123	                // using tensors to handle the NULL case, but if they fail to do so
00124	                // they'll end up with nasty segfaults, so this is public service.
00125	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00126	                {
00127	        __failure = 2;
00128	        if (!PyErr_Occurred()) {
00129	            PyErr_SetString(PyExc_RuntimeError,
00130	                "Unexpected error in an Op's C code. "
00131	                "No Python exception was set.");
00132	            }
00133	        goto __label_2;}
00134	            }
00135	            if (!PyArray_Check(py_V1)) {
00136	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00137	                {
00138	        __failure = 2;
00139	        if (!PyErr_Occurred()) {
00140	            PyErr_SetString(PyExc_RuntimeError,
00141	                "Unexpected error in an Op's C code. "
00142	                "No Python exception was set.");
00143	            }
00144	        goto __label_2;}
00145	            }
00146	            // We expect NPY_FLOAT32
00147	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00148	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00149	                PyErr_Format(PyExc_NotImplementedError,
00150	                             "expected an aligned array of type %ld "
00151	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00152	                             " with %ld dimensions, with 3 last dims "
00153	                             "%ld, %ld, %ld"
00154	                             " and 3 last strides %ld %ld, %ld.",
00155	                             (long int) NPY_FLOAT32,
00156	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00157	                             (long int) PyArray_NDIM(tmp),
00158	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00159	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00160	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00161	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00162	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00163	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00164	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00165	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00166	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00167	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00168	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00169	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00170	            );
00171	                {
00172	        __failure = 2;
00173	        if (!PyErr_Occurred()) {
00174	            PyErr_SetString(PyExc_RuntimeError,
00175	                "Unexpected error in an Op's C code. "
00176	                "No Python exception was set.");
00177	            }
00178	        goto __label_2;}
00179	            }
00180	            // This is a TypeError to be consistent with DEBUG_MODE
00181	            // Note: DEBUG_MODE also tells the name of the container
00182	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT32) {
00183	                PyErr_Format(PyExc_TypeError,
00184	                             "expected type_num %d (NPY_FLOAT32) got %d",
00185	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V1));
00186	                {
00187	        __failure = 2;
00188	        if (!PyErr_Occurred()) {
00189	            PyErr_SetString(PyExc_RuntimeError,
00190	                "Unexpected error in an Op's C code. "
00191	                "No Python exception was set.");
00192	            }
00193	        goto __label_2;}
00194	            }
00195	            
00196	        V1 = (PyArrayObject*)(py_V1);
00197	        Py_XINCREF(V1);
00198	        
00199	        }
00200	        
00201	{
00202	
00203	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00204	    {Py_XINCREF(py_V3);}
00205	    
00206	            V3 = NULL;
00207	            if (py_V3 == Py_None) {
00208	                // We can either fail here or set V3 to NULL and rely on Ops
00209	                // using tensors to handle the NULL case, but if they fail to do so
00210	                // they'll end up with nasty segfaults, so this is public service.
00211	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00212	                {
00213	        __failure = 4;
00214	        if (!PyErr_Occurred()) {
00215	            PyErr_SetString(PyExc_RuntimeError,
00216	                "Unexpected error in an Op's C code. "
00217	                "No Python exception was set.");
00218	            }
00219	        goto __label_4;}
00220	            }
00221	            if (!PyArray_Check(py_V3)) {
00222	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00223	                {
00224	        __failure = 4;
00225	        if (!PyErr_Occurred()) {
00226	            PyErr_SetString(PyExc_RuntimeError,
00227	                "Unexpected error in an Op's C code. "
00228	                "No Python exception was set.");
00229	            }
00230	        goto __label_4;}
00231	            }
00232	            // We expect NPY_FLOAT32
00233	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00234	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00235	                PyErr_Format(PyExc_NotImplementedError,
00236	                             "expected an aligned array of type %ld "
00237	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00238	                             " with %ld dimensions, with 3 last dims "
00239	                             "%ld, %ld, %ld"
00240	                             " and 3 last strides %ld %ld, %ld.",
00241	                             (long int) NPY_FLOAT32,
00242	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00243	                             (long int) PyArray_NDIM(tmp),
00244	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00245	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00246	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00247	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00248	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00249	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00250	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00251	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00252	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00253	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00254	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00255	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00256	            );
00257	                {
00258	        __failure = 4;
00259	        if (!PyErr_Occurred()) {
00260	            PyErr_SetString(PyExc_RuntimeError,
00261	                "Unexpected error in an Op's C code. "
00262	                "No Python exception was set.");
00263	            }
00264	        goto __label_4;}
00265	            }
00266	            // This is a TypeError to be consistent with DEBUG_MODE
00267	            // Note: DEBUG_MODE also tells the name of the container
00268	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT32) {
00269	                PyErr_Format(PyExc_TypeError,
00270	                             "expected type_num %d (NPY_FLOAT32) got %d",
00271	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V3));
00272	                {
00273	        __failure = 4;
00274	        if (!PyErr_Occurred()) {
00275	            PyErr_SetString(PyExc_RuntimeError,
00276	                "Unexpected error in an Op's C code. "
00277	                "No Python exception was set.");
00278	            }
00279	        goto __label_4;}
00280	            }
00281	            
00282	        V3 = (PyArrayObject*)(py_V3);
00283	        Py_XINCREF(V3);
00284	        
00285	{
00286	
00287	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00288	    {Py_XINCREF(py_V5);}
00289	    
00290	            V5 = NULL;
00291	            if (py_V5 == Py_None) {
00292	                // We can either fail here or set V5 to NULL and rely on Ops
00293	                // using tensors to handle the NULL case, but if they fail to do so
00294	                // they'll end up with nasty segfaults, so this is public service.
00295	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00296	                {
00297	        __failure = 6;
00298	        if (!PyErr_Occurred()) {
00299	            PyErr_SetString(PyExc_RuntimeError,
00300	                "Unexpected error in an Op's C code. "
00301	                "No Python exception was set.");
00302	            }
00303	        goto __label_6;}
00304	            }
00305	            if (!PyArray_Check(py_V5)) {
00306	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00307	                {
00308	        __failure = 6;
00309	        if (!PyErr_Occurred()) {
00310	            PyErr_SetString(PyExc_RuntimeError,
00311	                "Unexpected error in an Op's C code. "
00312	                "No Python exception was set.");
00313	            }
00314	        goto __label_6;}
00315	            }
00316	            // We expect NPY_FLOAT32
00317	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00318	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00319	                PyErr_Format(PyExc_NotImplementedError,
00320	                             "expected an aligned array of type %ld "
00321	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00322	                             " with %ld dimensions, with 3 last dims "
00323	                             "%ld, %ld, %ld"
00324	                             " and 3 last strides %ld %ld, %ld.",
00325	                             (long int) NPY_FLOAT32,
00326	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00327	                             (long int) PyArray_NDIM(tmp),
00328	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00329	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00330	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00331	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00332	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00333	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00334	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00335	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00336	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00337	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00338	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00339	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00340	            );
00341	                {
00342	        __failure = 6;
00343	        if (!PyErr_Occurred()) {
00344	            PyErr_SetString(PyExc_RuntimeError,
00345	                "Unexpected error in an Op's C code. "
00346	                "No Python exception was set.");
00347	            }
00348	        goto __label_6;}
00349	            }
00350	            // This is a TypeError to be consistent with DEBUG_MODE
00351	            // Note: DEBUG_MODE also tells the name of the container
00352	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT32) {
00353	                PyErr_Format(PyExc_TypeError,
00354	                             "expected type_num %d (NPY_FLOAT32) got %d",
00355	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V5));
00356	                {
00357	        __failure = 6;
00358	        if (!PyErr_Occurred()) {
00359	            PyErr_SetString(PyExc_RuntimeError,
00360	                "Unexpected error in an Op's C code. "
00361	                "No Python exception was set.");
00362	            }
00363	        goto __label_6;}
00364	            }
00365	            
00366	        V5 = (PyArrayObject*)(py_V5);
00367	        Py_XINCREF(V5);
00368	        
00369	{
00370	
00371	    py_V7 = PyList_GET_ITEM(storage_V7, 0);
00372	    {Py_XINCREF(py_V7);}
00373	    
00374	            V7 = NULL;
00375	            if (py_V7 == Py_None) {
00376	                // We can either fail here or set V7 to NULL and rely on Ops
00377	                // using tensors to handle the NULL case, but if they fail to do so
00378	                // they'll end up with nasty segfaults, so this is public service.
00379	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00380	                {
00381	        __failure = 8;
00382	        if (!PyErr_Occurred()) {
00383	            PyErr_SetString(PyExc_RuntimeError,
00384	                "Unexpected error in an Op's C code. "
00385	                "No Python exception was set.");
00386	            }
00387	        goto __label_8;}
00388	            }
00389	            if (!PyArray_Check(py_V7)) {
00390	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00391	                {
00392	        __failure = 8;
00393	        if (!PyErr_Occurred()) {
00394	            PyErr_SetString(PyExc_RuntimeError,
00395	                "Unexpected error in an Op's C code. "
00396	                "No Python exception was set.");
00397	            }
00398	        goto __label_8;}
00399	            }
00400	            // We expect NPY_FLOAT32
00401	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V7)) {
00402	                PyArrayObject * tmp = (PyArrayObject*) py_V7;
00403	                PyErr_Format(PyExc_NotImplementedError,
00404	                             "expected an aligned array of type %ld "
00405	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00406	                             " with %ld dimensions, with 3 last dims "
00407	                             "%ld, %ld, %ld"
00408	                             " and 3 last strides %ld %ld, %ld.",
00409	                             (long int) NPY_FLOAT32,
00410	                             (long int) PyArray_TYPE((PyArrayObject*) py_V7),
00411	                             (long int) PyArray_NDIM(tmp),
00412	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00413	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00414	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00415	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00416	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00417	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00418	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00419	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00420	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00421	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00422	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00423	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00424	            );
00425	                {
00426	        __failure = 8;
00427	        if (!PyErr_Occurred()) {
00428	            PyErr_SetString(PyExc_RuntimeError,
00429	                "Unexpected error in an Op's C code. "
00430	                "No Python exception was set.");
00431	            }
00432	        goto __label_8;}
00433	            }
00434	            // This is a TypeError to be consistent with DEBUG_MODE
00435	            // Note: DEBUG_MODE also tells the name of the container
00436	            if (PyArray_TYPE((PyArrayObject*) py_V7) != NPY_FLOAT32) {
00437	                PyErr_Format(PyExc_TypeError,
00438	                             "expected type_num %d (NPY_FLOAT32) got %d",
00439	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V7));
00440	                {
00441	        __failure = 8;
00442	        if (!PyErr_Occurred()) {
00443	            PyErr_SetString(PyExc_RuntimeError,
00444	                "Unexpected error in an Op's C code. "
00445	                "No Python exception was set.");
00446	            }
00447	        goto __label_8;}
00448	            }
00449	            
00450	        V7 = (PyArrayObject*)(py_V7);
00451	        Py_XINCREF(V7);
00452	        
00453	{
00454	// Op class Elemwise
00455	
00456	        npy_float32* V3_iter;
00457	        
00458	                int V3_jumpx_0;
00459	                
00460	                int V3_jumpx_1;
00461	                
00462	                int V3_jumpx_2;
00463	                
00464	        npy_float32* V5_iter;
00465	        
00466	                npy_intp V5_n0;
00467	                ssize_t V5_stride0;
00468	                int V5_jump0_0;
00469	                
00470	                npy_intp V5_n1;
00471	                ssize_t V5_stride1;
00472	                int V5_jump1_1;
00473	                
00474	                npy_intp V5_n2;
00475	                ssize_t V5_stride2;
00476	                int V5_jump2_2;
00477	                
00478	        npy_float32* V7_iter;
00479	        
00480	                int V7_jumpx_0;
00481	                
00482	                int V7_jumpx_1;
00483	                
00484	                int V7_jumpx_2;
00485	                
00486	
00487	                V3_jumpx_2 = -(0);
00488	                //printf("V3_jumpx_2 is:");
00489	                //std::cout << V3_jumpx_2 << std::endl;
00490	                
00491	                V3_jumpx_1 = -(0);
00492	                //printf("V3_jumpx_1 is:");
00493	                //std::cout << V3_jumpx_1 << std::endl;
00494	                
00495	                V3_jumpx_0 = -(0);
00496	                //printf("V3_jumpx_0 is:");
00497	                //std::cout << V3_jumpx_0 << std::endl;
00498	                
00499	            if (PyArray_NDIM(V5) < 3) {
00500	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00501	                {
00502	        __failure = 9;
00503	        if (!PyErr_Occurred()) {
00504	            PyErr_SetString(PyExc_RuntimeError,
00505	                "Unexpected error in an Op's C code. "
00506	                "No Python exception was set.");
00507	            }
00508	        goto __label_9;}
00509	            }
00510	            
00511	                V5_n2 = PyArray_DIMS(V5)[2];
00512	                V5_stride2 = PyArray_STRIDES(V5)[2] / sizeof(npy_float32);
00513	                V5_jump2_2 = (V5_stride2) - (0);
00514	                //printf("V5_jump2_2 is:");
00515	                //std::cout << V5_jump2_2 << std::endl;
00516	                
00517	                V5_n1 = PyArray_DIMS(V5)[1];
00518	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float32);
00519	                V5_jump1_1 = (V5_stride1) - (V5_n2*V5_stride2);
00520	                //printf("V5_jump1_1 is:");
00521	                //std::cout << V5_jump1_1 << std::endl;
00522	                
00523	                V5_n0 = PyArray_DIMS(V5)[0];
00524	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float32);
00525	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00526	                //printf("V5_jump0_0 is:");
00527	                //std::cout << V5_jump0_0 << std::endl;
00528	                
00529	                V7_jumpx_2 = -(0);
00530	                //printf("V7_jumpx_2 is:");
00531	                //std::cout << V7_jumpx_2 << std::endl;
00532	                
00533	                V7_jumpx_1 = -(0);
00534	                //printf("V7_jumpx_1 is:");
00535	                //std::cout << V7_jumpx_1 << std::endl;
00536	                
00537	                V7_jumpx_0 = -(0);
00538	                //printf("V7_jumpx_0 is:");
00539	                //std::cout << V7_jumpx_0 << std::endl;
00540	                
00541	
00542	        npy_float32* V1_iter;
00543	        
00544	                npy_intp V1_n0;
00545	                ssize_t V1_stride0;
00546	                int V1_jump0_0;
00547	                
00548	                npy_intp V1_n1;
00549	                ssize_t V1_stride1;
00550	                int V1_jump1_1;
00551	                
00552	                npy_intp V1_n2;
00553	                ssize_t V1_stride2;
00554	                int V1_jump2_2;
00555	                
00556	    {
00557	        npy_intp dims[3];
00558	        //npy_intp* dims = (npy_intp*)malloc(3 * sizeof(npy_intp));
00559	        dims[0] = V5_n0;
00560	dims[1] = V5_n1;
00561	dims[2] = V5_n2;
00562	
00563	        if (!V1) {
00564	            V1 = (PyArrayObject*)PyArray_EMPTY(3, dims,
00565	                                                    NPY_FLOAT32,
00566	                                                    PyArray_ISFORTRAN(V5));
00567	        }
00568	        else {
00569	            PyArray_Dims new_dims;
00570	            new_dims.len = 3;
00571	            new_dims.ptr = dims;
00572	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00573	            if (!success) {
00574	                // If we can't resize the ndarray we have we can allocate a new one.
00575	                PyErr_Clear();
00576	                Py_XDECREF(V1);
00577	                V1 = (PyArrayObject*)PyArray_EMPTY(3, dims, NPY_FLOAT32, 0);
00578	            }
00579	        }
00580	        if (!V1) {
00581	            {
00582	        __failure = 9;
00583	        if (!PyErr_Occurred()) {
00584	            PyErr_SetString(PyExc_RuntimeError,
00585	                "Unexpected error in an Op's C code. "
00586	                "No Python exception was set.");
00587	            }
00588	        goto __label_9;}
00589	        }
00590	    }
00591	    
00592	            if (PyArray_NDIM(V1) < 3) {
00593	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00594	                {
00595	        __failure = 9;
00596	        if (!PyErr_Occurred()) {
00597	            PyErr_SetString(PyExc_RuntimeError,
00598	                "Unexpected error in an Op's C code. "
00599	                "No Python exception was set.");
00600	            }
00601	        goto __label_9;}
00602	            }
00603	            
00604	                V1_n2 = PyArray_DIMS(V1)[2];
00605	                V1_stride2 = PyArray_STRIDES(V1)[2] / sizeof(npy_float32);
00606	                V1_jump2_2 = (V1_stride2) - (0);
00607	                //printf("V1_jump2_2 is:");
00608	                //std::cout << V1_jump2_2 << std::endl;
00609	                
00610	                V1_n1 = PyArray_DIMS(V1)[1];
00611	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float32);
00612	                V1_jump1_1 = (V1_stride1) - (V1_n2*V1_stride2);
00613	                //printf("V1_jump1_1 is:");
00614	                //std::cout << V1_jump1_1 << std::endl;
00615	                
00616	                V1_n0 = PyArray_DIMS(V1)[0];
00617	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float32);
00618	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00619	                //printf("V1_jump0_0 is:");
00620	                //std::cout << V1_jump0_0 << std::endl;
00621	                
00622	
00623	            if((PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00624	                
00625	                    // All output have the same size
00626	                    npy_intp n = PyArray_SIZE(V1);
00627	                    
00628	            dtype_V3& V3_i = ((dtype_V3*) PyArray_DATA(V3))[0];
00629	                            
00630	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00631	                            
00632	            dtype_V7& V7_i = ((dtype_V7*) PyArray_DATA(V7))[0];
00633	                            
00634	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00635	                            
00636	                    for(int i=0; i<n; i++){
00637	                        
00638	            dtype_V5& V5_i = V5_ptr[i];
00639	                            
00640	            dtype_V1& V1_i = V1_ptr[i];
00641	                            
00642	                        V1_i = V3_i + V5_i + V7_i;;
00643	                    }
00644	                    
00645	            }else{
00646	                {
00647	
00648	    std::vector< std::pair<int, int> > V1_loops(3);
00649	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00650	    
00651	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00652	            
00653	        V1_loops_it->second = 0;
00654	        ++V1_loops_it;
00655	        
00656	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00657	            
00658	        V1_loops_it->second = 1;
00659	        ++V1_loops_it;
00660	        
00661	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[2]);
00662	            
00663	        V1_loops_it->second = 2;
00664	        ++V1_loops_it;
00665	        
00666	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00667	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00668	    
00669	
00670	    int init_totals[3] = {V5_n0, V5_n1, V5_n2};
00671	    
00672	    V1_loops_it = V1_loops.begin();
00673	    
00674	        int TOTAL_0 = init_totals[V1_loops_it->second];
00675	        ++V1_loops_it;
00676	        
00677	        int TOTAL_1 = init_totals[V1_loops_it->second];
00678	        ++V1_loops_it;
00679	        
00680	        int TOTAL_2 = init_totals[V1_loops_it->second];
00681	        ++V1_loops_it;
00682	        
00683	
00684	    int init_strides[4][3] = {
00685	        0, 0, 0, 
00686	V5_stride0, V5_stride1, V5_stride2, 
00687	0, 0, 0, 
00688	V1_stride0, V1_stride1, V1_stride2
00689	    };
00690	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00691	    
00692	        V1_loops_rit = V1_loops.rbegin();
00693	            int V3_stride_l2 = init_strides[0][V1_loops_rit->second];
00694	            ++V1_loops_rit;
00695	            
00696	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00697	            ++V1_loops_rit;
00698	            
00699	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00700	            ++V1_loops_rit;
00701	            
00702	        V1_loops_rit = V1_loops.rbegin();
00703	            int V5_stride_l2 = init_strides[1][V1_loops_rit->second];
00704	            ++V1_loops_rit;
00705	            
00706	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00707	            ++V1_loops_rit;
00708	            
00709	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00710	            ++V1_loops_rit;
00711	            
00712	        V1_loops_rit = V1_loops.rbegin();
00713	            int V7_stride_l2 = init_strides[2][V1_loops_rit->second];
00714	            ++V1_loops_rit;
00715	            
00716	            int V7_stride_l1 = init_strides[2][V1_loops_rit->second];
00717	            ++V1_loops_rit;
00718	            
00719	            int V7_stride_l0 = init_strides[2][V1_loops_rit->second];
00720	            ++V1_loops_rit;
00721	            
00722	        V1_loops_rit = V1_loops.rbegin();
00723	            int V1_stride_l2 = init_strides[3][V1_loops_rit->second];
00724	            ++V1_loops_rit;
00725	            
00726	            int V1_stride_l1 = init_strides[3][V1_loops_rit->second];
00727	            ++V1_loops_rit;
00728	            
00729	            int V1_stride_l0 = init_strides[3][V1_loops_rit->second];
00730	            ++V1_loops_rit;
00731	            
00732	V3_iter = (npy_float32*)(PyArray_DATA(V3));
00733	V5_iter = (npy_float32*)(PyArray_DATA(V5));
00734	V7_iter = (npy_float32*)(PyArray_DATA(V7));
00735	V1_iter = (npy_float32*)(PyArray_DATA(V1));
00736	
00737	
00738	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00739	        { // begin loop 0
00740	            
00741	            
00742	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00743	        { // begin loop 1
00744	            
00745	            
00746	        for(int ITER_2 = 0; ITER_2<TOTAL_2; ITER_2++)
00747	        { // begin loop 2
00748	            npy_float32 &V3_i = * ( V3_iter+V3_stride_l2*ITER_2+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00749	npy_float32 &V5_i = * ( V5_iter+V5_stride_l2*ITER_2+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00750	npy_float32 &V7_i = * ( V7_iter+V7_stride_l2*ITER_2+V7_stride_l1*ITER_1+V7_stride_l0*ITER_0);
00751	npy_float32 &V1_i = * ( V1_iter+V1_stride_l2*ITER_2+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00752	
00753	            
00754	        {
00755	            
00756	            V1_i = V3_i + V5_i + V7_i;
00757	            
00758	        }
00759	        
00760	        } // end loop 2
00761	        
00762	        } // end loop 1
00763	        
00764	        } // end loop 0
00765	        
00766	}
00767	
00768	            }
00769	            __label_9:
00770	
00771	double __DUMMY_9;
00772	
00773	}
00774	__label_8:
00775	
00776	        if (V7) {
00777	            Py_XDECREF(V7);
00778	        }
00779	        
00780	    {Py_XDECREF(py_V7);}
00781	    
00782	double __DUMMY_8;
00783	
00784	}
00785	__label_6:
00786	
00787	        if (V5) {
00788	            Py_XDECREF(V5);
00789	        }
00790	        
00791	    {Py_XDECREF(py_V5);}
00792	    
00793	double __DUMMY_6;
00794	
00795	}
00796	__label_4:
00797	
00798	        if (V3) {
00799	            Py_XDECREF(V3);
00800	        }
00801	        
00802	    {Py_XDECREF(py_V3);}
00803	    
00804	double __DUMMY_4;
00805	
00806	}
00807	__label_2:
00808	
00809	    if (!__failure) {
00810	      
00811	        {Py_XDECREF(py_V1);}
00812	        if (!V1) {
00813	            Py_INCREF(Py_None);
00814	            py_V1 = Py_None;
00815	        }
00816	        else if ((void*)py_V1 != (void*)V1) {
00817	            py_V1 = (PyObject*)V1;
00818	        }
00819	
00820	        {Py_XINCREF(py_V1);}
00821	
00822	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00823	            PyErr_Format(PyExc_NotImplementedError,
00824	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00825	                         " with %ld dimensions, with 3 last dims "
00826	                         "%ld, %ld, %ld"
00827	                         " and 3 last strides %ld %ld, %ld.",
00828	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00829	                         (long int) PyArray_NDIM(V1),
00830	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00831	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00832	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00833	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00834	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00835	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00836	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00837	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00838	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00839	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00840	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00841	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00842	        );
00843	            {
00844	        __failure = 2;
00845	        if (!PyErr_Occurred()) {
00846	            PyErr_SetString(PyExc_RuntimeError,
00847	                "Unexpected error in an Op's C code. "
00848	                "No Python exception was set.");
00849	            }
00850	        goto __label_2;}
00851	        }
00852	        
00853	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00854	      {Py_XINCREF(py_V1);}
00855	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00856	      {Py_XDECREF(old);}
00857	    }
00858	    
00859	        if (V1) {
00860	            Py_XDECREF(V1);
00861	        }
00862	        
00863	    {Py_XDECREF(py_V1);}
00864	    
00865	double __DUMMY_2;
00866	
00867	}
00868	
00869	            
00870	        if (__failure) {
00871	            // When there is a failure, this code puts the exception
00872	            // in __ERROR.
00873	            PyObject* err_type = NULL;
00874	            PyObject* err_msg = NULL;
00875	            PyObject* err_traceback = NULL;
00876	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00877	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00878	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00879	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00880	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00881	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00882	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00883	            PyList_SET_ITEM(__ERROR, 0, err_type);
00884	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00885	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00886	            {Py_XDECREF(old_err_type);}
00887	            {Py_XDECREF(old_err_msg);}
00888	            {Py_XDECREF(old_err_traceback);}
00889	        }
00890	        // The failure code is returned to index what code block failed.
00891	        return __failure;
00892	        
00893	        }
00894	    };
00895	    }
00896	    
00897	
00898	        static int __struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb_executor(__struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb* self) {
00899	            return self->run();
00900	        }
00901	
00902	        static void __struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb_destructor(void* executor, void* self) {
00903	            delete ((__struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb*)self);
00904	        }
00905	        
00906	//////////////////////
00907	////  Functions
00908	//////////////////////
00909	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00910	  assert(PyTuple_Check(argtuple));
00911	  if (5 != PyTuple_Size(argtuple)){ 
00912	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 5, got %i", (int)PyTuple_Size(argtuple));
00913	     return NULL;
00914	  }
00915	  __struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb* struct_ptr = new __struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb();
00916	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3),PyTuple_GET_ITEM(argtuple, 4) ) != 0) {
00917	    delete struct_ptr;
00918	    return NULL;
00919	  }
00920	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb_executor), struct_ptr, __struct_compiled_op_3c0ac1f90d38d9a9f34fdf665fb04dbb_destructor);
00921	  return thunk; }
00922	
00923	//////////////////////
00924	////  Module init
00925	//////////////////////
00926	static PyMethodDef MyMethods[] = {
00927		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00928		{NULL, NULL, 0, NULL}
00929	};
00930	PyMODINIT_FUNC init3c0ac1f90d38d9a9f34fdf665fb04dbb(void){
00931	   import_array();
00932	   (void) Py_InitModule("3c0ac1f90d38d9a9f34fdf665fb04dbb", MyMethods);
00933	}
00934	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpqjOLsY/3c0ac1f90d38d9a9f34fdf665fb04dbb.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpqjOLsY/mod.cpp -lpython2.7
ERROR
test_clone (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_cloning_no_replace_strict_copy_inputs (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_cloning_no_replace_strict_not_copy_inputs (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_cloning_replace_not_strict_copy_inputs (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_cloning_replace_not_strict_not_copy_inputs (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_cloning_replace_strict_copy_inputs (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_cloning_replace_strict_not_copy_inputs (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_computing_gradient (theano.scan_module.tests.test_scan.T_Scan) ... ok
Test connection_pattern() in the presence of recurrent outputs ... ok
test_connection_pattern2 (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_crash_nonseq_grad (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_084ce674de79126c5f1054081a13183f {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_084ce674de79126c5f1054081a13183f() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_084ce674de79126c5f1054081a13183f(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float64* V5_iter;
00369	        
00370	                npy_intp V5_n0;
00371	                ssize_t V5_stride0;
00372	                int V5_jump0_0;
00373	                
00374	                int V5_jumpx_1;
00375	                
00376	
00377	            if (PyArray_NDIM(V3) < 2) {
00378	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00379	                {
00380	        __failure = 7;
00381	        if (!PyErr_Occurred()) {
00382	            PyErr_SetString(PyExc_RuntimeError,
00383	                "Unexpected error in an Op's C code. "
00384	                "No Python exception was set.");
00385	            }
00386	        goto __label_7;}
00387	            }
00388	            
00389	                V3_n1 = PyArray_DIMS(V3)[1];
00390	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00391	                V3_jump1_1 = (V3_stride1) - (0);
00392	                //printf("V3_jump1_1 is:");
00393	                //std::cout << V3_jump1_1 << std::endl;
00394	                
00395	                V3_n0 = PyArray_DIMS(V3)[0];
00396	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00397	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00398	                //printf("V3_jump0_0 is:");
00399	                //std::cout << V3_jump0_0 << std::endl;
00400	                
00401	            if (PyArray_NDIM(V5) < 1) {
00402	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00403	                {
00404	        __failure = 7;
00405	        if (!PyErr_Occurred()) {
00406	            PyErr_SetString(PyExc_RuntimeError,
00407	                "Unexpected error in an Op's C code. "
00408	                "No Python exception was set.");
00409	            }
00410	        goto __label_7;}
00411	            }
00412	            
00413	                V5_jumpx_1 = -(0);
00414	                //printf("V5_jumpx_1 is:");
00415	                //std::cout << V5_jumpx_1 << std::endl;
00416	                
00417	                V5_n0 = PyArray_DIMS(V5)[0];
00418	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00419	                V5_jump0_0 = (V5_stride0) - (0);
00420	                //printf("V5_jump0_0 is:");
00421	                //std::cout << V5_jump0_0 << std::endl;
00422	                
00423	            if (V3_n0 != V5_n0)
00424	            {
00425	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00426	                   0,
00427	                   0,
00428	                   V3_n0,
00429	                   1,
00430	                   0,
00431	                   V5_n0
00432	                );
00433	                {
00434	        __failure = 7;
00435	        if (!PyErr_Occurred()) {
00436	            PyErr_SetString(PyExc_RuntimeError,
00437	                "Unexpected error in an Op's C code. "
00438	                "No Python exception was set.");
00439	            }
00440	        goto __label_7;}
00441	            }
00442	            
00443	
00444	        npy_float64* V1_iter;
00445	        
00446	                npy_intp V1_n0;
00447	                ssize_t V1_stride0;
00448	                int V1_jump0_0;
00449	                
00450	                npy_intp V1_n1;
00451	                ssize_t V1_stride1;
00452	                int V1_jump1_1;
00453	                
00454	    {
00455	        npy_intp dims[2];
00456	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00457	        dims[0] = V3_n0;
00458	dims[1] = V3_n1;
00459	
00460	        if (!V1) {
00461	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00462	                                                    NPY_FLOAT64,
00463	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00464	        }
00465	        else {
00466	            PyArray_Dims new_dims;
00467	            new_dims.len = 2;
00468	            new_dims.ptr = dims;
00469	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00470	            if (!success) {
00471	                // If we can't resize the ndarray we have we can allocate a new one.
00472	                PyErr_Clear();
00473	                Py_XDECREF(V1);
00474	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00475	            }
00476	        }
00477	        if (!V1) {
00478	            {
00479	        __failure = 7;
00480	        if (!PyErr_Occurred()) {
00481	            PyErr_SetString(PyExc_RuntimeError,
00482	                "Unexpected error in an Op's C code. "
00483	                "No Python exception was set.");
00484	            }
00485	        goto __label_7;}
00486	        }
00487	    }
00488	    
00489	            if (PyArray_NDIM(V1) < 2) {
00490	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00491	                {
00492	        __failure = 7;
00493	        if (!PyErr_Occurred()) {
00494	            PyErr_SetString(PyExc_RuntimeError,
00495	                "Unexpected error in an Op's C code. "
00496	                "No Python exception was set.");
00497	            }
00498	        goto __label_7;}
00499	            }
00500	            
00501	                V1_n1 = PyArray_DIMS(V1)[1];
00502	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00503	                V1_jump1_1 = (V1_stride1) - (0);
00504	                //printf("V1_jump1_1 is:");
00505	                //std::cout << V1_jump1_1 << std::endl;
00506	                
00507	                V1_n0 = PyArray_DIMS(V1)[0];
00508	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00509	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00510	                //printf("V1_jump0_0 is:");
00511	                //std::cout << V1_jump0_0 << std::endl;
00512	                
00513	{
00514	
00515	    std::vector< std::pair<int, int> > V1_loops(2);
00516	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00517	    
00518	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00519	            
00520	        V1_loops_it->second = 0;
00521	        ++V1_loops_it;
00522	        
00523	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00524	            
00525	        V1_loops_it->second = 1;
00526	        ++V1_loops_it;
00527	        
00528	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00529	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00530	    
00531	
00532	    int init_totals[2] = {V3_n0, V3_n1};
00533	    
00534	    V1_loops_it = V1_loops.begin();
00535	    
00536	        int TOTAL_0 = init_totals[V1_loops_it->second];
00537	        ++V1_loops_it;
00538	        
00539	        int TOTAL_1 = init_totals[V1_loops_it->second];
00540	        ++V1_loops_it;
00541	        
00542	
00543	    int init_strides[3][2] = {
00544	        V3_stride0, V3_stride1, 
00545	V5_stride0, 0, 
00546	V1_stride0, V1_stride1
00547	    };
00548	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00549	    
00550	        V1_loops_rit = V1_loops.rbegin();
00551	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00552	            ++V1_loops_rit;
00553	            
00554	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00555	            ++V1_loops_rit;
00556	            
00557	        V1_loops_rit = V1_loops.rbegin();
00558	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00559	            ++V1_loops_rit;
00560	            
00561	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00562	            ++V1_loops_rit;
00563	            
00564	        V1_loops_rit = V1_loops.rbegin();
00565	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00566	            ++V1_loops_rit;
00567	            
00568	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00569	            ++V1_loops_rit;
00570	            
00571	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00572	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00573	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00574	
00575	
00576	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00577	        { // begin loop 0
00578	            
00579	            
00580	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00581	        { // begin loop 1
00582	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00583	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00584	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00585	
00586	            
00587	        {
00588	            
00589	            V1_i = V3_i / V5_i;
00590	            
00591	        }
00592	        
00593	        } // end loop 1
00594	        
00595	        } // end loop 0
00596	        
00597	}
00598	__label_7:
00599	
00600	double __DUMMY_7;
00601	
00602	}
00603	__label_6:
00604	
00605	        if (V5) {
00606	            Py_XDECREF(V5);
00607	        }
00608	        
00609	    {Py_XDECREF(py_V5);}
00610	    
00611	double __DUMMY_6;
00612	
00613	}
00614	__label_4:
00615	
00616	        if (V3) {
00617	            Py_XDECREF(V3);
00618	        }
00619	        
00620	    {Py_XDECREF(py_V3);}
00621	    
00622	double __DUMMY_4;
00623	
00624	}
00625	__label_2:
00626	
00627	    if (!__failure) {
00628	      
00629	        {Py_XDECREF(py_V1);}
00630	        if (!V1) {
00631	            Py_INCREF(Py_None);
00632	            py_V1 = Py_None;
00633	        }
00634	        else if ((void*)py_V1 != (void*)V1) {
00635	            py_V1 = (PyObject*)V1;
00636	        }
00637	
00638	        {Py_XINCREF(py_V1);}
00639	
00640	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00641	            PyErr_Format(PyExc_NotImplementedError,
00642	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00643	                         " with %ld dimensions, with 3 last dims "
00644	                         "%ld, %ld, %ld"
00645	                         " and 3 last strides %ld %ld, %ld.",
00646	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00647	                         (long int) PyArray_NDIM(V1),
00648	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00649	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00650	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00651	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00652	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00653	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00654	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00655	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00656	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00657	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00658	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00659	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00660	        );
00661	            {
00662	        __failure = 2;
00663	        if (!PyErr_Occurred()) {
00664	            PyErr_SetString(PyExc_RuntimeError,
00665	                "Unexpected error in an Op's C code. "
00666	                "No Python exception was set.");
00667	            }
00668	        goto __label_2;}
00669	        }
00670	        
00671	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00672	      {Py_XINCREF(py_V1);}
00673	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00674	      {Py_XDECREF(old);}
00675	    }
00676	    
00677	        if (V1) {
00678	            Py_XDECREF(V1);
00679	        }
00680	        
00681	    {Py_XDECREF(py_V1);}
00682	    
00683	double __DUMMY_2;
00684	
00685	}
00686	
00687	            
00688	        if (__failure) {
00689	            // When there is a failure, this code puts the exception
00690	            // in __ERROR.
00691	            PyObject* err_type = NULL;
00692	            PyObject* err_msg = NULL;
00693	            PyObject* err_traceback = NULL;
00694	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00695	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00696	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00697	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00698	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00699	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00700	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00701	            PyList_SET_ITEM(__ERROR, 0, err_type);
00702	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00703	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00704	            {Py_XDECREF(old_err_type);}
00705	            {Py_XDECREF(old_err_msg);}
00706	            {Py_XDECREF(old_err_traceback);}
00707	        }
00708	        // The failure code is returned to index what code block failed.
00709	        return __failure;
00710	        
00711	        }
00712	    };
00713	    }
00714	    
00715	
00716	        static int __struct_compiled_op_084ce674de79126c5f1054081a13183f_executor(__struct_compiled_op_084ce674de79126c5f1054081a13183f* self) {
00717	            return self->run();
00718	        }
00719	
00720	        static void __struct_compiled_op_084ce674de79126c5f1054081a13183f_destructor(void* executor, void* self) {
00721	            delete ((__struct_compiled_op_084ce674de79126c5f1054081a13183f*)self);
00722	        }
00723	        
00724	//////////////////////
00725	////  Functions
00726	//////////////////////
00727	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00728	  assert(PyTuple_Check(argtuple));
00729	  if (4 != PyTuple_Size(argtuple)){ 
00730	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00731	     return NULL;
00732	  }
00733	  __struct_compiled_op_084ce674de79126c5f1054081a13183f* struct_ptr = new __struct_compiled_op_084ce674de79126c5f1054081a13183f();
00734	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00735	    delete struct_ptr;
00736	    return NULL;
00737	  }
00738	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_084ce674de79126c5f1054081a13183f_executor), struct_ptr, __struct_compiled_op_084ce674de79126c5f1054081a13183f_destructor);
00739	  return thunk; }
00740	
00741	//////////////////////
00742	////  Module init
00743	//////////////////////
00744	static PyMethodDef MyMethods[] = {
00745		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00746		{NULL, NULL, 0, NULL}
00747	};
00748	PyMODINIT_FUNC init084ce674de79126c5f1054081a13183f(void){
00749	   import_array();
00750	   (void) Py_InitModule("084ce674de79126c5f1054081a13183f", MyMethods);
00751	}
00752	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmptK1rp4/084ce674de79126c5f1054081a13183f.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmptK1rp4/mod.cpp -lpython2.7
ERROR
test_disconnected_gradient (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_disconnected_gradient2 (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_disconnected_gradient3 (theano.scan_module.tests.test_scan.T_Scan) ... INFO (theano.gof.compilelock): Refreshing lock /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/lock_dir/lock
ok
test_dot_optimization (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_draw_as_input_to_scan (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_eliminate_nonseqs (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_eliminate_seqs (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_foldl_memory_consumption (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_foldr_memory_consumption (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_generator_one_output_scalar (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_gibbs_chain (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float32 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float32 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float32 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT32
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT32,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT32) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT32) got %d",
00171	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT32
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT32,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT32) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT32) got %d",
00257	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT32
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT32,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT32) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT32) got %d",
00341	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float32* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float32* V5_iter;
00369	        
00370	                int V5_jumpx_0;
00371	                
00372	                npy_intp V5_n1;
00373	                ssize_t V5_stride1;
00374	                int V5_jump1_1;
00375	                
00376	
00377	            if (PyArray_NDIM(V3) < 2) {
00378	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00379	                {
00380	        __failure = 7;
00381	        if (!PyErr_Occurred()) {
00382	            PyErr_SetString(PyExc_RuntimeError,
00383	                "Unexpected error in an Op's C code. "
00384	                "No Python exception was set.");
00385	            }
00386	        goto __label_7;}
00387	            }
00388	            
00389	                V3_n1 = PyArray_DIMS(V3)[1];
00390	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float32);
00391	                V3_jump1_1 = (V3_stride1) - (0);
00392	                //printf("V3_jump1_1 is:");
00393	                //std::cout << V3_jump1_1 << std::endl;
00394	                
00395	                V3_n0 = PyArray_DIMS(V3)[0];
00396	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float32);
00397	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00398	                //printf("V3_jump0_0 is:");
00399	                //std::cout << V3_jump0_0 << std::endl;
00400	                
00401	            if (PyArray_NDIM(V5) < 2) {
00402	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00403	                {
00404	        __failure = 7;
00405	        if (!PyErr_Occurred()) {
00406	            PyErr_SetString(PyExc_RuntimeError,
00407	                "Unexpected error in an Op's C code. "
00408	                "No Python exception was set.");
00409	            }
00410	        goto __label_7;}
00411	            }
00412	            
00413	                V5_n1 = PyArray_DIMS(V5)[1];
00414	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float32);
00415	                V5_jump1_1 = (V5_stride1) - (0);
00416	                //printf("V5_jump1_1 is:");
00417	                //std::cout << V5_jump1_1 << std::endl;
00418	                
00419	                V5_jumpx_0 = -(V5_n1*V5_stride1);
00420	                //printf("V5_jumpx_0 is:");
00421	                //std::cout << V5_jumpx_0 << std::endl;
00422	                
00423	            if (V3_n1 != V5_n1)
00424	            {
00425	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00426	                   0,
00427	                   1,
00428	                   V3_n1,
00429	                   1,
00430	                   1,
00431	                   V5_n1
00432	                );
00433	                {
00434	        __failure = 7;
00435	        if (!PyErr_Occurred()) {
00436	            PyErr_SetString(PyExc_RuntimeError,
00437	                "Unexpected error in an Op's C code. "
00438	                "No Python exception was set.");
00439	            }
00440	        goto __label_7;}
00441	            }
00442	            
00443	
00444	            if (V1) {
00445	                Py_XDECREF(V1);
00446	            }
00447	            V1 = V3;
00448	            Py_XINCREF(V1);
00449	            
00450	{
00451	
00452	    std::vector< std::pair<int, int> > V3_loops(2);
00453	    std::vector< std::pair<int, int> >::iterator V3_loops_it = V3_loops.begin();
00454	    
00455	            V3_loops_it->first = abs(PyArray_STRIDES(V3)[0]);
00456	            
00457	        V3_loops_it->second = 0;
00458	        ++V3_loops_it;
00459	        
00460	            V3_loops_it->first = abs(PyArray_STRIDES(V3)[1]);
00461	            
00462	        V3_loops_it->second = 1;
00463	        ++V3_loops_it;
00464	        
00465	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00466	    std::sort(V3_loops.rbegin(), V3_loops.rend());
00467	    
00468	
00469	    int init_totals[2] = {V3_n0, V3_n1};
00470	    
00471	    V3_loops_it = V3_loops.begin();
00472	    
00473	        int TOTAL_0 = init_totals[V3_loops_it->second];
00474	        ++V3_loops_it;
00475	        
00476	        int TOTAL_1 = init_totals[V3_loops_it->second];
00477	        ++V3_loops_it;
00478	        
00479	
00480	    int init_strides[2][2] = {
00481	        V3_stride0, V3_stride1, 
00482	0, V5_stride1
00483	    };
00484	    std::vector< std::pair<int, int> >::reverse_iterator V3_loops_rit;
00485	    
00486	        V3_loops_rit = V3_loops.rbegin();
00487	            int V3_stride_l1 = init_strides[0][V3_loops_rit->second];
00488	            ++V3_loops_rit;
00489	            
00490	            int V3_stride_l0 = init_strides[0][V3_loops_rit->second];
00491	            ++V3_loops_rit;
00492	            
00493	        V3_loops_rit = V3_loops.rbegin();
00494	            int V5_stride_l1 = init_strides[1][V3_loops_rit->second];
00495	            ++V3_loops_rit;
00496	            
00497	            int V5_stride_l0 = init_strides[1][V3_loops_rit->second];
00498	            ++V3_loops_rit;
00499	            
00500	V3_iter = (npy_float32*)(PyArray_DATA(V3));
00501	V5_iter = (npy_float32*)(PyArray_DATA(V5));
00502	
00503	
00504	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00505	        { // begin loop 0
00506	            
00507	            
00508	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00509	        { // begin loop 1
00510	            npy_float32 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00511	npy_float32 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00512	
00513	            
00514	        {
00515	            #define V1_i V3_i
00516	
00517	            {
00518	npy_float32 V7_tmp1;
00519	V7_tmp1 = V3_i + V5_i;
00520	V1_i = V7_tmp1 < -88.0f ? 0.0 : V7_tmp1 > 15.0f ? 1.0f : 1.0f /(1.0f + exp(-V7_tmp1));
00521	}
00522	
00523	            #undef V1_i
00524	
00525	        }
00526	        
00527	        } // end loop 1
00528	        
00529	        } // end loop 0
00530	        
00531	}
00532	__label_7:
00533	
00534	double __DUMMY_7;
00535	
00536	}
00537	__label_6:
00538	
00539	        if (V5) {
00540	            Py_XDECREF(V5);
00541	        }
00542	        
00543	    {Py_XDECREF(py_V5);}
00544	    
00545	double __DUMMY_6;
00546	
00547	}
00548	__label_4:
00549	
00550	        if (V3) {
00551	            Py_XDECREF(V3);
00552	        }
00553	        
00554	    {Py_XDECREF(py_V3);}
00555	    
00556	double __DUMMY_4;
00557	
00558	}
00559	__label_2:
00560	
00561	    if (!__failure) {
00562	      
00563	        {Py_XDECREF(py_V1);}
00564	        if (!V1) {
00565	            Py_INCREF(Py_None);
00566	            py_V1 = Py_None;
00567	        }
00568	        else if ((void*)py_V1 != (void*)V1) {
00569	            py_V1 = (PyObject*)V1;
00570	        }
00571	
00572	        {Py_XINCREF(py_V1);}
00573	
00574	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00575	            PyErr_Format(PyExc_NotImplementedError,
00576	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00577	                         " with %ld dimensions, with 3 last dims "
00578	                         "%ld, %ld, %ld"
00579	                         " and 3 last strides %ld %ld, %ld.",
00580	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00581	                         (long int) PyArray_NDIM(V1),
00582	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00583	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00584	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00585	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00586	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00587	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00588	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00589	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00590	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00591	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00592	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00593	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00594	        );
00595	            {
00596	        __failure = 2;
00597	        if (!PyErr_Occurred()) {
00598	            PyErr_SetString(PyExc_RuntimeError,
00599	                "Unexpected error in an Op's C code. "
00600	                "No Python exception was set.");
00601	            }
00602	        goto __label_2;}
00603	        }
00604	        
00605	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00606	      {Py_XINCREF(py_V1);}
00607	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00608	      {Py_XDECREF(old);}
00609	    }
00610	    
00611	        if (V1) {
00612	            Py_XDECREF(V1);
00613	        }
00614	        
00615	    {Py_XDECREF(py_V1);}
00616	    
00617	double __DUMMY_2;
00618	
00619	}
00620	
00621	            
00622	        if (__failure) {
00623	            // When there is a failure, this code puts the exception
00624	            // in __ERROR.
00625	            PyObject* err_type = NULL;
00626	            PyObject* err_msg = NULL;
00627	            PyObject* err_traceback = NULL;
00628	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00629	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00630	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00631	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00632	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00633	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00634	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00635	            PyList_SET_ITEM(__ERROR, 0, err_type);
00636	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00637	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00638	            {Py_XDECREF(old_err_type);}
00639	            {Py_XDECREF(old_err_msg);}
00640	            {Py_XDECREF(old_err_traceback);}
00641	        }
00642	        // The failure code is returned to index what code block failed.
00643	        return __failure;
00644	        
00645	        }
00646	    };
00647	    }
00648	    
00649	
00650	        static int __struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9_executor(__struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9* self) {
00651	            return self->run();
00652	        }
00653	
00654	        static void __struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9_destructor(void* executor, void* self) {
00655	            delete ((__struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9*)self);
00656	        }
00657	        
00658	//////////////////////
00659	////  Functions
00660	//////////////////////
00661	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00662	  assert(PyTuple_Check(argtuple));
00663	  if (4 != PyTuple_Size(argtuple)){ 
00664	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00665	     return NULL;
00666	  }
00667	  __struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9* struct_ptr = new __struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9();
00668	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00669	    delete struct_ptr;
00670	    return NULL;
00671	  }
00672	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9_executor), struct_ptr, __struct_compiled_op_afe381a6a6a2ba35818e333479e6b4d9_destructor);
00673	  return thunk; }
00674	
00675	//////////////////////
00676	////  Module init
00677	//////////////////////
00678	static PyMethodDef MyMethods[] = {
00679		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00680		{NULL, NULL, 0, NULL}
00681	};
00682	PyMODINIT_FUNC initafe381a6a6a2ba35818e333479e6b4d9(void){
00683	   import_array();
00684	   (void) Py_InitModule("afe381a6a6a2ba35818e333479e6b4d9", MyMethods);
00685	}
00686	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpMoFbTM/afe381a6a6a2ba35818e333479e6b4d9.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpMoFbTM/mod.cpp -lpython2.7
ERROR
test_grad_bug_disconnected_input (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_0e0d286bd63abb2546678e4d6428de73 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_0e0d286bd63abb2546678e4d6428de73() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_0e0d286bd63abb2546678e4d6428de73(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float64* V5_iter;
00369	        
00370	                npy_intp V5_n0;
00371	                ssize_t V5_stride0;
00372	                int V5_jump0_0;
00373	                
00374	                npy_intp V5_n1;
00375	                ssize_t V5_stride1;
00376	                int V5_jump1_1;
00377	                
00378	
00379	            if (PyArray_NDIM(V3) < 2) {
00380	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00381	                {
00382	        __failure = 7;
00383	        if (!PyErr_Occurred()) {
00384	            PyErr_SetString(PyExc_RuntimeError,
00385	                "Unexpected error in an Op's C code. "
00386	                "No Python exception was set.");
00387	            }
00388	        goto __label_7;}
00389	            }
00390	            
00391	                V3_n1 = PyArray_DIMS(V3)[1];
00392	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00393	                V3_jump1_1 = (V3_stride1) - (0);
00394	                //printf("V3_jump1_1 is:");
00395	                //std::cout << V3_jump1_1 << std::endl;
00396	                
00397	                V3_n0 = PyArray_DIMS(V3)[0];
00398	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00399	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00400	                //printf("V3_jump0_0 is:");
00401	                //std::cout << V3_jump0_0 << std::endl;
00402	                
00403	            if (PyArray_NDIM(V5) < 2) {
00404	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00405	                {
00406	        __failure = 7;
00407	        if (!PyErr_Occurred()) {
00408	            PyErr_SetString(PyExc_RuntimeError,
00409	                "Unexpected error in an Op's C code. "
00410	                "No Python exception was set.");
00411	            }
00412	        goto __label_7;}
00413	            }
00414	            
00415	                V5_n1 = PyArray_DIMS(V5)[1];
00416	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00417	                V5_jump1_1 = (V5_stride1) - (0);
00418	                //printf("V5_jump1_1 is:");
00419	                //std::cout << V5_jump1_1 << std::endl;
00420	                
00421	                V5_n0 = PyArray_DIMS(V5)[0];
00422	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00423	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00424	                //printf("V5_jump0_0 is:");
00425	                //std::cout << V5_jump0_0 << std::endl;
00426	                
00427	            if (V3_n0 != V5_n0)
00428	            {
00429	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00430	                   0,
00431	                   0,
00432	                   V3_n0,
00433	                   1,
00434	                   0,
00435	                   V5_n0
00436	                );
00437	                {
00438	        __failure = 7;
00439	        if (!PyErr_Occurred()) {
00440	            PyErr_SetString(PyExc_RuntimeError,
00441	                "Unexpected error in an Op's C code. "
00442	                "No Python exception was set.");
00443	            }
00444	        goto __label_7;}
00445	            }
00446	            
00447	            if (V3_n1 != V5_n1)
00448	            {
00449	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00450	                   0,
00451	                   1,
00452	                   V3_n1,
00453	                   1,
00454	                   1,
00455	                   V5_n1
00456	                );
00457	                {
00458	        __failure = 7;
00459	        if (!PyErr_Occurred()) {
00460	            PyErr_SetString(PyExc_RuntimeError,
00461	                "Unexpected error in an Op's C code. "
00462	                "No Python exception was set.");
00463	            }
00464	        goto __label_7;}
00465	            }
00466	            
00467	
00468	        npy_float64* V1_iter;
00469	        
00470	                npy_intp V1_n0;
00471	                ssize_t V1_stride0;
00472	                int V1_jump0_0;
00473	                
00474	                npy_intp V1_n1;
00475	                ssize_t V1_stride1;
00476	                int V1_jump1_1;
00477	                
00478	    {
00479	        npy_intp dims[2];
00480	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00481	        dims[0] = V3_n0;
00482	dims[1] = V3_n1;
00483	
00484	        if (!V1) {
00485	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00486	                                                    NPY_FLOAT64,
00487	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00488	        }
00489	        else {
00490	            PyArray_Dims new_dims;
00491	            new_dims.len = 2;
00492	            new_dims.ptr = dims;
00493	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00494	            if (!success) {
00495	                // If we can't resize the ndarray we have we can allocate a new one.
00496	                PyErr_Clear();
00497	                Py_XDECREF(V1);
00498	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00499	            }
00500	        }
00501	        if (!V1) {
00502	            {
00503	        __failure = 7;
00504	        if (!PyErr_Occurred()) {
00505	            PyErr_SetString(PyExc_RuntimeError,
00506	                "Unexpected error in an Op's C code. "
00507	                "No Python exception was set.");
00508	            }
00509	        goto __label_7;}
00510	        }
00511	    }
00512	    
00513	            if (PyArray_NDIM(V1) < 2) {
00514	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00515	                {
00516	        __failure = 7;
00517	        if (!PyErr_Occurred()) {
00518	            PyErr_SetString(PyExc_RuntimeError,
00519	                "Unexpected error in an Op's C code. "
00520	                "No Python exception was set.");
00521	            }
00522	        goto __label_7;}
00523	            }
00524	            
00525	                V1_n1 = PyArray_DIMS(V1)[1];
00526	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00527	                V1_jump1_1 = (V1_stride1) - (0);
00528	                //printf("V1_jump1_1 is:");
00529	                //std::cout << V1_jump1_1 << std::endl;
00530	                
00531	                V1_n0 = PyArray_DIMS(V1)[0];
00532	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00533	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00534	                //printf("V1_jump0_0 is:");
00535	                //std::cout << V1_jump0_0 << std::endl;
00536	                
00537	
00538	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00539	                
00540	                    // All output have the same size
00541	                    npy_intp n = PyArray_SIZE(V1);
00542	                    
00543	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00544	                            
00545	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00546	                            
00547	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00548	                            
00549	                    for(int i=0; i<n; i++){
00550	                        
00551	            dtype_V3& V3_i = V3_ptr[i];
00552	                            
00553	            dtype_V5& V5_i = V5_ptr[i];
00554	                            
00555	            dtype_V1& V1_i = V1_ptr[i];
00556	                            
00557	                        V1_i = V3_i + V5_i;;
00558	                    }
00559	                    
00560	            }else{
00561	                {
00562	
00563	    std::vector< std::pair<int, int> > V1_loops(2);
00564	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00565	    
00566	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00567	            
00568	        V1_loops_it->second = 0;
00569	        ++V1_loops_it;
00570	        
00571	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00572	            
00573	        V1_loops_it->second = 1;
00574	        ++V1_loops_it;
00575	        
00576	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00577	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00578	    
00579	
00580	    int init_totals[2] = {V3_n0, V3_n1};
00581	    
00582	    V1_loops_it = V1_loops.begin();
00583	    
00584	        int TOTAL_0 = init_totals[V1_loops_it->second];
00585	        ++V1_loops_it;
00586	        
00587	        int TOTAL_1 = init_totals[V1_loops_it->second];
00588	        ++V1_loops_it;
00589	        
00590	
00591	    int init_strides[3][2] = {
00592	        V3_stride0, V3_stride1, 
00593	V5_stride0, V5_stride1, 
00594	V1_stride0, V1_stride1
00595	    };
00596	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00597	    
00598	        V1_loops_rit = V1_loops.rbegin();
00599	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00600	            ++V1_loops_rit;
00601	            
00602	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00603	            ++V1_loops_rit;
00604	            
00605	        V1_loops_rit = V1_loops.rbegin();
00606	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00607	            ++V1_loops_rit;
00608	            
00609	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00610	            ++V1_loops_rit;
00611	            
00612	        V1_loops_rit = V1_loops.rbegin();
00613	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00614	            ++V1_loops_rit;
00615	            
00616	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00617	            ++V1_loops_rit;
00618	            
00619	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00620	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00621	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00622	
00623	
00624	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00625	        { // begin loop 0
00626	            
00627	            
00628	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00629	        { // begin loop 1
00630	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00631	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00632	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00633	
00634	            
00635	        {
00636	            
00637	            V1_i = V3_i + V5_i;
00638	            
00639	        }
00640	        
00641	        } // end loop 1
00642	        
00643	        } // end loop 0
00644	        
00645	}
00646	
00647	            }
00648	            __label_7:
00649	
00650	double __DUMMY_7;
00651	
00652	}
00653	__label_6:
00654	
00655	        if (V5) {
00656	            Py_XDECREF(V5);
00657	        }
00658	        
00659	    {Py_XDECREF(py_V5);}
00660	    
00661	double __DUMMY_6;
00662	
00663	}
00664	__label_4:
00665	
00666	        if (V3) {
00667	            Py_XDECREF(V3);
00668	        }
00669	        
00670	    {Py_XDECREF(py_V3);}
00671	    
00672	double __DUMMY_4;
00673	
00674	}
00675	__label_2:
00676	
00677	    if (!__failure) {
00678	      
00679	        {Py_XDECREF(py_V1);}
00680	        if (!V1) {
00681	            Py_INCREF(Py_None);
00682	            py_V1 = Py_None;
00683	        }
00684	        else if ((void*)py_V1 != (void*)V1) {
00685	            py_V1 = (PyObject*)V1;
00686	        }
00687	
00688	        {Py_XINCREF(py_V1);}
00689	
00690	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00691	            PyErr_Format(PyExc_NotImplementedError,
00692	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00693	                         " with %ld dimensions, with 3 last dims "
00694	                         "%ld, %ld, %ld"
00695	                         " and 3 last strides %ld %ld, %ld.",
00696	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00697	                         (long int) PyArray_NDIM(V1),
00698	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00699	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00700	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00701	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00702	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00703	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00704	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00705	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00706	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00707	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00708	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00709	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00710	        );
00711	            {
00712	        __failure = 2;
00713	        if (!PyErr_Occurred()) {
00714	            PyErr_SetString(PyExc_RuntimeError,
00715	                "Unexpected error in an Op's C code. "
00716	                "No Python exception was set.");
00717	            }
00718	        goto __label_2;}
00719	        }
00720	        
00721	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00722	      {Py_XINCREF(py_V1);}
00723	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00724	      {Py_XDECREF(old);}
00725	    }
00726	    
00727	        if (V1) {
00728	            Py_XDECREF(V1);
00729	        }
00730	        
00731	    {Py_XDECREF(py_V1);}
00732	    
00733	double __DUMMY_2;
00734	
00735	}
00736	
00737	            
00738	        if (__failure) {
00739	            // When there is a failure, this code puts the exception
00740	            // in __ERROR.
00741	            PyObject* err_type = NULL;
00742	            PyObject* err_msg = NULL;
00743	            PyObject* err_traceback = NULL;
00744	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00745	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00746	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00747	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00748	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00749	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00750	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00751	            PyList_SET_ITEM(__ERROR, 0, err_type);
00752	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00753	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00754	            {Py_XDECREF(old_err_type);}
00755	            {Py_XDECREF(old_err_msg);}
00756	            {Py_XDECREF(old_err_traceback);}
00757	        }
00758	        // The failure code is returned to index what code block failed.
00759	        return __failure;
00760	        
00761	        }
00762	    };
00763	    }
00764	    
00765	
00766	        static int __struct_compiled_op_0e0d286bd63abb2546678e4d6428de73_executor(__struct_compiled_op_0e0d286bd63abb2546678e4d6428de73* self) {
00767	            return self->run();
00768	        }
00769	
00770	        static void __struct_compiled_op_0e0d286bd63abb2546678e4d6428de73_destructor(void* executor, void* self) {
00771	            delete ((__struct_compiled_op_0e0d286bd63abb2546678e4d6428de73*)self);
00772	        }
00773	        
00774	//////////////////////
00775	////  Functions
00776	//////////////////////
00777	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00778	  assert(PyTuple_Check(argtuple));
00779	  if (4 != PyTuple_Size(argtuple)){ 
00780	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00781	     return NULL;
00782	  }
00783	  __struct_compiled_op_0e0d286bd63abb2546678e4d6428de73* struct_ptr = new __struct_compiled_op_0e0d286bd63abb2546678e4d6428de73();
00784	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00785	    delete struct_ptr;
00786	    return NULL;
00787	  }
00788	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_0e0d286bd63abb2546678e4d6428de73_executor), struct_ptr, __struct_compiled_op_0e0d286bd63abb2546678e4d6428de73_destructor);
00789	  return thunk; }
00790	
00791	//////////////////////
00792	////  Module init
00793	//////////////////////
00794	static PyMethodDef MyMethods[] = {
00795		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00796		{NULL, NULL, 0, NULL}
00797	};
00798	PyMODINIT_FUNC init0e0d286bd63abb2546678e4d6428de73(void){
00799	   import_array();
00800	   (void) Py_InitModule("0e0d286bd63abb2546678e4d6428de73", MyMethods);
00801	}
00802	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmprteOjm/0e0d286bd63abb2546678e4d6428de73.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmprteOjm/mod.cpp -lpython2.7
ERROR
test_grad_connectivity_matrix (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_grad_dtype_change (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_grad_duplicate_outputs (theano.scan_module.tests.test_scan.T_Scan) ... INFO (theano.gof.compilelock): Refreshing lock /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/lock_dir/lock
ok
test_grad_duplicate_outputs_connection_pattern (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_grad_find_input (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_grad_grad_mitsot_sitsot (theano.scan_module.tests.test_scan.T_Scan) ... ok
test_grad_multiple_outs (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_bb824a980e9792d133f9109a3462b1df {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_bb824a980e9792d133f9109a3462b1df() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_bb824a980e9792d133f9109a3462b1df(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                int V3_jumpx_1;
00365	                
00366	        npy_float64* V5_iter;
00367	        
00368	                int V5_jumpx_0;
00369	                
00370	                npy_intp V5_n1;
00371	                ssize_t V5_stride1;
00372	                int V5_jump1_1;
00373	                
00374	
00375	            if (PyArray_NDIM(V3) < 1) {
00376	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00377	                {
00378	        __failure = 7;
00379	        if (!PyErr_Occurred()) {
00380	            PyErr_SetString(PyExc_RuntimeError,
00381	                "Unexpected error in an Op's C code. "
00382	                "No Python exception was set.");
00383	            }
00384	        goto __label_7;}
00385	            }
00386	            
00387	                V3_jumpx_1 = -(0);
00388	                //printf("V3_jumpx_1 is:");
00389	                //std::cout << V3_jumpx_1 << std::endl;
00390	                
00391	                V3_n0 = PyArray_DIMS(V3)[0];
00392	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00393	                V3_jump0_0 = (V3_stride0) - (0);
00394	                //printf("V3_jump0_0 is:");
00395	                //std::cout << V3_jump0_0 << std::endl;
00396	                
00397	            if (PyArray_NDIM(V5) < 2) {
00398	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00399	                {
00400	        __failure = 7;
00401	        if (!PyErr_Occurred()) {
00402	            PyErr_SetString(PyExc_RuntimeError,
00403	                "Unexpected error in an Op's C code. "
00404	                "No Python exception was set.");
00405	            }
00406	        goto __label_7;}
00407	            }
00408	            
00409	                V5_n1 = PyArray_DIMS(V5)[1];
00410	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00411	                V5_jump1_1 = (V5_stride1) - (0);
00412	                //printf("V5_jump1_1 is:");
00413	                //std::cout << V5_jump1_1 << std::endl;
00414	                
00415	                V5_jumpx_0 = -(V5_n1*V5_stride1);
00416	                //printf("V5_jumpx_0 is:");
00417	                //std::cout << V5_jumpx_0 << std::endl;
00418	                
00419	
00420	        npy_float64* V1_iter;
00421	        
00422	                npy_intp V1_n0;
00423	                ssize_t V1_stride0;
00424	                int V1_jump0_0;
00425	                
00426	                npy_intp V1_n1;
00427	                ssize_t V1_stride1;
00428	                int V1_jump1_1;
00429	                
00430	    {
00431	        npy_intp dims[2];
00432	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00433	        dims[0] = V3_n0;
00434	dims[1] = V5_n1;
00435	
00436	        if (!V1) {
00437	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00438	                                                    NPY_FLOAT64,
00439	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00440	        }
00441	        else {
00442	            PyArray_Dims new_dims;
00443	            new_dims.len = 2;
00444	            new_dims.ptr = dims;
00445	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00446	            if (!success) {
00447	                // If we can't resize the ndarray we have we can allocate a new one.
00448	                PyErr_Clear();
00449	                Py_XDECREF(V1);
00450	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00451	            }
00452	        }
00453	        if (!V1) {
00454	            {
00455	        __failure = 7;
00456	        if (!PyErr_Occurred()) {
00457	            PyErr_SetString(PyExc_RuntimeError,
00458	                "Unexpected error in an Op's C code. "
00459	                "No Python exception was set.");
00460	            }
00461	        goto __label_7;}
00462	        }
00463	    }
00464	    
00465	            if (PyArray_NDIM(V1) < 2) {
00466	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00467	                {
00468	        __failure = 7;
00469	        if (!PyErr_Occurred()) {
00470	            PyErr_SetString(PyExc_RuntimeError,
00471	                "Unexpected error in an Op's C code. "
00472	                "No Python exception was set.");
00473	            }
00474	        goto __label_7;}
00475	            }
00476	            
00477	                V1_n1 = PyArray_DIMS(V1)[1];
00478	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00479	                V1_jump1_1 = (V1_stride1) - (0);
00480	                //printf("V1_jump1_1 is:");
00481	                //std::cout << V1_jump1_1 << std::endl;
00482	                
00483	                V1_n0 = PyArray_DIMS(V1)[0];
00484	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00485	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00486	                //printf("V1_jump0_0 is:");
00487	                //std::cout << V1_jump0_0 << std::endl;
00488	                
00489	{
00490	
00491	    std::vector< std::pair<int, int> > V1_loops(2);
00492	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00493	    
00494	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00495	            
00496	        V1_loops_it->second = 0;
00497	        ++V1_loops_it;
00498	        
00499	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00500	            
00501	        V1_loops_it->second = 1;
00502	        ++V1_loops_it;
00503	        
00504	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00505	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00506	    
00507	
00508	    int init_totals[2] = {V3_n0, V5_n1};
00509	    
00510	    V1_loops_it = V1_loops.begin();
00511	    
00512	        int TOTAL_0 = init_totals[V1_loops_it->second];
00513	        ++V1_loops_it;
00514	        
00515	        int TOTAL_1 = init_totals[V1_loops_it->second];
00516	        ++V1_loops_it;
00517	        
00518	
00519	    int init_strides[3][2] = {
00520	        V3_stride0, 0, 
00521	0, V5_stride1, 
00522	V1_stride0, V1_stride1
00523	    };
00524	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00525	    
00526	        V1_loops_rit = V1_loops.rbegin();
00527	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00528	            ++V1_loops_rit;
00529	            
00530	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00531	            ++V1_loops_rit;
00532	            
00533	        V1_loops_rit = V1_loops.rbegin();
00534	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00535	            ++V1_loops_rit;
00536	            
00537	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00538	            ++V1_loops_rit;
00539	            
00540	        V1_loops_rit = V1_loops.rbegin();
00541	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00542	            ++V1_loops_rit;
00543	            
00544	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00545	            ++V1_loops_rit;
00546	            
00547	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00548	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00549	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00550	
00551	
00552	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00553	        { // begin loop 0
00554	            
00555	            
00556	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00557	        { // begin loop 1
00558	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00559	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00560	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00561	
00562	            
00563	        {
00564	            
00565	            V1_i = V3_i * V5_i;
00566	            
00567	        }
00568	        
00569	        } // end loop 1
00570	        
00571	        } // end loop 0
00572	        
00573	}
00574	__label_7:
00575	
00576	double __DUMMY_7;
00577	
00578	}
00579	__label_6:
00580	
00581	        if (V5) {
00582	            Py_XDECREF(V5);
00583	        }
00584	        
00585	    {Py_XDECREF(py_V5);}
00586	    
00587	double __DUMMY_6;
00588	
00589	}
00590	__label_4:
00591	
00592	        if (V3) {
00593	            Py_XDECREF(V3);
00594	        }
00595	        
00596	    {Py_XDECREF(py_V3);}
00597	    
00598	double __DUMMY_4;
00599	
00600	}
00601	__label_2:
00602	
00603	    if (!__failure) {
00604	      
00605	        {Py_XDECREF(py_V1);}
00606	        if (!V1) {
00607	            Py_INCREF(Py_None);
00608	            py_V1 = Py_None;
00609	        }
00610	        else if ((void*)py_V1 != (void*)V1) {
00611	            py_V1 = (PyObject*)V1;
00612	        }
00613	
00614	        {Py_XINCREF(py_V1);}
00615	
00616	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00617	            PyErr_Format(PyExc_NotImplementedError,
00618	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00619	                         " with %ld dimensions, with 3 last dims "
00620	                         "%ld, %ld, %ld"
00621	                         " and 3 last strides %ld %ld, %ld.",
00622	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00623	                         (long int) PyArray_NDIM(V1),
00624	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00625	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00626	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00627	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00628	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00629	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00630	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00631	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00632	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00633	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00634	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00635	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00636	        );
00637	            {
00638	        __failure = 2;
00639	        if (!PyErr_Occurred()) {
00640	            PyErr_SetString(PyExc_RuntimeError,
00641	                "Unexpected error in an Op's C code. "
00642	                "No Python exception was set.");
00643	            }
00644	        goto __label_2;}
00645	        }
00646	        
00647	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00648	      {Py_XINCREF(py_V1);}
00649	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00650	      {Py_XDECREF(old);}
00651	    }
00652	    
00653	        if (V1) {
00654	            Py_XDECREF(V1);
00655	        }
00656	        
00657	    {Py_XDECREF(py_V1);}
00658	    
00659	double __DUMMY_2;
00660	
00661	}
00662	
00663	            
00664	        if (__failure) {
00665	            // When there is a failure, this code puts the exception
00666	            // in __ERROR.
00667	            PyObject* err_type = NULL;
00668	            PyObject* err_msg = NULL;
00669	            PyObject* err_traceback = NULL;
00670	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00671	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00672	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00673	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00674	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00675	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00676	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00677	            PyList_SET_ITEM(__ERROR, 0, err_type);
00678	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00679	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00680	            {Py_XDECREF(old_err_type);}
00681	            {Py_XDECREF(old_err_msg);}
00682	            {Py_XDECREF(old_err_traceback);}
00683	        }
00684	        // The failure code is returned to index what code block failed.
00685	        return __failure;
00686	        
00687	        }
00688	    };
00689	    }
00690	    
00691	
00692	        static int __struct_compiled_op_bb824a980e9792d133f9109a3462b1df_executor(__struct_compiled_op_bb824a980e9792d133f9109a3462b1df* self) {
00693	            return self->run();
00694	        }
00695	
00696	        static void __struct_compiled_op_bb824a980e9792d133f9109a3462b1df_destructor(void* executor, void* self) {
00697	            delete ((__struct_compiled_op_bb824a980e9792d133f9109a3462b1df*)self);
00698	        }
00699	        
00700	//////////////////////
00701	////  Functions
00702	//////////////////////
00703	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00704	  assert(PyTuple_Check(argtuple));
00705	  if (4 != PyTuple_Size(argtuple)){ 
00706	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00707	     return NULL;
00708	  }
00709	  __struct_compiled_op_bb824a980e9792d133f9109a3462b1df* struct_ptr = new __struct_compiled_op_bb824a980e9792d133f9109a3462b1df();
00710	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00711	    delete struct_ptr;
00712	    return NULL;
00713	  }
00714	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_bb824a980e9792d133f9109a3462b1df_executor), struct_ptr, __struct_compiled_op_bb824a980e9792d133f9109a3462b1df_destructor);
00715	  return thunk; }
00716	
00717	//////////////////////
00718	////  Module init
00719	//////////////////////
00720	static PyMethodDef MyMethods[] = {
00721		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00722		{NULL, NULL, 0, NULL}
00723	};
00724	PyMODINIT_FUNC initbb824a980e9792d133f9109a3462b1df(void){
00725	   import_array();
00726	   (void) Py_InitModule("bb824a980e9792d133f9109a3462b1df", MyMethods);
00727	}
00728	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmptawEBd/bb824a980e9792d133f9109a3462b1df.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmptawEBd/mod.cpp -lpython2.7
ERROR
test_grad_multiple_outs_some_disconnected (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                int V3_jumpx_0;
00361	                
00362	                int V3_jumpx_1;
00363	                
00364	        npy_float64* V5_iter;
00365	        
00366	                int V5_jumpx_0;
00367	                
00368	                int V5_jumpx_1;
00369	                
00370	
00371	                V3_jumpx_1 = -(0);
00372	                //printf("V3_jumpx_1 is:");
00373	                //std::cout << V3_jumpx_1 << std::endl;
00374	                
00375	                V3_jumpx_0 = -(0);
00376	                //printf("V3_jumpx_0 is:");
00377	                //std::cout << V3_jumpx_0 << std::endl;
00378	                
00379	                V5_jumpx_1 = -(0);
00380	                //printf("V5_jumpx_1 is:");
00381	                //std::cout << V5_jumpx_1 << std::endl;
00382	                
00383	                V5_jumpx_0 = -(0);
00384	                //printf("V5_jumpx_0 is:");
00385	                //std::cout << V5_jumpx_0 << std::endl;
00386	                
00387	
00388	        npy_float64* V1_iter;
00389	        
00390	                npy_intp V1_n0;
00391	                ssize_t V1_stride0;
00392	                int V1_jump0_0;
00393	                
00394	                npy_intp V1_n1;
00395	                ssize_t V1_stride1;
00396	                int V1_jump1_1;
00397	                
00398	    {
00399	        npy_intp dims[2];
00400	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00401	        dims[0] = 1;
00402	dims[1] = 1;
00403	
00404	        if (!V1) {
00405	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00406	                                                    NPY_FLOAT64,
00407	                                                    0);
00408	        }
00409	        else {
00410	            PyArray_Dims new_dims;
00411	            new_dims.len = 2;
00412	            new_dims.ptr = dims;
00413	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00414	            if (!success) {
00415	                // If we can't resize the ndarray we have we can allocate a new one.
00416	                PyErr_Clear();
00417	                Py_XDECREF(V1);
00418	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00419	            }
00420	        }
00421	        if (!V1) {
00422	            {
00423	        __failure = 7;
00424	        if (!PyErr_Occurred()) {
00425	            PyErr_SetString(PyExc_RuntimeError,
00426	                "Unexpected error in an Op's C code. "
00427	                "No Python exception was set.");
00428	            }
00429	        goto __label_7;}
00430	        }
00431	    }
00432	    
00433	            if (PyArray_NDIM(V1) < 2) {
00434	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00435	                {
00436	        __failure = 7;
00437	        if (!PyErr_Occurred()) {
00438	            PyErr_SetString(PyExc_RuntimeError,
00439	                "Unexpected error in an Op's C code. "
00440	                "No Python exception was set.");
00441	            }
00442	        goto __label_7;}
00443	            }
00444	            
00445	                V1_n1 = PyArray_DIMS(V1)[1];
00446	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00447	                V1_jump1_1 = (V1_stride1) - (0);
00448	                //printf("V1_jump1_1 is:");
00449	                //std::cout << V1_jump1_1 << std::endl;
00450	                
00451	                V1_n0 = PyArray_DIMS(V1)[0];
00452	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00453	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00454	                //printf("V1_jump0_0 is:");
00455	                //std::cout << V1_jump0_0 << std::endl;
00456	                
00457	{
00458	
00459	    std::vector< std::pair<int, int> > V1_loops(2);
00460	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00461	    
00462	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00463	            
00464	        V1_loops_it->second = 0;
00465	        ++V1_loops_it;
00466	        
00467	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00468	            
00469	        V1_loops_it->second = 1;
00470	        ++V1_loops_it;
00471	        
00472	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00473	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00474	    
00475	
00476	    int init_totals[2] = {V1_n0, V1_n1};
00477	    
00478	    V1_loops_it = V1_loops.begin();
00479	    
00480	        int TOTAL_0 = init_totals[V1_loops_it->second];
00481	        ++V1_loops_it;
00482	        
00483	        int TOTAL_1 = init_totals[V1_loops_it->second];
00484	        ++V1_loops_it;
00485	        
00486	
00487	    int init_strides[3][2] = {
00488	        0, 0, 
00489	0, 0, 
00490	V1_stride0, V1_stride1
00491	    };
00492	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00493	    
00494	        V1_loops_rit = V1_loops.rbegin();
00495	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00496	            ++V1_loops_rit;
00497	            
00498	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00499	            ++V1_loops_rit;
00500	            
00501	        V1_loops_rit = V1_loops.rbegin();
00502	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00503	            ++V1_loops_rit;
00504	            
00505	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00506	            ++V1_loops_rit;
00507	            
00508	        V1_loops_rit = V1_loops.rbegin();
00509	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00510	            ++V1_loops_rit;
00511	            
00512	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00513	            ++V1_loops_rit;
00514	            
00515	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00516	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00517	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00518	
00519	
00520	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00521	        { // begin loop 0
00522	            
00523	            
00524	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00525	        { // begin loop 1
00526	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00527	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00528	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00529	
00530	            
00531	        {
00532	            
00533	            V1_i = V3_i * V5_i;
00534	            
00535	        }
00536	        
00537	        } // end loop 1
00538	        
00539	        } // end loop 0
00540	        
00541	}
00542	__label_7:
00543	
00544	double __DUMMY_7;
00545	
00546	}
00547	__label_6:
00548	
00549	        if (V5) {
00550	            Py_XDECREF(V5);
00551	        }
00552	        
00553	    {Py_XDECREF(py_V5);}
00554	    
00555	double __DUMMY_6;
00556	
00557	}
00558	__label_4:
00559	
00560	        if (V3) {
00561	            Py_XDECREF(V3);
00562	        }
00563	        
00564	    {Py_XDECREF(py_V3);}
00565	    
00566	double __DUMMY_4;
00567	
00568	}
00569	__label_2:
00570	
00571	    if (!__failure) {
00572	      
00573	        {Py_XDECREF(py_V1);}
00574	        if (!V1) {
00575	            Py_INCREF(Py_None);
00576	            py_V1 = Py_None;
00577	        }
00578	        else if ((void*)py_V1 != (void*)V1) {
00579	            py_V1 = (PyObject*)V1;
00580	        }
00581	
00582	        {Py_XINCREF(py_V1);}
00583	
00584	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00585	            PyErr_Format(PyExc_NotImplementedError,
00586	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00587	                         " with %ld dimensions, with 3 last dims "
00588	                         "%ld, %ld, %ld"
00589	                         " and 3 last strides %ld %ld, %ld.",
00590	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00591	                         (long int) PyArray_NDIM(V1),
00592	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00593	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00594	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00595	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00596	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00597	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00598	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00599	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00600	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00601	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00602	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00603	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00604	        );
00605	            {
00606	        __failure = 2;
00607	        if (!PyErr_Occurred()) {
00608	            PyErr_SetString(PyExc_RuntimeError,
00609	                "Unexpected error in an Op's C code. "
00610	                "No Python exception was set.");
00611	            }
00612	        goto __label_2;}
00613	        }
00614	        
00615	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00616	      {Py_XINCREF(py_V1);}
00617	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00618	      {Py_XDECREF(old);}
00619	    }
00620	    
00621	        if (V1) {
00622	            Py_XDECREF(V1);
00623	        }
00624	        
00625	    {Py_XDECREF(py_V1);}
00626	    
00627	double __DUMMY_2;
00628	
00629	}
00630	
00631	            
00632	        if (__failure) {
00633	            // When there is a failure, this code puts the exception
00634	            // in __ERROR.
00635	            PyObject* err_type = NULL;
00636	            PyObject* err_msg = NULL;
00637	            PyObject* err_traceback = NULL;
00638	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00639	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00640	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00641	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00642	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00643	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00644	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00645	            PyList_SET_ITEM(__ERROR, 0, err_type);
00646	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00647	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00648	            {Py_XDECREF(old_err_type);}
00649	            {Py_XDECREF(old_err_msg);}
00650	            {Py_XDECREF(old_err_traceback);}
00651	        }
00652	        // The failure code is returned to index what code block failed.
00653	        return __failure;
00654	        
00655	        }
00656	    };
00657	    }
00658	    
00659	
00660	        static int __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39_executor(__struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39* self) {
00661	            return self->run();
00662	        }
00663	
00664	        static void __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39_destructor(void* executor, void* self) {
00665	            delete ((__struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39*)self);
00666	        }
00667	        
00668	//////////////////////
00669	////  Functions
00670	//////////////////////
00671	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00672	  assert(PyTuple_Check(argtuple));
00673	  if (4 != PyTuple_Size(argtuple)){ 
00674	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00675	     return NULL;
00676	  }
00677	  __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39* struct_ptr = new __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39();
00678	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00679	    delete struct_ptr;
00680	    return NULL;
00681	  }
00682	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39_executor), struct_ptr, __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39_destructor);
00683	  return thunk; }
00684	
00685	//////////////////////
00686	////  Module init
00687	//////////////////////
00688	static PyMethodDef MyMethods[] = {
00689		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00690		{NULL, NULL, 0, NULL}
00691	};
00692	PyMODINIT_FUNC initca6ae3ee049bf28e6dfdeb5d8d128a39(void){
00693	   import_array();
00694	   (void) Py_InitModule("ca6ae3ee049bf28e6dfdeb5d8d128a39", MyMethods);
00695	}
00696	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpLpD9nS/ca6ae3ee049bf28e6dfdeb5d8d128a39.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpLpD9nS/mod.cpp -lpython2.7
ERROR
test_grad_multiple_outs_some_disconnected_2 (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                int V3_jumpx_0;
00361	                
00362	                int V3_jumpx_1;
00363	                
00364	        npy_float64* V5_iter;
00365	        
00366	                int V5_jumpx_0;
00367	                
00368	                int V5_jumpx_1;
00369	                
00370	
00371	                V3_jumpx_1 = -(0);
00372	                //printf("V3_jumpx_1 is:");
00373	                //std::cout << V3_jumpx_1 << std::endl;
00374	                
00375	                V3_jumpx_0 = -(0);
00376	                //printf("V3_jumpx_0 is:");
00377	                //std::cout << V3_jumpx_0 << std::endl;
00378	                
00379	                V5_jumpx_1 = -(0);
00380	                //printf("V5_jumpx_1 is:");
00381	                //std::cout << V5_jumpx_1 << std::endl;
00382	                
00383	                V5_jumpx_0 = -(0);
00384	                //printf("V5_jumpx_0 is:");
00385	                //std::cout << V5_jumpx_0 << std::endl;
00386	                
00387	
00388	        npy_float64* V1_iter;
00389	        
00390	                npy_intp V1_n0;
00391	                ssize_t V1_stride0;
00392	                int V1_jump0_0;
00393	                
00394	                npy_intp V1_n1;
00395	                ssize_t V1_stride1;
00396	                int V1_jump1_1;
00397	                
00398	    {
00399	        npy_intp dims[2];
00400	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00401	        dims[0] = 1;
00402	dims[1] = 1;
00403	
00404	        if (!V1) {
00405	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00406	                                                    NPY_FLOAT64,
00407	                                                    0);
00408	        }
00409	        else {
00410	            PyArray_Dims new_dims;
00411	            new_dims.len = 2;
00412	            new_dims.ptr = dims;
00413	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00414	            if (!success) {
00415	                // If we can't resize the ndarray we have we can allocate a new one.
00416	                PyErr_Clear();
00417	                Py_XDECREF(V1);
00418	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00419	            }
00420	        }
00421	        if (!V1) {
00422	            {
00423	        __failure = 7;
00424	        if (!PyErr_Occurred()) {
00425	            PyErr_SetString(PyExc_RuntimeError,
00426	                "Unexpected error in an Op's C code. "
00427	                "No Python exception was set.");
00428	            }
00429	        goto __label_7;}
00430	        }
00431	    }
00432	    
00433	            if (PyArray_NDIM(V1) < 2) {
00434	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00435	                {
00436	        __failure = 7;
00437	        if (!PyErr_Occurred()) {
00438	            PyErr_SetString(PyExc_RuntimeError,
00439	                "Unexpected error in an Op's C code. "
00440	                "No Python exception was set.");
00441	            }
00442	        goto __label_7;}
00443	            }
00444	            
00445	                V1_n1 = PyArray_DIMS(V1)[1];
00446	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00447	                V1_jump1_1 = (V1_stride1) - (0);
00448	                //printf("V1_jump1_1 is:");
00449	                //std::cout << V1_jump1_1 << std::endl;
00450	                
00451	                V1_n0 = PyArray_DIMS(V1)[0];
00452	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00453	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00454	                //printf("V1_jump0_0 is:");
00455	                //std::cout << V1_jump0_0 << std::endl;
00456	                
00457	{
00458	
00459	    std::vector< std::pair<int, int> > V1_loops(2);
00460	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00461	    
00462	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00463	            
00464	        V1_loops_it->second = 0;
00465	        ++V1_loops_it;
00466	        
00467	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00468	            
00469	        V1_loops_it->second = 1;
00470	        ++V1_loops_it;
00471	        
00472	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00473	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00474	    
00475	
00476	    int init_totals[2] = {V1_n0, V1_n1};
00477	    
00478	    V1_loops_it = V1_loops.begin();
00479	    
00480	        int TOTAL_0 = init_totals[V1_loops_it->second];
00481	        ++V1_loops_it;
00482	        
00483	        int TOTAL_1 = init_totals[V1_loops_it->second];
00484	        ++V1_loops_it;
00485	        
00486	
00487	    int init_strides[3][2] = {
00488	        0, 0, 
00489	0, 0, 
00490	V1_stride0, V1_stride1
00491	    };
00492	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00493	    
00494	        V1_loops_rit = V1_loops.rbegin();
00495	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00496	            ++V1_loops_rit;
00497	            
00498	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00499	            ++V1_loops_rit;
00500	            
00501	        V1_loops_rit = V1_loops.rbegin();
00502	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00503	            ++V1_loops_rit;
00504	            
00505	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00506	            ++V1_loops_rit;
00507	            
00508	        V1_loops_rit = V1_loops.rbegin();
00509	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00510	            ++V1_loops_rit;
00511	            
00512	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00513	            ++V1_loops_rit;
00514	            
00515	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00516	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00517	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00518	
00519	
00520	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00521	        { // begin loop 0
00522	            
00523	            
00524	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00525	        { // begin loop 1
00526	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00527	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00528	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00529	
00530	            
00531	        {
00532	            
00533	            V1_i = V3_i * V5_i;
00534	            
00535	        }
00536	        
00537	        } // end loop 1
00538	        
00539	        } // end loop 0
00540	        
00541	}
00542	__label_7:
00543	
00544	double __DUMMY_7;
00545	
00546	}
00547	__label_6:
00548	
00549	        if (V5) {
00550	            Py_XDECREF(V5);
00551	        }
00552	        
00553	    {Py_XDECREF(py_V5);}
00554	    
00555	double __DUMMY_6;
00556	
00557	}
00558	__label_4:
00559	
00560	        if (V3) {
00561	            Py_XDECREF(V3);
00562	        }
00563	        
00564	    {Py_XDECREF(py_V3);}
00565	    
00566	double __DUMMY_4;
00567	
00568	}
00569	__label_2:
00570	
00571	    if (!__failure) {
00572	      
00573	        {Py_XDECREF(py_V1);}
00574	        if (!V1) {
00575	            Py_INCREF(Py_None);
00576	            py_V1 = Py_None;
00577	        }
00578	        else if ((void*)py_V1 != (void*)V1) {
00579	            py_V1 = (PyObject*)V1;
00580	        }
00581	
00582	        {Py_XINCREF(py_V1);}
00583	
00584	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00585	            PyErr_Format(PyExc_NotImplementedError,
00586	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00587	                         " with %ld dimensions, with 3 last dims "
00588	                         "%ld, %ld, %ld"
00589	                         " and 3 last strides %ld %ld, %ld.",
00590	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00591	                         (long int) PyArray_NDIM(V1),
00592	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00593	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00594	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00595	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00596	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00597	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00598	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00599	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00600	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00601	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00602	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00603	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00604	        );
00605	            {
00606	        __failure = 2;
00607	        if (!PyErr_Occurred()) {
00608	            PyErr_SetString(PyExc_RuntimeError,
00609	                "Unexpected error in an Op's C code. "
00610	                "No Python exception was set.");
00611	            }
00612	        goto __label_2;}
00613	        }
00614	        
00615	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00616	      {Py_XINCREF(py_V1);}
00617	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00618	      {Py_XDECREF(old);}
00619	    }
00620	    
00621	        if (V1) {
00622	            Py_XDECREF(V1);
00623	        }
00624	        
00625	    {Py_XDECREF(py_V1);}
00626	    
00627	double __DUMMY_2;
00628	
00629	}
00630	
00631	            
00632	        if (__failure) {
00633	            // When there is a failure, this code puts the exception
00634	            // in __ERROR.
00635	            PyObject* err_type = NULL;
00636	            PyObject* err_msg = NULL;
00637	            PyObject* err_traceback = NULL;
00638	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00639	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00640	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00641	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00642	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00643	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00644	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00645	            PyList_SET_ITEM(__ERROR, 0, err_type);
00646	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00647	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00648	            {Py_XDECREF(old_err_type);}
00649	            {Py_XDECREF(old_err_msg);}
00650	            {Py_XDECREF(old_err_traceback);}
00651	        }
00652	        // The failure code is returned to index what code block failed.
00653	        return __failure;
00654	        
00655	        }
00656	    };
00657	    }
00658	    
00659	
00660	        static int __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39_executor(__struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39* self) {
00661	            return self->run();
00662	        }
00663	
00664	        static void __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39_destructor(void* executor, void* self) {
00665	            delete ((__struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39*)self);
00666	        }
00667	        
00668	//////////////////////
00669	////  Functions
00670	//////////////////////
00671	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00672	  assert(PyTuple_Check(argtuple));
00673	  if (4 != PyTuple_Size(argtuple)){ 
00674	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00675	     return NULL;
00676	  }
00677	  __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39* struct_ptr = new __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39();
00678	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00679	    delete struct_ptr;
00680	    return NULL;
00681	  }
00682	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39_executor), struct_ptr, __struct_compiled_op_ca6ae3ee049bf28e6dfdeb5d8d128a39_destructor);
00683	  return thunk; }
00684	
00685	//////////////////////
00686	////  Module init
00687	//////////////////////
00688	static PyMethodDef MyMethods[] = {
00689		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00690		{NULL, NULL, 0, NULL}
00691	};
00692	PyMODINIT_FUNC initca6ae3ee049bf28e6dfdeb5d8d128a39(void){
00693	   import_array();
00694	   (void) Py_InitModule("ca6ae3ee049bf28e6dfdeb5d8d128a39", MyMethods);
00695	}
00696	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpvWjQkF/ca6ae3ee049bf28e6dfdeb5d8d128a39.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpvWjQkF/mod.cpp -lpython2.7
ERROR
test_grad_multiple_outs_some_truncate (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_00ddd87b3207a941dda892013e5f4775 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_00ddd87b3207a941dda892013e5f4775() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_00ddd87b3207a941dda892013e5f4775(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float64* V5_iter;
00369	        
00370	                npy_intp V5_n0;
00371	                ssize_t V5_stride0;
00372	                int V5_jump0_0;
00373	                
00374	                npy_intp V5_n1;
00375	                ssize_t V5_stride1;
00376	                int V5_jump1_1;
00377	                
00378	
00379	            if (PyArray_NDIM(V3) < 2) {
00380	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00381	                {
00382	        __failure = 7;
00383	        if (!PyErr_Occurred()) {
00384	            PyErr_SetString(PyExc_RuntimeError,
00385	                "Unexpected error in an Op's C code. "
00386	                "No Python exception was set.");
00387	            }
00388	        goto __label_7;}
00389	            }
00390	            
00391	                V3_n1 = PyArray_DIMS(V3)[1];
00392	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00393	                V3_jump1_1 = (V3_stride1) - (0);
00394	                //printf("V3_jump1_1 is:");
00395	                //std::cout << V3_jump1_1 << std::endl;
00396	                
00397	                V3_n0 = PyArray_DIMS(V3)[0];
00398	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00399	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00400	                //printf("V3_jump0_0 is:");
00401	                //std::cout << V3_jump0_0 << std::endl;
00402	                
00403	            if (PyArray_NDIM(V5) < 2) {
00404	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00405	                {
00406	        __failure = 7;
00407	        if (!PyErr_Occurred()) {
00408	            PyErr_SetString(PyExc_RuntimeError,
00409	                "Unexpected error in an Op's C code. "
00410	                "No Python exception was set.");
00411	            }
00412	        goto __label_7;}
00413	            }
00414	            
00415	                V5_n1 = PyArray_DIMS(V5)[1];
00416	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00417	                V5_jump1_1 = (V5_stride1) - (0);
00418	                //printf("V5_jump1_1 is:");
00419	                //std::cout << V5_jump1_1 << std::endl;
00420	                
00421	                V5_n0 = PyArray_DIMS(V5)[0];
00422	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00423	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00424	                //printf("V5_jump0_0 is:");
00425	                //std::cout << V5_jump0_0 << std::endl;
00426	                
00427	            if (V3_n0 != V5_n0)
00428	            {
00429	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00430	                   0,
00431	                   0,
00432	                   V3_n0,
00433	                   1,
00434	                   0,
00435	                   V5_n0
00436	                );
00437	                {
00438	        __failure = 7;
00439	        if (!PyErr_Occurred()) {
00440	            PyErr_SetString(PyExc_RuntimeError,
00441	                "Unexpected error in an Op's C code. "
00442	                "No Python exception was set.");
00443	            }
00444	        goto __label_7;}
00445	            }
00446	            
00447	            if (V3_n1 != V5_n1)
00448	            {
00449	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00450	                   0,
00451	                   1,
00452	                   V3_n1,
00453	                   1,
00454	                   1,
00455	                   V5_n1
00456	                );
00457	                {
00458	        __failure = 7;
00459	        if (!PyErr_Occurred()) {
00460	            PyErr_SetString(PyExc_RuntimeError,
00461	                "Unexpected error in an Op's C code. "
00462	                "No Python exception was set.");
00463	            }
00464	        goto __label_7;}
00465	            }
00466	            
00467	
00468	            if (V1) {
00469	                Py_XDECREF(V1);
00470	            }
00471	            V1 = V3;
00472	            Py_XINCREF(V1);
00473	            
00474	
00475	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00476	                
00477	                    // All output have the same size
00478	                    npy_intp n = PyArray_SIZE(V1);
00479	                    
00480	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00481	                            
00482	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00483	                            
00484	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00485	                            
00486	                    for(int i=0; i<n; i++){
00487	                        
00488	            dtype_V3& V3_i = V3_ptr[i];
00489	                            
00490	            dtype_V5& V5_i = V5_ptr[i];
00491	                            
00492	            dtype_V1& V1_i = V1_ptr[i];
00493	                            
00494	                        V1_i = V3_i * V5_i;;
00495	                    }
00496	                    
00497	            }else{
00498	                {
00499	
00500	    std::vector< std::pair<int, int> > V3_loops(2);
00501	    std::vector< std::pair<int, int> >::iterator V3_loops_it = V3_loops.begin();
00502	    
00503	            V3_loops_it->first = abs(PyArray_STRIDES(V3)[0]);
00504	            
00505	        V3_loops_it->second = 0;
00506	        ++V3_loops_it;
00507	        
00508	            V3_loops_it->first = abs(PyArray_STRIDES(V3)[1]);
00509	            
00510	        V3_loops_it->second = 1;
00511	        ++V3_loops_it;
00512	        
00513	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00514	    std::sort(V3_loops.rbegin(), V3_loops.rend());
00515	    
00516	
00517	    int init_totals[2] = {V3_n0, V3_n1};
00518	    
00519	    V3_loops_it = V3_loops.begin();
00520	    
00521	        int TOTAL_0 = init_totals[V3_loops_it->second];
00522	        ++V3_loops_it;
00523	        
00524	        int TOTAL_1 = init_totals[V3_loops_it->second];
00525	        ++V3_loops_it;
00526	        
00527	
00528	    int init_strides[2][2] = {
00529	        V3_stride0, V3_stride1, 
00530	V5_stride0, V5_stride1
00531	    };
00532	    std::vector< std::pair<int, int> >::reverse_iterator V3_loops_rit;
00533	    
00534	        V3_loops_rit = V3_loops.rbegin();
00535	            int V3_stride_l1 = init_strides[0][V3_loops_rit->second];
00536	            ++V3_loops_rit;
00537	            
00538	            int V3_stride_l0 = init_strides[0][V3_loops_rit->second];
00539	            ++V3_loops_rit;
00540	            
00541	        V3_loops_rit = V3_loops.rbegin();
00542	            int V5_stride_l1 = init_strides[1][V3_loops_rit->second];
00543	            ++V3_loops_rit;
00544	            
00545	            int V5_stride_l0 = init_strides[1][V3_loops_rit->second];
00546	            ++V3_loops_rit;
00547	            
00548	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00549	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00550	
00551	
00552	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00553	        { // begin loop 0
00554	            
00555	            
00556	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00557	        { // begin loop 1
00558	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00559	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00560	
00561	            
00562	        {
00563	            #define V1_i V3_i
00564	
00565	            V1_i = V3_i * V5_i;
00566	            #undef V1_i
00567	
00568	        }
00569	        
00570	        } // end loop 1
00571	        
00572	        } // end loop 0
00573	        
00574	}
00575	
00576	            }
00577	            __label_7:
00578	
00579	double __DUMMY_7;
00580	
00581	}
00582	__label_6:
00583	
00584	        if (V5) {
00585	            Py_XDECREF(V5);
00586	        }
00587	        
00588	    {Py_XDECREF(py_V5);}
00589	    
00590	double __DUMMY_6;
00591	
00592	}
00593	__label_4:
00594	
00595	        if (V3) {
00596	            Py_XDECREF(V3);
00597	        }
00598	        
00599	    {Py_XDECREF(py_V3);}
00600	    
00601	double __DUMMY_4;
00602	
00603	}
00604	__label_2:
00605	
00606	    if (!__failure) {
00607	      
00608	        {Py_XDECREF(py_V1);}
00609	        if (!V1) {
00610	            Py_INCREF(Py_None);
00611	            py_V1 = Py_None;
00612	        }
00613	        else if ((void*)py_V1 != (void*)V1) {
00614	            py_V1 = (PyObject*)V1;
00615	        }
00616	
00617	        {Py_XINCREF(py_V1);}
00618	
00619	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00620	            PyErr_Format(PyExc_NotImplementedError,
00621	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00622	                         " with %ld dimensions, with 3 last dims "
00623	                         "%ld, %ld, %ld"
00624	                         " and 3 last strides %ld %ld, %ld.",
00625	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00626	                         (long int) PyArray_NDIM(V1),
00627	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00628	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00629	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00630	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00631	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00632	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00633	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00634	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00635	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00636	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00637	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00638	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00639	        );
00640	            {
00641	        __failure = 2;
00642	        if (!PyErr_Occurred()) {
00643	            PyErr_SetString(PyExc_RuntimeError,
00644	                "Unexpected error in an Op's C code. "
00645	                "No Python exception was set.");
00646	            }
00647	        goto __label_2;}
00648	        }
00649	        
00650	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00651	      {Py_XINCREF(py_V1);}
00652	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00653	      {Py_XDECREF(old);}
00654	    }
00655	    
00656	        if (V1) {
00657	            Py_XDECREF(V1);
00658	        }
00659	        
00660	    {Py_XDECREF(py_V1);}
00661	    
00662	double __DUMMY_2;
00663	
00664	}
00665	
00666	            
00667	        if (__failure) {
00668	            // When there is a failure, this code puts the exception
00669	            // in __ERROR.
00670	            PyObject* err_type = NULL;
00671	            PyObject* err_msg = NULL;
00672	            PyObject* err_traceback = NULL;
00673	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00674	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00675	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00676	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00677	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00678	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00679	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00680	            PyList_SET_ITEM(__ERROR, 0, err_type);
00681	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00682	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00683	            {Py_XDECREF(old_err_type);}
00684	            {Py_XDECREF(old_err_msg);}
00685	            {Py_XDECREF(old_err_traceback);}
00686	        }
00687	        // The failure code is returned to index what code block failed.
00688	        return __failure;
00689	        
00690	        }
00691	    };
00692	    }
00693	    
00694	
00695	        static int __struct_compiled_op_00ddd87b3207a941dda892013e5f4775_executor(__struct_compiled_op_00ddd87b3207a941dda892013e5f4775* self) {
00696	            return self->run();
00697	        }
00698	
00699	        static void __struct_compiled_op_00ddd87b3207a941dda892013e5f4775_destructor(void* executor, void* self) {
00700	            delete ((__struct_compiled_op_00ddd87b3207a941dda892013e5f4775*)self);
00701	        }
00702	        
00703	//////////////////////
00704	////  Functions
00705	//////////////////////
00706	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00707	  assert(PyTuple_Check(argtuple));
00708	  if (4 != PyTuple_Size(argtuple)){ 
00709	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00710	     return NULL;
00711	  }
00712	  __struct_compiled_op_00ddd87b3207a941dda892013e5f4775* struct_ptr = new __struct_compiled_op_00ddd87b3207a941dda892013e5f4775();
00713	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00714	    delete struct_ptr;
00715	    return NULL;
00716	  }
00717	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_00ddd87b3207a941dda892013e5f4775_executor), struct_ptr, __struct_compiled_op_00ddd87b3207a941dda892013e5f4775_destructor);
00718	  return thunk; }
00719	
00720	//////////////////////
00721	////  Module init
00722	//////////////////////
00723	static PyMethodDef MyMethods[] = {
00724		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00725		{NULL, NULL, 0, NULL}
00726	};
00727	PyMODINIT_FUNC init00ddd87b3207a941dda892013e5f4775(void){
00728	   import_array();
00729	   (void) Py_InitModule("00ddd87b3207a941dda892013e5f4775", MyMethods);
00730	}
00731	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpOYKAHH/00ddd87b3207a941dda892013e5f4775.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpOYKAHH/mod.cpp -lpython2.7
ERROR
test_grad_multiple_outs_some_uncomputable (theano.scan_module.tests.test_scan.T_Scan) ... INFO (theano.gof.compilelock): Refreshing lock /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/lock_dir/lock
00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_e862cca780673b33a636e17eeff8569e {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V1;
00019	        
00020	
00021	        __struct_compiled_op_e862cca780673b33a636e17eeff8569e() {
00022	            // This is only somewhat safe because we:
00023	            //  1) Are not a virtual class
00024	            //  2) Do not use any virtual classes in the members
00025	            //  3) Deal with mostly POD and pointers
00026	
00027	            // If this changes, we would have to revise this, but for
00028	            // now I am tired of chasing segfaults because
00029	            // initialization code had an error and some pointer has
00030	            // a junk value.
00031	            memset(this, 0, sizeof(*this));
00032	        }
00033	        ~__struct_compiled_op_e862cca780673b33a636e17eeff8569e(void) {
00034	            cleanup();
00035	        }
00036	
00037	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V1) {
00038	            Py_XINCREF(storage_V3);
00039	Py_XINCREF(storage_V1);
00040	            this->storage_V3 = storage_V3;
00041	this->storage_V1 = storage_V1;
00042	            
00043	
00044	
00045	
00046	            this->__ERROR = __ERROR;
00047	            return 0;
00048	        }
00049	        void cleanup(void) {
00050	            __label_1:
00051	
00052	double __DUMMY_1;
00053	__label_3:
00054	
00055	double __DUMMY_3;
00056	__label_6:
00057	
00058	double __DUMMY_6;
00059	
00060	            Py_XDECREF(this->storage_V3);
00061	Py_XDECREF(this->storage_V1);
00062	        }
00063	        int run(void) {
00064	            int __failure = 0;
00065	            
00066	    PyObject* py_V1;
00067	    
00068	        PyArrayObject* V1;
00069	        
00070	            typedef npy_float64 dtype_V1;
00071	            
00072	    PyObject* py_V3;
00073	    
00074	        PyArrayObject* V3;
00075	        
00076	            typedef npy_int32 dtype_V3;
00077	            
00078	{
00079	
00080	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00081	    {Py_XINCREF(py_V1);}
00082	    
00083	        if (py_V1 == Py_None)
00084	        {
00085	            
00086	        V1 = NULL;
00087	        
00088	        }
00089	        else
00090	        {
00091	            
00092	            V1 = NULL;
00093	            if (py_V1 == Py_None) {
00094	                // We can either fail here or set V1 to NULL and rely on Ops
00095	                // using tensors to handle the NULL case, but if they fail to do so
00096	                // they'll end up with nasty segfaults, so this is public service.
00097	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00098	                {
00099	        __failure = 2;
00100	        if (!PyErr_Occurred()) {
00101	            PyErr_SetString(PyExc_RuntimeError,
00102	                "Unexpected error in an Op's C code. "
00103	                "No Python exception was set.");
00104	            }
00105	        goto __label_2;}
00106	            }
00107	            if (!PyArray_Check(py_V1)) {
00108	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00109	                {
00110	        __failure = 2;
00111	        if (!PyErr_Occurred()) {
00112	            PyErr_SetString(PyExc_RuntimeError,
00113	                "Unexpected error in an Op's C code. "
00114	                "No Python exception was set.");
00115	            }
00116	        goto __label_2;}
00117	            }
00118	            // We expect NPY_FLOAT64
00119	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00120	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00121	                PyErr_Format(PyExc_NotImplementedError,
00122	                             "expected an aligned array of type %ld "
00123	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00124	                             " with %ld dimensions, with 3 last dims "
00125	                             "%ld, %ld, %ld"
00126	                             " and 3 last strides %ld %ld, %ld.",
00127	                             (long int) NPY_FLOAT64,
00128	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00129	                             (long int) PyArray_NDIM(tmp),
00130	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00131	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00132	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00133	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00134	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00135	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00136	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00137	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00138	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00139	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00140	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00141	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00142	            );
00143	                {
00144	        __failure = 2;
00145	        if (!PyErr_Occurred()) {
00146	            PyErr_SetString(PyExc_RuntimeError,
00147	                "Unexpected error in an Op's C code. "
00148	                "No Python exception was set.");
00149	            }
00150	        goto __label_2;}
00151	            }
00152	            // This is a TypeError to be consistent with DEBUG_MODE
00153	            // Note: DEBUG_MODE also tells the name of the container
00154	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00155	                PyErr_Format(PyExc_TypeError,
00156	                             "expected type_num %d (NPY_FLOAT64) got %d",
00157	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00158	                {
00159	        __failure = 2;
00160	        if (!PyErr_Occurred()) {
00161	            PyErr_SetString(PyExc_RuntimeError,
00162	                "Unexpected error in an Op's C code. "
00163	                "No Python exception was set.");
00164	            }
00165	        goto __label_2;}
00166	            }
00167	            
00168	        V1 = (PyArrayObject*)(py_V1);
00169	        Py_XINCREF(V1);
00170	        
00171	        }
00172	        
00173	{
00174	
00175	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00176	    {Py_XINCREF(py_V3);}
00177	    
00178	            V3 = NULL;
00179	            if (py_V3 == Py_None) {
00180	                // We can either fail here or set V3 to NULL and rely on Ops
00181	                // using tensors to handle the NULL case, but if they fail to do so
00182	                // they'll end up with nasty segfaults, so this is public service.
00183	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            if (!PyArray_Check(py_V3)) {
00194	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00195	                {
00196	        __failure = 4;
00197	        if (!PyErr_Occurred()) {
00198	            PyErr_SetString(PyExc_RuntimeError,
00199	                "Unexpected error in an Op's C code. "
00200	                "No Python exception was set.");
00201	            }
00202	        goto __label_4;}
00203	            }
00204	            // We expect NPY_INT32
00205	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00206	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00207	                PyErr_Format(PyExc_NotImplementedError,
00208	                             "expected an aligned array of type %ld "
00209	                             "(NPY_INT32), got non-aligned array of type %ld"
00210	                             " with %ld dimensions, with 3 last dims "
00211	                             "%ld, %ld, %ld"
00212	                             " and 3 last strides %ld %ld, %ld.",
00213	                             (long int) NPY_INT32,
00214	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00215	                             (long int) PyArray_NDIM(tmp),
00216	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00217	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00218	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00219	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00220	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00221	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00222	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00223	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00224	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00225	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00226	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00227	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00228	            );
00229	                {
00230	        __failure = 4;
00231	        if (!PyErr_Occurred()) {
00232	            PyErr_SetString(PyExc_RuntimeError,
00233	                "Unexpected error in an Op's C code. "
00234	                "No Python exception was set.");
00235	            }
00236	        goto __label_4;}
00237	            }
00238	            // This is a TypeError to be consistent with DEBUG_MODE
00239	            // Note: DEBUG_MODE also tells the name of the container
00240	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_INT32) {
00241	                PyErr_Format(PyExc_TypeError,
00242	                             "expected type_num %d (NPY_INT32) got %d",
00243	                             NPY_INT32, PyArray_TYPE((PyArrayObject*) py_V3));
00244	                {
00245	        __failure = 4;
00246	        if (!PyErr_Occurred()) {
00247	            PyErr_SetString(PyExc_RuntimeError,
00248	                "Unexpected error in an Op's C code. "
00249	                "No Python exception was set.");
00250	            }
00251	        goto __label_4;}
00252	            }
00253	            
00254	        V3 = (PyArrayObject*)(py_V3);
00255	        Py_XINCREF(V3);
00256	        
00257	{
00258	// Op class Elemwise
00259	
00260	        npy_int32* V3_iter;
00261	        
00262	                npy_intp V3_n0;
00263	                ssize_t V3_stride0;
00264	                int V3_jump0_0;
00265	                
00266	                int V3_jumpx_1;
00267	                
00268	
00269	            if (PyArray_NDIM(V3) < 1) {
00270	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00271	                {
00272	        __failure = 5;
00273	        if (!PyErr_Occurred()) {
00274	            PyErr_SetString(PyExc_RuntimeError,
00275	                "Unexpected error in an Op's C code. "
00276	                "No Python exception was set.");
00277	            }
00278	        goto __label_5;}
00279	            }
00280	            
00281	                V3_jumpx_1 = -(0);
00282	                //printf("V3_jumpx_1 is:");
00283	                //std::cout << V3_jumpx_1 << std::endl;
00284	                
00285	                V3_n0 = PyArray_DIMS(V3)[0];
00286	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_int32);
00287	                V3_jump0_0 = (V3_stride0) - (0);
00288	                //printf("V3_jump0_0 is:");
00289	                //std::cout << V3_jump0_0 << std::endl;
00290	                
00291	
00292	        npy_float64* V1_iter;
00293	        
00294	                npy_intp V1_n0;
00295	                ssize_t V1_stride0;
00296	                int V1_jump0_0;
00297	                
00298	                npy_intp V1_n1;
00299	                ssize_t V1_stride1;
00300	                int V1_jump1_1;
00301	                
00302	    {
00303	        npy_intp dims[2];
00304	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00305	        dims[0] = V3_n0;
00306	dims[1] = 1;
00307	
00308	        if (!V1) {
00309	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00310	                                                    NPY_FLOAT64,
00311	                                                    PyArray_ISFORTRAN(V3));
00312	        }
00313	        else {
00314	            PyArray_Dims new_dims;
00315	            new_dims.len = 2;
00316	            new_dims.ptr = dims;
00317	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00318	            if (!success) {
00319	                // If we can't resize the ndarray we have we can allocate a new one.
00320	                PyErr_Clear();
00321	                Py_XDECREF(V1);
00322	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00323	            }
00324	        }
00325	        if (!V1) {
00326	            {
00327	        __failure = 5;
00328	        if (!PyErr_Occurred()) {
00329	            PyErr_SetString(PyExc_RuntimeError,
00330	                "Unexpected error in an Op's C code. "
00331	                "No Python exception was set.");
00332	            }
00333	        goto __label_5;}
00334	        }
00335	    }
00336	    
00337	            if (PyArray_NDIM(V1) < 2) {
00338	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00339	                {
00340	        __failure = 5;
00341	        if (!PyErr_Occurred()) {
00342	            PyErr_SetString(PyExc_RuntimeError,
00343	                "Unexpected error in an Op's C code. "
00344	                "No Python exception was set.");
00345	            }
00346	        goto __label_5;}
00347	            }
00348	            
00349	                V1_n1 = PyArray_DIMS(V1)[1];
00350	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00351	                V1_jump1_1 = (V1_stride1) - (0);
00352	                //printf("V1_jump1_1 is:");
00353	                //std::cout << V1_jump1_1 << std::endl;
00354	                
00355	                V1_n0 = PyArray_DIMS(V1)[0];
00356	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00357	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00358	                //printf("V1_jump0_0 is:");
00359	                //std::cout << V1_jump0_0 << std::endl;
00360	                
00361	
00362	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V1))){
00363	                
00364	                    // All output have the same size
00365	                    npy_intp n = PyArray_SIZE(V1);
00366	                    
00367	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00368	                            
00369	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00370	                            
00371	                    for(int i=0; i<n; i++){
00372	                        
00373	            dtype_V3& V3_i = V3_ptr[i];
00374	                            
00375	            dtype_V1& V1_i = V1_ptr[i];
00376	                            
00377	                        V1_i = (npy_float64)V3_i;;
00378	                    }
00379	                    
00380	            }else{
00381	                {
00382	
00383	    std::vector< std::pair<int, int> > V1_loops(2);
00384	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00385	    
00386	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00387	            
00388	        V1_loops_it->second = 0;
00389	        ++V1_loops_it;
00390	        
00391	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00392	            
00393	        V1_loops_it->second = 1;
00394	        ++V1_loops_it;
00395	        
00396	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00397	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00398	    
00399	
00400	    int init_totals[2] = {V3_n0, V1_n1};
00401	    
00402	    V1_loops_it = V1_loops.begin();
00403	    
00404	        int TOTAL_0 = init_totals[V1_loops_it->second];
00405	        ++V1_loops_it;
00406	        
00407	        int TOTAL_1 = init_totals[V1_loops_it->second];
00408	        ++V1_loops_it;
00409	        
00410	
00411	    int init_strides[2][2] = {
00412	        V3_stride0, 0, 
00413	V1_stride0, V1_stride1
00414	    };
00415	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00416	    
00417	        V1_loops_rit = V1_loops.rbegin();
00418	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00419	            ++V1_loops_rit;
00420	            
00421	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00422	            ++V1_loops_rit;
00423	            
00424	        V1_loops_rit = V1_loops.rbegin();
00425	            int V1_stride_l1 = init_strides[1][V1_loops_rit->second];
00426	            ++V1_loops_rit;
00427	            
00428	            int V1_stride_l0 = init_strides[1][V1_loops_rit->second];
00429	            ++V1_loops_rit;
00430	            
00431	V3_iter = (npy_int32*)(PyArray_DATA(V3));
00432	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00433	
00434	
00435	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00436	        { // begin loop 0
00437	            
00438	            
00439	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00440	        { // begin loop 1
00441	            npy_int32 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00442	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00443	
00444	            
00445	        {
00446	            
00447	            V1_i = (npy_float64)V3_i;
00448	            
00449	        }
00450	        
00451	        } // end loop 1
00452	        
00453	        } // end loop 0
00454	        
00455	}
00456	
00457	            }
00458	            __label_5:
00459	
00460	double __DUMMY_5;
00461	
00462	}
00463	__label_4:
00464	
00465	        if (V3) {
00466	            Py_XDECREF(V3);
00467	        }
00468	        
00469	    {Py_XDECREF(py_V3);}
00470	    
00471	double __DUMMY_4;
00472	
00473	}
00474	__label_2:
00475	
00476	    if (!__failure) {
00477	      
00478	        {Py_XDECREF(py_V1);}
00479	        if (!V1) {
00480	            Py_INCREF(Py_None);
00481	            py_V1 = Py_None;
00482	        }
00483	        else if ((void*)py_V1 != (void*)V1) {
00484	            py_V1 = (PyObject*)V1;
00485	        }
00486	
00487	        {Py_XINCREF(py_V1);}
00488	
00489	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00490	            PyErr_Format(PyExc_NotImplementedError,
00491	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00492	                         " with %ld dimensions, with 3 last dims "
00493	                         "%ld, %ld, %ld"
00494	                         " and 3 last strides %ld %ld, %ld.",
00495	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00496	                         (long int) PyArray_NDIM(V1),
00497	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00498	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00499	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00500	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00501	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00502	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00503	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00504	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00505	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00506	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00507	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00508	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00509	        );
00510	            {
00511	        __failure = 2;
00512	        if (!PyErr_Occurred()) {
00513	            PyErr_SetString(PyExc_RuntimeError,
00514	                "Unexpected error in an Op's C code. "
00515	                "No Python exception was set.");
00516	            }
00517	        goto __label_2;}
00518	        }
00519	        
00520	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00521	      {Py_XINCREF(py_V1);}
00522	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00523	      {Py_XDECREF(old);}
00524	    }
00525	    
00526	        if (V1) {
00527	            Py_XDECREF(V1);
00528	        }
00529	        
00530	    {Py_XDECREF(py_V1);}
00531	    
00532	double __DUMMY_2;
00533	
00534	}
00535	
00536	            
00537	        if (__failure) {
00538	            // When there is a failure, this code puts the exception
00539	            // in __ERROR.
00540	            PyObject* err_type = NULL;
00541	            PyObject* err_msg = NULL;
00542	            PyObject* err_traceback = NULL;
00543	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00544	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00545	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00546	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00547	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00548	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00549	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00550	            PyList_SET_ITEM(__ERROR, 0, err_type);
00551	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00552	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00553	            {Py_XDECREF(old_err_type);}
00554	            {Py_XDECREF(old_err_msg);}
00555	            {Py_XDECREF(old_err_traceback);}
00556	        }
00557	        // The failure code is returned to index what code block failed.
00558	        return __failure;
00559	        
00560	        }
00561	    };
00562	    }
00563	    
00564	
00565	        static int __struct_compiled_op_e862cca780673b33a636e17eeff8569e_executor(__struct_compiled_op_e862cca780673b33a636e17eeff8569e* self) {
00566	            return self->run();
00567	        }
00568	
00569	        static void __struct_compiled_op_e862cca780673b33a636e17eeff8569e_destructor(void* executor, void* self) {
00570	            delete ((__struct_compiled_op_e862cca780673b33a636e17eeff8569e*)self);
00571	        }
00572	        
00573	//////////////////////
00574	////  Functions
00575	//////////////////////
00576	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00577	  assert(PyTuple_Check(argtuple));
00578	  if (3 != PyTuple_Size(argtuple)){ 
00579	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 3, got %i", (int)PyTuple_Size(argtuple));
00580	     return NULL;
00581	  }
00582	  __struct_compiled_op_e862cca780673b33a636e17eeff8569e* struct_ptr = new __struct_compiled_op_e862cca780673b33a636e17eeff8569e();
00583	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2) ) != 0) {
00584	    delete struct_ptr;
00585	    return NULL;
00586	  }
00587	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_e862cca780673b33a636e17eeff8569e_executor), struct_ptr, __struct_compiled_op_e862cca780673b33a636e17eeff8569e_destructor);
00588	  return thunk; }
00589	
00590	//////////////////////
00591	////  Module init
00592	//////////////////////
00593	static PyMethodDef MyMethods[] = {
00594		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00595		{NULL, NULL, 0, NULL}
00596	};
00597	PyMODINIT_FUNC inite862cca780673b33a636e17eeff8569e(void){
00598	   import_array();
00599	   (void) Py_InitModule("e862cca780673b33a636e17eeff8569e", MyMethods);
00600	}
00601	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmph3nHDk/e862cca780673b33a636e17eeff8569e.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmph3nHDk/mod.cpp -lpython2.7
ERROR
test_grad_multiple_outs_taps (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V5;
00019	PyObject* storage_V1;
00020	        
00021	
00022	        __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09() {
00023	            // This is only somewhat safe because we:
00024	            //  1) Are not a virtual class
00025	            //  2) Do not use any virtual classes in the members
00026	            //  3) Deal with mostly POD and pointers
00027	
00028	            // If this changes, we would have to revise this, but for
00029	            // now I am tired of chasing segfaults because
00030	            // initialization code had an error and some pointer has
00031	            // a junk value.
00032	            memset(this, 0, sizeof(*this));
00033	        }
00034	        ~__struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09(void) {
00035	            cleanup();
00036	        }
00037	
00038	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V5, PyObject* storage_V1) {
00039	            Py_XINCREF(storage_V3);
00040	Py_XINCREF(storage_V5);
00041	Py_XINCREF(storage_V1);
00042	            this->storage_V3 = storage_V3;
00043	this->storage_V5 = storage_V5;
00044	this->storage_V1 = storage_V1;
00045	            
00046	
00047	
00048	
00049	
00050	            this->__ERROR = __ERROR;
00051	            return 0;
00052	        }
00053	        void cleanup(void) {
00054	            __label_1:
00055	
00056	double __DUMMY_1;
00057	__label_3:
00058	
00059	double __DUMMY_3;
00060	__label_5:
00061	
00062	double __DUMMY_5;
00063	__label_8:
00064	
00065	double __DUMMY_8;
00066	
00067	            Py_XDECREF(this->storage_V3);
00068	Py_XDECREF(this->storage_V5);
00069	Py_XDECREF(this->storage_V1);
00070	        }
00071	        int run(void) {
00072	            int __failure = 0;
00073	            
00074	    PyObject* py_V1;
00075	    
00076	        PyArrayObject* V1;
00077	        
00078	            typedef npy_float64 dtype_V1;
00079	            
00080	    PyObject* py_V3;
00081	    
00082	        PyArrayObject* V3;
00083	        
00084	            typedef npy_float64 dtype_V3;
00085	            
00086	    PyObject* py_V5;
00087	    
00088	        PyArrayObject* V5;
00089	        
00090	            typedef npy_float64 dtype_V5;
00091	            
00092	{
00093	
00094	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00095	    {Py_XINCREF(py_V1);}
00096	    
00097	        if (py_V1 == Py_None)
00098	        {
00099	            
00100	        V1 = NULL;
00101	        
00102	        }
00103	        else
00104	        {
00105	            
00106	            V1 = NULL;
00107	            if (py_V1 == Py_None) {
00108	                // We can either fail here or set V1 to NULL and rely on Ops
00109	                // using tensors to handle the NULL case, but if they fail to do so
00110	                // they'll end up with nasty segfaults, so this is public service.
00111	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00112	                {
00113	        __failure = 2;
00114	        if (!PyErr_Occurred()) {
00115	            PyErr_SetString(PyExc_RuntimeError,
00116	                "Unexpected error in an Op's C code. "
00117	                "No Python exception was set.");
00118	            }
00119	        goto __label_2;}
00120	            }
00121	            if (!PyArray_Check(py_V1)) {
00122	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00123	                {
00124	        __failure = 2;
00125	        if (!PyErr_Occurred()) {
00126	            PyErr_SetString(PyExc_RuntimeError,
00127	                "Unexpected error in an Op's C code. "
00128	                "No Python exception was set.");
00129	            }
00130	        goto __label_2;}
00131	            }
00132	            // We expect NPY_FLOAT64
00133	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00134	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00135	                PyErr_Format(PyExc_NotImplementedError,
00136	                             "expected an aligned array of type %ld "
00137	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00138	                             " with %ld dimensions, with 3 last dims "
00139	                             "%ld, %ld, %ld"
00140	                             " and 3 last strides %ld %ld, %ld.",
00141	                             (long int) NPY_FLOAT64,
00142	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00143	                             (long int) PyArray_NDIM(tmp),
00144	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00145	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00146	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00147	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00148	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00149	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00150	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00151	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00152	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00153	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00154	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00155	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00156	            );
00157	                {
00158	        __failure = 2;
00159	        if (!PyErr_Occurred()) {
00160	            PyErr_SetString(PyExc_RuntimeError,
00161	                "Unexpected error in an Op's C code. "
00162	                "No Python exception was set.");
00163	            }
00164	        goto __label_2;}
00165	            }
00166	            // This is a TypeError to be consistent with DEBUG_MODE
00167	            // Note: DEBUG_MODE also tells the name of the container
00168	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00169	                PyErr_Format(PyExc_TypeError,
00170	                             "expected type_num %d (NPY_FLOAT64) got %d",
00171	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00172	                {
00173	        __failure = 2;
00174	        if (!PyErr_Occurred()) {
00175	            PyErr_SetString(PyExc_RuntimeError,
00176	                "Unexpected error in an Op's C code. "
00177	                "No Python exception was set.");
00178	            }
00179	        goto __label_2;}
00180	            }
00181	            
00182	        V1 = (PyArrayObject*)(py_V1);
00183	        Py_XINCREF(V1);
00184	        
00185	        }
00186	        
00187	{
00188	
00189	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00190	    {Py_XINCREF(py_V3);}
00191	    
00192	            V3 = NULL;
00193	            if (py_V3 == Py_None) {
00194	                // We can either fail here or set V3 to NULL and rely on Ops
00195	                // using tensors to handle the NULL case, but if they fail to do so
00196	                // they'll end up with nasty segfaults, so this is public service.
00197	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00198	                {
00199	        __failure = 4;
00200	        if (!PyErr_Occurred()) {
00201	            PyErr_SetString(PyExc_RuntimeError,
00202	                "Unexpected error in an Op's C code. "
00203	                "No Python exception was set.");
00204	            }
00205	        goto __label_4;}
00206	            }
00207	            if (!PyArray_Check(py_V3)) {
00208	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00209	                {
00210	        __failure = 4;
00211	        if (!PyErr_Occurred()) {
00212	            PyErr_SetString(PyExc_RuntimeError,
00213	                "Unexpected error in an Op's C code. "
00214	                "No Python exception was set.");
00215	            }
00216	        goto __label_4;}
00217	            }
00218	            // We expect NPY_FLOAT64
00219	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00220	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00221	                PyErr_Format(PyExc_NotImplementedError,
00222	                             "expected an aligned array of type %ld "
00223	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00224	                             " with %ld dimensions, with 3 last dims "
00225	                             "%ld, %ld, %ld"
00226	                             " and 3 last strides %ld %ld, %ld.",
00227	                             (long int) NPY_FLOAT64,
00228	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00229	                             (long int) PyArray_NDIM(tmp),
00230	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00231	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00232	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00233	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00234	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00235	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00236	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00237	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00238	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00239	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00240	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00241	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00242	            );
00243	                {
00244	        __failure = 4;
00245	        if (!PyErr_Occurred()) {
00246	            PyErr_SetString(PyExc_RuntimeError,
00247	                "Unexpected error in an Op's C code. "
00248	                "No Python exception was set.");
00249	            }
00250	        goto __label_4;}
00251	            }
00252	            // This is a TypeError to be consistent with DEBUG_MODE
00253	            // Note: DEBUG_MODE also tells the name of the container
00254	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT64) {
00255	                PyErr_Format(PyExc_TypeError,
00256	                             "expected type_num %d (NPY_FLOAT64) got %d",
00257	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V3));
00258	                {
00259	        __failure = 4;
00260	        if (!PyErr_Occurred()) {
00261	            PyErr_SetString(PyExc_RuntimeError,
00262	                "Unexpected error in an Op's C code. "
00263	                "No Python exception was set.");
00264	            }
00265	        goto __label_4;}
00266	            }
00267	            
00268	        V3 = (PyArrayObject*)(py_V3);
00269	        Py_XINCREF(V3);
00270	        
00271	{
00272	
00273	    py_V5 = PyList_GET_ITEM(storage_V5, 0);
00274	    {Py_XINCREF(py_V5);}
00275	    
00276	            V5 = NULL;
00277	            if (py_V5 == Py_None) {
00278	                // We can either fail here or set V5 to NULL and rely on Ops
00279	                // using tensors to handle the NULL case, but if they fail to do so
00280	                // they'll end up with nasty segfaults, so this is public service.
00281	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00282	                {
00283	        __failure = 6;
00284	        if (!PyErr_Occurred()) {
00285	            PyErr_SetString(PyExc_RuntimeError,
00286	                "Unexpected error in an Op's C code. "
00287	                "No Python exception was set.");
00288	            }
00289	        goto __label_6;}
00290	            }
00291	            if (!PyArray_Check(py_V5)) {
00292	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00293	                {
00294	        __failure = 6;
00295	        if (!PyErr_Occurred()) {
00296	            PyErr_SetString(PyExc_RuntimeError,
00297	                "Unexpected error in an Op's C code. "
00298	                "No Python exception was set.");
00299	            }
00300	        goto __label_6;}
00301	            }
00302	            // We expect NPY_FLOAT64
00303	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V5)) {
00304	                PyArrayObject * tmp = (PyArrayObject*) py_V5;
00305	                PyErr_Format(PyExc_NotImplementedError,
00306	                             "expected an aligned array of type %ld "
00307	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00308	                             " with %ld dimensions, with 3 last dims "
00309	                             "%ld, %ld, %ld"
00310	                             " and 3 last strides %ld %ld, %ld.",
00311	                             (long int) NPY_FLOAT64,
00312	                             (long int) PyArray_TYPE((PyArrayObject*) py_V5),
00313	                             (long int) PyArray_NDIM(tmp),
00314	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00315	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00316	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00317	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00318	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00319	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00320	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00321	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00322	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00323	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00324	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00325	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00326	            );
00327	                {
00328	        __failure = 6;
00329	        if (!PyErr_Occurred()) {
00330	            PyErr_SetString(PyExc_RuntimeError,
00331	                "Unexpected error in an Op's C code. "
00332	                "No Python exception was set.");
00333	            }
00334	        goto __label_6;}
00335	            }
00336	            // This is a TypeError to be consistent with DEBUG_MODE
00337	            // Note: DEBUG_MODE also tells the name of the container
00338	            if (PyArray_TYPE((PyArrayObject*) py_V5) != NPY_FLOAT64) {
00339	                PyErr_Format(PyExc_TypeError,
00340	                             "expected type_num %d (NPY_FLOAT64) got %d",
00341	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V5));
00342	                {
00343	        __failure = 6;
00344	        if (!PyErr_Occurred()) {
00345	            PyErr_SetString(PyExc_RuntimeError,
00346	                "Unexpected error in an Op's C code. "
00347	                "No Python exception was set.");
00348	            }
00349	        goto __label_6;}
00350	            }
00351	            
00352	        V5 = (PyArrayObject*)(py_V5);
00353	        Py_XINCREF(V5);
00354	        
00355	{
00356	// Op class Elemwise
00357	
00358	        npy_float64* V3_iter;
00359	        
00360	                npy_intp V3_n0;
00361	                ssize_t V3_stride0;
00362	                int V3_jump0_0;
00363	                
00364	                npy_intp V3_n1;
00365	                ssize_t V3_stride1;
00366	                int V3_jump1_1;
00367	                
00368	        npy_float64* V5_iter;
00369	        
00370	                npy_intp V5_n0;
00371	                ssize_t V5_stride0;
00372	                int V5_jump0_0;
00373	                
00374	                npy_intp V5_n1;
00375	                ssize_t V5_stride1;
00376	                int V5_jump1_1;
00377	                
00378	
00379	            if (PyArray_NDIM(V3) < 2) {
00380	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00381	                {
00382	        __failure = 7;
00383	        if (!PyErr_Occurred()) {
00384	            PyErr_SetString(PyExc_RuntimeError,
00385	                "Unexpected error in an Op's C code. "
00386	                "No Python exception was set.");
00387	            }
00388	        goto __label_7;}
00389	            }
00390	            
00391	                V3_n1 = PyArray_DIMS(V3)[1];
00392	                V3_stride1 = PyArray_STRIDES(V3)[1] / sizeof(npy_float64);
00393	                V3_jump1_1 = (V3_stride1) - (0);
00394	                //printf("V3_jump1_1 is:");
00395	                //std::cout << V3_jump1_1 << std::endl;
00396	                
00397	                V3_n0 = PyArray_DIMS(V3)[0];
00398	                V3_stride0 = PyArray_STRIDES(V3)[0] / sizeof(npy_float64);
00399	                V3_jump0_0 = (V3_stride0) - (V3_n1*V3_stride1);
00400	                //printf("V3_jump0_0 is:");
00401	                //std::cout << V3_jump0_0 << std::endl;
00402	                
00403	            if (PyArray_NDIM(V5) < 2) {
00404	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00405	                {
00406	        __failure = 7;
00407	        if (!PyErr_Occurred()) {
00408	            PyErr_SetString(PyExc_RuntimeError,
00409	                "Unexpected error in an Op's C code. "
00410	                "No Python exception was set.");
00411	            }
00412	        goto __label_7;}
00413	            }
00414	            
00415	                V5_n1 = PyArray_DIMS(V5)[1];
00416	                V5_stride1 = PyArray_STRIDES(V5)[1] / sizeof(npy_float64);
00417	                V5_jump1_1 = (V5_stride1) - (0);
00418	                //printf("V5_jump1_1 is:");
00419	                //std::cout << V5_jump1_1 << std::endl;
00420	                
00421	                V5_n0 = PyArray_DIMS(V5)[0];
00422	                V5_stride0 = PyArray_STRIDES(V5)[0] / sizeof(npy_float64);
00423	                V5_jump0_0 = (V5_stride0) - (V5_n1*V5_stride1);
00424	                //printf("V5_jump0_0 is:");
00425	                //std::cout << V5_jump0_0 << std::endl;
00426	                
00427	            if (V3_n0 != V5_n0)
00428	            {
00429	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00430	                   0,
00431	                   0,
00432	                   V3_n0,
00433	                   1,
00434	                   0,
00435	                   V5_n0
00436	                );
00437	                {
00438	        __failure = 7;
00439	        if (!PyErr_Occurred()) {
00440	            PyErr_SetString(PyExc_RuntimeError,
00441	                "Unexpected error in an Op's C code. "
00442	                "No Python exception was set.");
00443	            }
00444	        goto __label_7;}
00445	            }
00446	            
00447	            if (V3_n1 != V5_n1)
00448	            {
00449	                PyErr_Format(PyExc_ValueError, "Input dimension mis-match. (input[%i].shape[%i] = %i, input[%i].shape[%i] = %i)",
00450	                   0,
00451	                   1,
00452	                   V3_n1,
00453	                   1,
00454	                   1,
00455	                   V5_n1
00456	                );
00457	                {
00458	        __failure = 7;
00459	        if (!PyErr_Occurred()) {
00460	            PyErr_SetString(PyExc_RuntimeError,
00461	                "Unexpected error in an Op's C code. "
00462	                "No Python exception was set.");
00463	            }
00464	        goto __label_7;}
00465	            }
00466	            
00467	
00468	        npy_float64* V1_iter;
00469	        
00470	                npy_intp V1_n0;
00471	                ssize_t V1_stride0;
00472	                int V1_jump0_0;
00473	                
00474	                npy_intp V1_n1;
00475	                ssize_t V1_stride1;
00476	                int V1_jump1_1;
00477	                
00478	    {
00479	        npy_intp dims[2];
00480	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00481	        dims[0] = V3_n0;
00482	dims[1] = V3_n1;
00483	
00484	        if (!V1) {
00485	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00486	                                                    NPY_FLOAT64,
00487	                                                    PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5));
00488	        }
00489	        else {
00490	            PyArray_Dims new_dims;
00491	            new_dims.len = 2;
00492	            new_dims.ptr = dims;
00493	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00494	            if (!success) {
00495	                // If we can't resize the ndarray we have we can allocate a new one.
00496	                PyErr_Clear();
00497	                Py_XDECREF(V1);
00498	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00499	            }
00500	        }
00501	        if (!V1) {
00502	            {
00503	        __failure = 7;
00504	        if (!PyErr_Occurred()) {
00505	            PyErr_SetString(PyExc_RuntimeError,
00506	                "Unexpected error in an Op's C code. "
00507	                "No Python exception was set.");
00508	            }
00509	        goto __label_7;}
00510	        }
00511	    }
00512	    
00513	            if (PyArray_NDIM(V1) < 2) {
00514	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00515	                {
00516	        __failure = 7;
00517	        if (!PyErr_Occurred()) {
00518	            PyErr_SetString(PyExc_RuntimeError,
00519	                "Unexpected error in an Op's C code. "
00520	                "No Python exception was set.");
00521	            }
00522	        goto __label_7;}
00523	            }
00524	            
00525	                V1_n1 = PyArray_DIMS(V1)[1];
00526	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00527	                V1_jump1_1 = (V1_stride1) - (0);
00528	                //printf("V1_jump1_1 is:");
00529	                //std::cout << V1_jump1_1 << std::endl;
00530	                
00531	                V1_n0 = PyArray_DIMS(V1)[0];
00532	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00533	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00534	                //printf("V1_jump0_0 is:");
00535	                //std::cout << V1_jump0_0 << std::endl;
00536	                
00537	
00538	            if((PyArray_ISCONTIGUOUS(V3) && PyArray_ISCONTIGUOUS(V5) && PyArray_ISCONTIGUOUS(V1)) || (PyArray_ISFORTRAN(V3) && PyArray_ISFORTRAN(V5) && PyArray_ISFORTRAN(V1))){
00539	                
00540	                    // All output have the same size
00541	                    npy_intp n = PyArray_SIZE(V1);
00542	                    
00543	            dtype_V3 * V3_ptr = (dtype_V3*) PyArray_DATA(V3);
00544	                            
00545	            dtype_V5 * V5_ptr = (dtype_V5*) PyArray_DATA(V5);
00546	                            
00547	            dtype_V1 * V1_ptr = (dtype_V1*) PyArray_DATA(V1);
00548	                            
00549	                    for(int i=0; i<n; i++){
00550	                        
00551	            dtype_V3& V3_i = V3_ptr[i];
00552	                            
00553	            dtype_V5& V5_i = V5_ptr[i];
00554	                            
00555	            dtype_V1& V1_i = V1_ptr[i];
00556	                            
00557	                        V1_i = V3_i * V5_i;;
00558	                    }
00559	                    
00560	            }else{
00561	                {
00562	
00563	    std::vector< std::pair<int, int> > V1_loops(2);
00564	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00565	    
00566	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00567	            
00568	        V1_loops_it->second = 0;
00569	        ++V1_loops_it;
00570	        
00571	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00572	            
00573	        V1_loops_it->second = 1;
00574	        ++V1_loops_it;
00575	        
00576	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00577	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00578	    
00579	
00580	    int init_totals[2] = {V3_n0, V3_n1};
00581	    
00582	    V1_loops_it = V1_loops.begin();
00583	    
00584	        int TOTAL_0 = init_totals[V1_loops_it->second];
00585	        ++V1_loops_it;
00586	        
00587	        int TOTAL_1 = init_totals[V1_loops_it->second];
00588	        ++V1_loops_it;
00589	        
00590	
00591	    int init_strides[3][2] = {
00592	        V3_stride0, V3_stride1, 
00593	V5_stride0, V5_stride1, 
00594	V1_stride0, V1_stride1
00595	    };
00596	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00597	    
00598	        V1_loops_rit = V1_loops.rbegin();
00599	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00600	            ++V1_loops_rit;
00601	            
00602	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00603	            ++V1_loops_rit;
00604	            
00605	        V1_loops_rit = V1_loops.rbegin();
00606	            int V5_stride_l1 = init_strides[1][V1_loops_rit->second];
00607	            ++V1_loops_rit;
00608	            
00609	            int V5_stride_l0 = init_strides[1][V1_loops_rit->second];
00610	            ++V1_loops_rit;
00611	            
00612	        V1_loops_rit = V1_loops.rbegin();
00613	            int V1_stride_l1 = init_strides[2][V1_loops_rit->second];
00614	            ++V1_loops_rit;
00615	            
00616	            int V1_stride_l0 = init_strides[2][V1_loops_rit->second];
00617	            ++V1_loops_rit;
00618	            
00619	V3_iter = (npy_float64*)(PyArray_DATA(V3));
00620	V5_iter = (npy_float64*)(PyArray_DATA(V5));
00621	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00622	
00623	
00624	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00625	        { // begin loop 0
00626	            
00627	            
00628	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00629	        { // begin loop 1
00630	            npy_float64 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00631	npy_float64 &V5_i = * ( V5_iter+V5_stride_l1*ITER_1+V5_stride_l0*ITER_0);
00632	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00633	
00634	            
00635	        {
00636	            
00637	            V1_i = V3_i * V5_i;
00638	            
00639	        }
00640	        
00641	        } // end loop 1
00642	        
00643	        } // end loop 0
00644	        
00645	}
00646	
00647	            }
00648	            __label_7:
00649	
00650	double __DUMMY_7;
00651	
00652	}
00653	__label_6:
00654	
00655	        if (V5) {
00656	            Py_XDECREF(V5);
00657	        }
00658	        
00659	    {Py_XDECREF(py_V5);}
00660	    
00661	double __DUMMY_6;
00662	
00663	}
00664	__label_4:
00665	
00666	        if (V3) {
00667	            Py_XDECREF(V3);
00668	        }
00669	        
00670	    {Py_XDECREF(py_V3);}
00671	    
00672	double __DUMMY_4;
00673	
00674	}
00675	__label_2:
00676	
00677	    if (!__failure) {
00678	      
00679	        {Py_XDECREF(py_V1);}
00680	        if (!V1) {
00681	            Py_INCREF(Py_None);
00682	            py_V1 = Py_None;
00683	        }
00684	        else if ((void*)py_V1 != (void*)V1) {
00685	            py_V1 = (PyObject*)V1;
00686	        }
00687	
00688	        {Py_XINCREF(py_V1);}
00689	
00690	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00691	            PyErr_Format(PyExc_NotImplementedError,
00692	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00693	                         " with %ld dimensions, with 3 last dims "
00694	                         "%ld, %ld, %ld"
00695	                         " and 3 last strides %ld %ld, %ld.",
00696	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00697	                         (long int) PyArray_NDIM(V1),
00698	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00699	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00700	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00701	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00702	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00703	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00704	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00705	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00706	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00707	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00708	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00709	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00710	        );
00711	            {
00712	        __failure = 2;
00713	        if (!PyErr_Occurred()) {
00714	            PyErr_SetString(PyExc_RuntimeError,
00715	                "Unexpected error in an Op's C code. "
00716	                "No Python exception was set.");
00717	            }
00718	        goto __label_2;}
00719	        }
00720	        
00721	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00722	      {Py_XINCREF(py_V1);}
00723	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00724	      {Py_XDECREF(old);}
00725	    }
00726	    
00727	        if (V1) {
00728	            Py_XDECREF(V1);
00729	        }
00730	        
00731	    {Py_XDECREF(py_V1);}
00732	    
00733	double __DUMMY_2;
00734	
00735	}
00736	
00737	            
00738	        if (__failure) {
00739	            // When there is a failure, this code puts the exception
00740	            // in __ERROR.
00741	            PyObject* err_type = NULL;
00742	            PyObject* err_msg = NULL;
00743	            PyObject* err_traceback = NULL;
00744	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00745	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00746	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00747	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00748	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00749	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00750	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00751	            PyList_SET_ITEM(__ERROR, 0, err_type);
00752	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00753	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00754	            {Py_XDECREF(old_err_type);}
00755	            {Py_XDECREF(old_err_msg);}
00756	            {Py_XDECREF(old_err_traceback);}
00757	        }
00758	        // The failure code is returned to index what code block failed.
00759	        return __failure;
00760	        
00761	        }
00762	    };
00763	    }
00764	    
00765	
00766	        static int __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09_executor(__struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09* self) {
00767	            return self->run();
00768	        }
00769	
00770	        static void __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09_destructor(void* executor, void* self) {
00771	            delete ((__struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09*)self);
00772	        }
00773	        
00774	//////////////////////
00775	////  Functions
00776	//////////////////////
00777	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00778	  assert(PyTuple_Check(argtuple));
00779	  if (4 != PyTuple_Size(argtuple)){ 
00780	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 4, got %i", (int)PyTuple_Size(argtuple));
00781	     return NULL;
00782	  }
00783	  __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09* struct_ptr = new __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09();
00784	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2),PyTuple_GET_ITEM(argtuple, 3) ) != 0) {
00785	    delete struct_ptr;
00786	    return NULL;
00787	  }
00788	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09_executor), struct_ptr, __struct_compiled_op_c12c19f770b4f8bc513a48412d2bea09_destructor);
00789	  return thunk; }
00790	
00791	//////////////////////
00792	////  Module init
00793	//////////////////////
00794	static PyMethodDef MyMethods[] = {
00795		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00796		{NULL, NULL, 0, NULL}
00797	};
00798	PyMODINIT_FUNC initc12c19f770b4f8bc513a48412d2bea09(void){
00799	   import_array();
00800	   (void) Py_InitModule("c12c19f770b4f8bc513a48412d2bea09", MyMethods);
00801	}
00802	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpjgqOzh/c12c19f770b4f8bc513a48412d2bea09.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpjgqOzh/mod.cpp -lpython2.7
ERROR
test_grad_multiple_outs_taps_backwards (theano.scan_module.tests.test_scan.T_Scan) ... 00001	#include <Python.h>
00002	#include <iostream>
00003	#include "theano_mod_helper.h"
00004	#include <math.h>
00005	#include <numpy/arrayobject.h>
00006	#include <numpy/arrayscalars.h>
00007	#include <vector>
00008	#include <algorithm>
00009	//////////////////////
00010	////  Support Code
00011	//////////////////////
00012	
00013	    namespace {
00014	    struct __struct_compiled_op_7baf9bdd4768e37b296b93092950a377 {
00015	        PyObject* __ERROR;
00016	
00017	        PyObject* storage_V3;
00018	PyObject* storage_V1;
00019	        
00020	
00021	        __struct_compiled_op_7baf9bdd4768e37b296b93092950a377() {
00022	            // This is only somewhat safe because we:
00023	            //  1) Are not a virtual class
00024	            //  2) Do not use any virtual classes in the members
00025	            //  3) Deal with mostly POD and pointers
00026	
00027	            // If this changes, we would have to revise this, but for
00028	            // now I am tired of chasing segfaults because
00029	            // initialization code had an error and some pointer has
00030	            // a junk value.
00031	            memset(this, 0, sizeof(*this));
00032	        }
00033	        ~__struct_compiled_op_7baf9bdd4768e37b296b93092950a377(void) {
00034	            cleanup();
00035	        }
00036	
00037	        int init(PyObject* __ERROR, PyObject* storage_V3, PyObject* storage_V1) {
00038	            Py_XINCREF(storage_V3);
00039	Py_XINCREF(storage_V1);
00040	            this->storage_V3 = storage_V3;
00041	this->storage_V1 = storage_V1;
00042	            
00043	
00044	
00045	
00046	            this->__ERROR = __ERROR;
00047	            return 0;
00048	        }
00049	        void cleanup(void) {
00050	            __label_1:
00051	
00052	double __DUMMY_1;
00053	__label_3:
00054	
00055	double __DUMMY_3;
00056	__label_6:
00057	
00058	double __DUMMY_6;
00059	
00060	            Py_XDECREF(this->storage_V3);
00061	Py_XDECREF(this->storage_V1);
00062	        }
00063	        int run(void) {
00064	            int __failure = 0;
00065	            
00066	    PyObject* py_V1;
00067	    
00068	        PyArrayObject* V1;
00069	        
00070	            typedef npy_float64 dtype_V1;
00071	            
00072	    PyObject* py_V3;
00073	    
00074	        PyArrayObject* V3;
00075	        
00076	            typedef npy_float32 dtype_V3;
00077	            
00078	{
00079	
00080	    py_V1 = PyList_GET_ITEM(storage_V1, 0);
00081	    {Py_XINCREF(py_V1);}
00082	    
00083	        if (py_V1 == Py_None)
00084	        {
00085	            
00086	        V1 = NULL;
00087	        
00088	        }
00089	        else
00090	        {
00091	            
00092	            V1 = NULL;
00093	            if (py_V1 == Py_None) {
00094	                // We can either fail here or set V1 to NULL and rely on Ops
00095	                // using tensors to handle the NULL case, but if they fail to do so
00096	                // they'll end up with nasty segfaults, so this is public service.
00097	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00098	                {
00099	        __failure = 2;
00100	        if (!PyErr_Occurred()) {
00101	            PyErr_SetString(PyExc_RuntimeError,
00102	                "Unexpected error in an Op's C code. "
00103	                "No Python exception was set.");
00104	            }
00105	        goto __label_2;}
00106	            }
00107	            if (!PyArray_Check(py_V1)) {
00108	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00109	                {
00110	        __failure = 2;
00111	        if (!PyErr_Occurred()) {
00112	            PyErr_SetString(PyExc_RuntimeError,
00113	                "Unexpected error in an Op's C code. "
00114	                "No Python exception was set.");
00115	            }
00116	        goto __label_2;}
00117	            }
00118	            // We expect NPY_FLOAT64
00119	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00120	                PyArrayObject * tmp = (PyArrayObject*) py_V1;
00121	                PyErr_Format(PyExc_NotImplementedError,
00122	                             "expected an aligned array of type %ld "
00123	                             "(NPY_FLOAT64), got non-aligned array of type %ld"
00124	                             " with %ld dimensions, with 3 last dims "
00125	                             "%ld, %ld, %ld"
00126	                             " and 3 last strides %ld %ld, %ld.",
00127	                             (long int) NPY_FLOAT64,
00128	                             (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00129	                             (long int) PyArray_NDIM(tmp),
00130	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00131	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00132	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00133	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00134	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00135	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00136	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00137	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00138	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00139	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00140	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00141	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00142	            );
00143	                {
00144	        __failure = 2;
00145	        if (!PyErr_Occurred()) {
00146	            PyErr_SetString(PyExc_RuntimeError,
00147	                "Unexpected error in an Op's C code. "
00148	                "No Python exception was set.");
00149	            }
00150	        goto __label_2;}
00151	            }
00152	            // This is a TypeError to be consistent with DEBUG_MODE
00153	            // Note: DEBUG_MODE also tells the name of the container
00154	            if (PyArray_TYPE((PyArrayObject*) py_V1) != NPY_FLOAT64) {
00155	                PyErr_Format(PyExc_TypeError,
00156	                             "expected type_num %d (NPY_FLOAT64) got %d",
00157	                             NPY_FLOAT64, PyArray_TYPE((PyArrayObject*) py_V1));
00158	                {
00159	        __failure = 2;
00160	        if (!PyErr_Occurred()) {
00161	            PyErr_SetString(PyExc_RuntimeError,
00162	                "Unexpected error in an Op's C code. "
00163	                "No Python exception was set.");
00164	            }
00165	        goto __label_2;}
00166	            }
00167	            
00168	        V1 = (PyArrayObject*)(py_V1);
00169	        Py_XINCREF(V1);
00170	        
00171	        }
00172	        
00173	{
00174	
00175	    py_V3 = PyList_GET_ITEM(storage_V3, 0);
00176	    {Py_XINCREF(py_V3);}
00177	    
00178	            V3 = NULL;
00179	            if (py_V3 == Py_None) {
00180	                // We can either fail here or set V3 to NULL and rely on Ops
00181	                // using tensors to handle the NULL case, but if they fail to do so
00182	                // they'll end up with nasty segfaults, so this is public service.
00183	                PyErr_SetString(PyExc_ValueError, "expected an ndarray, not None");
00184	                {
00185	        __failure = 4;
00186	        if (!PyErr_Occurred()) {
00187	            PyErr_SetString(PyExc_RuntimeError,
00188	                "Unexpected error in an Op's C code. "
00189	                "No Python exception was set.");
00190	            }
00191	        goto __label_4;}
00192	            }
00193	            if (!PyArray_Check(py_V3)) {
00194	                PyErr_SetString(PyExc_ValueError, "expected an ndarray");
00195	                {
00196	        __failure = 4;
00197	        if (!PyErr_Occurred()) {
00198	            PyErr_SetString(PyExc_RuntimeError,
00199	                "Unexpected error in an Op's C code. "
00200	                "No Python exception was set.");
00201	            }
00202	        goto __label_4;}
00203	            }
00204	            // We expect NPY_FLOAT32
00205	            if (!PyArray_ISALIGNED((PyArrayObject*) py_V3)) {
00206	                PyArrayObject * tmp = (PyArrayObject*) py_V3;
00207	                PyErr_Format(PyExc_NotImplementedError,
00208	                             "expected an aligned array of type %ld "
00209	                             "(NPY_FLOAT32), got non-aligned array of type %ld"
00210	                             " with %ld dimensions, with 3 last dims "
00211	                             "%ld, %ld, %ld"
00212	                             " and 3 last strides %ld %ld, %ld.",
00213	                             (long int) NPY_FLOAT32,
00214	                             (long int) PyArray_TYPE((PyArrayObject*) py_V3),
00215	                             (long int) PyArray_NDIM(tmp),
00216	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00217	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-3] : -1),
00218	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00219	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-2] : -1),
00220	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00221	            PyArray_DIMS(tmp)[PyArray_NDIM(tmp)-1] : -1),
00222	                             (long int) (PyArray_NDIM(tmp) >= 3 ?
00223	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-3] : -1),
00224	                             (long int) (PyArray_NDIM(tmp) >= 2 ?
00225	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-2] : -1),
00226	                             (long int) (PyArray_NDIM(tmp) >= 1 ?
00227	            PyArray_STRIDES(tmp)[PyArray_NDIM(tmp)-1] : -1)
00228	            );
00229	                {
00230	        __failure = 4;
00231	        if (!PyErr_Occurred()) {
00232	            PyErr_SetString(PyExc_RuntimeError,
00233	                "Unexpected error in an Op's C code. "
00234	                "No Python exception was set.");
00235	            }
00236	        goto __label_4;}
00237	            }
00238	            // This is a TypeError to be consistent with DEBUG_MODE
00239	            // Note: DEBUG_MODE also tells the name of the container
00240	            if (PyArray_TYPE((PyArrayObject*) py_V3) != NPY_FLOAT32) {
00241	                PyErr_Format(PyExc_TypeError,
00242	                             "expected type_num %d (NPY_FLOAT32) got %d",
00243	                             NPY_FLOAT32, PyArray_TYPE((PyArrayObject*) py_V3));
00244	                {
00245	        __failure = 4;
00246	        if (!PyErr_Occurred()) {
00247	            PyErr_SetString(PyExc_RuntimeError,
00248	                "Unexpected error in an Op's C code. "
00249	                "No Python exception was set.");
00250	            }
00251	        goto __label_4;}
00252	            }
00253	            
00254	        V3 = (PyArrayObject*)(py_V3);
00255	        Py_XINCREF(V3);
00256	        
00257	{
00258	// Op class Elemwise
00259	
00260	        npy_float32* V3_iter;
00261	        
00262	                int V3_jumpx_0;
00263	                
00264	                int V3_jumpx_1;
00265	                
00266	
00267	                V3_jumpx_1 = -(0);
00268	                //printf("V3_jumpx_1 is:");
00269	                //std::cout << V3_jumpx_1 << std::endl;
00270	                
00271	                V3_jumpx_0 = -(0);
00272	                //printf("V3_jumpx_0 is:");
00273	                //std::cout << V3_jumpx_0 << std::endl;
00274	                
00275	
00276	        npy_float64* V1_iter;
00277	        
00278	                npy_intp V1_n0;
00279	                ssize_t V1_stride0;
00280	                int V1_jump0_0;
00281	                
00282	                npy_intp V1_n1;
00283	                ssize_t V1_stride1;
00284	                int V1_jump1_1;
00285	                
00286	    {
00287	        npy_intp dims[2];
00288	        //npy_intp* dims = (npy_intp*)malloc(2 * sizeof(npy_intp));
00289	        dims[0] = 1;
00290	dims[1] = 1;
00291	
00292	        if (!V1) {
00293	            V1 = (PyArrayObject*)PyArray_EMPTY(2, dims,
00294	                                                    NPY_FLOAT64,
00295	                                                    0);
00296	        }
00297	        else {
00298	            PyArray_Dims new_dims;
00299	            new_dims.len = 2;
00300	            new_dims.ptr = dims;
00301	            PyObject* success = PyArray_Resize(V1, &new_dims, 0, NPY_CORDER);
00302	            if (!success) {
00303	                // If we can't resize the ndarray we have we can allocate a new one.
00304	                PyErr_Clear();
00305	                Py_XDECREF(V1);
00306	                V1 = (PyArrayObject*)PyArray_EMPTY(2, dims, NPY_FLOAT64, 0);
00307	            }
00308	        }
00309	        if (!V1) {
00310	            {
00311	        __failure = 5;
00312	        if (!PyErr_Occurred()) {
00313	            PyErr_SetString(PyExc_RuntimeError,
00314	                "Unexpected error in an Op's C code. "
00315	                "No Python exception was set.");
00316	            }
00317	        goto __label_5;}
00318	        }
00319	    }
00320	    
00321	            if (PyArray_NDIM(V1) < 2) {
00322	                PyErr_SetString(PyExc_ValueError, "Not enough dimensions on input.");
00323	                {
00324	        __failure = 5;
00325	        if (!PyErr_Occurred()) {
00326	            PyErr_SetString(PyExc_RuntimeError,
00327	                "Unexpected error in an Op's C code. "
00328	                "No Python exception was set.");
00329	            }
00330	        goto __label_5;}
00331	            }
00332	            
00333	                V1_n1 = PyArray_DIMS(V1)[1];
00334	                V1_stride1 = PyArray_STRIDES(V1)[1] / sizeof(npy_float64);
00335	                V1_jump1_1 = (V1_stride1) - (0);
00336	                //printf("V1_jump1_1 is:");
00337	                //std::cout << V1_jump1_1 << std::endl;
00338	                
00339	                V1_n0 = PyArray_DIMS(V1)[0];
00340	                V1_stride0 = PyArray_STRIDES(V1)[0] / sizeof(npy_float64);
00341	                V1_jump0_0 = (V1_stride0) - (V1_n1*V1_stride1);
00342	                //printf("V1_jump0_0 is:");
00343	                //std::cout << V1_jump0_0 << std::endl;
00344	                
00345	{
00346	
00347	    std::vector< std::pair<int, int> > V1_loops(2);
00348	    std::vector< std::pair<int, int> >::iterator V1_loops_it = V1_loops.begin();
00349	    
00350	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[0]);
00351	            
00352	        V1_loops_it->second = 0;
00353	        ++V1_loops_it;
00354	        
00355	            V1_loops_it->first = abs(PyArray_STRIDES(V1)[1]);
00356	            
00357	        V1_loops_it->second = 1;
00358	        ++V1_loops_it;
00359	        
00360	    // rbegin and rend are reversed iterators, so this sorts in decreasing order
00361	    std::sort(V1_loops.rbegin(), V1_loops.rend());
00362	    
00363	
00364	    int init_totals[2] = {V1_n0, V1_n1};
00365	    
00366	    V1_loops_it = V1_loops.begin();
00367	    
00368	        int TOTAL_0 = init_totals[V1_loops_it->second];
00369	        ++V1_loops_it;
00370	        
00371	        int TOTAL_1 = init_totals[V1_loops_it->second];
00372	        ++V1_loops_it;
00373	        
00374	
00375	    int init_strides[2][2] = {
00376	        0, 0, 
00377	V1_stride0, V1_stride1
00378	    };
00379	    std::vector< std::pair<int, int> >::reverse_iterator V1_loops_rit;
00380	    
00381	        V1_loops_rit = V1_loops.rbegin();
00382	            int V3_stride_l1 = init_strides[0][V1_loops_rit->second];
00383	            ++V1_loops_rit;
00384	            
00385	            int V3_stride_l0 = init_strides[0][V1_loops_rit->second];
00386	            ++V1_loops_rit;
00387	            
00388	        V1_loops_rit = V1_loops.rbegin();
00389	            int V1_stride_l1 = init_strides[1][V1_loops_rit->second];
00390	            ++V1_loops_rit;
00391	            
00392	            int V1_stride_l0 = init_strides[1][V1_loops_rit->second];
00393	            ++V1_loops_rit;
00394	            
00395	V3_iter = (npy_float32*)(PyArray_DATA(V3));
00396	V1_iter = (npy_float64*)(PyArray_DATA(V1));
00397	
00398	
00399	        for(int ITER_0 = 0; ITER_0<TOTAL_0; ITER_0++)
00400	        { // begin loop 0
00401	            
00402	            
00403	        for(int ITER_1 = 0; ITER_1<TOTAL_1; ITER_1++)
00404	        { // begin loop 1
00405	            npy_float32 &V3_i = * ( V3_iter+V3_stride_l1*ITER_1+V3_stride_l0*ITER_0);
00406	npy_float64 &V1_i = * ( V1_iter+V1_stride_l1*ITER_1+V1_stride_l0*ITER_0);
00407	
00408	            
00409	        {
00410	            
00411	            V1_i = V3_i;
00412	            
00413	        }
00414	        
00415	        } // end loop 1
00416	        
00417	        } // end loop 0
00418	        
00419	}
00420	__label_5:
00421	
00422	double __DUMMY_5;
00423	
00424	}
00425	__label_4:
00426	
00427	        if (V3) {
00428	            Py_XDECREF(V3);
00429	        }
00430	        
00431	    {Py_XDECREF(py_V3);}
00432	    
00433	double __DUMMY_4;
00434	
00435	}
00436	__label_2:
00437	
00438	    if (!__failure) {
00439	      
00440	        {Py_XDECREF(py_V1);}
00441	        if (!V1) {
00442	            Py_INCREF(Py_None);
00443	            py_V1 = Py_None;
00444	        }
00445	        else if ((void*)py_V1 != (void*)V1) {
00446	            py_V1 = (PyObject*)V1;
00447	        }
00448	
00449	        {Py_XINCREF(py_V1);}
00450	
00451	        if (V1 && !PyArray_ISALIGNED((PyArrayObject*) py_V1)) {
00452	            PyErr_Format(PyExc_NotImplementedError,
00453	                         "c_sync: expected an aligned array, got non-aligned array of type %ld"
00454	                         " with %ld dimensions, with 3 last dims "
00455	                         "%ld, %ld, %ld"
00456	                         " and 3 last strides %ld %ld, %ld.",
00457	                         (long int) PyArray_TYPE((PyArrayObject*) py_V1),
00458	                         (long int) PyArray_NDIM(V1),
00459	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00460	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-3] : -1),
00461	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00462	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-2] : -1),
00463	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00464	        PyArray_DIMS(V1)[PyArray_NDIM(V1)-1] : -1),
00465	                         (long int) (PyArray_NDIM(V1) >= 3 ?
00466	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-3] : -1),
00467	                         (long int) (PyArray_NDIM(V1) >= 2 ?
00468	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-2] : -1),
00469	                         (long int) (PyArray_NDIM(V1) >= 1 ?
00470	        PyArray_STRIDES(V1)[PyArray_NDIM(V1)-1] : -1)
00471	        );
00472	            {
00473	        __failure = 2;
00474	        if (!PyErr_Occurred()) {
00475	            PyErr_SetString(PyExc_RuntimeError,
00476	                "Unexpected error in an Op's C code. "
00477	                "No Python exception was set.");
00478	            }
00479	        goto __label_2;}
00480	        }
00481	        
00482	      PyObject* old = PyList_GET_ITEM(storage_V1, 0);
00483	      {Py_XINCREF(py_V1);}
00484	      PyList_SET_ITEM(storage_V1, 0, py_V1);
00485	      {Py_XDECREF(old);}
00486	    }
00487	    
00488	        if (V1) {
00489	            Py_XDECREF(V1);
00490	        }
00491	        
00492	    {Py_XDECREF(py_V1);}
00493	    
00494	double __DUMMY_2;
00495	
00496	}
00497	
00498	            
00499	        if (__failure) {
00500	            // When there is a failure, this code puts the exception
00501	            // in __ERROR.
00502	            PyObject* err_type = NULL;
00503	            PyObject* err_msg = NULL;
00504	            PyObject* err_traceback = NULL;
00505	            PyErr_Fetch(&err_type, &err_msg, &err_traceback);
00506	            if (!err_type) {err_type = Py_None;Py_INCREF(Py_None);}
00507	            if (!err_msg) {err_msg = Py_None; Py_INCREF(Py_None);}
00508	            if (!err_traceback) {err_traceback = Py_None; Py_INCREF(Py_None);}
00509	            PyObject* old_err_type = PyList_GET_ITEM(__ERROR, 0);
00510	            PyObject* old_err_msg = PyList_GET_ITEM(__ERROR, 1);
00511	            PyObject* old_err_traceback = PyList_GET_ITEM(__ERROR, 2);
00512	            PyList_SET_ITEM(__ERROR, 0, err_type);
00513	            PyList_SET_ITEM(__ERROR, 1, err_msg);
00514	            PyList_SET_ITEM(__ERROR, 2, err_traceback);
00515	            {Py_XDECREF(old_err_type);}
00516	            {Py_XDECREF(old_err_msg);}
00517	            {Py_XDECREF(old_err_traceback);}
00518	        }
00519	        // The failure code is returned to index what code block failed.
00520	        return __failure;
00521	        
00522	        }
00523	    };
00524	    }
00525	    
00526	
00527	        static int __struct_compiled_op_7baf9bdd4768e37b296b93092950a377_executor(__struct_compiled_op_7baf9bdd4768e37b296b93092950a377* self) {
00528	            return self->run();
00529	        }
00530	
00531	        static void __struct_compiled_op_7baf9bdd4768e37b296b93092950a377_destructor(void* executor, void* self) {
00532	            delete ((__struct_compiled_op_7baf9bdd4768e37b296b93092950a377*)self);
00533	        }
00534	        
00535	//////////////////////
00536	////  Functions
00537	//////////////////////
00538	static PyObject * instantiate(PyObject * self, PyObject *argtuple) {
00539	  assert(PyTuple_Check(argtuple));
00540	  if (3 != PyTuple_Size(argtuple)){ 
00541	     PyErr_Format(PyExc_TypeError, "Wrong number of arguments, expected 3, got %i", (int)PyTuple_Size(argtuple));
00542	     return NULL;
00543	  }
00544	  __struct_compiled_op_7baf9bdd4768e37b296b93092950a377* struct_ptr = new __struct_compiled_op_7baf9bdd4768e37b296b93092950a377();
00545	  if (struct_ptr->init( PyTuple_GET_ITEM(argtuple, 0),PyTuple_GET_ITEM(argtuple, 1),PyTuple_GET_ITEM(argtuple, 2) ) != 0) {
00546	    delete struct_ptr;
00547	    return NULL;
00548	  }
00549	  PyObject* thunk = PyCObject_FromVoidPtrAndDesc((void*)(&__struct_compiled_op_7baf9bdd4768e37b296b93092950a377_executor), struct_ptr, __struct_compiled_op_7baf9bdd4768e37b296b93092950a377_destructor);
00550	  return thunk; }
00551	
00552	//////////////////////
00553	////  Module init
00554	//////////////////////
00555	static PyMethodDef MyMethods[] = {
00556		{"instantiate", instantiate, METH_VARARGS, "undocumented"} ,
00557		{NULL, NULL, 0, NULL}
00558	};
00559	PyMODINIT_FUNC init7baf9bdd4768e37b296b93092950a377(void){
00560	   import_array();
00561	   (void) Py_InitModule("7baf9bdd4768e37b296b93092950a377", MyMethods);
00562	}
00563	
Problem occurred during compilation with the command line below:
/usr/bin/g++ -shared -g -O3 -fno-math-errno -Wno-unused-label -Wno-unused-variable -Wno-write-strings -DNPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION -m64 -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -I/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof -L/usr/lib -fvisibility=hidden -o /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpiN4muz/7baf9bdd4768e37b296b93092950a377.so /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpiN4muz/mod.cpp -lpython2.7
ERROR (theano.gof.opt): Optimization failure due to: constant_folding
ERROR (theano.gof.opt): node: Elemwise{Identity}(TensorConstant{(1, 1) of 0.0})
ERROR (theano.gof.opt): TRACEBACK:
ERROR (theano.gof.opt): Traceback (most recent call last):
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/opt.py", line 1982, in process_node
    replacements = lopt.transform(node)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/tensor/opt.py", line 6450, in constant_folding
    no_recycling=[], impl=impl)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/op.py", line 935, in make_thunk
    no_recycling)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/op.py", line 839, in make_c_thunk
    output_storage=node_output_storage)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1190, in make_thunk
    keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1131, in __compile__
    keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1586, in cthunk_factory
    key=key, lnk=self, keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cmodule.py", line 1159, in module_from_key
    module = lnk.compile_cmodule(location)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1489, in compile_cmodule
    preargs=preargs)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cmodule.py", line 2316, in compile_str
    (status, compile_stderr.replace('\n', '. ')))
[...]
theano.gof.opt: ERROR: Optimization failure due to: constant_folding
theano.gof.opt: ERROR: node: Elemwise{Cast{float32}}(TensorConstant{(1, 1, 1, 1) of 0})
theano.gof.opt: ERROR: TRACEBACK:
theano.gof.opt: ERROR: Traceback (most recent call last):
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/opt.py", line 1982, in process_node
    replacements = lopt.transform(node)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/tensor/opt.py", line 6450, in constant_folding
    no_recycling=[], impl=impl)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/op.py", line 935, in make_thunk
    no_recycling)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/op.py", line 839, in make_c_thunk
    output_storage=node_output_storage)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1190, in make_thunk
    keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1131, in __compile__
    keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1586, in cthunk_factory
    key=key, lnk=self, keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cmodule.py", line 1159, in module_from_key
    module = lnk.compile_cmodule(location)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1489, in compile_cmodule
    preargs=preargs)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cmodule.py", line 2316, in compile_str
    (status, compile_stderr.replace('\n', '. ')))
Exception: ("Compilation failed (return status=1): In file included from /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:1:. In file included from /usr/include/python2.7/Python.h:88:. /usr/include/python2.7/unicodeobject.h:534:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register PyObject *obj,     /* Object */.     ^~~~~~~~~. /usr/include/python2.7/unicodeobject.h:553:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register PyObject *obj      /* Object */.     ^~~~~~~~~. /usr/include/python2.7/unicodeobject.h:575:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register const wchar_t *w,  /* wchar_t buffer */.     ^~~~~~~~~. /usr/include/python2.7/unicodeobject.h:593:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register wchar_t *w,        /* wchar_t buffer */.     ^~~~~~~~~. In file included from /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:1:. In file included from /usr/include/python2.7/Python.h:97:. /usr/include/python2.7/stringobject.h:173:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register PyObject *obj,     /* string or Unicode object */.     ^~~~~~~~~. /usr/include/python2.7/stringobject.h:174:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register char **s,          /* pointer to buffer variable */.     ^~~~~~~~~. /usr/include/python2.7/stringobject.h:175:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register Py_ssize_t *len    /* pointer to length variable or NULL.     ^~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:408:27: error: non-constant-expression cannot be narrowed from type 'npy_intp' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing].     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                           ^~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:408:27: note: insert an explicit cast to silence this issue.     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                           ^~~~~.                           static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:408:34: error: non-constant-expression cannot be narrowed from type 'npy_intp' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing].     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                  ^~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:408:34: note: insert an explicit cast to silence this issue.     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                  ^~~~~.                                  static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:408:41: error: non-constant-expression cannot be narrowed from type 'npy_intp' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing].     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                         ^~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:408:41: note: insert an explicit cast to silence this issue.     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                         ^~~~~.                                         static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:408:48: error: non-constant-expression cannot be narrowed from type 'npy_intp' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing].     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                                ^~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:408:48: note: insert an explicit cast to silence this issue.     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                                ^~~~~.                                                static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:427:1: error: non-constant-expression cannot be narrowed from type 'ssize_t' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing]. V1_stride0, V1_stride1, V1_stride2, V1_stride3. ^~~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:427:1: note: insert an explicit cast to silence this issue. V1_stride0, V1_stride1, V1_stride2, V1_stride3. ^~~~~~~~~~. static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:427:13: error: non-constant-expression cannot be narrowed from type 'ssize_t' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing]. V1_stride0, V1_stride1, V1_stride2, V1_stride3.             ^~~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:427:13: note: insert an explicit cast to silence this issue. V1_stride0, V1_stride1, V1_stride2, V1_stride3.             ^~~~~~~~~~.             static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:427:25: error: non-constant-expression cannot be narrowed from type 'ssize_t' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing]. V1_stride0, V1_stride1, V1_stride2, V1_stride3.                         ^~~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:427:25: note: insert an explicit cast to silence this issue. V1_stride0, V1_stride1, V1_stride2, V1_stride3.                         ^~~~~~~~~~.                         static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:427:37: error: non-constant-expression cannot be narrowed from type 'ssize_t' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing]. V1_stride0, V1_stride1, V1_stride2, V1_stride3.                                     ^~~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpNGVecH/mod.cpp:427:37: note: insert an explicit cast to silence this issue. V1_stride0, V1_stride1, V1_stride2, V1_stride3.                                     ^~~~~~~~~~.                                     static_cast<int>( ). 7 warnings and 8 errors generated.. ", '[Elemwise{Cast{float32}}(TensorConstant{(1, 1, 1, 1) of 0})]')

theano.gof.opt: ERROR: Optimization failure due to: constant_folding
theano.gof.opt: ERROR: node: Elemwise{Cast{float32}}(TensorConstant{(1, 1, 1, 1) of 0})
theano.gof.opt: ERROR: TRACEBACK:
theano.gof.opt: ERROR: Traceback (most recent call last):
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/opt.py", line 1982, in process_node
    replacements = lopt.transform(node)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/tensor/opt.py", line 6450, in constant_folding
    no_recycling=[], impl=impl)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/op.py", line 935, in make_thunk
    no_recycling)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/op.py", line 839, in make_c_thunk
    output_storage=node_output_storage)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1190, in make_thunk
    keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1131, in __compile__
    keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1586, in cthunk_factory
    key=key, lnk=self, keep_lock=keep_lock)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cmodule.py", line 1159, in module_from_key
    module = lnk.compile_cmodule(location)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cc.py", line 1489, in compile_cmodule
    preargs=preargs)
  File "/<<BUILDDIR>>/theano-0.9.0+dfsg/theano/gof/cmodule.py", line 2316, in compile_str
    (status, compile_stderr.replace('\n', '. ')))
Exception: ("Compilation failed (return status=1): In file included from /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:1:. In file included from /usr/include/python2.7/Python.h:88:. /usr/include/python2.7/unicodeobject.h:534:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register PyObject *obj,     /* Object */.     ^~~~~~~~~. /usr/include/python2.7/unicodeobject.h:553:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register PyObject *obj      /* Object */.     ^~~~~~~~~. /usr/include/python2.7/unicodeobject.h:575:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register const wchar_t *w,  /* wchar_t buffer */.     ^~~~~~~~~. /usr/include/python2.7/unicodeobject.h:593:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register wchar_t *w,        /* wchar_t buffer */.     ^~~~~~~~~. In file included from /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:1:. In file included from /usr/include/python2.7/Python.h:97:. /usr/include/python2.7/stringobject.h:173:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register PyObject *obj,     /* string or Unicode object */.     ^~~~~~~~~. /usr/include/python2.7/stringobject.h:174:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register char **s,          /* pointer to buffer variable */.     ^~~~~~~~~. /usr/include/python2.7/stringobject.h:175:5: warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register].     register Py_ssize_t *len    /* pointer to length variable or NULL.     ^~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:408:27: error: non-constant-expression cannot be narrowed from type 'npy_intp' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing].     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                           ^~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:408:27: note: insert an explicit cast to silence this issue.     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                           ^~~~~.                           static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:408:34: error: non-constant-expression cannot be narrowed from type 'npy_intp' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing].     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                  ^~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:408:34: note: insert an explicit cast to silence this issue.     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                  ^~~~~.                                  static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:408:41: error: non-constant-expression cannot be narrowed from type 'npy_intp' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing].     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                         ^~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:408:41: note: insert an explicit cast to silence this issue.     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                         ^~~~~.                                         static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:408:48: error: non-constant-expression cannot be narrowed from type 'npy_intp' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing].     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                                ^~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:408:48: note: insert an explicit cast to silence this issue.     int init_totals[4] = {V1_n0, V1_n1, V1_n2, V1_n3};.                                                ^~~~~.                                                static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:427:1: error: non-constant-expression cannot be narrowed from type 'ssize_t' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing]. V1_stride0, V1_stride1, V1_stride2, V1_stride3. ^~~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:427:1: note: insert an explicit cast to silence this issue. V1_stride0, V1_stride1, V1_stride2, V1_stride3. ^~~~~~~~~~. static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:427:13: error: non-constant-expression cannot be narrowed from type 'ssize_t' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing]. V1_stride0, V1_stride1, V1_stride2, V1_stride3.             ^~~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:427:13: note: insert an explicit cast to silence this issue. V1_stride0, V1_stride1, V1_stride2, V1_stride3.             ^~~~~~~~~~.             static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:427:25: error: non-constant-expression cannot be narrowed from type 'ssize_t' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing]. V1_stride0, V1_stride1, V1_stride2, V1_stride3.                         ^~~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:427:25: note: insert an explicit cast to silence this issue. V1_stride0, V1_stride1, V1_stride2, V1_stride3.                         ^~~~~~~~~~.                         static_cast<int>( ). /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:427:37: error: non-constant-expression cannot be narrowed from type 'ssize_t' (aka 'long') to 'int' in initializer list [-Wc++11-narrowing]. V1_stride0, V1_stride1, V1_stride2, V1_stride3.                                     ^~~~~~~~~~. /<<BUILDDIR>>/theano-0.9.0+dfsg/.pybuild/compiledir_Linux-4.9--amd64-x86_64-with-debian-buster-sid--2.7.15-64/tmpxtkmN8/mod.cpp:427:37: note: insert an explicit cast to silence this issue. V1_stride0, V1_stride1, V1_stride2, V1_stride3.                                     ^~~~~~~~~~.                                     static_cast<int>( ). 7 warnings and 8 errors generated.. ", '[Elemwise{Cast{float32}}(TensorConstant{(1, 1, 1, 1) of 0})]')

--------------------- >> end captured logging << ---------------------

----------------------------------------------------------------------
Ran 5485 tests in 4367.026s

FAILED (SKIP=728, errors=1585, failures=1)
0.56794379721
0.56794379721
0.56794379721
0.56794379721
E: pybuild pybuild:336: test: plugin custom failed with: exit code=1: PYTHONPATH=. python2.7 bin/theano-nose -v
dh_auto_test: pybuild --test --test-nose -i python{version} -p 2.7 returned exit code 13
make[1]: *** [debian/rules:37: override_dh_auto_test] Error 25
make[1]: Leaving directory '/<<BUILDDIR>>/theano-0.9.0+dfsg'
make: *** [debian/rules:8: build-arch] Error 2
dpkg-buildpackage: error: debian/rules build-arch subprocess returned exit status 2
--------------------------------------------------------------------------------
Build finished at 2018-05-02T13:46:09Z

Finished
--------


+------------------------------------------------------------------------------+
| Cleanup                                                                      |
+------------------------------------------------------------------------------+

Purging /<<BUILDDIR>>
Not cleaning session: cloned chroot in use
E: Build failure (dpkg-buildpackage died)

+------------------------------------------------------------------------------+
| Summary                                                                      |
+------------------------------------------------------------------------------+

Build Architecture: amd64
Build Type: any
Build-Space: 426108
Build-Time: 4382
Distribution: unstable
Fail-Stage: build
Host Architecture: amd64
Install-Time: 50
Job: theano_0.9.0+dfsg-2
Machine Architecture: amd64
Package: theano
Package-Time: 4446
Source-Version: 0.9.0+dfsg-2
Space: 426108
Status: attempted
Version: 0.9.0+dfsg-2
--------------------------------------------------------------------------------
Finished at 2018-05-02T13:46:09Z
Build needed 01:14:06, 426108k disk space
E: Build failure (dpkg-buildpackage died)
DC-Status: Failed 4447.822968196s
DC-Time-Estimation: 4447.822968196 versus expected 19227 (r/m: 3.3227889548397003 ; m: 4447.822968196)
