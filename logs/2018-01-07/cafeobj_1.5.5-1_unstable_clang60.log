DC-Build-Header: cafeobj 1.5.5-1 / 2018-02-07 20:35:08 +0000
DC-Task: type:rebuild-binarch-only source:cafeobj version:1.5.5-1 chroot:unstable esttime:191 logfile:/tmp/cafeobj_1.5.5-1_unstable_clang60.log modes:clang60:binarch-only
DC-Sbuild-call: su user42 -c 'sbuild -n --arch-any --apt-update -d unstable -v  --chroot-setup-commands=/tmp/clang60 cafeobj_1.5.5-1'
sbuild (Debian sbuild) 0.73.0 (23 Dec 2016) on ip-172-31-25-80.eu-central-1.compute.internal

+==============================================================================+
| cafeobj 1.5.5-1 (amd64)                      Wed, 07 Feb 2018 20:35:08 +0000 |
+==============================================================================+

Package: cafeobj
Version: 1.5.5-1
Source Version: 1.5.5-1
Distribution: unstable
Machine Architecture: amd64
Host Architecture: amd64
Build Architecture: amd64
Build Type: any

I: NOTICE: Log filtering will replace 'var/run/schroot/mount/unstable-amd64-sbuild-892e967f-67f0-4571-b917-5fe4c8771a13' with '<<CHROOT>>'

+------------------------------------------------------------------------------+
| Chroot Setup Commands                                                        |
+------------------------------------------------------------------------------+


/tmp/clang60
------------

+ echo 'Entering customization script...'
Entering customization script...
+ CLANG_VERSION=6.0
+ echo 'Install of clang-6.0'
Install of clang-6.0
+ apt-get update
Get:1 http://127.0.0.1:9999/debian unstable InRelease [241 kB]
Get:2 http://127.0.0.1:9999/debian unstable/main Sources.diff/Index [27.9 kB]
Get:3 http://127.0.0.1:9999/debian unstable/main amd64 Packages.diff/Index [27.9 kB]
Get:4 http://127.0.0.1:9999/debian unstable/main Sources 2018-02-07-1427.34.pdiff [9180 B]
Get:4 http://127.0.0.1:9999/debian unstable/main Sources 2018-02-07-1427.34.pdiff [9180 B]
Get:5 http://127.0.0.1:9999/debian unstable/main amd64 Packages 2018-02-07-1427.34.pdiff [14.2 kB]
Get:5 http://127.0.0.1:9999/debian unstable/main amd64 Packages 2018-02-07-1427.34.pdiff [14.2 kB]
Get:6 http://127.0.0.1:9999/debian unstable/main Translation-en [5980 kB]
Fetched 6300 kB in 2s (3420 kB/s)
Reading package lists...
+ apt-get install --yes --no-install-recommends --force-yes clang-6.0
Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  lib32gcc1 lib32stdc++6 libbsd0 libc6-i386 libclang-common-6.0-dev
  libclang1-6.0 libedit2 libjsoncpp1 libllvm6.0 libncurses5 libobjc-7-dev
  libobjc4
Suggested packages:
  gnustep gnustep-devel clang-6.0-doc
Recommended packages:
  llvm-6.0-dev python libomp-dev libgpm2
The following NEW packages will be installed:
  clang-6.0 lib32gcc1 lib32stdc++6 libbsd0 libc6-i386 libclang-common-6.0-dev
  libclang1-6.0 libedit2 libjsoncpp1 libllvm6.0 libncurses5 libobjc-7-dev
  libobjc4
0 upgraded, 13 newly installed, 0 to remove and 1 not upgraded.
Need to get 37.6 MB of archives.
After this operation, 187 MB of additional disk space will be used.
Get:1 http://127.0.0.1:9999/debian unstable/main amd64 libjsoncpp1 amd64 1.7.4-3 [75.6 kB]
Get:2 http://127.0.0.1:9999/debian unstable/main amd64 libbsd0 amd64 0.8.7-1 [92.1 kB]
Get:3 http://127.0.0.1:9999/debian unstable/main amd64 libncurses5 amd64 6.0+20171125-1 [95.7 kB]
Get:4 http://127.0.0.1:9999/debian unstable/main amd64 libedit2 amd64 3.1-20170329-1 [85.2 kB]
Get:5 http://127.0.0.1:9999/debian unstable/main amd64 libllvm6.0 amd64 1:6.0~+rc1-1 [14.5 MB]
Get:6 http://127.0.0.1:9999/debian unstable/main amd64 libobjc4 amd64 7.3.0-1 [51.2 kB]
Get:7 http://127.0.0.1:9999/debian unstable/main amd64 libobjc-7-dev amd64 7.3.0-1 [203 kB]
Get:8 http://127.0.0.1:9999/debian unstable/main amd64 libc6-i386 amd64 2.26-6 [2836 kB]
Get:9 http://127.0.0.1:9999/debian unstable/main amd64 lib32gcc1 amd64 1:7.3.0-1 [46.8 kB]
Get:10 http://127.0.0.1:9999/debian unstable/main amd64 lib32stdc++6 amd64 7.3.0-1 [405 kB]
Get:11 http://127.0.0.1:9999/debian unstable/main amd64 libclang-common-6.0-dev amd64 1:6.0~+rc1-1 [3097 kB]
Get:12 http://127.0.0.1:9999/debian unstable/main amd64 libclang1-6.0 amd64 1:6.0~+rc1-1 [6983 kB]
Get:13 http://127.0.0.1:9999/debian unstable/main amd64 clang-6.0 amd64 1:6.0~+rc1-1 [9171 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 37.6 MB in 0s (96.6 MB/s)
Selecting previously unselected package libjsoncpp1:amd64.
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 9974 files and directories currently installed.)
Preparing to unpack .../00-libjsoncpp1_1.7.4-3_amd64.deb ...
Unpacking libjsoncpp1:amd64 (1.7.4-3) ...
Selecting previously unselected package libbsd0:amd64.
Preparing to unpack .../01-libbsd0_0.8.7-1_amd64.deb ...
Unpacking libbsd0:amd64 (0.8.7-1) ...
Selecting previously unselected package libncurses5:amd64.
Preparing to unpack .../02-libncurses5_6.0+20171125-1_amd64.deb ...
Unpacking libncurses5:amd64 (6.0+20171125-1) ...
Selecting previously unselected package libedit2:amd64.
Preparing to unpack .../03-libedit2_3.1-20170329-1_amd64.deb ...
Unpacking libedit2:amd64 (3.1-20170329-1) ...
Selecting previously unselected package libllvm6.0:amd64.
Preparing to unpack .../04-libllvm6.0_1%3a6.0~+rc1-1_amd64.deb ...
Unpacking libllvm6.0:amd64 (1:6.0~+rc1-1) ...
Selecting previously unselected package libobjc4:amd64.
Preparing to unpack .../05-libobjc4_7.3.0-1_amd64.deb ...
Unpacking libobjc4:amd64 (7.3.0-1) ...
Selecting previously unselected package libobjc-7-dev:amd64.
Preparing to unpack .../06-libobjc-7-dev_7.3.0-1_amd64.deb ...
Unpacking libobjc-7-dev:amd64 (7.3.0-1) ...
Selecting previously unselected package libc6-i386.
Preparing to unpack .../07-libc6-i386_2.26-6_amd64.deb ...
Unpacking libc6-i386 (2.26-6) ...
Selecting previously unselected package lib32gcc1.
Preparing to unpack .../08-lib32gcc1_1%3a7.3.0-1_amd64.deb ...
Unpacking lib32gcc1 (1:7.3.0-1) ...
Selecting previously unselected package lib32stdc++6.
Preparing to unpack .../09-lib32stdc++6_7.3.0-1_amd64.deb ...
Unpacking lib32stdc++6 (7.3.0-1) ...
Selecting previously unselected package libclang-common-6.0-dev.
Preparing to unpack .../10-libclang-common-6.0-dev_1%3a6.0~+rc1-1_amd64.deb ...
Unpacking libclang-common-6.0-dev (1:6.0~+rc1-1) ...
Selecting previously unselected package libclang1-6.0:amd64.
Preparing to unpack .../11-libclang1-6.0_1%3a6.0~+rc1-1_amd64.deb ...
Unpacking libclang1-6.0:amd64 (1:6.0~+rc1-1) ...
Selecting previously unselected package clang-6.0.
Preparing to unpack .../12-clang-6.0_1%3a6.0~+rc1-1_amd64.deb ...
Unpacking clang-6.0 (1:6.0~+rc1-1) ...
Setting up libncurses5:amd64 (6.0+20171125-1) ...
Setting up libobjc4:amd64 (7.3.0-1) ...
Setting up libc6-i386 (2.26-6) ...
Setting up libbsd0:amd64 (0.8.7-1) ...
Setting up libobjc-7-dev:amd64 (7.3.0-1) ...
Processing triggers for libc-bin (2.26-6) ...
Setting up lib32gcc1 (1:7.3.0-1) ...
Setting up libjsoncpp1:amd64 (1.7.4-3) ...
Setting up libedit2:amd64 (3.1-20170329-1) ...
Setting up libllvm6.0:amd64 (1:6.0~+rc1-1) ...
Setting up libclang1-6.0:amd64 (1:6.0~+rc1-1) ...
Setting up lib32stdc++6 (7.3.0-1) ...
Setting up libclang-common-6.0-dev (1:6.0~+rc1-1) ...
Setting up clang-6.0 (1:6.0~+rc1-1) ...
Processing triggers for libc-bin (2.26-6) ...
W: --force-yes is deprecated, use one of the options starting with --allow instead.
+ echo 'Replace gcc, g++ & cpp by clang'
Replace gcc, g++ & cpp by clang
+ VERSIONS='4.6 4.7 4.8 4.9 5 6 7 8'
+ cd /usr/bin
+ for VERSION in $VERSIONS
+ rm -f g++-4.6 gcc-4.6 cpp-4.6 gcc
+ ln -s clang++-6.0 g++-4.6
+ ln -s clang-6.0 gcc-4.6
+ ln -s clang-6.0 cpp-4.6
+ ln -s clang-6.0 gcc
+ echo 'gcc-4.6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.7 gcc-4.7 cpp-4.7 gcc
+ ln -s clang++-6.0 g++-4.7
+ ln -s clang-6.0 gcc-4.7
+ ln -s clang-6.0 cpp-4.7
+ ln -s clang-6.0 gcc
+ echo 'gcc-4.7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.8 gcc-4.8 cpp-4.8 gcc
+ ln -s clang++-6.0 g++-4.8
+ ln -s clang-6.0 gcc-4.8
+ ln -s clang-6.0 cpp-4.8
+ ln -s clang-6.0 gcc
+ echo 'gcc-4.8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.9 gcc-4.9 cpp-4.9 gcc
+ ln -s clang++-6.0 g++-4.9
+ ln -s clang-6.0 gcc-4.9
+ ln -s clang-6.0 cpp-4.9
+ ln -s clang-6.0 gcc
+ echo 'gcc-4.9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-5 gcc-5 cpp-5 gcc
+ ln -s clang++-6.0 g++-5
+ ln -s clang-6.0 gcc-5
+ ln -s clang-6.0 cpp-5
+ ln -s clang-6.0 gcc
+ echo 'gcc-5 hold'
+ dpkg --set-selections
+ echo 'g++-5 hold'
+ dpkg --set-selections
+ for VERSION in $VERSIONS
+ rm -f g++-6 gcc-6 cpp-6 gcc
+ ln -s clang++-6.0 g++-6
+ ln -s clang-6.0 gcc-6
+ ln -s clang-6.0 cpp-6
+ ln -s clang-6.0 gcc
+ echo 'gcc-6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-7 gcc-7 cpp-7 gcc
+ ln -s clang++-6.0 g++-7
+ ln -s clang-6.0 gcc-7
+ ln -s clang-6.0 cpp-7
+ ln -s clang-6.0 gcc
+ echo 'gcc-7 hold'
+ dpkg --set-selections
+ echo 'g++-7 hold'
+ dpkg --set-selections
+ for VERSION in $VERSIONS
+ rm -f g++-8 gcc-8 cpp-8 gcc
+ ln -s clang++-6.0 g++-8
+ ln -s clang-6.0 gcc-8
+ ln -s clang-6.0 cpp-8
+ ln -s clang-6.0 gcc
+ echo 'gcc-8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ cd -
/build/cafeobj-jXtz2b
+ echo 'Check if gcc, g++ & cpp are actually clang'
Check if gcc, g++ & cpp are actually clang
+ gcc --version
+ grep clang
+ cpp --version
+ grep clang
+ g++ --version
+ grep clang

I: Finished running '/tmp/clang60'.

Finished processing commands.
--------------------------------------------------------------------------------

+------------------------------------------------------------------------------+
| Update chroot                                                                |
+------------------------------------------------------------------------------+

Hit:1 http://127.0.0.1:9999/debian unstable InRelease
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
Calculating upgrade...
The following packages will be upgraded:
  libdebconfclient0
1 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Need to get 48.3 kB of archives.
After this operation, 0 B of additional disk space will be used.
Get:1 http://127.0.0.1:9999/debian unstable/main amd64 libdebconfclient0 amd64 0.240 [48.3 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 48.3 kB in 0s (4061 kB/s)
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 10722 files and directories currently installed.)
Preparing to unpack .../libdebconfclient0_0.240_amd64.deb ...
Unpacking libdebconfclient0:amd64 (0.240) over (0.239) ...
Setting up libdebconfclient0:amd64 (0.240) ...
Processing triggers for libc-bin (2.26-6) ...

+------------------------------------------------------------------------------+
| Fetch source files                                                           |
+------------------------------------------------------------------------------+


Check APT
---------

Checking available source versions...

Download source files with APT
------------------------------

Reading package lists...
NOTICE: 'cafeobj' packaging is maintained in the 'Git' version control system at:
git://git.cafeobj.org/cafeobj.git
Please use:
git clone git://git.cafeobj.org/cafeobj.git
to retrieve the latest (possibly unreleased) updates to the package.
Need to get 8169 kB of source archives.
Get:1 http://127.0.0.1:9999/debian unstable/main cafeobj 1.5.5-1 (dsc) [1759 B]
Get:2 http://127.0.0.1:9999/debian unstable/main cafeobj 1.5.5-1 (tar) [8152 kB]
Get:3 http://127.0.0.1:9999/debian unstable/main cafeobj 1.5.5-1 (diff) [14.6 kB]
Fetched 8169 kB in 0s (42.0 MB/s)
Download complete and in download only mode
I: NOTICE: Log filtering will replace 'build/cafeobj-jXtz2b/cafeobj-1.5.5' with '<<PKGBUILDDIR>>'
I: NOTICE: Log filtering will replace 'build/cafeobj-jXtz2b' with '<<BUILDDIR>>'

+------------------------------------------------------------------------------+
| Install build-essential                                                      |
+------------------------------------------------------------------------------+


Setup apt archive
-----------------

Merged Build-Depends: build-essential, fakeroot
Filtered Build-Depends: build-essential, fakeroot
dpkg-deb: building package 'sbuild-build-depends-core-dummy' in '/<<BUILDDIR>>/resolver-jmGtJR/apt_archive/sbuild-build-depends-core-dummy.deb'.
dpkg-scanpackages: warning: Packages in archive but missing from override file:
dpkg-scanpackages: warning:   sbuild-build-depends-core-dummy
dpkg-scanpackages: info: Wrote 1 entries to output Packages file.
Ign:1 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ InRelease
Get:2 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ Release [957 B]
Ign:3 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ Release.gpg
Get:4 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ Sources [349 B]
Get:5 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ Packages [434 B]
Fetched 1740 B in 0s (118 kB/s)
Reading package lists...
Reading package lists...

Install core build dependencies (apt-based resolver)
----------------------------------------------------

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following NEW packages will be installed:
  sbuild-build-depends-core-dummy
0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.
Need to get 852 B of archives.
After this operation, 0 B of additional disk space will be used.
Get:1 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ sbuild-build-depends-core-dummy 0.invalid.0 [852 B]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 852 B in 0s (0 B/s)
Selecting previously unselected package sbuild-build-depends-core-dummy.
(Reading database ... 10722 files and directories currently installed.)
Preparing to unpack .../sbuild-build-depends-core-dummy_0.invalid.0_amd64.deb ...
Unpacking sbuild-build-depends-core-dummy (0.invalid.0) ...
Setting up sbuild-build-depends-core-dummy (0.invalid.0) ...

+------------------------------------------------------------------------------+
| Check architectures                                                          |
+------------------------------------------------------------------------------+

Arch check ok (amd64 included in any all)

+------------------------------------------------------------------------------+
| Install package build dependencies                                           |
+------------------------------------------------------------------------------+


Setup apt archive
-----------------

Merged Build-Depends: debhelper (>= 8.1.0~), sbcl, fonts-mplus, fonts-freefont-otf, texlive-latex-recommended, texlive-fonts-recommended, texlive-latex-extra, texlive-bibtex-extra, texlive-xetex, lmodern, pandoc, pandoc-citeproc, texlive-generic-extra, imagemagick, fonts-motoya-l-maruberi, texlive-extra-utils, ghostscript
Filtered Build-Depends: debhelper (>= 8.1.0~), sbcl, fonts-mplus, fonts-freefont-otf, texlive-latex-recommended, texlive-fonts-recommended, texlive-latex-extra, texlive-bibtex-extra, texlive-xetex, lmodern, pandoc, pandoc-citeproc, texlive-generic-extra, imagemagick, fonts-motoya-l-maruberi, texlive-extra-utils, ghostscript
dpkg-deb: building package 'sbuild-build-depends-cafeobj-dummy' in '/<<BUILDDIR>>/resolver-jmGtJR/apt_archive/sbuild-build-depends-cafeobj-dummy.deb'.
dpkg-scanpackages: warning: Packages in archive but missing from override file:
dpkg-scanpackages: warning:   sbuild-build-depends-cafeobj-dummy sbuild-build-depends-core-dummy
dpkg-scanpackages: info: Wrote 2 entries to output Packages file.
Ign:1 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ InRelease
Get:2 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ Release [963 B]
Ign:3 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ Release.gpg
Get:4 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ Sources [621 B]
Get:5 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ Packages [702 B]
Fetched 2286 B in 0s (157 kB/s)
Reading package lists...
Reading package lists...

Install cafeobj build dependencies (apt-based resolver)
-------------------------------------------------------

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  autoconf automake autopoint autotools-dev bsdmainutils debhelper
  dh-autoreconf dh-strip-nondeterminism file fontconfig-config
  fonts-dejavu-core fonts-freefont-otf fonts-lmodern fonts-motoya-l-maruberi
  fonts-mplus gettext gettext-base ghostscript groff-base hicolor-icon-theme
  imagemagick imagemagick-6-common imagemagick-6.q16 intltool-debian
  libarchive-zip-perl libavahi-client3 libavahi-common-data libavahi-common3
  libbibutils2 libcairo2 libcroco3 libcups2 libcupsimage2 libdatrie1
  libdbus-1-3 libexpat1 libfftw3-double3 libfile-stripnondeterminism-perl
  libfontconfig1 libfreetype6 libghc-pandoc-citeproc-data libglib2.0-0
  libgraphite2-3 libgs9 libgs9-common libgssapi-krb5-2 libharfbuzz-icu0
  libharfbuzz0b libice6 libicu57 libidn11 libijs-0.35 libjbig0 libjbig2dec0
  libjpeg62-turbo libk5crypto3 libkeyutils1 libkpathsea6 libkrb5-3
  libkrb5support0 liblcms2-2 liblqr-1-0 libltdl7 liblua5.1-0 libluajit-5.1-2
  libluajit-5.1-common libmagic-mgc libmagic1 libmagickcore-6.q16-3
  libmagickwand-6.q16-3 libmime-charset-perl libnspr4 libnss3 libopenjp2-7
  libpaper-utils libpaper1 libpipeline1 libpixman-1-0 libpng16-16 libpoppler72
  libpotrace0 libptexenc1 libpython-stdlib libpython2.7-minimal
  libpython2.7-stdlib libreadline7 libsigsegv2 libsm6 libsombok3 libsqlite3-0
  libssl1.1 libsynctex1 libtexlua52 libtexluajit2 libthai-data libthai0
  libtiff5 libtimedate-perl libtool libunicode-linebreak-perl libx11-6
  libx11-data libxau6 libxaw7 libxcb-render0 libxcb-shm0 libxcb1 libxdmcp6
  libxext6 libxi6 libxml2 libxmu6 libxpm4 libxrender1 libxt6 libyaml-0-2
  libzzip-0-13 lmodern lsb-base m4 man-db mime-support pandoc pandoc-citeproc
  pandoc-data po-debconf poppler-data preview-latex-style python
  python-minimal python2.7 python2.7-minimal readline-common sbcl t1utils
  tex-common texlive-base texlive-bibtex-extra texlive-binaries
  texlive-extra-utils texlive-fonts-recommended texlive-generic-extra
  texlive-latex-base texlive-latex-extra texlive-latex-recommended
  texlive-pictures texlive-plain-generic texlive-xetex tipa ucf x11-common
  xdg-utils
Suggested packages:
  autoconf-archive gnu-standards autoconf-doc wamerican | wordlist whois
  vacation dh-make dwz gettext-doc libasprintf-dev libgettextpo-dev
  ghostscript-x groff imagemagick-doc autotrace cups-bsd | lpr | lprng curl
  enscript ffmpeg gimp gnuplot grads graphviz hp2xx html2ps libwmf-bin mplayer
  povray radiance sane-utils transfig ufraw-batch cups-common libfftw3-bin
  libfftw3-dev krb5-doc krb5-user liblcms2-utils libmagickcore-6.q16-3-extra
  libencode-hanextra-perl libpod2-base-perl libtool-doc gfortran
  | fortran95-compiler gcj-jdk m4-doc less www-browser apparmor texlive-luatex
  context wkhtmltopdf libmail-box-perl poppler-utils fonts-japanese-mincho
  | fonts-ipafont-mincho fonts-japanese-gothic | fonts-ipafont-gothic
  fonts-arphic-ukai fonts-arphic-uming fonts-nanum python-doc python-tk
  python2.7-doc binfmt-support readline-doc sbcl-doc sbcl-source slime perl-tk
  xpdf-reader | pdf-viewer chktex dvidvi dvipng fragmaster lacheck latexdiff
  latexmk purifyeps xindy texlive-fonts-recommended-doc texlive-latex-base-doc
  python-pygments icc-profiles libfile-which-perl
  libspreadsheet-parseexcel-perl texlive-latex-extra-doc
  texlive-latex-recommended-doc texlive-pstricks dot2tex prerex ruby-tcltk
  | libtcltk-ruby texlive-pictures-doc vprerex
Recommended packages:
  curl | wget | lynx-cur gsfonts libmagickcore-6.q16-3-extra netpbm
  libcupsfilters1 dbus libarchive-cpio-perl libglib2.0-data shared-mime-info
  xdg-user-dirs fonts-droid-fallback krb5-locales libltdl-dev
  libmail-sendmail-perl binfmt-support libfile-homedir-perl libyaml-tiny-perl
  ruby | ruby-interpreter tex-gyre tk libfile-mimeinfo-perl libnet-dbus-perl
  libx11-protocol-perl x11-utils x11-xserver-utils
The following NEW packages will be installed:
  autoconf automake autopoint autotools-dev bsdmainutils debhelper
  dh-autoreconf dh-strip-nondeterminism file fontconfig-config
  fonts-dejavu-core fonts-freefont-otf fonts-lmodern fonts-motoya-l-maruberi
  fonts-mplus gettext gettext-base ghostscript groff-base hicolor-icon-theme
  imagemagick imagemagick-6-common imagemagick-6.q16 intltool-debian
  libarchive-zip-perl libavahi-client3 libavahi-common-data libavahi-common3
  libbibutils2 libcairo2 libcroco3 libcups2 libcupsimage2 libdatrie1
  libdbus-1-3 libexpat1 libfftw3-double3 libfile-stripnondeterminism-perl
  libfontconfig1 libfreetype6 libghc-pandoc-citeproc-data libglib2.0-0
  libgraphite2-3 libgs9 libgs9-common libgssapi-krb5-2 libharfbuzz-icu0
  libharfbuzz0b libice6 libicu57 libidn11 libijs-0.35 libjbig0 libjbig2dec0
  libjpeg62-turbo libk5crypto3 libkeyutils1 libkpathsea6 libkrb5-3
  libkrb5support0 liblcms2-2 liblqr-1-0 libltdl7 liblua5.1-0 libluajit-5.1-2
  libluajit-5.1-common libmagic-mgc libmagic1 libmagickcore-6.q16-3
  libmagickwand-6.q16-3 libmime-charset-perl libnspr4 libnss3 libopenjp2-7
  libpaper-utils libpaper1 libpipeline1 libpixman-1-0 libpng16-16 libpoppler72
  libpotrace0 libptexenc1 libpython-stdlib libpython2.7-minimal
  libpython2.7-stdlib libreadline7 libsigsegv2 libsm6 libsombok3 libsqlite3-0
  libssl1.1 libsynctex1 libtexlua52 libtexluajit2 libthai-data libthai0
  libtiff5 libtimedate-perl libtool libunicode-linebreak-perl libx11-6
  libx11-data libxau6 libxaw7 libxcb-render0 libxcb-shm0 libxcb1 libxdmcp6
  libxext6 libxi6 libxml2 libxmu6 libxpm4 libxrender1 libxt6 libyaml-0-2
  libzzip-0-13 lmodern lsb-base m4 man-db mime-support pandoc pandoc-citeproc
  pandoc-data po-debconf poppler-data preview-latex-style python
  python-minimal python2.7 python2.7-minimal readline-common sbcl
  sbuild-build-depends-cafeobj-dummy t1utils tex-common texlive-base
  texlive-bibtex-extra texlive-binaries texlive-extra-utils
  texlive-fonts-recommended texlive-generic-extra texlive-latex-base
  texlive-latex-extra texlive-latex-recommended texlive-pictures
  texlive-plain-generic texlive-xetex tipa ucf x11-common xdg-utils
0 upgraded, 153 newly installed, 0 to remove and 0 not upgraded.
Need to get 298 MB of archives.
After this operation, 870 MB of additional disk space will be used.
Get:1 copy:/<<BUILDDIR>>/resolver-jmGtJR/apt_archive ./ sbuild-build-depends-cafeobj-dummy 0.invalid.0 [984 B]
Get:2 http://127.0.0.1:9999/debian unstable/main amd64 groff-base amd64 1.22.3-9 [1160 kB]
Get:3 http://127.0.0.1:9999/debian unstable/main amd64 bsdmainutils amd64 11.1.2 [190 kB]
Get:4 http://127.0.0.1:9999/debian unstable/main amd64 libpipeline1 amd64 1.5.0-1 [29.0 kB]
Get:5 http://127.0.0.1:9999/debian unstable/main amd64 man-db amd64 2.8.0-2 [1170 kB]
Get:6 http://127.0.0.1:9999/debian unstable/main amd64 libpython2.7-minimal amd64 2.7.14-6 [393 kB]
Get:7 http://127.0.0.1:9999/debian unstable/main amd64 python2.7-minimal amd64 2.7.14-6 [1353 kB]
Get:8 http://127.0.0.1:9999/debian unstable/main amd64 python-minimal amd64 2.7.14-4 [41.0 kB]
Get:9 http://127.0.0.1:9999/debian unstable/main amd64 mime-support all 3.60 [36.7 kB]
Get:10 http://127.0.0.1:9999/debian unstable/main amd64 libexpat1 amd64 2.2.5-3 [96.8 kB]
Get:11 http://127.0.0.1:9999/debian unstable/main amd64 readline-common all 7.0-3 [70.4 kB]
Get:12 http://127.0.0.1:9999/debian unstable/main amd64 libreadline7 amd64 7.0-3 [151 kB]
Get:13 http://127.0.0.1:9999/debian unstable/main amd64 libsqlite3-0 amd64 3.22.0-1 [595 kB]
Get:14 http://127.0.0.1:9999/debian unstable/main amd64 libssl1.1 amd64 1.1.0g-2 [1346 kB]
Get:15 http://127.0.0.1:9999/debian unstable/main amd64 libpython2.7-stdlib amd64 2.7.14-6 [1912 kB]
Get:16 http://127.0.0.1:9999/debian unstable/main amd64 python2.7 amd64 2.7.14-6 [293 kB]
Get:17 http://127.0.0.1:9999/debian unstable/main amd64 libpython-stdlib amd64 2.7.14-4 [20.4 kB]
Get:18 http://127.0.0.1:9999/debian unstable/main amd64 python amd64 2.7.14-4 [155 kB]
Get:19 http://127.0.0.1:9999/debian unstable/main amd64 fonts-motoya-l-maruberi all 1.01-4 [1458 kB]
Get:20 http://127.0.0.1:9999/debian unstable/main amd64 libfftw3-double3 amd64 3.3.7-1 [740 kB]
Get:21 http://127.0.0.1:9999/debian unstable/main amd64 libpng16-16 amd64 1.6.34-1 [287 kB]
Get:22 http://127.0.0.1:9999/debian unstable/main amd64 libfreetype6 amd64 2.8.1-1 [461 kB]
Get:23 http://127.0.0.1:9999/debian unstable/main amd64 ucf all 3.0036 [70.2 kB]
Get:24 http://127.0.0.1:9999/debian unstable/main amd64 fonts-dejavu-core all 2.37-1 [1068 kB]
Get:25 http://127.0.0.1:9999/debian unstable/main amd64 fontconfig-config all 2.12.6-0.1 [304 kB]
Get:26 http://127.0.0.1:9999/debian unstable/main amd64 libfontconfig1 amd64 2.12.6-0.1 [368 kB]
Get:27 http://127.0.0.1:9999/debian unstable/main amd64 libjbig0 amd64 2.1-3.1+b2 [31.0 kB]
Get:28 http://127.0.0.1:9999/debian unstable/main amd64 libjpeg62-turbo amd64 1:1.5.2-2+b1 [134 kB]
Get:29 http://127.0.0.1:9999/debian unstable/main amd64 liblcms2-2 amd64 2.9-1 [145 kB]
Get:30 http://127.0.0.1:9999/debian unstable/main amd64 libglib2.0-0 amd64 2.54.3-2 [2822 kB]
Get:31 http://127.0.0.1:9999/debian unstable/main amd64 liblqr-1-0 amd64 0.4.2-2.1 [29.1 kB]
Get:32 http://127.0.0.1:9999/debian unstable/main amd64 libltdl7 amd64 2.4.6-2 [389 kB]
Get:33 http://127.0.0.1:9999/debian unstable/main amd64 libopenjp2-7 amd64 2.3.0-1 [163 kB]
Get:34 http://127.0.0.1:9999/debian unstable/main amd64 libtiff5 amd64 4.0.9-3 [245 kB]
Get:35 http://127.0.0.1:9999/debian unstable/main amd64 libxau6 amd64 1:1.0.8-1+b2 [19.9 kB]
Get:36 http://127.0.0.1:9999/debian unstable/main amd64 libxdmcp6 amd64 1:1.1.2-3 [26.3 kB]
Get:37 http://127.0.0.1:9999/debian unstable/main amd64 libxcb1 amd64 1.12-1 [133 kB]
Get:38 http://127.0.0.1:9999/debian unstable/main amd64 libx11-data all 2:1.6.4-3 [290 kB]
Get:39 http://127.0.0.1:9999/debian unstable/main amd64 libx11-6 amd64 2:1.6.4-3 [747 kB]
Get:40 http://127.0.0.1:9999/debian unstable/main amd64 libxext6 amd64 2:1.3.3-1+b2 [52.5 kB]
Get:41 http://127.0.0.1:9999/debian unstable/main amd64 libicu57 amd64 57.1-8 [7699 kB]
Get:42 http://127.0.0.1:9999/debian unstable/main amd64 libxml2 amd64 2.9.4+dfsg1-6.1 [725 kB]
Get:43 http://127.0.0.1:9999/debian unstable/main amd64 imagemagick-6-common all 8:6.9.7.4+dfsg-16.1 [186 kB]
Get:44 http://127.0.0.1:9999/debian unstable/main amd64 libmagickcore-6.q16-3 amd64 8:6.9.7.4+dfsg-16.1 [1744 kB]
Get:45 http://127.0.0.1:9999/debian unstable/main amd64 libmagickwand-6.q16-3 amd64 8:6.9.7.4+dfsg-16.1 [423 kB]
Get:46 http://127.0.0.1:9999/debian unstable/main amd64 poppler-data all 0.4.8-2 [1490 kB]
Get:47 http://127.0.0.1:9999/debian unstable/main amd64 tex-common all 6.09 [53.2 kB]
Get:48 http://127.0.0.1:9999/debian unstable/main amd64 libmagic-mgc amd64 1:5.32-1 [225 kB]
Get:49 http://127.0.0.1:9999/debian unstable/main amd64 libmagic1 amd64 1:5.32-1 [111 kB]
Get:50 http://127.0.0.1:9999/debian unstable/main amd64 file amd64 1:5.32-1 [64.4 kB]
Get:51 http://127.0.0.1:9999/debian unstable/main amd64 gettext-base amd64 0.19.8.1-4 [122 kB]
Get:52 http://127.0.0.1:9999/debian unstable/main amd64 libsigsegv2 amd64 2.12-1 [32.7 kB]
Get:53 http://127.0.0.1:9999/debian unstable/main amd64 m4 amd64 1.4.18-1 [202 kB]
Get:54 http://127.0.0.1:9999/debian unstable/main amd64 autoconf all 2.69-11 [341 kB]
Get:55 http://127.0.0.1:9999/debian unstable/main amd64 autotools-dev all 20171216.1 [75.9 kB]
Get:56 http://127.0.0.1:9999/debian unstable/main amd64 automake all 1:1.15.1-3 [736 kB]
Get:57 http://127.0.0.1:9999/debian unstable/main amd64 autopoint all 0.19.8.1-4 [434 kB]
Get:58 http://127.0.0.1:9999/debian unstable/main amd64 libtool all 2.4.6-2 [545 kB]
Get:59 http://127.0.0.1:9999/debian unstable/main amd64 dh-autoreconf all 16 [16.3 kB]
Get:60 http://127.0.0.1:9999/debian unstable/main amd64 libarchive-zip-perl all 1.60-1 [95.6 kB]
Get:61 http://127.0.0.1:9999/debian unstable/main amd64 libfile-stripnondeterminism-perl all 0.040-1 [18.4 kB]
Get:62 http://127.0.0.1:9999/debian unstable/main amd64 libtimedate-perl all 2.3000-2 [42.2 kB]
Get:63 http://127.0.0.1:9999/debian unstable/main amd64 dh-strip-nondeterminism all 0.040-1 [11.8 kB]
Get:64 http://127.0.0.1:9999/debian unstable/main amd64 libcroco3 amd64 0.6.12-2 [144 kB]
Get:65 http://127.0.0.1:9999/debian unstable/main amd64 gettext amd64 0.19.8.1-4 [1302 kB]
Get:66 http://127.0.0.1:9999/debian unstable/main amd64 intltool-debian all 0.35.0+20060710.4 [26.3 kB]
Get:67 http://127.0.0.1:9999/debian unstable/main amd64 po-debconf all 1.0.20 [247 kB]
Get:68 http://127.0.0.1:9999/debian unstable/main amd64 debhelper all 11.1.4 [1005 kB]
Get:69 http://127.0.0.1:9999/debian unstable/main amd64 fonts-freefont-otf all 20120503-7 [3171 kB]
Get:70 http://127.0.0.1:9999/debian unstable/main amd64 fonts-lmodern all 2.004.5-3 [4540 kB]
Get:71 http://127.0.0.1:9999/debian unstable/main amd64 fonts-mplus all 063-1 [26.9 MB]
Get:72 http://127.0.0.1:9999/debian unstable/main amd64 libavahi-common-data amd64 0.7-3.1 [122 kB]
Get:73 http://127.0.0.1:9999/debian unstable/main amd64 libavahi-common3 amd64 0.7-3.1 [54.3 kB]
Get:74 http://127.0.0.1:9999/debian unstable/main amd64 libdbus-1-3 amd64 1.12.2-1 [208 kB]
Get:75 http://127.0.0.1:9999/debian unstable/main amd64 libavahi-client3 amd64 0.7-3.1 [57.6 kB]
Get:76 http://127.0.0.1:9999/debian unstable/main amd64 libkeyutils1 amd64 1.5.9-9.2 [12.9 kB]
Get:77 http://127.0.0.1:9999/debian unstable/main amd64 libkrb5support0 amd64 1.16-2 [62.8 kB]
Get:78 http://127.0.0.1:9999/debian unstable/main amd64 libk5crypto3 amd64 1.16-2 [121 kB]
Get:79 http://127.0.0.1:9999/debian unstable/main amd64 libkrb5-3 amd64 1.16-2 [316 kB]
Get:80 http://127.0.0.1:9999/debian unstable/main amd64 libgssapi-krb5-2 amd64 1.16-2 [158 kB]
Get:81 http://127.0.0.1:9999/debian unstable/main amd64 libcups2 amd64 2.2.6-4 [319 kB]
Get:82 http://127.0.0.1:9999/debian unstable/main amd64 libcupsimage2 amd64 2.2.6-4 [128 kB]
Get:83 http://127.0.0.1:9999/debian unstable/main amd64 libidn11 amd64 1.33-2.1 [116 kB]
Get:84 http://127.0.0.1:9999/debian unstable/main amd64 libijs-0.35 amd64 0.35-12 [18.4 kB]
Get:85 http://127.0.0.1:9999/debian unstable/main amd64 libjbig2dec0 amd64 0.13-5 [60.1 kB]
Get:86 http://127.0.0.1:9999/debian unstable/main amd64 libpaper1 amd64 1.1.24+nmu5 [21.6 kB]
Get:87 http://127.0.0.1:9999/debian unstable/main amd64 libgs9-common all 9.22~dfsg-1 [5242 kB]
Get:88 http://127.0.0.1:9999/debian unstable/main amd64 libgs9 amd64 9.22~dfsg-1 [2163 kB]
Get:89 http://127.0.0.1:9999/debian unstable/main amd64 ghostscript amd64 9.22~dfsg-1 [95.6 kB]
Get:90 http://127.0.0.1:9999/debian unstable/main amd64 hicolor-icon-theme all 0.17-1 [11.5 kB]
Get:91 http://127.0.0.1:9999/debian unstable/main amd64 imagemagick-6.q16 amd64 8:6.9.7.4+dfsg-16.1 [564 kB]
Get:92 http://127.0.0.1:9999/debian unstable/main amd64 imagemagick amd64 8:6.9.7.4+dfsg-16.1 [143 kB]
Get:93 http://127.0.0.1:9999/debian unstable/main amd64 libbibutils2 amd64 4.12-5+b2 [212 kB]
Get:94 http://127.0.0.1:9999/debian unstable/main amd64 libpixman-1-0 amd64 0.34.0-2 [529 kB]
Get:95 http://127.0.0.1:9999/debian unstable/main amd64 libxcb-render0 amd64 1.12-1 [105 kB]
Get:96 http://127.0.0.1:9999/debian unstable/main amd64 libxcb-shm0 amd64 1.12-1 [95.9 kB]
Get:97 http://127.0.0.1:9999/debian unstable/main amd64 libxrender1 amd64 1:0.9.10-1 [33.0 kB]
Get:98 http://127.0.0.1:9999/debian unstable/main amd64 libcairo2 amd64 1.15.10-1 [663 kB]
Get:99 http://127.0.0.1:9999/debian unstable/main amd64 libdatrie1 amd64 0.2.10-6 [36.5 kB]
Get:100 http://127.0.0.1:9999/debian unstable/main amd64 libghc-pandoc-citeproc-data all 0.10.5.1-1 [70.0 kB]
Get:101 http://127.0.0.1:9999/debian unstable/main amd64 libgraphite2-3 amd64 1.3.10-8 [84.2 kB]
Get:102 http://127.0.0.1:9999/debian unstable/main amd64 libharfbuzz0b amd64 1.7.2-1 [738 kB]
Get:103 http://127.0.0.1:9999/debian unstable/main amd64 libharfbuzz-icu0 amd64 1.7.2-1 [513 kB]
Get:104 http://127.0.0.1:9999/debian unstable/main amd64 lsb-base all 9.20170808 [28.1 kB]
Get:105 http://127.0.0.1:9999/debian unstable/main amd64 x11-common all 1:7.7+19 [251 kB]
Get:106 http://127.0.0.1:9999/debian unstable/main amd64 libice6 amd64 2:1.0.9-2 [58.7 kB]
Get:107 http://127.0.0.1:9999/debian unstable/main amd64 libkpathsea6 amd64 2017.20170613.44572-8+b1 [162 kB]
Get:108 http://127.0.0.1:9999/debian unstable/main amd64 liblua5.1-0 amd64 5.1.5-8.1+b2 [111 kB]
Get:109 http://127.0.0.1:9999/debian unstable/main amd64 libluajit-5.1-common all 2.1.0~beta3+dfsg-5.1 [46.7 kB]
Get:110 http://127.0.0.1:9999/debian unstable/main amd64 libluajit-5.1-2 amd64 2.1.0~beta3+dfsg-5.1 [230 kB]
Get:111 http://127.0.0.1:9999/debian unstable/main amd64 libmime-charset-perl all 1.012.2-1 [35.4 kB]
Get:112 http://127.0.0.1:9999/debian unstable/main amd64 libnspr4 amd64 2:4.18-1 [117 kB]
Get:113 http://127.0.0.1:9999/debian unstable/main amd64 libnss3 amd64 2:3.35-2 [1147 kB]
Get:114 http://127.0.0.1:9999/debian unstable/main amd64 libpaper-utils amd64 1.1.24+nmu5 [17.6 kB]
Get:115 http://127.0.0.1:9999/debian unstable/main amd64 libpoppler72 amd64 0.61.1-2 [1338 kB]
Get:116 http://127.0.0.1:9999/debian unstable/main amd64 libpotrace0 amd64 1.14-2 [25.7 kB]
Get:117 http://127.0.0.1:9999/debian unstable/main amd64 libptexenc1 amd64 2017.20170613.44572-8+b1 [58.9 kB]
Get:118 http://127.0.0.1:9999/debian unstable/main amd64 libsm6 amd64 2:1.2.2-1+b3 [33.3 kB]
Get:119 http://127.0.0.1:9999/debian unstable/main amd64 libthai-data all 0.1.27-1 [168 kB]
Get:120 http://127.0.0.1:9999/debian unstable/main amd64 libthai0 amd64 0.1.27-1 [53.1 kB]
Get:121 http://127.0.0.1:9999/debian unstable/main amd64 libsombok3 amd64 2.4.0-1+b2 [31.4 kB]
Get:122 http://127.0.0.1:9999/debian unstable/main amd64 libsynctex1 amd64 2017.20170613.44572-8+b1 [66.0 kB]
Get:123 http://127.0.0.1:9999/debian unstable/main amd64 libtexlua52 amd64 2017.20170613.44572-8+b1 [112 kB]
Get:124 http://127.0.0.1:9999/debian unstable/main amd64 libtexluajit2 amd64 2017.20170613.44572-8+b1 [252 kB]
Get:125 http://127.0.0.1:9999/debian unstable/main amd64 libunicode-linebreak-perl amd64 0.0.20160702-1+b3 [102 kB]
Get:126 http://127.0.0.1:9999/debian unstable/main amd64 libxt6 amd64 1:1.1.5-1 [188 kB]
Get:127 http://127.0.0.1:9999/debian unstable/main amd64 libxmu6 amd64 2:1.1.2-2 [60.3 kB]
Get:128 http://127.0.0.1:9999/debian unstable/main amd64 libxpm4 amd64 1:3.5.12-1 [49.1 kB]
Get:129 http://127.0.0.1:9999/debian unstable/main amd64 libxaw7 amd64 2:1.0.13-1+b2 [201 kB]
Get:130 http://127.0.0.1:9999/debian unstable/main amd64 libxi6 amd64 2:1.7.9-1 [82.6 kB]
Get:131 http://127.0.0.1:9999/debian unstable/main amd64 libyaml-0-2 amd64 0.1.7-2 [47.6 kB]
Get:132 http://127.0.0.1:9999/debian unstable/main amd64 libzzip-0-13 amd64 0.13.62-3.1 [55.4 kB]
Get:133 http://127.0.0.1:9999/debian unstable/main amd64 lmodern all 2.004.5-3 [9461 kB]
Get:134 http://127.0.0.1:9999/debian unstable/main amd64 pandoc-data all 1.19.2.4~dfsg-1 [236 kB]
Get:135 http://127.0.0.1:9999/debian unstable/main amd64 pandoc amd64 1.19.2.4~dfsg-1+b3 [6867 kB]
Get:136 http://127.0.0.1:9999/debian unstable/main amd64 pandoc-citeproc amd64 0.10.5.1-1+b3 [5584 kB]
Get:137 http://127.0.0.1:9999/debian unstable/main amd64 preview-latex-style all 11.91-1 [201 kB]
Get:138 http://127.0.0.1:9999/debian unstable/main amd64 sbcl amd64 2:1.4.4-1 [8780 kB]
Get:139 http://127.0.0.1:9999/debian unstable/main amd64 t1utils amd64 1.41-2 [62.0 kB]
Get:140 http://127.0.0.1:9999/debian unstable/main amd64 texlive-binaries amd64 2017.20170613.44572-8+b1 [8031 kB]
Get:141 http://127.0.0.1:9999/debian unstable/main amd64 xdg-utils all 1.1.2-1 [72.7 kB]
Get:142 http://127.0.0.1:9999/debian unstable/main amd64 texlive-base all 2017.20180110-1 [18.7 MB]
Get:143 http://127.0.0.1:9999/debian unstable/main amd64 texlive-latex-base all 2017.20180110-1 [979 kB]
Get:144 http://127.0.0.1:9999/debian unstable/main amd64 texlive-bibtex-extra all 2017.20180110-1 [55.5 MB]
Get:145 http://127.0.0.1:9999/debian unstable/main amd64 texlive-extra-utils all 2017.20180110-1 [21.2 MB]
Get:146 http://127.0.0.1:9999/debian unstable/main amd64 texlive-fonts-recommended all 2017.20180110-1 [5294 kB]
Get:147 http://127.0.0.1:9999/debian unstable/main amd64 texlive-plain-generic all 2017.20180110-1 [23.7 MB]
Get:148 http://127.0.0.1:9999/debian unstable/main amd64 texlive-generic-extra all 2017.20180110-1 [31.2 kB]
Get:149 http://127.0.0.1:9999/debian unstable/main amd64 texlive-latex-recommended all 2017.20180110-1 [14.9 MB]
Get:150 http://127.0.0.1:9999/debian unstable/main amd64 texlive-pictures all 2017.20180110-1 [4037 kB]
Get:151 http://127.0.0.1:9999/debian unstable/main amd64 texlive-latex-extra all 2017.20180110-1 [10.6 MB]
Get:152 http://127.0.0.1:9999/debian unstable/main amd64 tipa all 2:1.3-20 [2972 kB]
Get:153 http://127.0.0.1:9999/debian unstable/main amd64 texlive-xetex all 2017.20180110-1 [10.6 MB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 298 MB in 3s (93.9 MB/s)
Selecting previously unselected package groff-base.
(Reading database ... 10722 files and directories currently installed.)
Preparing to unpack .../00-groff-base_1.22.3-9_amd64.deb ...
Unpacking groff-base (1.22.3-9) ...
Selecting previously unselected package bsdmainutils.
Preparing to unpack .../01-bsdmainutils_11.1.2_amd64.deb ...
Unpacking bsdmainutils (11.1.2) ...
Selecting previously unselected package libpipeline1:amd64.
Preparing to unpack .../02-libpipeline1_1.5.0-1_amd64.deb ...
Unpacking libpipeline1:amd64 (1.5.0-1) ...
Selecting previously unselected package man-db.
Preparing to unpack .../03-man-db_2.8.0-2_amd64.deb ...
Unpacking man-db (2.8.0-2) ...
Selecting previously unselected package libpython2.7-minimal:amd64.
Preparing to unpack .../04-libpython2.7-minimal_2.7.14-6_amd64.deb ...
Unpacking libpython2.7-minimal:amd64 (2.7.14-6) ...
Selecting previously unselected package python2.7-minimal.
Preparing to unpack .../05-python2.7-minimal_2.7.14-6_amd64.deb ...
Unpacking python2.7-minimal (2.7.14-6) ...
Selecting previously unselected package python-minimal.
Preparing to unpack .../06-python-minimal_2.7.14-4_amd64.deb ...
Unpacking python-minimal (2.7.14-4) ...
Selecting previously unselected package mime-support.
Preparing to unpack .../07-mime-support_3.60_all.deb ...
Unpacking mime-support (3.60) ...
Selecting previously unselected package libexpat1:amd64.
Preparing to unpack .../08-libexpat1_2.2.5-3_amd64.deb ...
Unpacking libexpat1:amd64 (2.2.5-3) ...
Selecting previously unselected package readline-common.
Preparing to unpack .../09-readline-common_7.0-3_all.deb ...
Unpacking readline-common (7.0-3) ...
Selecting previously unselected package libreadline7:amd64.
Preparing to unpack .../10-libreadline7_7.0-3_amd64.deb ...
Unpacking libreadline7:amd64 (7.0-3) ...
Selecting previously unselected package libsqlite3-0:amd64.
Preparing to unpack .../11-libsqlite3-0_3.22.0-1_amd64.deb ...
Unpacking libsqlite3-0:amd64 (3.22.0-1) ...
Selecting previously unselected package libssl1.1:amd64.
Preparing to unpack .../12-libssl1.1_1.1.0g-2_amd64.deb ...
Unpacking libssl1.1:amd64 (1.1.0g-2) ...
Selecting previously unselected package libpython2.7-stdlib:amd64.
Preparing to unpack .../13-libpython2.7-stdlib_2.7.14-6_amd64.deb ...
Unpacking libpython2.7-stdlib:amd64 (2.7.14-6) ...
Selecting previously unselected package python2.7.
Preparing to unpack .../14-python2.7_2.7.14-6_amd64.deb ...
Unpacking python2.7 (2.7.14-6) ...
Selecting previously unselected package libpython-stdlib:amd64.
Preparing to unpack .../15-libpython-stdlib_2.7.14-4_amd64.deb ...
Unpacking libpython-stdlib:amd64 (2.7.14-4) ...
Setting up libpython2.7-minimal:amd64 (2.7.14-6) ...
Setting up python2.7-minimal (2.7.14-6) ...
Setting up python-minimal (2.7.14-4) ...
Selecting previously unselected package python.
(Reading database ... 12152 files and directories currently installed.)
Preparing to unpack .../000-python_2.7.14-4_amd64.deb ...
Unpacking python (2.7.14-4) ...
Selecting previously unselected package fonts-motoya-l-maruberi.
Preparing to unpack .../001-fonts-motoya-l-maruberi_1.01-4_all.deb ...
Unpacking fonts-motoya-l-maruberi (1.01-4) ...
Selecting previously unselected package libfftw3-double3:amd64.
Preparing to unpack .../002-libfftw3-double3_3.3.7-1_amd64.deb ...
Unpacking libfftw3-double3:amd64 (3.3.7-1) ...
Selecting previously unselected package libpng16-16:amd64.
Preparing to unpack .../003-libpng16-16_1.6.34-1_amd64.deb ...
Unpacking libpng16-16:amd64 (1.6.34-1) ...
Selecting previously unselected package libfreetype6:amd64.
Preparing to unpack .../004-libfreetype6_2.8.1-1_amd64.deb ...
Unpacking libfreetype6:amd64 (2.8.1-1) ...
Selecting previously unselected package ucf.
Preparing to unpack .../005-ucf_3.0036_all.deb ...
Moving old data out of the way
Unpacking ucf (3.0036) ...
Selecting previously unselected package fonts-dejavu-core.
Preparing to unpack .../006-fonts-dejavu-core_2.37-1_all.deb ...
Unpacking fonts-dejavu-core (2.37-1) ...
Selecting previously unselected package fontconfig-config.
Preparing to unpack .../007-fontconfig-config_2.12.6-0.1_all.deb ...
Unpacking fontconfig-config (2.12.6-0.1) ...
Selecting previously unselected package libfontconfig1:amd64.
Preparing to unpack .../008-libfontconfig1_2.12.6-0.1_amd64.deb ...
Unpacking libfontconfig1:amd64 (2.12.6-0.1) ...
Selecting previously unselected package libjbig0:amd64.
Preparing to unpack .../009-libjbig0_2.1-3.1+b2_amd64.deb ...
Unpacking libjbig0:amd64 (2.1-3.1+b2) ...
Selecting previously unselected package libjpeg62-turbo:amd64.
Preparing to unpack .../010-libjpeg62-turbo_1%3a1.5.2-2+b1_amd64.deb ...
Unpacking libjpeg62-turbo:amd64 (1:1.5.2-2+b1) ...
Selecting previously unselected package liblcms2-2:amd64.
Preparing to unpack .../011-liblcms2-2_2.9-1_amd64.deb ...
Unpacking liblcms2-2:amd64 (2.9-1) ...
Selecting previously unselected package libglib2.0-0:amd64.
Preparing to unpack .../012-libglib2.0-0_2.54.3-2_amd64.deb ...
Unpacking libglib2.0-0:amd64 (2.54.3-2) ...
Selecting previously unselected package liblqr-1-0:amd64.
Preparing to unpack .../013-liblqr-1-0_0.4.2-2.1_amd64.deb ...
Unpacking liblqr-1-0:amd64 (0.4.2-2.1) ...
Selecting previously unselected package libltdl7:amd64.
Preparing to unpack .../014-libltdl7_2.4.6-2_amd64.deb ...
Unpacking libltdl7:amd64 (2.4.6-2) ...
Selecting previously unselected package libopenjp2-7:amd64.
Preparing to unpack .../015-libopenjp2-7_2.3.0-1_amd64.deb ...
Unpacking libopenjp2-7:amd64 (2.3.0-1) ...
Selecting previously unselected package libtiff5:amd64.
Preparing to unpack .../016-libtiff5_4.0.9-3_amd64.deb ...
Unpacking libtiff5:amd64 (4.0.9-3) ...
Selecting previously unselected package libxau6:amd64.
Preparing to unpack .../017-libxau6_1%3a1.0.8-1+b2_amd64.deb ...
Unpacking libxau6:amd64 (1:1.0.8-1+b2) ...
Selecting previously unselected package libxdmcp6:amd64.
Preparing to unpack .../018-libxdmcp6_1%3a1.1.2-3_amd64.deb ...
Unpacking libxdmcp6:amd64 (1:1.1.2-3) ...
Selecting previously unselected package libxcb1:amd64.
Preparing to unpack .../019-libxcb1_1.12-1_amd64.deb ...
Unpacking libxcb1:amd64 (1.12-1) ...
Selecting previously unselected package libx11-data.
Preparing to unpack .../020-libx11-data_2%3a1.6.4-3_all.deb ...
Unpacking libx11-data (2:1.6.4-3) ...
Selecting previously unselected package libx11-6:amd64.
Preparing to unpack .../021-libx11-6_2%3a1.6.4-3_amd64.deb ...
Unpacking libx11-6:amd64 (2:1.6.4-3) ...
Selecting previously unselected package libxext6:amd64.
Preparing to unpack .../022-libxext6_2%3a1.3.3-1+b2_amd64.deb ...
Unpacking libxext6:amd64 (2:1.3.3-1+b2) ...
Selecting previously unselected package libicu57:amd64.
Preparing to unpack .../023-libicu57_57.1-8_amd64.deb ...
Unpacking libicu57:amd64 (57.1-8) ...
Selecting previously unselected package libxml2:amd64.
Preparing to unpack .../024-libxml2_2.9.4+dfsg1-6.1_amd64.deb ...
Unpacking libxml2:amd64 (2.9.4+dfsg1-6.1) ...
Selecting previously unselected package imagemagick-6-common.
Preparing to unpack .../025-imagemagick-6-common_8%3a6.9.7.4+dfsg-16.1_all.deb ...
Unpacking imagemagick-6-common (8:6.9.7.4+dfsg-16.1) ...
Selecting previously unselected package libmagickcore-6.q16-3:amd64.
Preparing to unpack .../026-libmagickcore-6.q16-3_8%3a6.9.7.4+dfsg-16.1_amd64.deb ...
Unpacking libmagickcore-6.q16-3:amd64 (8:6.9.7.4+dfsg-16.1) ...
Selecting previously unselected package libmagickwand-6.q16-3:amd64.
Preparing to unpack .../027-libmagickwand-6.q16-3_8%3a6.9.7.4+dfsg-16.1_amd64.deb ...
Unpacking libmagickwand-6.q16-3:amd64 (8:6.9.7.4+dfsg-16.1) ...
Selecting previously unselected package poppler-data.
Preparing to unpack .../028-poppler-data_0.4.8-2_all.deb ...
Unpacking poppler-data (0.4.8-2) ...
Selecting previously unselected package tex-common.
Preparing to unpack .../029-tex-common_6.09_all.deb ...
Unpacking tex-common (6.09) ...
Selecting previously unselected package libmagic-mgc.
Preparing to unpack .../030-libmagic-mgc_1%3a5.32-1_amd64.deb ...
Unpacking libmagic-mgc (1:5.32-1) ...
Selecting previously unselected package libmagic1:amd64.
Preparing to unpack .../031-libmagic1_1%3a5.32-1_amd64.deb ...
Unpacking libmagic1:amd64 (1:5.32-1) ...
Selecting previously unselected package file.
Preparing to unpack .../032-file_1%3a5.32-1_amd64.deb ...
Unpacking file (1:5.32-1) ...
Selecting previously unselected package gettext-base.
Preparing to unpack .../033-gettext-base_0.19.8.1-4_amd64.deb ...
Unpacking gettext-base (0.19.8.1-4) ...
Selecting previously unselected package libsigsegv2:amd64.
Preparing to unpack .../034-libsigsegv2_2.12-1_amd64.deb ...
Unpacking libsigsegv2:amd64 (2.12-1) ...
Selecting previously unselected package m4.
Preparing to unpack .../035-m4_1.4.18-1_amd64.deb ...
Unpacking m4 (1.4.18-1) ...
Selecting previously unselected package autoconf.
Preparing to unpack .../036-autoconf_2.69-11_all.deb ...
Unpacking autoconf (2.69-11) ...
Selecting previously unselected package autotools-dev.
Preparing to unpack .../037-autotools-dev_20171216.1_all.deb ...
Unpacking autotools-dev (20171216.1) ...
Selecting previously unselected package automake.
Preparing to unpack .../038-automake_1%3a1.15.1-3_all.deb ...
Unpacking automake (1:1.15.1-3) ...
Selecting previously unselected package autopoint.
Preparing to unpack .../039-autopoint_0.19.8.1-4_all.deb ...
Unpacking autopoint (0.19.8.1-4) ...
Selecting previously unselected package libtool.
Preparing to unpack .../040-libtool_2.4.6-2_all.deb ...
Unpacking libtool (2.4.6-2) ...
Selecting previously unselected package dh-autoreconf.
Preparing to unpack .../041-dh-autoreconf_16_all.deb ...
Unpacking dh-autoreconf (16) ...
Selecting previously unselected package libarchive-zip-perl.
Preparing to unpack .../042-libarchive-zip-perl_1.60-1_all.deb ...
Unpacking libarchive-zip-perl (1.60-1) ...
Selecting previously unselected package libfile-stripnondeterminism-perl.
Preparing to unpack .../043-libfile-stripnondeterminism-perl_0.040-1_all.deb ...
Unpacking libfile-stripnondeterminism-perl (0.040-1) ...
Selecting previously unselected package libtimedate-perl.
Preparing to unpack .../044-libtimedate-perl_2.3000-2_all.deb ...
Unpacking libtimedate-perl (2.3000-2) ...
Selecting previously unselected package dh-strip-nondeterminism.
Preparing to unpack .../045-dh-strip-nondeterminism_0.040-1_all.deb ...
Unpacking dh-strip-nondeterminism (0.040-1) ...
Selecting previously unselected package libcroco3:amd64.
Preparing to unpack .../046-libcroco3_0.6.12-2_amd64.deb ...
Unpacking libcroco3:amd64 (0.6.12-2) ...
Selecting previously unselected package gettext.
Preparing to unpack .../047-gettext_0.19.8.1-4_amd64.deb ...
Unpacking gettext (0.19.8.1-4) ...
Selecting previously unselected package intltool-debian.
Preparing to unpack .../048-intltool-debian_0.35.0+20060710.4_all.deb ...
Unpacking intltool-debian (0.35.0+20060710.4) ...
Selecting previously unselected package po-debconf.
Preparing to unpack .../049-po-debconf_1.0.20_all.deb ...
Unpacking po-debconf (1.0.20) ...
Selecting previously unselected package debhelper.
Preparing to unpack .../050-debhelper_11.1.4_all.deb ...
Unpacking debhelper (11.1.4) ...
Selecting previously unselected package fonts-freefont-otf.
Preparing to unpack .../051-fonts-freefont-otf_20120503-7_all.deb ...
Unpacking fonts-freefont-otf (20120503-7) ...
Selecting previously unselected package fonts-lmodern.
Preparing to unpack .../052-fonts-lmodern_2.004.5-3_all.deb ...
Unpacking fonts-lmodern (2.004.5-3) ...
Selecting previously unselected package fonts-mplus.
Preparing to unpack .../053-fonts-mplus_063-1_all.deb ...
Unpacking fonts-mplus (063-1) ...
Selecting previously unselected package libavahi-common-data:amd64.
Preparing to unpack .../054-libavahi-common-data_0.7-3.1_amd64.deb ...
Unpacking libavahi-common-data:amd64 (0.7-3.1) ...
Selecting previously unselected package libavahi-common3:amd64.
Preparing to unpack .../055-libavahi-common3_0.7-3.1_amd64.deb ...
Unpacking libavahi-common3:amd64 (0.7-3.1) ...
Selecting previously unselected package libdbus-1-3:amd64.
Preparing to unpack .../056-libdbus-1-3_1.12.2-1_amd64.deb ...
Unpacking libdbus-1-3:amd64 (1.12.2-1) ...
Selecting previously unselected package libavahi-client3:amd64.
Preparing to unpack .../057-libavahi-client3_0.7-3.1_amd64.deb ...
Unpacking libavahi-client3:amd64 (0.7-3.1) ...
Selecting previously unselected package libkeyutils1:amd64.
Preparing to unpack .../058-libkeyutils1_1.5.9-9.2_amd64.deb ...
Unpacking libkeyutils1:amd64 (1.5.9-9.2) ...
Selecting previously unselected package libkrb5support0:amd64.
Preparing to unpack .../059-libkrb5support0_1.16-2_amd64.deb ...
Unpacking libkrb5support0:amd64 (1.16-2) ...
Selecting previously unselected package libk5crypto3:amd64.
Preparing to unpack .../060-libk5crypto3_1.16-2_amd64.deb ...
Unpacking libk5crypto3:amd64 (1.16-2) ...
Selecting previously unselected package libkrb5-3:amd64.
Preparing to unpack .../061-libkrb5-3_1.16-2_amd64.deb ...
Unpacking libkrb5-3:amd64 (1.16-2) ...
Selecting previously unselected package libgssapi-krb5-2:amd64.
Preparing to unpack .../062-libgssapi-krb5-2_1.16-2_amd64.deb ...
Unpacking libgssapi-krb5-2:amd64 (1.16-2) ...
Selecting previously unselected package libcups2:amd64.
Preparing to unpack .../063-libcups2_2.2.6-4_amd64.deb ...
Unpacking libcups2:amd64 (2.2.6-4) ...
Selecting previously unselected package libcupsimage2:amd64.
Preparing to unpack .../064-libcupsimage2_2.2.6-4_amd64.deb ...
Unpacking libcupsimage2:amd64 (2.2.6-4) ...
Selecting previously unselected package libidn11:amd64.
Preparing to unpack .../065-libidn11_1.33-2.1_amd64.deb ...
Unpacking libidn11:amd64 (1.33-2.1) ...
Selecting previously unselected package libijs-0.35:amd64.
Preparing to unpack .../066-libijs-0.35_0.35-12_amd64.deb ...
Unpacking libijs-0.35:amd64 (0.35-12) ...
Selecting previously unselected package libjbig2dec0:amd64.
Preparing to unpack .../067-libjbig2dec0_0.13-5_amd64.deb ...
Unpacking libjbig2dec0:amd64 (0.13-5) ...
Selecting previously unselected package libpaper1:amd64.
Preparing to unpack .../068-libpaper1_1.1.24+nmu5_amd64.deb ...
Unpacking libpaper1:amd64 (1.1.24+nmu5) ...
Selecting previously unselected package libgs9-common.
Preparing to unpack .../069-libgs9-common_9.22~dfsg-1_all.deb ...
Unpacking libgs9-common (9.22~dfsg-1) ...
Selecting previously unselected package libgs9:amd64.
Preparing to unpack .../070-libgs9_9.22~dfsg-1_amd64.deb ...
Unpacking libgs9:amd64 (9.22~dfsg-1) ...
Selecting previously unselected package ghostscript.
Preparing to unpack .../071-ghostscript_9.22~dfsg-1_amd64.deb ...
Unpacking ghostscript (9.22~dfsg-1) ...
Selecting previously unselected package hicolor-icon-theme.
Preparing to unpack .../072-hicolor-icon-theme_0.17-1_all.deb ...
Unpacking hicolor-icon-theme (0.17-1) ...
Selecting previously unselected package imagemagick-6.q16.
Preparing to unpack .../073-imagemagick-6.q16_8%3a6.9.7.4+dfsg-16.1_amd64.deb ...
Unpacking imagemagick-6.q16 (8:6.9.7.4+dfsg-16.1) ...
Selecting previously unselected package imagemagick.
Preparing to unpack .../074-imagemagick_8%3a6.9.7.4+dfsg-16.1_amd64.deb ...
Unpacking imagemagick (8:6.9.7.4+dfsg-16.1) ...
Selecting previously unselected package libbibutils2.
Preparing to unpack .../075-libbibutils2_4.12-5+b2_amd64.deb ...
Unpacking libbibutils2 (4.12-5+b2) ...
Selecting previously unselected package libpixman-1-0:amd64.
Preparing to unpack .../076-libpixman-1-0_0.34.0-2_amd64.deb ...
Unpacking libpixman-1-0:amd64 (0.34.0-2) ...
Selecting previously unselected package libxcb-render0:amd64.
Preparing to unpack .../077-libxcb-render0_1.12-1_amd64.deb ...
Unpacking libxcb-render0:amd64 (1.12-1) ...
Selecting previously unselected package libxcb-shm0:amd64.
Preparing to unpack .../078-libxcb-shm0_1.12-1_amd64.deb ...
Unpacking libxcb-shm0:amd64 (1.12-1) ...
Selecting previously unselected package libxrender1:amd64.
Preparing to unpack .../079-libxrender1_1%3a0.9.10-1_amd64.deb ...
Unpacking libxrender1:amd64 (1:0.9.10-1) ...
Selecting previously unselected package libcairo2:amd64.
Preparing to unpack .../080-libcairo2_1.15.10-1_amd64.deb ...
Unpacking libcairo2:amd64 (1.15.10-1) ...
Selecting previously unselected package libdatrie1:amd64.
Preparing to unpack .../081-libdatrie1_0.2.10-6_amd64.deb ...
Unpacking libdatrie1:amd64 (0.2.10-6) ...
Selecting previously unselected package libghc-pandoc-citeproc-data.
Preparing to unpack .../082-libghc-pandoc-citeproc-data_0.10.5.1-1_all.deb ...
Unpacking libghc-pandoc-citeproc-data (0.10.5.1-1) ...
Selecting previously unselected package libgraphite2-3:amd64.
Preparing to unpack .../083-libgraphite2-3_1.3.10-8_amd64.deb ...
Unpacking libgraphite2-3:amd64 (1.3.10-8) ...
Selecting previously unselected package libharfbuzz0b:amd64.
Preparing to unpack .../084-libharfbuzz0b_1.7.2-1_amd64.deb ...
Unpacking libharfbuzz0b:amd64 (1.7.2-1) ...
Selecting previously unselected package libharfbuzz-icu0:amd64.
Preparing to unpack .../085-libharfbuzz-icu0_1.7.2-1_amd64.deb ...
Unpacking libharfbuzz-icu0:amd64 (1.7.2-1) ...
Selecting previously unselected package lsb-base.
Preparing to unpack .../086-lsb-base_9.20170808_all.deb ...
Unpacking lsb-base (9.20170808) ...
Selecting previously unselected package x11-common.
Preparing to unpack .../087-x11-common_1%3a7.7+19_all.deb ...
Unpacking x11-common (1:7.7+19) ...
Selecting previously unselected package libice6:amd64.
Preparing to unpack .../088-libice6_2%3a1.0.9-2_amd64.deb ...
Unpacking libice6:amd64 (2:1.0.9-2) ...
Selecting previously unselected package libkpathsea6:amd64.
Preparing to unpack .../089-libkpathsea6_2017.20170613.44572-8+b1_amd64.deb ...
Unpacking libkpathsea6:amd64 (2017.20170613.44572-8+b1) ...
Selecting previously unselected package liblua5.1-0:amd64.
Preparing to unpack .../090-liblua5.1-0_5.1.5-8.1+b2_amd64.deb ...
Unpacking liblua5.1-0:amd64 (5.1.5-8.1+b2) ...
Selecting previously unselected package libluajit-5.1-common.
Preparing to unpack .../091-libluajit-5.1-common_2.1.0~beta3+dfsg-5.1_all.deb ...
Unpacking libluajit-5.1-common (2.1.0~beta3+dfsg-5.1) ...
Selecting previously unselected package libluajit-5.1-2:amd64.
Preparing to unpack .../092-libluajit-5.1-2_2.1.0~beta3+dfsg-5.1_amd64.deb ...
Unpacking libluajit-5.1-2:amd64 (2.1.0~beta3+dfsg-5.1) ...
Selecting previously unselected package libmime-charset-perl.
Preparing to unpack .../093-libmime-charset-perl_1.012.2-1_all.deb ...
Unpacking libmime-charset-perl (1.012.2-1) ...
Selecting previously unselected package libnspr4:amd64.
Preparing to unpack .../094-libnspr4_2%3a4.18-1_amd64.deb ...
Unpacking libnspr4:amd64 (2:4.18-1) ...
Selecting previously unselected package libnss3:amd64.
Preparing to unpack .../095-libnss3_2%3a3.35-2_amd64.deb ...
Unpacking libnss3:amd64 (2:3.35-2) ...
Selecting previously unselected package libpaper-utils.
Preparing to unpack .../096-libpaper-utils_1.1.24+nmu5_amd64.deb ...
Unpacking libpaper-utils (1.1.24+nmu5) ...
Selecting previously unselected package libpoppler72:amd64.
Preparing to unpack .../097-libpoppler72_0.61.1-2_amd64.deb ...
Unpacking libpoppler72:amd64 (0.61.1-2) ...
Selecting previously unselected package libpotrace0.
Preparing to unpack .../098-libpotrace0_1.14-2_amd64.deb ...
Unpacking libpotrace0 (1.14-2) ...
Selecting previously unselected package libptexenc1:amd64.
Preparing to unpack .../099-libptexenc1_2017.20170613.44572-8+b1_amd64.deb ...
Unpacking libptexenc1:amd64 (2017.20170613.44572-8+b1) ...
Selecting previously unselected package libsm6:amd64.
Preparing to unpack .../100-libsm6_2%3a1.2.2-1+b3_amd64.deb ...
Unpacking libsm6:amd64 (2:1.2.2-1+b3) ...
Selecting previously unselected package libthai-data.
Preparing to unpack .../101-libthai-data_0.1.27-1_all.deb ...
Unpacking libthai-data (0.1.27-1) ...
Selecting previously unselected package libthai0:amd64.
Preparing to unpack .../102-libthai0_0.1.27-1_amd64.deb ...
Unpacking libthai0:amd64 (0.1.27-1) ...
Selecting previously unselected package libsombok3:amd64.
Preparing to unpack .../103-libsombok3_2.4.0-1+b2_amd64.deb ...
Unpacking libsombok3:amd64 (2.4.0-1+b2) ...
Selecting previously unselected package libsynctex1:amd64.
Preparing to unpack .../104-libsynctex1_2017.20170613.44572-8+b1_amd64.deb ...
Unpacking libsynctex1:amd64 (2017.20170613.44572-8+b1) ...
Selecting previously unselected package libtexlua52:amd64.
Preparing to unpack .../105-libtexlua52_2017.20170613.44572-8+b1_amd64.deb ...
Unpacking libtexlua52:amd64 (2017.20170613.44572-8+b1) ...
Selecting previously unselected package libtexluajit2:amd64.
Preparing to unpack .../106-libtexluajit2_2017.20170613.44572-8+b1_amd64.deb ...
Unpacking libtexluajit2:amd64 (2017.20170613.44572-8+b1) ...
Selecting previously unselected package libunicode-linebreak-perl.
Preparing to unpack .../107-libunicode-linebreak-perl_0.0.20160702-1+b3_amd64.deb ...
Unpacking libunicode-linebreak-perl (0.0.20160702-1+b3) ...
Selecting previously unselected package libxt6:amd64.
Preparing to unpack .../108-libxt6_1%3a1.1.5-1_amd64.deb ...
Unpacking libxt6:amd64 (1:1.1.5-1) ...
Selecting previously unselected package libxmu6:amd64.
Preparing to unpack .../109-libxmu6_2%3a1.1.2-2_amd64.deb ...
Unpacking libxmu6:amd64 (2:1.1.2-2) ...
Selecting previously unselected package libxpm4:amd64.
Preparing to unpack .../110-libxpm4_1%3a3.5.12-1_amd64.deb ...
Unpacking libxpm4:amd64 (1:3.5.12-1) ...
Selecting previously unselected package libxaw7:amd64.
Preparing to unpack .../111-libxaw7_2%3a1.0.13-1+b2_amd64.deb ...
Unpacking libxaw7:amd64 (2:1.0.13-1+b2) ...
Selecting previously unselected package libxi6:amd64.
Preparing to unpack .../112-libxi6_2%3a1.7.9-1_amd64.deb ...
Unpacking libxi6:amd64 (2:1.7.9-1) ...
Selecting previously unselected package libyaml-0-2:amd64.
Preparing to unpack .../113-libyaml-0-2_0.1.7-2_amd64.deb ...
Unpacking libyaml-0-2:amd64 (0.1.7-2) ...
Selecting previously unselected package libzzip-0-13:amd64.
Preparing to unpack .../114-libzzip-0-13_0.13.62-3.1_amd64.deb ...
Unpacking libzzip-0-13:amd64 (0.13.62-3.1) ...
Selecting previously unselected package lmodern.
Preparing to unpack .../115-lmodern_2.004.5-3_all.deb ...
Unpacking lmodern (2.004.5-3) ...
Selecting previously unselected package pandoc-data.
Preparing to unpack .../116-pandoc-data_1.19.2.4~dfsg-1_all.deb ...
Unpacking pandoc-data (1.19.2.4~dfsg-1) ...
Selecting previously unselected package pandoc.
Preparing to unpack .../117-pandoc_1.19.2.4~dfsg-1+b3_amd64.deb ...
Unpacking pandoc (1.19.2.4~dfsg-1+b3) ...
Selecting previously unselected package pandoc-citeproc.
Preparing to unpack .../118-pandoc-citeproc_0.10.5.1-1+b3_amd64.deb ...
Unpacking pandoc-citeproc (0.10.5.1-1+b3) ...
Selecting previously unselected package preview-latex-style.
Preparing to unpack .../119-preview-latex-style_11.91-1_all.deb ...
Unpacking preview-latex-style (11.91-1) ...
Selecting previously unselected package sbcl.
Preparing to unpack .../120-sbcl_2%3a1.4.4-1_amd64.deb ...
Unpacking sbcl (2:1.4.4-1) ...
Selecting previously unselected package t1utils.
Preparing to unpack .../121-t1utils_1.41-2_amd64.deb ...
Unpacking t1utils (1.41-2) ...
Selecting previously unselected package texlive-binaries.
Preparing to unpack .../122-texlive-binaries_2017.20170613.44572-8+b1_amd64.deb ...
Unpacking texlive-binaries (2017.20170613.44572-8+b1) ...
Selecting previously unselected package xdg-utils.
Preparing to unpack .../123-xdg-utils_1.1.2-1_all.deb ...
Unpacking xdg-utils (1.1.2-1) ...
Selecting previously unselected package texlive-base.
Preparing to unpack .../124-texlive-base_2017.20180110-1_all.deb ...
Unpacking texlive-base (2017.20180110-1) ...
Selecting previously unselected package texlive-latex-base.
Preparing to unpack .../125-texlive-latex-base_2017.20180110-1_all.deb ...
Unpacking texlive-latex-base (2017.20180110-1) ...
Selecting previously unselected package texlive-bibtex-extra.
Preparing to unpack .../126-texlive-bibtex-extra_2017.20180110-1_all.deb ...
Unpacking texlive-bibtex-extra (2017.20180110-1) ...
Selecting previously unselected package texlive-extra-utils.
Preparing to unpack .../127-texlive-extra-utils_2017.20180110-1_all.deb ...
Unpacking texlive-extra-utils (2017.20180110-1) ...
Selecting previously unselected package texlive-fonts-recommended.
Preparing to unpack .../128-texlive-fonts-recommended_2017.20180110-1_all.deb ...
Unpacking texlive-fonts-recommended (2017.20180110-1) ...
Selecting previously unselected package texlive-plain-generic.
Preparing to unpack .../129-texlive-plain-generic_2017.20180110-1_all.deb ...
Unpacking texlive-plain-generic (2017.20180110-1) ...
Selecting previously unselected package texlive-generic-extra.
Preparing to unpack .../130-texlive-generic-extra_2017.20180110-1_all.deb ...
Unpacking texlive-generic-extra (2017.20180110-1) ...
Selecting previously unselected package texlive-latex-recommended.
Preparing to unpack .../131-texlive-latex-recommended_2017.20180110-1_all.deb ...
Unpacking texlive-latex-recommended (2017.20180110-1) ...
Selecting previously unselected package texlive-pictures.
Preparing to unpack .../132-texlive-pictures_2017.20180110-1_all.deb ...
Unpacking texlive-pictures (2017.20180110-1) ...
Selecting previously unselected package texlive-latex-extra.
Preparing to unpack .../133-texlive-latex-extra_2017.20180110-1_all.deb ...
Unpacking texlive-latex-extra (2017.20180110-1) ...
Selecting previously unselected package tipa.
Preparing to unpack .../134-tipa_2%3a1.3-20_all.deb ...
Unpacking tipa (2:1.3-20) ...
Selecting previously unselected package texlive-xetex.
Preparing to unpack .../135-texlive-xetex_2017.20180110-1_all.deb ...
Unpacking texlive-xetex (2017.20180110-1) ...
Selecting previously unselected package sbuild-build-depends-cafeobj-dummy.
Preparing to unpack .../136-sbuild-build-depends-cafeobj-dummy_0.invalid.0_amd64.deb ...
Unpacking sbuild-build-depends-cafeobj-dummy (0.invalid.0) ...
Setting up libgs9-common (9.22~dfsg-1) ...
Setting up libkpathsea6:amd64 (2017.20170613.44572-8+b1) ...
Setting up fonts-mplus (063-1) ...
Setting up libtexlua52:amd64 (2017.20170613.44572-8+b1) ...
Setting up imagemagick-6-common (8:6.9.7.4+dfsg-16.1) ...
Setting up readline-common (7.0-3) ...
Setting up libexpat1:amd64 (2.2.5-3) ...
Setting up libsynctex1:amd64 (2017.20170613.44572-8+b1) ...
Setting up libopenjp2-7:amd64 (2.3.0-1) ...
Setting up libptexenc1:amd64 (2017.20170613.44572-8+b1) ...
Setting up libjpeg62-turbo:amd64 (1:1.5.2-2+b1) ...
Setting up libarchive-zip-perl (1.60-1) ...
Setting up libbibutils2 (4.12-5+b2) ...
Setting up libluajit-5.1-common (2.1.0~beta3+dfsg-5.1) ...
Setting up mime-support (3.60) ...
Setting up libpng16-16:amd64 (1.6.34-1) ...
Setting up libtimedate-perl (2.3000-2) ...
Setting up liblcms2-2:amd64 (2.9-1) ...
Setting up libjbig0:amd64 (2.1-3.1+b2) ...
Setting up libsigsegv2:amd64 (2.12-1) ...
Setting up fonts-dejavu-core (2.37-1) ...
Setting up poppler-data (0.4.8-2) ...
Setting up libreadline7:amd64 (7.0-3) ...
Setting up groff-base (1.22.3-9) ...
Setting up libglib2.0-0:amd64 (2.54.3-2) ...
No schema files found: doing nothing.
Setting up pandoc-data (1.19.2.4~dfsg-1) ...
Setting up libghc-pandoc-citeproc-data (0.10.5.1-1) ...
Setting up libdatrie1:amd64 (0.2.10-6) ...
Setting up libtiff5:amd64 (4.0.9-3) ...
Setting up gettext-base (0.19.8.1-4) ...
Setting up fonts-freefont-otf (20120503-7) ...
Setting up libpipeline1:amd64 (1.5.0-1) ...
Setting up m4 (1.4.18-1) ...
Setting up libfftw3-double3:amd64 (3.3.7-1) ...
Setting up libicu57:amd64 (57.1-8) ...
Setting up libnspr4:amd64 (2:4.18-1) ...
Setting up ucf (3.0036) ...
Setting up libxml2:amd64 (2.9.4+dfsg1-6.1) ...
Setting up libfreetype6:amd64 (2.8.1-1) ...
Setting up libmagic-mgc (1:5.32-1) ...
Setting up libmagic1:amd64 (1:5.32-1) ...
Setting up lsb-base (9.20170808) ...
Setting up libgraphite2-3:amd64 (1.3.10-8) ...
Setting up libcroco3:amd64 (0.6.12-2) ...
Setting up liblqr-1-0:amd64 (0.4.2-2.1) ...
Setting up libjbig2dec0:amd64 (0.13-5) ...
Setting up libyaml-0-2:amd64 (0.1.7-2) ...
Setting up libpixman-1-0:amd64 (0.34.0-2) ...
Setting up libmime-charset-perl (1.012.2-1) ...
Processing triggers for libc-bin (2.26-6) ...
Setting up autotools-dev (20171216.1) ...
Setting up t1utils (1.41-2) ...
Setting up libssl1.1:amd64 (1.1.0g-2) ...
Setting up libltdl7:amd64 (2.4.6-2) ...
Setting up fonts-motoya-l-maruberi (1.01-4) ...
Setting up libluajit-5.1-2:amd64 (2.1.0~beta3+dfsg-5.1) ...
Setting up libijs-0.35:amd64 (0.35-12) ...
Setting up libsqlite3-0:amd64 (3.22.0-1) ...
Setting up sbcl (2:1.4.4-1) ...
Setting up libpotrace0 (1.14-2) ...
Setting up liblua5.1-0:amd64 (5.1.5-8.1+b2) ...
Setting up libthai-data (0.1.27-1) ...
Setting up libxdmcp6:amd64 (1:1.1.2-3) ...
Setting up libkeyutils1:amd64 (1.5.9-9.2) ...
Setting up bsdmainutils (11.1.2) ...
update-alternatives: using /usr/bin/bsd-write to provide /usr/bin/write (write) in auto mode
update-alternatives: using /usr/bin/bsd-from to provide /usr/bin/from (from) in auto mode
Setting up libzzip-0-13:amd64 (0.13.62-3.1) ...
Setting up x11-common (1:7.7+19) ...
update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults
invoke-rc.d: could not determine current runlevel
All runlevel operations denied by policy
invoke-rc.d: policy-rc.d denied execution of start.
Setting up xdg-utils (1.1.2-1) ...
Setting up hicolor-icon-theme (0.17-1) ...
Setting up libtexluajit2:amd64 (2017.20170613.44572-8+b1) ...
Setting up libx11-data (2:1.6.4-3) ...
Setting up libpython2.7-stdlib:amd64 (2.7.14-6) ...
Setting up libxau6:amd64 (1:1.0.8-1+b2) ...
Setting up autopoint (0.19.8.1-4) ...
Setting up libidn11:amd64 (1.33-2.1) ...
Setting up libdbus-1-3:amd64 (1.12.2-1) ...
Setting up fonts-lmodern (2.004.5-3) ...
Setting up libavahi-common-data:amd64 (0.7-3.1) ...
Setting up libfile-stripnondeterminism-perl (0.040-1) ...
Setting up libpaper1:amd64 (1.1.24+nmu5) ...

Creating config file /etc/papersize with new version
Setting up libpaper-utils (1.1.24+nmu5) ...
Setting up fontconfig-config (2.12.6-0.1) ...
Setting up tex-common (6.09) ...
update-language: texlive-base not installed and configured, doing nothing!
Setting up pandoc (1.19.2.4~dfsg-1+b3) ...
Setting up gettext (0.19.8.1-4) ...
Setting up python2.7 (2.7.14-6) ...
Setting up libnss3:amd64 (2:3.35-2) ...
Setting up libharfbuzz0b:amd64 (1.7.2-1) ...
Setting up preview-latex-style (11.91-1) ...
Setting up autoconf (2.69-11) ...
Setting up libthai0:amd64 (0.1.27-1) ...
Setting up file (1:5.32-1) ...
Setting up libkrb5support0:amd64 (1.16-2) ...
Setting up libpython-stdlib:amd64 (2.7.14-4) ...
Setting up intltool-debian (0.35.0+20060710.4) ...
Setting up automake (1:1.15.1-3) ...
update-alternatives: using /usr/bin/automake-1.15 to provide /usr/bin/automake (automake) in auto mode
Setting up libice6:amd64 (2:1.0.9-2) ...
Setting up man-db (2.8.0-2) ...
Not building database; man-db/auto-update is not 'true'.
Setting up pandoc-citeproc (0.10.5.1-1+b3) ...
Setting up libavahi-common3:amd64 (0.7-3.1) ...
Setting up libxcb1:amd64 (1.12-1) ...
Setting up lmodern (2.004.5-3) ...
Setting up python (2.7.14-4) ...
Setting up libsombok3:amd64 (2.4.0-1+b2) ...
Setting up libtool (2.4.6-2) ...
Setting up libfontconfig1:amd64 (2.12.6-0.1) ...
Setting up libsm6:amd64 (2:1.2.2-1+b3) ...
Setting up libk5crypto3:amd64 (1.16-2) ...
Setting up libxcb-render0:amd64 (1.12-1) ...
Setting up libharfbuzz-icu0:amd64 (1.7.2-1) ...
Setting up po-debconf (1.0.20) ...
Setting up libx11-6:amd64 (2:1.6.4-3) ...
Setting up libunicode-linebreak-perl (0.0.20160702-1+b3) ...
Setting up libxcb-shm0:amd64 (1.12-1) ...
Setting up libxpm4:amd64 (1:3.5.12-1) ...
Setting up libxt6:amd64 (1:1.1.5-1) ...
Setting up libxrender1:amd64 (1:0.9.10-1) ...
Setting up libavahi-client3:amd64 (0.7-3.1) ...
Setting up libkrb5-3:amd64 (1.16-2) ...
Setting up libpoppler72:amd64 (0.61.1-2) ...
Setting up libxext6:amd64 (2:1.3.3-1+b2) ...
Setting up libxmu6:amd64 (2:1.1.2-2) ...
Setting up libgssapi-krb5-2:amd64 (1.16-2) ...
Setting up libcups2:amd64 (2.2.6-4) ...
Setting up libxi6:amd64 (2:1.7.9-1) ...
Setting up libxaw7:amd64 (2:1.0.13-1+b2) ...
Setting up libcairo2:amd64 (1.15.10-1) ...
Setting up libmagickcore-6.q16-3:amd64 (8:6.9.7.4+dfsg-16.1) ...
Setting up libcupsimage2:amd64 (2.2.6-4) ...
Setting up libmagickwand-6.q16-3:amd64 (8:6.9.7.4+dfsg-16.1) ...
Setting up libgs9:amd64 (9.22~dfsg-1) ...
Setting up imagemagick-6.q16 (8:6.9.7.4+dfsg-16.1) ...
update-alternatives: using /usr/bin/compare-im6.q16 to provide /usr/bin/compare (compare) in auto mode
update-alternatives: using /usr/bin/compare-im6.q16 to provide /usr/bin/compare-im6 (compare-im6) in auto mode
update-alternatives: using /usr/bin/animate-im6.q16 to provide /usr/bin/animate (animate) in auto mode
update-alternatives: using /usr/bin/animate-im6.q16 to provide /usr/bin/animate-im6 (animate-im6) in auto mode
update-alternatives: using /usr/bin/convert-im6.q16 to provide /usr/bin/convert (convert) in auto mode
update-alternatives: using /usr/bin/convert-im6.q16 to provide /usr/bin/convert-im6 (convert-im6) in auto mode
update-alternatives: using /usr/bin/composite-im6.q16 to provide /usr/bin/composite (composite) in auto mode
update-alternatives: using /usr/bin/composite-im6.q16 to provide /usr/bin/composite-im6 (composite-im6) in auto mode
update-alternatives: using /usr/bin/conjure-im6.q16 to provide /usr/bin/conjure (conjure) in auto mode
update-alternatives: using /usr/bin/conjure-im6.q16 to provide /usr/bin/conjure-im6 (conjure-im6) in auto mode
update-alternatives: using /usr/bin/import-im6.q16 to provide /usr/bin/import (import) in auto mode
update-alternatives: using /usr/bin/import-im6.q16 to provide /usr/bin/import-im6 (import-im6) in auto mode
update-alternatives: using /usr/bin/identify-im6.q16 to provide /usr/bin/identify (identify) in auto mode
update-alternatives: using /usr/bin/identify-im6.q16 to provide /usr/bin/identify-im6 (identify-im6) in auto mode
update-alternatives: using /usr/bin/stream-im6.q16 to provide /usr/bin/stream (stream) in auto mode
update-alternatives: using /usr/bin/stream-im6.q16 to provide /usr/bin/stream-im6 (stream-im6) in auto mode
update-alternatives: using /usr/bin/display-im6.q16 to provide /usr/bin/display (display) in auto mode
update-alternatives: using /usr/bin/display-im6.q16 to provide /usr/bin/display-im6 (display-im6) in auto mode
update-alternatives: using /usr/bin/montage-im6.q16 to provide /usr/bin/montage (montage) in auto mode
update-alternatives: using /usr/bin/montage-im6.q16 to provide /usr/bin/montage-im6 (montage-im6) in auto mode
update-alternatives: using /usr/bin/mogrify-im6.q16 to provide /usr/bin/mogrify (mogrify) in auto mode
update-alternatives: using /usr/bin/mogrify-im6.q16 to provide /usr/bin/mogrify-im6 (mogrify-im6) in auto mode
Setting up ghostscript (9.22~dfsg-1) ...
Setting up texlive-binaries (2017.20170613.44572-8+b1) ...
update-alternatives: using /usr/bin/xdvi-xaw to provide /usr/bin/xdvi.bin (xdvi.bin) in auto mode
update-alternatives: using /usr/bin/bibtex.original to provide /usr/bin/bibtex (bibtex) in auto mode
Setting up imagemagick (8:6.9.7.4+dfsg-16.1) ...
Setting up texlive-base (2017.20180110-1) ...
tl-paper: setting paper size for dvips to a4: /var/lib/texmf/dvips/config/config-paper.ps
tl-paper: setting paper size for dvipdfmx to a4: /var/lib/texmf/dvipdfmx/dvipdfmx-paper.cfg
tl-paper: setting paper size for xdvi to a4: /var/lib/texmf/xdvi/XDvi-paper
tl-paper: setting paper size for pdftex to a4: /var/lib/texmf/tex/generic/config/pdftexconfig.tex
Setting up texlive-fonts-recommended (2017.20180110-1) ...
Setting up texlive-plain-generic (2017.20180110-1) ...
Setting up texlive-latex-base (2017.20180110-1) ...
Setting up texlive-latex-recommended (2017.20180110-1) ...
Setting up texlive-extra-utils (2017.20180110-1) ...
Setting up texlive-pictures (2017.20180110-1) ...
Setting up tipa (2:1.3-20) ...
Regenerating '/var/lib/texmf/fmtutil.cnf-DEBIAN'... done.
Regenerating '/var/lib/texmf/fmtutil.cnf-TEXLIVEDIST'... done.
update-fmtutil has updated the following file(s):
	/var/lib/texmf/fmtutil.cnf-DEBIAN
	/var/lib/texmf/fmtutil.cnf-TEXLIVEDIST
If you want to activate the changes in the above file(s),
you should run fmtutil-sys or fmtutil.
Setting up texlive-generic-extra (2017.20180110-1) ...
Setting up texlive-bibtex-extra (2017.20180110-1) ...
Setting up texlive-latex-extra (2017.20180110-1) ...
Setting up texlive-xetex (2017.20180110-1) ...
Setting up debhelper (11.1.4) ...
Setting up dh-autoreconf (16) ...
Setting up dh-strip-nondeterminism (0.040-1) ...
Setting up sbuild-build-depends-cafeobj-dummy (0.invalid.0) ...
Processing triggers for libc-bin (2.26-6) ...
Processing triggers for tex-common (6.09) ...
Running updmap-sys. This may take some time... done.
Running mktexlsr /var/lib/texmf ... done.
Building format(s) --all.
	This may take some time... done.

+------------------------------------------------------------------------------+
| Build environment                                                            |
+------------------------------------------------------------------------------+

Kernel: Linux 4.9.0-2-amd64 amd64 (x86_64)
Toolchain package versions: binutils_2.30-2 dpkg-dev_1.19.0.5 g++-7_7.3.0-1 gcc-7_7.3.0-1 libc6-dev_2.26-6 libstdc++-7-dev_7.3.0-1 libstdc++6_7.3.0-1 linux-libc-dev_4.14.13-1
Package versions: adduser_3.117 apt_1.6~alpha7 autoconf_2.69-11 automake_1:1.15.1-3 autopoint_0.19.8.1-4 autotools-dev_20171216.1 base-files_10.1 base-passwd_3.5.44 bash_4.4.18-1 binutils_2.30-2 binutils-common_2.30-2 binutils-x86-64-linux-gnu_2.30-2 bsdmainutils_11.1.2 bsdutils_1:2.30.2-0.3 build-essential_12.4 bzip2_1.0.6-8.1 clang-6.0_1:6.0~+rc1-1 coreutils_8.28-1 cpp_4:7.2.0-1d1 cpp-7_7.3.0-1 dash_0.5.8-2.10 debconf_1.5.65 debfoster_2.7-2.1+b1 debhelper_11.1.4 debian-archive-keyring_2017.7 debianutils_4.8.4 dh-autoreconf_16 dh-strip-nondeterminism_0.040-1 diffutils_1:3.6-1 dpkg_1.19.0.5 dpkg-dev_1.19.0.5 e2fslibs_1.43.8-2 e2fsprogs_1.43.8-2 eatmydata_105-5 fakeroot_1.22-2 fdisk_2.30.2-0.3 file_1:5.32-1 findutils_4.6.0+git+20170828-2 fontconfig-config_2.12.6-0.1 fonts-dejavu-core_2.37-1 fonts-freefont-otf_20120503-7 fonts-lmodern_2.004.5-3 fonts-motoya-l-maruberi_1.01-4 fonts-mplus_063-1 g++_4:7.2.0-1d1 g++-7_7.3.0-1 gcc_4:7.2.0-1d1 gcc-6-base_6.4.0-12 gcc-7_7.3.0-1 gcc-7-base_7.3.0-1 gettext_0.19.8.1-4 gettext-base_0.19.8.1-4 ghostscript_9.22~dfsg-1 gpgv_2.2.4-2 grep_3.1-2 groff-base_1.22.3-9 gzip_1.6-5+b1 hicolor-icon-theme_0.17-1 hostname_3.20 imagemagick_8:6.9.7.4+dfsg-16.1 imagemagick-6-common_8:6.9.7.4+dfsg-16.1 imagemagick-6.q16_8:6.9.7.4+dfsg-16.1 init-system-helpers_1.51 intltool-debian_0.35.0+20060710.4 lib32gcc1_1:7.3.0-1 lib32stdc++6_7.3.0-1 libacl1_2.2.52-3+b1 libapt-pkg5.0_1.6~alpha7 libarchive-zip-perl_1.60-1 libasan4_7.3.0-1 libatomic1_7.3.0-1 libattr1_1:2.4.47-2+b2 libaudit-common_1:2.8.2-1 libaudit1_1:2.8.2-1 libavahi-client3_0.7-3.1 libavahi-common-data_0.7-3.1 libavahi-common3_0.7-3.1 libbibutils2_4.12-5+b2 libbinutils_2.30-2 libblkid1_2.30.2-0.3 libbsd0_0.8.7-1 libbz2-1.0_1.0.6-8.1 libc-bin_2.26-6 libc-dev-bin_2.26-6 libc6_2.26-6 libc6-dev_2.26-6 libc6-i386_2.26-6 libcairo2_1.15.10-1 libcap-ng0_0.7.7-3.1+b1 libcc1-0_7.3.0-1 libcilkrts5_7.3.0-1 libclang-common-6.0-dev_1:6.0~+rc1-1 libclang1-6.0_1:6.0~+rc1-1 libcomerr2_1.43.8-2 libcroco3_0.6.12-2 libcups2_2.2.6-4 libcupsimage2_2.2.6-4 libdatrie1_0.2.10-6 libdb5.3_5.3.28-13.1+b1 libdbus-1-3_1.12.2-1 libdebconfclient0_0.240 libdpkg-perl_1.19.0.5 libeatmydata1_105-5 libedit2_3.1-20170329-1 libexpat1_2.2.5-3 libfakeroot_1.22-2 libfdisk1_2.30.2-0.3 libffi6_3.2.1-8 libfftw3-double3_3.3.7-1 libfile-stripnondeterminism-perl_0.040-1 libfontconfig1_2.12.6-0.1 libfreetype6_2.8.1-1 libgc1c2_1:7.4.2-8.1 libgcc-7-dev_7.3.0-1 libgcc1_1:7.3.0-1 libgcrypt20_1.8.1-4 libgdbm3_1.8.3-14 libgdbm5_1.14.1-2 libghc-pandoc-citeproc-data_0.10.5.1-1 libglib2.0-0_2.54.3-2 libgmp10_2:6.1.2+dfsg-2 libgnutls30_3.5.17-1 libgomp1_7.3.0-1 libgpg-error0_1.27-6 libgraphite2-3_1.3.10-8 libgs9_9.22~dfsg-1 libgs9-common_9.22~dfsg-1 libgssapi-krb5-2_1.16-2 libharfbuzz-icu0_1.7.2-1 libharfbuzz0b_1.7.2-1 libhogweed4_3.4-1 libice6_2:1.0.9-2 libicu57_57.1-8 libidn11_1.33-2.1 libidn2-0_2.0.4-1.1 libijs-0.35_0.35-12 libisl15_0.18-1 libitm1_7.3.0-1 libjbig0_2.1-3.1+b2 libjbig2dec0_0.13-5 libjpeg62-turbo_1:1.5.2-2+b1 libjsoncpp1_1.7.4-3 libk5crypto3_1.16-2 libkeyutils1_1.5.9-9.2 libkpathsea6_2017.20170613.44572-8+b1 libkrb5-3_1.16-2 libkrb5support0_1.16-2 liblcms2-2_2.9-1 libllvm6.0_1:6.0~+rc1-1 liblqr-1-0_0.4.2-2.1 liblsan0_7.3.0-1 libltdl7_2.4.6-2 liblua5.1-0_5.1.5-8.1+b2 libluajit-5.1-2_2.1.0~beta3+dfsg-5.1 libluajit-5.1-common_2.1.0~beta3+dfsg-5.1 liblz4-1_0.0~r131-2+b1 liblzma5_5.2.2-1.3 libmagic-mgc_1:5.32-1 libmagic1_1:5.32-1 libmagickcore-6.q16-3_8:6.9.7.4+dfsg-16.1 libmagickwand-6.q16-3_8:6.9.7.4+dfsg-16.1 libmime-charset-perl_1.012.2-1 libmount1_2.30.2-0.3 libmpc3_1.1.0-1 libmpfr4_3.1.6-1 libmpfr6_4.0.1~rc2-1 libmpx2_7.3.0-1 libncurses5_6.0+20171125-1 libncursesw5_6.0+20171125-1 libnettle6_3.4-1 libnspr4_2:4.18-1 libnss3_2:3.35-2 libobjc-7-dev_7.3.0-1 libobjc4_7.3.0-1 libopenjp2-7_2.3.0-1 libp11-kit0_0.23.9-2 libpam-modules_1.1.8-3.6 libpam-modules-bin_1.1.8-3.6 libpam-runtime_1.1.8-3.6 libpam0g_1.1.8-3.6 libpaper-utils_1.1.24+nmu5 libpaper1_1.1.24+nmu5 libpcre3_2:8.39-9 libperl5.26_5.26.1-4+b1 libpipeline1_1.5.0-1 libpixman-1-0_0.34.0-2 libpng16-16_1.6.34-1 libpoppler72_0.61.1-2 libpotrace0_1.14-2 libptexenc1_2017.20170613.44572-8+b1 libpython-stdlib_2.7.14-4 libpython2.7-minimal_2.7.14-6 libpython2.7-stdlib_2.7.14-6 libquadmath0_7.3.0-1 libreadline7_7.0-3 libseccomp2_2.3.1-2.1 libselinux1_2.7-2+b1 libsemanage-common_2.7-2 libsemanage1_2.7-2+b1 libsepol1_2.7-1 libsigsegv2_2.12-1 libsm6_2:1.2.2-1+b3 libsmartcols1_2.30.2-0.3 libsombok3_2.4.0-1+b2 libsqlite3-0_3.22.0-1 libss2_1.43.8-2 libssl1.1_1.1.0g-2 libstdc++-7-dev_7.3.0-1 libstdc++6_7.3.0-1 libsynctex1_2017.20170613.44572-8+b1 libsystemd0_237-1 libtasn1-6_4.13-2 libtexlua52_2017.20170613.44572-8+b1 libtexluajit2_2017.20170613.44572-8+b1 libthai-data_0.1.27-1 libthai0_0.1.27-1 libtiff5_4.0.9-3 libtimedate-perl_2.3000-2 libtinfo5_6.0+20171125-1 libtool_2.4.6-2 libtsan0_7.3.0-1 libubsan0_7.3.0-1 libudev1_237-1 libunicode-linebreak-perl_0.0.20160702-1+b3 libunistring2_0.9.8-1 libustr-1.0-1_1.0.4-6 libuuid1_2.30.2-0.3 libx11-6_2:1.6.4-3 libx11-data_2:1.6.4-3 libxau6_1:1.0.8-1+b2 libxaw7_2:1.0.13-1+b2 libxcb-render0_1.12-1 libxcb-shm0_1.12-1 libxcb1_1.12-1 libxdmcp6_1:1.1.2-3 libxext6_2:1.3.3-1+b2 libxi6_2:1.7.9-1 libxml2_2.9.4+dfsg1-6.1 libxmu6_2:1.1.2-2 libxpm4_1:3.5.12-1 libxrender1_1:0.9.10-1 libxt6_1:1.1.5-1 libyaml-0-2_0.1.7-2 libzzip-0-13_0.13.62-3.1 linux-libc-dev_4.14.13-1 lmodern_2.004.5-3 login_1:4.5-1 lsb-base_9.20170808 m4_1.4.18-1 make_4.1-9.1 man-db_2.8.0-2 mawk_1.3.3-17+b3 mime-support_3.60 mount_2.30.2-0.3 multiarch-support_2.26-6 ncurses-base_6.0+20171125-1 ncurses-bin_6.0+20171125-1 pandoc_1.19.2.4~dfsg-1+b3 pandoc-citeproc_0.10.5.1-1+b3 pandoc-data_1.19.2.4~dfsg-1 passwd_1:4.5-1 patch_2.7.5-1+b2 perl_5.26.1-4+b1 perl-base_5.26.1-4+b1 perl-modules-5.26_5.26.1-4 po-debconf_1.0.20 poppler-data_0.4.8-2 preview-latex-style_11.91-1 python_2.7.14-4 python-minimal_2.7.14-4 python2.7_2.7.14-6 python2.7-minimal_2.7.14-6 readline-common_7.0-3 sbcl_2:1.4.4-1 sbuild-build-depends-cafeobj-dummy_0.invalid.0 sbuild-build-depends-core-dummy_0.invalid.0 sed_4.4-2 sensible-utils_0.0.11 sysvinit-utils_2.88dsf-59.10 t1utils_1.41-2 tar_1.29b-2 tex-common_6.09 texlive-base_2017.20180110-1 texlive-bibtex-extra_2017.20180110-1 texlive-binaries_2017.20170613.44572-8+b1 texlive-extra-utils_2017.20180110-1 texlive-fonts-recommended_2017.20180110-1 texlive-generic-extra_2017.20180110-1 texlive-latex-base_2017.20180110-1 texlive-latex-extra_2017.20180110-1 texlive-latex-recommended_2017.20180110-1 texlive-pictures_2017.20180110-1 texlive-plain-generic_2017.20180110-1 texlive-xetex_2017.20180110-1 tipa_2:1.3-20 ucf_3.0036 util-linux_2.30.2-0.3 x11-common_1:7.7+19 xdg-utils_1.1.2-1 xz-utils_5.2.2-1.3 zlib1g_1:1.2.8.dfsg-5

+------------------------------------------------------------------------------+
| Build                                                                        |
+------------------------------------------------------------------------------+


Unpack source
-------------

gpgv: unknown type of key resource 'trustedkeys.kbx'
gpgv: keyblock resource '/sbuild-nonexistent/.gnupg/trustedkeys.kbx': General error
gpgv: Signature made Wed Jul 27 14:56:58 2016 UTC
gpgv:                using RSA key EC00B8DAD32266AA
gpgv: Can't check signature: No public key
dpkg-source: warning: failed to verify signature on ./cafeobj_1.5.5-1.dsc
dpkg-source: info: extracting cafeobj in /<<PKGBUILDDIR>>
dpkg-source: info: unpacking cafeobj_1.5.5.orig.tar.gz
dpkg-source: info: unpacking cafeobj_1.5.5-1.debian.tar.xz
dpkg-source: info: applying fix-refman-fonts
dpkg-source: info: applying fix-syntax-font
dpkg-source: info: applying armhf-remove-buildopts
dpkg-source: info: applying namespace-use-tikz
dpkg-source: info: applying kosakusha-logo
dpkg-source: info: applying citp-updates
dpkg-source: info: applying autoconf-doc-changes
dpkg-source: info: applying fix-pn-fonts
dpkg-source: info: applying change-logo-font

Check disk space
----------------

Sufficient free space for build

User Environment
----------------

APT_CONFIG=/var/lib/sbuild/apt.conf
HOME=/sbuild-nonexistent
LANG=en_US.UTF-8
LC_ALL=POSIX
LOGNAME=user42
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
SCHROOT_ALIAS_NAME=unstable-amd64-sbuild
SCHROOT_CHROOT_NAME=unstable-amd64-sbuild
SCHROOT_COMMAND=env
SCHROOT_GID=1001
SCHROOT_GROUP=user42
SCHROOT_SESSION_ID=unstable-amd64-sbuild-892e967f-67f0-4571-b917-5fe4c8771a13
SCHROOT_UID=1001
SCHROOT_USER=user42
SHELL=/bin/sh
USER=user42

dpkg-buildpackage
-----------------

dpkg-buildpackage: info: source package cafeobj
dpkg-buildpackage: info: source version 1.5.5-1
dpkg-buildpackage: info: source distribution unstable
dpkg-buildpackage: info: source changed by Norbert Preining <preining@debian.org>
 dpkg-source --before-build cafeobj-1.5.5
dpkg-buildpackage: info: host architecture amd64
 fakeroot debian/rules clean
dh_testdir
dh_testroot
[ ! -f Makefile ] || /usr/bin/make distclean
rm -f install-arch-stamp install-indep-stamp
rm -f build-arch-stamp build-indep-stamp
rm -rf /<<PKGBUILDDIR>>/tmpcache
dh_clean
dh_clean: Compatibility levels before 9 are deprecated (level 7 in use)
 debian/rules build-arch
dh_testdir
./configure --prefix=/usr --with-lisp=sbcl --enable-rebuild-doc
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
/bin/bash: /<<PKGBUILDDIR>>/missing: No such file or directory
configure: WARNING: 'missing' script is too old or missing
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... no
checking for mawk... mawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
checking for gcl... no
checking for lisp... no
checking for sbcl... /usr/bin/sbcl
checking for alisp... no
checking for clisp... no
checking for ccl... no
checking for ccl64... no
checking whether make sets $(MAKE)... (cached) yes
configure: Building for the following lisp interpreters:  sbcl
checking for emacs... no
checking for xemacs... no
checking where .elc files should go... ${datadir}/emacs/site-lisp
checking for xelatex... yes
checking for bibtex... yes
checking for pandoc... yes
checking for pdflatex... yes
checking that generated files are newer than configure... done
configure: creating ./config.status
config.status: creating Makefile
config.status: creating make-cafeobj.lisp
config.status: creating version.lisp
config.status: creating xbin/cafeobj.in
config.status: creating doc/refman/Makefile
config.status: creating doc/manual/Makefile
config.status: creating doc/RefCard/Makefile
config.status: creating doc/PigNose/Makefile
config.status: creating doc/citp-manual/Makefile
config.status: creating doc/namespace/Makefile
config.status: creating doc/etc/Makefile
# remove prebuild documentation pdf and rebuild them
rm -f doc/manual/manual.pdf
rm -f doc/refman/reference-manual.pdf
rm -f doc/PigNose/pnguide.pdf
rm -f doc/RefCard/interp.pdf
rm -f doc/RefCard/syntax.pdf
rm -f doc/namespace/namespace.pdf
make build
make[1]: Entering directory '/<<PKGBUILDDIR>>'
mkdir -p dumps/sbcl/
sbcl --dynamic-space-size 2048 < make-cafeobj.lisp
This is SBCL 1.4.4.debian, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
* 
NIL
* 
#<PACKAGE "COMMON-LISP-USER">
* 
#<PACKAGE "CHAOS">
* 
*CHAOS-ROOT*
* 
"."
* 
CHAOS::*CAFEOBJ-INSTALL-DIR*
* 
"."
* 
CHAOS::*MAKE-BIGPINK*
* 
(:BIGPINK :64-BIT :64-BIT-REGISTERS :ALIEN-CALLBACKS :ANSI-CL :ASH-RIGHT-VOPS
 :C-STACK-IS-CONTROL-STACK :COMMON-LISP :COMPACT-INSTANCE-HEADER
 :COMPARE-AND-SWAP-VOPS :COMPLEX-FLOAT-VOPS :CYCLE-COUNTER :ELF :FLOAT-EQL-VOPS
 :FP-AND-PC-STANDARD-SAVE :GCC-TLS :GENCGC :IEEE-FLOATING-POINT :IMMOBILE-CODE
 :IMMOBILE-SPACE :INLINE-CONSTANTS :INTEGER-EQL-VOP :LARGEFILE :LINKAGE-TABLE
 :LINUX :LITTLE-ENDIAN :MEMORY-BARRIER-VOPS :MULTIPLY-HIGH-VOPS
 :OS-PROVIDES-BLKSIZE-T :OS-PROVIDES-DLADDR :OS-PROVIDES-DLOPEN
 :OS-PROVIDES-GETPROTOBY-R :OS-PROVIDES-POLL :OS-PROVIDES-PUTWC
 :OS-PROVIDES-SUSECONDS-T :PACKAGE-LOCAL-NICKNAMES :RAW-INSTANCE-INIT-VOPS
 :RAW-SIGNED-WORD :RELOCATABLE-HEAP :SB-AFTER-XC-CORE :SB-CORE-COMPRESSION
 :SB-DOC :SB-EVAL :SB-FUTEX :SB-LDB :SB-PACKAGE-LOCKS :SB-SIMD-PACK
 :SB-SOURCE-LOCATIONS :SB-THREAD :SB-UNICODE :SB-XREF-FOR-INTERNALS :SBCL
 :STACK-ALLOCATABLE-CLOSURES :STACK-ALLOCATABLE-FIXED-OBJECTS
 :STACK-ALLOCATABLE-LISTS :STACK-ALLOCATABLE-VECTORS
 :STACK-GROWS-DOWNWARD-NOT-UPWARD :SYMBOL-INFO-VOPS :UNBIND-N-VOP
 :UNDEFINED-FUN-RESTARTS :UNIX :UNWIND-TO-FRAME-AND-CALL-VOP :X86-64)
* 
NIL
* ; in: DEFUN MAKE-EXEC-IMAGE
;     (SETQ *CHAOS-NEW* T)
; 
; caught WARNING:
;   undefined variable: *CHAOS-NEW*

;     (SETQ CHAOS::-CAFEOBJ-LOAD-TIME- (CHAOS::GET-TIME-STRING))
; 
; caught WARNING:
;   undefined variable: CHAOS::-CAFEOBJ-LOAD-TIME-

;     (CHAOS::GET-TIME-STRING)
; 
; caught STYLE-WARNING:
;   undefined function: CHAOS::GET-TIME-STRING

;     (CHAOS::SET-CAFEOBJ-STANDARD-LIBRARY-PATH)
; 
; caught STYLE-WARNING:
;   undefined function: CHAOS::SET-CAFEOBJ-STANDARD-LIBRARY-PATH
; 
; compilation unit finished
;   Undefined functions:
;     CHAOS::GET-TIME-STRING CHAOS::SET-CAFEOBJ-STANDARD-LIBRARY-PATH
;   Undefined variables:
;     *CHAOS-NEW* CHAOS::-CAFEOBJ-LOAD-TIME-
;   caught 2 WARNING conditions
;   caught 2 STYLE-WARNING conditions

MAKE-EXEC-IMAGE
* 
CHAOS::*COMPILE-BUILTIN-AXIOM*
* 
MAKE-CAFEOBJ
* 
** making CafeOBJ (STYLE-WARNING: using deprecated EVAL-WHEN situation names LOAD EVAL
WARNING:
   System definition file #P"/<<PKGBUILDDIR>>/sysdef.asd"
   contains definition for system "chaosx". Please only define "sysdef" and
   secondary systems with a name starting with "sysdef/" (e.g. "sysdef/test")
   in that file.
WARNING:
   System definition file
   #P"/<<PKGBUILDDIR>>/cl-ppcre/cl-ppcre.asd" contains
   definition for system "cl-ppcre-test". Please only define "cl-ppcre" and
   secondary systems with a name starting with "cl-ppcre/" (e.g.
   "cl-ppcre/test") in that file.
WARNING: System definition file #P"/<<PKGBUILDDIR>>/cl-ppcre/cl-ppcre.asd" contains definition for system "cl-ppcre-test". Please only define "cl-ppcre" and secondary systems with a name starting with "cl-ppcre/" (e.g. "cl-ppcre/test") in that file.
.)
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/packages.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-USER)
; compiling (DEFPACKAGE :CL-PPCRE ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/packages-tmpGHU3ALSV.fasl written
; compilation finished in 0:00:00.002
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/specials.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFVAR *STANDARD-OPTIMIZE-SETTINGS* ...)
; compiling (DEFVAR *SPECIAL-OPTIMIZE-SETTINGS* ...)
; compiling (DEFVAR *EXTENDED-MODE-P* ...)
; compiling (DECLAIM (BOOLEAN *EXTENDED-MODE-P*))
; compiling (DEFVAR *REGEX-CHAR-CODE-LIMIT* ...)
; compiling (DECLAIM (FIXNUM *REGEX-CHAR-CODE-LIMIT*))
; compiling (DEFVAR *STRING* ...)
; compiling (DECLAIM (SIMPLE-STRING *STRING*))
; compiling (DEFVAR *START-POS* ...)
; compiling (DECLAIM (FIXNUM *START-POS*))
; compiling (DEFVAR *REAL-START-POS* ...)
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *END-POS* ...)
; compiling (DECLAIM (FIXNUM *END-POS*))
; compiling (DEFVAR *REG-STARTS* ...)
; compiling (DECLAIM (SIMPLE-VECTOR *REG-STARTS*))
; compiling (DEFVAR *REGS-MAYBE-START* ...)
; compiling (DECLAIM (SIMPLE-VECTOR *REGS-MAYBE-START*))
; compiling (DEFVAR *REG-ENDS* ...)
; compiling (DECLAIM (SIMPLE-VECTOR *REG-ENDS*))
; compiling (DEFVAR *END-STRING-POS* ...)
; compiling (DEFVAR *REP-NUM* ...)
; compiling (DECLAIM (FIXNUM *REP-NUM*))
; compiling (DEFVAR *ZERO-LENGTH-NUM* ...)
; compiling (DECLAIM (FIXNUM *ZERO-LENGTH-NUM*))
; compiling (DEFVAR *REPEAT-COUNTERS* ...)
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *LAST-POS-STORES* ...)
; compiling (DECLAIM (SIMPLE-VECTOR *LAST-POS-STORES*))
; compiling (DEFVAR *USE-BMH-MATCHERS* ...)
; compiling (DEFVAR *OPTIMIZE-CHAR-CLASSES* ...)
; compiling (DEFVAR *PROPERTY-RESOLVER* ...)
; compiling (DEFVAR *ALLOW-QUOTING* ...)
; compiling (DEFVAR *ALLOW-NAMED-REGISTERS* ...)
; compiling (PUSHNEW :CL-PPCRE ...)
; compiling (DEFVAR *HYPERDOC-BASE-URI* ...)
; compiling (LET (#) ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/specials-tmpAAURSO1.fasl written
; compilation finished in 0:00:00.007
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/util.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFMACRO DEFCONSTANT ...)
; compiling (DEFMACRO WITH-UNIQUE-NAMES ...)
; compiling (DEFMACRO WITH-REBINDING ...)
; compiling (DECLAIM (INLINE DIGIT-CHAR-P))
; compiling (DEFUN DIGIT-CHAR-P ...)
; compiling (DECLAIM (INLINE WORD-CHAR-P))
; compiling (DEFUN WORD-CHAR-P ...)
; compiling (DEFCONSTANT +WHITESPACE-CHAR-STRING+ ...)
; compiling (DEFUN WHITESPACEP ...)
; compiling (DEFMACRO MAYBE-COERCE-TO-SIMPLE-STRING ...)
; compiling (DECLAIM (INLINE NSUBSEQ))
; compiling (DEFUN NSUBSEQ ...)
; compiling (DEFUN NORMALIZE-VAR-LIST ...)
; compiling (DEFUN STRING-LIST-TO-SIMPLE-STRING ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/util.lisp
; in: DEFUN STRING-LIST-TO-SIMPLE-STRING
;     (REPLACE CL-PPCRE::RESULT-STRING STRING :START1 CL-PPCRE::CURR-POS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a SIMPLE-BASE-STRING.

; compiling (DEFUN COMPLEMENT* ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/util.lisp
; in: DEFUN COMPLEMENT*
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/util-tmp5GEXGEG5.fasl written
; compilation finished in 0:00:00.033
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/errors.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFVAR *SYNTAX-ERROR-STRING* ...)
; compiling (DEFINE-CONDITION PPCRE-ERROR ...)
; compiling (DEFINE-CONDITION PPCRE-SYNTAX-ERROR ...)
; compiling (SETF (DOCUMENTATION # ...) ...)
; compiling (SETF (DOCUMENTATION # ...) ...)
; compiling (DEFINE-CONDITION PPCRE-INVOCATION-ERROR ...)
; compiling (DEFMACRO SIGNAL-SYNTAX-ERROR* ...)
; compiling (DEFMACRO SIGNAL-SYNTAX-ERROR ...)
; compiling (DEFMACRO SIGNAL-INVOCATION-ERROR ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/errors-tmpAR3FSGEY.fasl written
; compilation finished in 0:00:00.012
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/charset.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFCONSTANT +PROBE-DEPTH+ ...)
; compiling (DEFUN MAKE-CHAR-VECTOR ...)
; compiling (DEFSTRUCT (CHARSET #) ...)
; compiling (DEFMETHOD MAKE-LOAD-FORM ...)
; compiling (DECLAIM (INLINE MIX))
; compiling (DEFUN MIX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/charset.lisp
; in: DEFUN MIX
;     (+ CL-PPCRE::CODE CL-PPCRE::HASH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (SIGNED-BYTE 64) &REST
;                                                          T).
;       etc.

; compiling (DECLAIM (INLINE COMPUTE-INDEX))
; compiling (DEFUN COMPUTE-INDEX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/charset.lisp
; in: DEFUN COMPUTE-INDEX
;     (LENGTH VECTOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR)))
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR
;                            (RATIONAL (-4611686018427387899)
;                                      (4611686018427387899))
;                            DOUBLE-FLOAT SINGLE-FLOAT), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF AND IF IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LET IF AND IF IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (1+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))))
; ==>
;   (+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))) 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT
;                               (RATIONAL (-4611686018427387900)
;                                         (9223372036854775798))), not a RATIONAL.

;     (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR)))
; --> LET IF AND IF IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF AND IF IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR
;                                (RATIONAL (-4611686018427387899)
;                                          (4611686018427387899))
;                                DOUBLE-FLOAT SINGLE-FLOAT), not a FIXNUM.
;       The result is a (VALUES
;                        (OR SINGLE-FLOAT DOUBLE-FLOAT
;                            (RATIONAL (-4611686018427387900)
;                                      (9223372036854775798)))
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a (OR
;                                (RATIONAL (-4611686018427387899)
;                                          (4611686018427387899))
;                                DOUBLE-FLOAT SINGLE-FLOAT), not a (SIGNED-BYTE
;                                                                   64).
;       The result is a (VALUES
;                        (OR SINGLE-FLOAT DOUBLE-FLOAT
;                            (RATIONAL (-4611686018427387900)
;                                      (9223372036854775798)))
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (1+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))))
; ==>
;   (+ (MOD CL-PPCRE::HASH (1- (LENGTH VECTOR))) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT
;                                   (RATIONAL (-4611686018427387900)
;                                             (9223372036854775798))), not a FIXNUM.
;       The result is a (VALUES
;                        (OR
;                         (RATIONAL (-4611686018427387899) (9223372036854775799))
;                         DOUBLE-FLOAT SINGLE-FLOAT)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR SINGLE-FLOAT DOUBLE-FLOAT
;                                   (RATIONAL (-4611686018427387900)
;                                             (9223372036854775798))), not a FIXNUM.
;       The result is a (VALUES
;                        (OR
;                         (RATIONAL (-4611686018427387899) (9223372036854775799))
;                         DOUBLE-FLOAT SINGLE-FLOAT)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN IN-CHARSET-P ...)
; compiling (DEFUN ADD-TO-CHARSET ...)
; compiling (DEFUN %ADD-TO-CHARSET ...)
; compiling (DEFUN %ADD-TO-CHARSET/EXPAND ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/charset.lisp
; in: DEFUN %ADD-TO-CHARSET/EXPAND
;     (* 2 CL-PPCRE::NEW-SIZE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to
;   associate */(* /) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (>= CL-PPCRE::NEW-SIZE 371370)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* 2 CL-PPCRE::NEW-SIZE)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (>= CL-PPCRE::NEW-SIZE 371370)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (LET* ((CL-PPCRE::OLD-VECTOR (CL-PPCRE::CHARSET-VECTOR SET))
;            (CL-PPCRE::NEW-SIZE (* 2 (LENGTH CL-PPCRE::OLD-VECTOR))))
;       (TAGBODY
;        :RETRY
;         (MULTIPLE-VALUE-BIND (CL-PPCRE::NEW-DEPTH CL-PPCRE::NEW-VECTOR)
;             (IF (>= CL-PPCRE::NEW-SIZE 371370)
;                 (VALUES 0 #)
;                 (VALUES CL-PPCRE::+PROBE-DEPTH+ #))
;           (SETF # CL-PPCRE::NEW-DEPTH
;                 # CL-PPCRE::NEW-VECTOR)
;           (FLET (#)
;             (CL-PPCRE::TRY-ADD CHAR)
;             (DOTIMES # #))))
;       (INCF (CL-PPCRE::CHARSET-COUNT SET))
;       T)
; 
; note: doing signed word to integer coercion (cost 20) to NEW-SIZE

; compiling (DEFUN MAP-CHARSET ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/charset.lisp
; in: DEFUN MAP-CHARSET
;     (ZEROP (DECF CL-PPCRE::N))
; ==>
;   (= (DECF CL-PPCRE::N) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (DECF CL-PPCRE::N)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; ==>
;   (SETQ CL-PPCRE::N (SB-IMPL::XSUBTRACT 1 CL-PPCRE::N))
; 
; note: doing signed word to integer coercion (cost 20) to N

; compiling (DEFUN CREATE-CHARSET-FROM-TEST-FUNCTION ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/charset.lisp
; in: DEFUN CREATE-CHARSET-FROM-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::WITH CL-PPCRE::CHARSET = (CL-PPCRE::MAKE-CHARSET)
;           CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR ...)
; --> BLOCK LET LET LET TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> BLOCK LET LET LET TAGBODY WHEN IF >= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET LET LET TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> BLOCK LET LET LET TAGBODY WHEN IF >= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/charset-tmpJAIDFZTC.fasl written
; compilation finished in 0:00:00.036
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/charmap.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFSTRUCT (CHARMAP #) ...)
; compiling (DEFMETHOD MAKE-LOAD-FORM ...)
; compiling (DECLAIM (INLINE IN-CHARMAP-P))
; compiling (DEFUN IN-CHARMAP-P ...)
; compiling (DEFUN CHARMAP-CONTENTS ...)
; compiling (DEFUN MAKE-CHARMAP ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/charmap.lisp
; in: DEFUN MAKE-CHARMAP
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

; compiling (DEFUN CREATE-CHARMAP-FROM-TEST-FUNCTION ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/charmap.lisp
; in: DEFUN CREATE-CHARMAP-FROM-TEST-FUNCTION
;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM (1-
;                                                        CL-PPCRE::END) CL-PPCRE::DOWNTO CL-PPCRE::START
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --> BLOCK LET LET TAGBODY WHEN IF 
; ==>
;   (< CL-PPCRE::CODE #:LOOP-LIMIT-18)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --> BLOCK LET LET TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> BLOCK LET LET TAGBODY WHEN IF >= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET LET TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> BLOCK LET LET TAGBODY WHEN IF >= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (1- CL-PPCRE::END)
; ==>
;   (- CL-PPCRE::END 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM (1-
;                                                        CL-PPCRE::END) CL-PPCRE::DOWNTO CL-PPCRE::START
;           CL-PPCRE::FOR CHAR = (CODE-CHAR CL-PPCRE::CODE)
;           CL-PPCRE::UNTIL ...)
; --> BLOCK LET LET TAGBODY WHEN IF 
; ==>
;   (< CL-PPCRE::CODE #:LOOP-LIMIT-18)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/charmap-tmp8V3J6PE9.fasl written
; compilation finished in 0:00:00.034
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/chartest.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFUN CREATE-HASH-TABLE-FROM-TEST-FUNCTION ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/chartest.lisp
; in: DEFUN CREATE-HASH-TABLE-FROM-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (LOOP CL-PPCRE::WITH HASH-TABLE = (MAKE-HASH-TABLE)
;           CL-PPCRE::FOR CL-PPCRE::CODE CL-PPCRE::FROM CL-PPCRE::START CL-PPCRE::BELOW
;           CL-PPCRE::END
;           CL-PPCRE::FOR ...)
; --> BLOCK LET LET LET TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> BLOCK LET LET LET TAGBODY WHEN IF >= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> BLOCK LET LET LET TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> BLOCK LET LET LET TAGBODY WHEN IF >= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN CREATE-OPTIMIZED-TEST-FUNCTION ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/chartest.lisp
; in: DEFUN CREATE-OPTIMIZED-TEST-FUNCTION
;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert division by 2^k to shift
; due to type uncertainty:
;   The first argument is a REAL, not a INTEGER.
; 
; note: unable to
;   convert integer division to multiplication
; due to type uncertainty:
;   The first argument is a REAL, not a (UNSIGNED-BYTE 64).

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (RATIONAL (-2) (2)) DOUBLE-FLOAT
;                               SINGLE-FLOAT), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to
;   convert division by 2^k to shift
; due to type uncertainty:
;   The first argument is a REAL, not a INTEGER.
; 
; note: unable to
;   convert integer division to multiplication
; due to type uncertainty:
;   The first argument is a REAL, not a (UNSIGNED-BYTE 64).

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a (OR (RATIONAL (-2) (2)) DOUBLE-FLOAT
;                               SINGLE-FLOAT), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST
;                                                              T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST
;                                                              T).
;       etc.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ SB-C::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= (HASH-TABLE-COUNT HASH-TABLE)
;         (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2))
; --> IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST
;                                                              T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST
;                                                              T).
;       etc.

;     (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ SB-C::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= (CL-PPCRE::CHARSET-COUNT CL-PPCRE::CHARSET)
;         (CEILING (- CL-PPCRE::END CL-PPCRE::START) 2))
; --> IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/chartest-tmp9V47YWQF.fasl written
; compilation finished in 0:00:00.016
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/lexer.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DECLAIM (INLINE MAP-CHAR-TO-SPECIAL-CLASS))
; compiling (DEFUN MAP-CHAR-TO-SPECIAL-CHAR-CLASS ...)
; compiling (DEFSTRUCT (LEXER #) ...)
; compiling (DEFUN MAKE-LEXER ...)
; compiling (DECLAIM (INLINE END-OF-STRING-P))
; compiling (DEFUN END-OF-STRING-P ...)
; compiling (DECLAIM (INLINE LOOKING-AT-P))
; compiling (DEFUN LOOKING-AT-P ...)
; compiling (DECLAIM (INLINE NEXT-CHAR-NON-EXTENDED))
; compiling (DEFUN NEXT-CHAR-NON-EXTENDED ...)
; compiling (DEFUN NEXT-CHAR ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/lexer.lisp
; in: DEFUN NEXT-CHAR
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                     "Comment group not closed.")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS CL-PPCRE::ERROR-POS :FORMAT-CONTROL
;          "Comment group not closed." :FORMAT-ARGUMENTS (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (INLINE FAIL))
; compiling (DEFUN FAIL ...)
; compiling (DEFUN GET-NUMBER ...)
; compiling (DECLAIM (INLINE TRY-NUMBER))
; compiling (DEFUN TRY-NUMBER ...)
; compiling (DECLAIM (INLINE MAKE-CHAR-FROM-CODE))
; compiling (DEFUN MAKE-CHAR-FROM-CODE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/lexer.lisp
; in: DEFUN MAKE-CHAR-FROM-CODE
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* CL-PPCRE::ERROR-POS
;                                     "No character for hex-code ~X." NUMBER)
; --> ERROR 
; ==>
;   CL-PPCRE::ERROR-POS
; 
; note: deleting unreachable code

; compiling (DEFUN UNESCAPE-CHAR ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/lexer.lisp
; in: DEFUN UNESCAPE-CHAR
;     (CL-PPCRE::MAKE-CHAR-FROM-CODE NUMBER CL-PPCRE::ERROR-POS)
; --> BLOCK LET OR LET IF CL-PPCRE::SIGNAL-SYNTAX-ERROR* ERROR LIST CONS 
; ==>
;   NUMBER
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

;     (CHAR-UPCASE CL-PPCRE::NEXT-CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

; compiling (DEFUN READ-CHAR-PROPERTY ...)
; compiling (DEFUN COLLECT-CHAR-CLASS ...)
; compiling (DEFUN MAYBE-PARSE-FLAGS ...)
; compiling (DEFUN GET-QUANTIFIER ...)
; compiling (DEFUN PARSE-REGISTER-NAME-AUX ...)
; compiling (DEFUN GET-TOKEN ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/lexer.lisp
; in: DEFUN GET-TOKEN
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR "End of string following '(?<'.")
; --> CL-PPCRE::SIGNAL-SYNTAX-ERROR* ERROR 
; ==>
;   "End of string following '(?<'."
; 
; note: deleting unreachable code

;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;                                     "Character '~A' may not follow '(?<'."
;                                     CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Character '~A' may not follow '(?<'." :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;                                     "Character '~A' may not follow '(?'."
;                                     CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Character '~A' may not follow '(?'." :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER))
;                                     "Quantifier '~A' not allowed."
;                                     CL-PPCRE::NEXT-CHAR)
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS
;          (1- (CL-PPCRE::LEXER-POS CL-PPCRE::LEXER)) :FORMAT-CONTROL
;          "Quantifier '~A' not allowed." :FORMAT-ARGUMENTS
;          (LIST CL-PPCRE::NEXT-CHAR))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (INLINE UNGET-TOKEN))
; file: /<<PKGBUILDDIR>>/cl-ppcre/lexer.lisp
; in: DECLAIM (INLINE UNGET-TOKEN)
;     (DECLAIM (INLINE CL-PPCRE::UNGET-TOKEN))
; --> EVAL-WHEN 
; ==>
;   (SB-C::%PROCLAIM '(INLINE CL-PPCRE::UNGET-TOKEN) (SB-C:SOURCE-LOCATION))
; 
; caught STYLE-WARNING:
;   Proclaiming CL-PPCRE::UNGET-TOKEN to be INLINE, but 1 call to it was previously
;   compiled. A declaration of NOTINLINE at the call site will eliminate this
;   warning, as will proclaiming and defining the function before its first
;   potential use.

; compiling (DEFUN UNGET-TOKEN ...)
; compiling (DECLAIM (INLINE START-OF-SUBEXPR-P))
; compiling (DEFUN START-OF-SUBEXPR-P ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/lexer-tmp9BN22RMA.fasl written
; compilation finished in 0:00:00.114
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "cl-ppcre" "lexer">
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/parser.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFUN GROUP ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/parser.lisp
; in: DEFUN GROUP
;     (CL-PPCRE::SIGNAL-SYNTAX-ERROR* (+ CL-PPCRE::OPEN-PAREN-POS 2)
;                                     "Opening paren has no matching closing paren.")
; ==>
;   (ERROR 'CL-PPCRE:PPCRE-SYNTAX-ERROR :POS (+ CL-PPCRE::OPEN-PAREN-POS 2)
;          :FORMAT-CONTROL "Opening paren has no matching closing paren."
;          :FORMAT-ARGUMENTS (LIST))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN GREEDY-QUANT ...)
; compiling (DEFUN QUANT ...)
; compiling (DEFUN SEQ ...)
; compiling (DEFUN REG-EXPR ...)
; compiling (DEFUN PARSE-STRING ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/parser-tmp1CXFJSK9.fasl written
; compilation finished in 0:00:00.015
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/regex-class.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFCLASS REGEX ...)
; compiling (DEFCLASS SEQ ...)
; compiling (DEFCLASS ALTERNATION ...)
; compiling (DEFCLASS LOOKAHEAD ...)
; compiling (DEFCLASS LOOKBEHIND ...)
; compiling (DEFCLASS REPETITION ...)
; compiling (DEFMETHOD PRINT-OBJECT ...)
; compiling (DEFCLASS REGISTER ...)
; compiling (DEFMETHOD PRINT-OBJECT ...)
; compiling (DEFCLASS STANDALONE ...)
; compiling (DEFCLASS BACK-REFERENCE ...)
; compiling (DEFCLASS CHAR-CLASS ...)
; compiling (DEFCLASS STR ...)
; compiling (DEFMETHOD PRINT-OBJECT ...)
; compiling (DEFCLASS ANCHOR ...)
; compiling (DEFCLASS EVERYTHING ...)
; compiling (DEFCLASS WORD-BOUNDARY ...)
; compiling (DEFCLASS BRANCH ...)
; compiling (DEFCLASS FILTER ...)
; compiling (DEFCLASS VOID ...)
; compiling (DEFMETHOD INITIALIZE-INSTANCE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class.lisp
; in: DEFMETHOD INITIALIZE-INSTANCE :AFTER (STR)
;     (COERCE CL-PPCRE::STR-SLOT 'SIMPLE-STRING)
; --> THE IF REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

;     (LENGTH (CL-PPCRE::STR CL-PPCRE::STR))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/regex-class-tmpX4BRKI0R.fasl written
; compilation finished in 0:00:00.014
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFMETHOD LEN ...)
; compiling (DEFMETHOD STR ...)
; compiling (DEFMETHOD SKIP ...)
; compiling (DEFMETHOD START-OF-END-STRING-P ...)
; compiling (DEFGENERIC CASE-MODE ...)
; compiling (DEFMETHOD CASE-MODE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD CASE-MODE (STR T)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::STR))
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::STR) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; compiling (DEFMETHOD CASE-MODE ...)
; compiling (DEFGENERIC COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFMETHOD COPY-REGEX ...)
; compiling (DEFGENERIC REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFMETHOD REMOVE-REGISTERS ...)
; compiling (DEFGENERIC EVERYTHINGP ...)
; compiling (DEFMETHOD EVERYTHINGP ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD EVERYTHINGP (SEQ)
;     (LENGTH CL-PPCRE::CLEANED-ELEMENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; compiling (DEFMETHOD EVERYTHINGP ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD EVERYTHINGP (ALTERNATION)
;     (DEFMETHOD CL-PPCRE::EVERYTHINGP
;                ((CL-PPCRE::ALTERNATION CL-PPCRE::ALTERNATION))
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       (WITH-SLOTS (CL-PPCRE::CHOICES)
;           CL-PPCRE::ALTERNATION
;         (AND (= 1 (LENGTH CL-PPCRE::CHOICES))
;              (CL-PPCRE::EVERYTHINGP (FIRST CL-PPCRE::CHOICES)))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF = 
; ==>
;   (LENGTH (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::CHOICES))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFMETHOD EVERYTHINGP ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD EVERYTHINGP (REPETITION)
;     (DEFMETHOD CL-PPCRE::EVERYTHINGP
;                ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION))
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       (WITH-SLOTS (CL-PPCRE::MAXIMUM CL-PPCRE::MINIMUM CL-PPCRE::REGEX)
;           CL-PPCRE::REPETITION
;         (AND CL-PPCRE::MAXIMUM (= 1 CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;              (CL-PPCRE::EVERYTHINGP CL-PPCRE::REGEX))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF = 
; --> (LAMBDA (#:G4 #:G3 #:G2) (DECLARE (TYPE NUMBER #:G4 #:G3 #:G2)) (IF (= #:G4 #:G3) (IF (= #:G3 #:G2) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF 
; ==>
;   (= #:G4 #:G3)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF = 
; --> (LAMBDA (#:G4 #:G3 #:G2) (DECLARE (TYPE NUMBER #:G4 #:G3 #:G2)) (IF (= #:G4 #:G3) (IF (= #:G3 #:G2) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF 
; ==>
;   (= #:G3 #:G2)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; compiling (DEFMETHOD EVERYTHINGP ...)
; compiling (DEFMETHOD EVERYTHINGP ...)
; compiling (DEFMETHOD EVERYTHINGP ...)
; compiling (DEFMETHOD EVERYTHINGP ...)
; compiling (DEFGENERIC REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD REGEX-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::ELEMENTS
;                                                           CL-PPCRE::SEQ)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           IF (NOT CL-PPCRE::LEN)
;           DO ...)
; --> BLOCK LET LET SB-LOOP::WITH-SUM-COUNT LET TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-4 CL-PPCRE::LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD REGEX-LENGTH ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD REGEX-LENGTH (ALTERNATION)
;     (/= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; --> IF 
; ==>
;   (= CL-PPCRE::LEN CL-PPCRE::OLD-LEN)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; compiling (DEFMETHOD REGEX-LENGTH ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD REGEX-LENGTH (BRANCH)
;     (EQL CL-PPCRE::THEN-LENGTH
;          (CL-PPCRE::REGEX-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMETHOD REGEX-LENGTH ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD REGEX-LENGTH (REPETITION)
;     (DEFMETHOD CL-PPCRE::REGEX-LENGTH
;                ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION))
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;           CL-PPCRE::REPETITION
;         (IF (AND CL-PPCRE::LEN (EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;             (* CL-PPCRE::MINIMUM CL-PPCRE::LEN)
;             NIL)))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (* (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;      (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN))
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF 
; ==>
;   (EQL (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;        (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (* (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;      (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFMETHOD REGEX-LENGTH ...)
; compiling (DEFGENERIC REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD REGEX-MIN-LENGTH (SEQ)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::ELEMENTS
;                                                           CL-PPCRE::SEQ)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-MIN-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           CL-PPCRE::SUM CL-PPCRE::LEN)
; --> BLOCK LET LET SB-LOOP::WITH-SUM-COUNT LET TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-4 CL-PPCRE::LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD REGEX-MIN-LENGTH (ALTERNATION)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::SUB-REGEX CL-PPCRE::IN (CL-PPCRE::CHOICES
;                                                           CL-PPCRE::ALTERNATION)
;           CL-PPCRE::FOR CL-PPCRE::LEN = (CL-PPCRE::REGEX-MIN-LENGTH
;                                          CL-PPCRE::SUB-REGEX)
;           CL-PPCRE::MINIMIZE CL-PPCRE::LEN)
; --> BLOCK LET LET SB-LOOP::WITH-MINIMAX-VALUE LET TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF < IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-8 #:LOOP-MAXMIN-7)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD REGEX-MIN-LENGTH (BRANCH)
;     (MIN (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH))
;          (CL-PPCRE::REGEX-MIN-LENGTH (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD REGEX-MIN-LENGTH (REPETITION)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFMETHOD REGEX-MIN-LENGTH ...)
; compiling (DEFGENERIC COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (ALTERNATION T)
;     (/= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; --> IF 
; ==>
;   (= CL-PPCRE::CURR-OFFSET CL-PPCRE::OLD-OFFSET)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (BRANCH T)
;     (EQL CL-PPCRE::THEN-OFFSET
;          (CL-PPCRE::COMPUTE-OFFSETS (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;           CL-PPCRE::START-POS))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (REPETITION T)
;     (DEFMETHOD CL-PPCRE::COMPUTE-OFFSETS
;                ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION) CL-PPCRE::START-POS)
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       (WITH-SLOTS (CL-PPCRE::LEN CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;           CL-PPCRE::REPETITION
;         (IF (AND CL-PPCRE::LEN (EQ CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM))
;             (+ CL-PPCRE::START-POS (* CL-PPCRE::MINIMUM CL-PPCRE::LEN))
;             NIL)))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF + 
; ==>
;   (* (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;      (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN))
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF 
; ==>
;   (+ CL-PPCRE::START-POS
;      (* (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;         (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (CHAR-CLASS T)
;     (1+ CL-PPCRE::START-POS)
; ==>
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (EVERYTHING T)
;     (1+ CL-PPCRE::START-POS)
; ==>
;   (+ CL-PPCRE::START-POS 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (STR T)
;     (+ CL-PPCRE::START-POS (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; compiling (DEFMETHOD COMPUTE-OFFSETS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/regex-class-util.lisp
; in: DEFMETHOD COMPUTE-OFFSETS (FILTER T)
;     (+ CL-PPCRE::START-POS CL-PPCRE::LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-OFFSETS ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/regex-class-util-tmpQ371UGST.fasl written
; compilation finished in 0:00:00.121
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/convert.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFMACRO CASE-INSENSITIVE-MODE-P ...)
; compiling (DEFMACRO MULTI-LINE-MODE-P ...)
; compiling (DEFMACRO SINGLE-LINE-MODE-P ...)
; compiling (DEFUN SET-FLAG ...)
; compiling (DEFGENERIC RESOLVE-PROPERTY ...)
; compiling (DEFUN CONVERT-CHAR-CLASS-TO-TEST-FUNCTION ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/convert.lisp
; in: DEFUN CONVERT-CHAR-CLASS-TO-TEST-FUNCTION
;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-DOWNCASE CHAR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-UPCASE CHAR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-DOWNCASE CHAR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION (CHAR-UPCASE CHAR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CHAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-DOWN)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-UP)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (CHAR-DOWNCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-UPCASE CHAR)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-DOWN)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

;     (FUNCALL CL-PPCRE::TEST-FUNCTION CL-PPCRE::CHAR-UP)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TEST-FUNCTION is not known to be a function

; compiling (DEFUN MAYBE-SPLIT-REPETITION ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/convert.lisp
; in: DEFUN MAYBE-SPLIT-REPETITION
;     (- CL-PPCRE::MAXIMUM CL-PPCRE::MINIMUM)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN MAYBE-ACCUMULATE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/convert.lisp
; in: DEFUN MAYBE-ACCUMULATE
;     (SETF (SUBSEQ (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR)
;                   (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH)
;                      (CL-PPCRE::LEN CL-PPCRE::STR)))
;             (CL-PPCRE::STR CL-PPCRE::STR)
;           (CL-PPCRE::SKIP CL-PPCRE::STR) T)
; --> PROGN SETF LET* 
; ==>
;   (REPLACE #:SEQUENCE #:NEW1 :START1 #:START :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        SINGLE-FLOAT (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        DOUBLE-FLOAT (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 2) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 4) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 7) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 8) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 15) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 16) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 31) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 32) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 62) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 62)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 62) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 63) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (UNSIGNED-BYTE 64) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 8) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 16) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 32) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY FIXNUM (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (SIGNED-BYTE 64) (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                            (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (COMPLEX SINGLE-FLOAT)
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                            (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY
;                                                        (COMPLEX DOUBLE-FLOAT)
;                                                        (*))
;                                                       &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-VECTOR
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                              &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES SEQUENCE &OPTIONAL), not a (VALUES
;                                                       (SIMPLE-ARRAY CHARACTER
;                                                        (*))
;                                                       &REST T).

;     (+ (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (- (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DECLAIM (INLINE CONVERT-AUX))
; compiling (DEFUN CONVERT-AUX ...)
; compiling (DEFGENERIC CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/convert.lisp
; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :BRANCH) T)
;     (LENGTH (CL-PPCRE::CHOICES CL-PPCRE::ALTERNATIONS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (1- (THE FIXNUM CL-PPCRE::TEST-CANDIDATE))
; ==>
;   (- (THE FIXNUM CL-PPCRE::TEST-CANDIDATE) 1)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/convert.lisp
; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :GREEDY-REPETITION) T)
;     (ZEROP LENGTH)
; --> = IF 
; ==>
;   (= LENGTH 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (1- CL-PPCRE::MAXIMUM)
; ==>
;   (- CL-PPCRE::MAXIMUM 1)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/convert.lisp
; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :NAMED-REGISTER) T)
;     (COPY-SEQ (SECOND CL-PPCRE::PARSE-TREE))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/convert.lisp
; in: DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ((EQL :BACK-REFERENCE) T)
;     (STRING= CL-PPCRE::NAME CL-PPCRE::BACKREF-NAME)
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.
;   The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                                SYMBOL CHARACTER), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.
;   The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                                SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (COPY-SEQ CL-PPCRE::BACKREF-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (- CL-PPCRE::REG-NUM CL-PPCRE::REG-INDEX)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::NAME CL-PPCRE::IN CL-PPCRE::REG-NAMES
;           CL-PPCRE::FOR CL-PPCRE::REG-INDEX CL-PPCRE::FROM 0
;           WHEN (STRING= CL-PPCRE::NAME CL-PPCRE::BACKREF-NAME)
;           CL-PPCRE::COLLECT ...)
; --> BLOCK LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* TAGBODY 
; --> SB-LOOP::LOOP-DESETQ SETQ THE 1+ 
; ==>
;   (+ CL-PPCRE::REG-INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

;     (1- CL-PPCRE::BACKREF-NUMBER)
; ==>
;   (- CL-PPCRE::BACKREF-NUMBER 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-COMPOUND-PARSE-TREE ...)
; compiling (DEFGENERIC CONVERT-SIMPLE-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-SIMPLE-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-SIMPLE-PARSE-TREE ...)
; compiling (DEFMETHOD CONVERT-SIMPLE-PARSE-TREE ...)
; compiling (DEFUN CONVERT ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/convert.lisp
; in: DEFUN CONVERT
;     (COERCE (SLOT-VALUE CL-PPCRE::STARTS-WITH 'CL-PPCRE::STR) 'SIMPLE-STRING)
; --> THE IF REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/convert-tmp2OWI3Q7U.fasl written
; compilation finished in 0:00:00.164
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFGENERIC FLATTEN ...)
; compiling (DEFMETHOD FLATTEN ...)
; compiling (DEFMETHOD FLATTEN ...)
; compiling (DEFMETHOD FLATTEN ...)
; compiling (DEFMETHOD FLATTEN ...)
; compiling (DEFGENERIC GATHER-STRINGS ...)
; compiling (DEFMETHOD GATHER-STRINGS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD GATHER-STRINGS (SEQ)
;     (MAKE-ARRAY CL-PPCRE::COLLECTOR-LENGTH :INITIAL-CONTENTS CL-PPCRE::COLLECTOR
;                 :ELEMENT-TYPE 'CHARACTER :FILL-POINTER T :ADJUSTABLE T)
; --> LET TRULY-THE SB-C::MAKE-ARRAY-HEADER* LET 
; ==>
;   (REPLACE SB-C::DATA SB-C::INITIAL-CONTENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a VECTOR, not a SIMPLE-BASE-STRING.

;     (SETF (SUBSEQ CL-PPCRE::COLLECTOR CL-PPCRE::OLD-COLLECTOR-LENGTH)
;             (CL-PPCRE::STR CL-PPCRE::ELEMENT)
;           CL-PPCRE::SKIP (CL-PPCRE::SKIP CL-PPCRE::ELEMENT))
; --> PROGN SETF LET* 
; ==>
;   (REPLACE #:SEQUENCE #:NEW1 :START1 #:START :END1 NIL)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY SINGLE-FLOAT
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY DOUBLE-FLOAT (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY DOUBLE-FLOAT
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BIT-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-BIT-VECTOR.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BIT-VECTOR
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 2) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 2) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 4) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 4) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 7) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 7) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 8) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 15)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 15) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 16)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 16) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 31)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 31) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 32)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 32) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 62) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 62)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 62) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 63)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 63) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (UNSIGNED-BYTE 64)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (UNSIGNED-BYTE 64) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 8) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 8) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 16) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 16) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 32) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 32) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY FIXNUM (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY FIXNUM (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (SIGNED-BYTE 64) (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (SIGNED-BYTE 64) (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                          (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX SINGLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (COMPLEX SINGLE-FLOAT)
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                          (*)).
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY (COMPLEX DOUBLE-FLOAT)
;                                             (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY
;                                                      (COMPLEX DOUBLE-FLOAT)
;                                                      (*))
;                                                     &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-VECTOR.
;   The second argument is a SEQUENCE, not a SIMPLE-VECTOR.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-VECTOR &REST
;                                                            T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-BASE-STRING.
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES SIMPLE-BASE-STRING
;                                                            &REST T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY CHARACTER (*)).
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.
;   The result is a (VALUES VECTOR &OPTIONAL), not a (VALUES
;                                                     (SIMPLE-ARRAY CHARACTER
;                                                      (*))
;                                                     &REST T).

;     (INCF CL-PPCRE::COLLECTOR-LENGTH (CL-PPCRE::LEN CL-PPCRE::ELEMENT))
; --> SETQ THE 
; ==>
;   (+ (CL-PPCRE::LEN CL-PPCRE::ELEMENT) CL-PPCRE::COLLECTOR-LENGTH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       etc.

; compiling (DEFMETHOD GATHER-STRINGS ...)
; compiling (DEFMETHOD GATHER-STRINGS ...)
; compiling (DEFMETHOD GATHER-STRINGS ...)
; compiling (DEFGENERIC START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD START-ANCHORED-P (REPETITION)
;     (PLUSP (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION))
; ==>
;   (> (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; compiling (DEFMETHOD START-ANCHORED-P ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD START-ANCHORED-P (REGEX)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::REGEX))
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::REGEX) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; compiling (DEFGENERIC END-STRING-AUX ...)
; compiling (DEFMETHOD END-STRING-AUX ...)
; compiling (DEFMETHOD END-STRING-AUX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD END-STRING-AUX (SEQ)
;     (ZEROP (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END))
; --> = IF 
; ==>
;   (= (CL-PPCRE::LEN CL-PPCRE::ELEMENT-END) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAKE-ARRAY CL-PPCRE::CONCATENATED-LENGTH :INITIAL-CONTENTS
;                 (REVERSE (CL-PPCRE::STR CL-PPCRE::CONCATENATED-START))
;                 :ELEMENT-TYPE 'CHARACTER :FILL-POINTER T :ADJUSTABLE T)
; --> UNLESS IF = 
; ==>
;   (LENGTH SB-C::INITIAL-CONTENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; --> UNLESS IF ERROR 
; ==>
;   (LENGTH SB-C::INITIAL-CONTENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; --> LET TRULY-THE SB-C::MAKE-ARRAY-HEADER* LET 
; ==>
;   (REPLACE SB-C::DATA SB-C::INITIAL-CONTENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                     CHARACTER
;                                                                     (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                                SB-KERNEL:EXTENDED-SEQUENCE), not a SIMPLE-BASE-STRING.

;     (CHAR CL-PPCRE::STR CL-PPCRE::I)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

; compiling (DEFMETHOD END-STRING-AUX ...)
; compiling (DEFMETHOD END-STRING-AUX ...)
; compiling (DEFMETHOD END-STRING-AUX ...)
; compiling (DEFUN END-STRING ...)
; compiling (DEFGENERIC COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (ALTERNATION T)
;     (LOOP CL-PPCRE::FOR CL-PPCRE::CHOICE CL-PPCRE::IN (CL-PPCRE::CHOICES
;                                                        CL-PPCRE::ALTERNATION)
;           CL-PPCRE::MINIMIZE (CL-PPCRE::COMPUTE-MIN-REST CL-PPCRE::CHOICE
;                               CL-PPCRE::CURRENT-MIN-REST))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF < IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-9 #:LOOP-MAXMIN-8)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (BRANCH T)
;     (MIN
;      (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::THEN-REGEX CL-PPCRE::BRANCH)
;       CL-PPCRE::CURRENT-MIN-REST)
;      (CL-PPCRE::COMPUTE-MIN-REST (CL-PPCRE::ELSE-REGEX CL-PPCRE::BRANCH)
;       CL-PPCRE::CURRENT-MIN-REST))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (STR T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::STR))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (FILTER T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (OR (CL-PPCRE::LEN CL-PPCRE::FILTER) 0))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (REPETITION T)
;     (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;        (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (+ CL-PPCRE::CURRENT-MIN-REST
;        (* (CL-PPCRE::MINIMUM CL-PPCRE::REPETITION)
;           (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (LOOKBEHIND T)
;     (+ CL-PPCRE::CURRENT-MIN-REST (CL-PPCRE::LEN CL-PPCRE::LOOKBEHIND))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFMETHOD COMPUTE-MIN-REST ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/optimize.lisp
; in: DEFMETHOD COMPUTE-MIN-REST (REGEX T)
;     (1+ CL-PPCRE::CURRENT-MIN-REST)
; ==>
;   (+ CL-PPCRE::CURRENT-MIN-REST 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/optimize-tmp9KKTJMYV.fasl written
; compilation finished in 0:00:00.089
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/closures.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DECLAIM (INLINE *STRING*= ...))
; compiling (DEFUN *STRING*= ...)
; compiling (DEFUN *STRING*-EQUAL ...)
; compiling (DEFGENERIC CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (LOOKBEHIND T)
;     (FUNCALL CL-PPCRE::TEST-MATCHER (- CL-PPCRE::START-POS CL-PPCRE::LEN))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TEST-MATCHER)
;                   (- CL-PPCRE::START-POS CL-PPCRE::LEN))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFMACRO INSERT-CHAR-CLASS-TESTER ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (CHAR-CLASS T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::CHAR-CLASS
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::START-POS))
;       (LAMBDA (CL-PPCRE::START-POS)
;         (DECLARE (FIXNUM CL-PPCRE::START-POS))
;         (AND (< CL-PPCRE::START-POS CL-PPCRE::*END-POS*)
;              (CL-PPCRE::CHAR-CLASS-TEST)
;              (FUNCALL CL-PPCRE::NEXT-FN (1+ CL-PPCRE::START-POS)))))
; --> LET LET LAMBDA FUNCTION AND IF IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:TEST-FUNCTION5)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (STR T)
;     (LENGTH CL-PPCRE::END-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL CL-PPCRE::NEXT-FN (+ CL-PPCRE::START-POS CL-PPCRE::LEN))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::NEXT-FN)
;                   (+ CL-PPCRE::START-POS CL-PPCRE::LEN))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (INLINE WORD-BOUNDARY-P))
; compiling (DEFUN WORD-BOUNDARY-P ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (FILTER T)
;     (FUNCALL CL-PPCRE::FN CL-PPCRE::START-POS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::FN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   FN is not known to be a function

;     (FUNCALL CL-PPCRE::NEXT-FN CL-PPCRE::NEXT-POS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::NEXT-FN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   NEXT-FN is not known to be a function

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/closures-tmpJU0JWO19.fasl written
; compilation finished in 0:00:00.101
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFMACRO INCF-AFTER ...)
; compiling (DEFMACRO GREEDY-CONSTANT-LENGTH-CLOSURE ...)
; compiling (DEFUN CREATE-GREEDY-EVERYTHING-MATCHER ...)
; compiling (DEFGENERIC CREATE-GREEDY-CONSTANT-LENGTH-MATCHER ...)
; compiling (DEFMETHOD CREATE-GREEDY-CONSTANT-LENGTH-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> BLOCK TAGBODY WHEN IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:TEST-FUNCTION41)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> LET LET CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION LET 
; --> MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; compiling (DEFGENERIC CREATE-GREEDY-NO-ZERO-MATCHER ...)
; compiling (DEFMETHOD CREATE-GREEDY-NO-ZERO-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* SB-IMPL::XSUBTRACT AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFGENERIC CREATE-GREEDY-MATCHER ...)
; compiling (DEFMETHOD CREATE-GREEDY-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --> PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* SB-IMPL::XSUBTRACT AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFMACRO NON-GREEDY-CONSTANT-LENGTH-CLOSURE ...)
; compiling (DEFGENERIC CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER ...)
; compiling (DEFMETHOD CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET LOOP BLOCK LET LET TAGBODY UNLESS IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:TEST-FUNCTION113)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE T)
; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (FUNCALL CL-PPCRE::INNER-MATCHER CL-PPCRE::CURR-POS))
; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET MIN LET LET IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -13835058055282163709
;                                13835058055282163712), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ 
; ==>
;   (+ (- CL-PPCRE::*END-POS* CL-PPCRE::LEN CL-PPCRE::MIN-REST) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -13835058055282163710
;                                13835058055282163711), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163709 13835058055282163712)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR/= #\Newline (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE T)
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE (CL-PPCRE::CHAR-CLASS-TEST)))
; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> LET LET CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE IF LAMBDA FUNCTION 
; --> LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*= CL-PPCRE::STR CL-PPCRE::CURR-POS
;                           (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0 CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CL-PPCRE::*STRING*-EQUAL CL-PPCRE::STR CL-PPCRE::CURR-POS
;                                (+ CL-PPCRE::CURR-POS CL-PPCRE::LEN) 0
;                                CL-PPCRE::LEN))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR= CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

;     (CL-PPCRE::NON-GREEDY-CONSTANT-LENGTH-CLOSURE
;      (CHAR-EQUAL CL-PPCRE::CHR (SCHAR CL-PPCRE::*STRING* CL-PPCRE::CURR-POS)))
; --> IF LAMBDA FUNCTION LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET 1+ + - 
; ==>
;   (- (- CL-PPCRE::*END-POS* CL-PPCRE::LEN) CL-PPCRE::MIN-REST)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; --> IF LAMBDA FUNCTION LET MIN LET LET MIN LET 
; ==>
;   (+ CL-PPCRE::START-POS (THE FIXNUM (* CL-PPCRE::LEN CL-PPCRE::MAXIMUM)))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 64) arithmetic

; compiling (DEFGENERIC CREATE-NON-GREEDY-NO-ZERO-MATCHER ...)
; compiling (DEFMETHOD CREATE-NON-GREEDY-NO-ZERO-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-NON-GREEDY-NO-ZERO-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* SB-IMPL::XSUBTRACT AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFGENERIC CREATE-NON-GREEDY-MATCHER ...)
; compiling (DEFMETHOD CREATE-NON-GREEDY-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-NON-GREEDY-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (SVREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --> PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* SB-IMPL::XSUBTRACT AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFMACRO CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE ...)
; compiling (DEFGENERIC CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER ...)
; compiling (DEFMETHOD CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in:
;      DEFMETHOD CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER (REPETITION T)
;     (CL-PPCRE::INSERT-CHAR-CLASS-TESTER (CL-PPCRE::REGEX
;                                          (SCHAR CL-PPCRE::*STRING*
;                                                 CL-PPCRE::CURR-POS))
;       (CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE
;        (AND (CL-PPCRE::CHAR-CLASS-TEST) (1+ CL-PPCRE::CURR-POS))))
; --> LET LET CL-PPCRE::CONSTANT-REPETITION-CONSTANT-LENGTH-CLOSURE LAMBDA 
; --> FUNCTION LET AND IF IF LOOP BLOCK LET TAGBODY UNLESS IF AND IF FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:TEST-FUNCTION51)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; compiling (DEFGENERIC CREATE-CONSTANT-REPETITION-MATCHER ...)
; compiling (DEFMETHOD CREATE-CONSTANT-REPETITION-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-CONSTANT-REPETITION-MATCHER (REPETITION T)
;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0)
; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* SB-IMPL::XSUBTRACT AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (SETF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM) 0
;           (AREF CL-PPCRE::*LAST-POS-STORES* CL-PPCRE::ZERO-LENGTH-NUM) NIL)
; --> PROGN SETF LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (ZEROP (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION))
; ==>
;   (= (CL-PPCRE::MIN-LEN CL-PPCRE::REPETITION) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (INCF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* + AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

;     (DECF (AREF CL-PPCRE::*REPEAT-COUNTERS* CL-PPCRE::REP-NUM))
; --> LET* SB-IMPL::XSUBTRACT AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (VECTOR FIXNUM), not a SIMPLE-ARRAY.

; compiling (DEFMETHOD CREATE-MATCHER-AUX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/repetition-closures.lisp
; in: DEFMETHOD CREATE-MATCHER-AUX (REPETITION T)
;     (DEFMETHOD CL-PPCRE::CREATE-MATCHER-AUX
;                ((CL-PPCRE::REPETITION CL-PPCRE::REPETITION) CL-PPCRE::NEXT-FN)
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       (WITH-SLOTS (CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM CL-PPCRE::LEN
;                                      CL-PPCRE::MIN-LEN CL-PPCRE::GREEDYP
;                                      CL-PPCRE::CONTAINS-REGISTER-P)
;           CL-PPCRE::REPETITION
;         (COND
;          ((AND CL-PPCRE::MAXIMUM #)
;           (ERROR "Got REPETITION with MAXIMUM 0 (should not happen)"))
;          ((AND CL-PPCRE::MAXIMUM #)
;           (ERROR
;            "Got REPETITION with MAXIMUM 1 and MINIMUM 1 (should not happen)"))
;          ((AND # CL-PPCRE::LEN #)
;           (CL-PPCRE::CREATE-CONSTANT-REPETITION-CONSTANT-LENGTH-MATCHER
;            CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;          ((EQL CL-PPCRE::MINIMUM CL-PPCRE::MAXIMUM)
;           (CL-PPCRE::CREATE-CONSTANT-REPETITION-MATCHER CL-PPCRE::REPETITION
;            CL-PPCRE::NEXT-FN))
;          ((AND CL-PPCRE::GREEDYP CL-PPCRE::LEN #)
;           (CL-PPCRE::CREATE-GREEDY-CONSTANT-LENGTH-MATCHER CL-PPCRE::REPETITION
;            CL-PPCRE::NEXT-FN))
;          ((AND CL-PPCRE::GREEDYP #)
;           (CL-PPCRE::CREATE-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;            CL-PPCRE::NEXT-FN))
;          (CL-PPCRE::GREEDYP
;           (CL-PPCRE::CREATE-GREEDY-MATCHER CL-PPCRE::REPETITION
;            CL-PPCRE::NEXT-FN))
;          ((AND CL-PPCRE::LEN # #)
;           (CL-PPCRE::CREATE-NON-GREEDY-CONSTANT-LENGTH-MATCHER
;            CL-PPCRE::REPETITION CL-PPCRE::NEXT-FN))
;          ((OR # #)
;           (CL-PPCRE::CREATE-NON-GREEDY-NO-ZERO-MATCHER CL-PPCRE::REPETITION
;            CL-PPCRE::NEXT-FN))
;          (T
;           (CL-PPCRE::CREATE-NON-GREEDY-MATCHER CL-PPCRE::REPETITION
;            CL-PPCRE::NEXT-FN)))))
; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF ZEROP 
; ==>
;   (= (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G7 #:G6 #:G5) (DECLARE (TYPE NUMBER #:G7 #:G6 #:G5)) (IF (= #:G7 #:G6) (IF (= #:G6 #:G5) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF 
; ==>
;   (= #:G7 #:G6)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G7 #:G6 #:G5) (DECLARE (TYPE NUMBER #:G7 #:G6 #:G5)) (IF (= #:G7 #:G6) (IF (= #:G6 #:G5) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF 
; ==>
;   (= #:G6 #:G5)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> LET PLUSP > IF 
; ==>
;   (> (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MIN-LEN) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF IF 
; --> IF IF PLUSP 
; ==>
;   (> (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF IF 
; --> IF LET PLUSP > IF 
; ==>
;   (> (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MIN-LEN) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF = 
; --> (LAMBDA (#:G7 #:G6 #:G5) (DECLARE (TYPE NUMBER #:G7 #:G6 #:G5)) (IF (= #:G7 #:G6) (IF (= #:G6 #:G5) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF 
; ==>
;   (= #:G7 #:G6)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF 
; ==>
;   (EQL (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;        (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF IF 
; ==>
;   (EQL (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MINIMUM)
;        (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MAXIMUM))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF 
; --> LET PLUSP > IF 
; ==>
;   (> (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MIN-LEN) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF IF 
; --> IF IF PLUSP 
; ==>
;   (> (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::LEN) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> PROGN EVAL-WHEN SB-PCL::%DEFMETHOD-EXPANDER SB-PCL::LOAD-DEFMETHOD 
; --> SB-PCL::LOAD-DEFMETHOD LIST* LET* SB-INT:NAMED-LAMBDA FUNCTION 
; --> SYMBOL-MACROLET SB-PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> SB-PCL::BIND-FAST-LEXICAL-METHOD-FUNCTIONS FLET SB-PCL::BIND-ARGS LET* 
; --> LOCALLY SYMBOL-MACROLET BLOCK LET SYMBOL-MACROLET IF IF IF IF IF IF IF IF 
; --> IF LET PLUSP > IF 
; ==>
;   (> (SB-PCL::ACCESSOR-SLOT-VALUE #:G0 'CL-PPCRE::MIN-LEN) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/repetition-closures-tmpZX2WN8N4.fasl written
; compilation finished in 0:00:00.248
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/scanner.lisp" (written 09 SEP 2014 08:18:38 PM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFMACRO BMH-MATCHER-AUX ...)
; compiling (DEFUN CREATE-BMH-MATCHER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/scanner.lisp
; in: DEFUN CREATE-BMH-MATCHER
;     (LENGTH CL-PPCRE::PATTERN)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CHAR-UPCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE (SCHAR CL-PPCRE::PATTERN CL-PPCRE::K))
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a CHARACTER, not a BASE-CHAR.

;     (SEARCH CL-PPCRE::PATTERN CL-PPCRE::*STRING* :START2 CL-PPCRE::START-POS
;             :END2 CL-PPCRE::*END-POS* :TEST CL-PPCRE::TEST)
; 
; note: unable to
;   open code
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (MAKE-ARRAY CL-PPCRE:*REGEX-CHAR-CODE-LIMIT* :ELEMENT-TYPE 'FIXNUM
;                 :INITIAL-ELEMENT CL-PPCRE::M)
; --> FILL LET* 
; ==>
;   (SB-KERNEL:UB64-BASH-FILL
;    (LET ((SB-C::RES (LDB # #)))
;      (DECLARE (TYPE WORD SB-C::RES))
;      SB-C::RES)
;    SB-C::SEQ (SB-KERNEL:CHECK-BOUND SB-C::SEQ SB-C::BOUND SB-C::START)
;    (-
;     (IF SB-C::END
;         (SB-KERNEL:CHECK-BOUND SB-C::SEQ SB-C::BOUND SB-C::END)
;         SB-C::LEN)
;     SB-C::START))
; 
; note: doing unsigned word to integer coercion (cost 20)

; compiling (DEFMACRO CHAR-SEARCHER-AUX ...)
; compiling (DEFUN CREATE-CHAR-SEARCHER ...)
; compiling (DECLAIM (INLINE NEWLINE-SKIPPER))
; compiling (DEFUN NEWLINE-SKIPPER ...)
; compiling (DEFMACRO INSERT-ADVANCE-FN ...)
; compiling (DEFUN CREATE-SCANNER-AUX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/scanner.lisp
; in: DEFUN CREATE-SCANNER-AUX
;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF < 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF < 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF < 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF < 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF < 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF < 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF < 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN UNLESS IF AND IF <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF < 
; ==>
;   (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF AND IF 
; ==>
;   (< (+ CL-PPCRE::*END-STRING-POS* CL-PPCRE::END-STRING-LEN)
;      CL-PPCRE::*END-POS*)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; --> LAMBDA FUNCTION BLOCK LET* LABELS COND IF PROGN WHEN IF BLOCK LOOP BLOCK 
; --> TAGBODY PROGN LET COND IF IF INCF SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::*END-STRING-POS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS) CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND 'CL-PPCRE::*END-STRING-POS*
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :FLAGS (SB-C::DELETED)
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {100260BD43}> {1002875A83}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN LET UNLESS IF WHEN IF 
; --> SETQ THE FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND 'CL-PPCRE::*END-STRING-POS*
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :FLAGS (SB-C::DELETED)
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {100260BD43}> {100282C4C3}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN LET UNLESS IF WHEN IF 
; --> SETQ THE FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND 'CL-PPCRE::*END-STRING-POS*
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :FLAGS (SB-C::DELETED)
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {100260BD43}> {10027E4223}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN LET UNLESS IF WHEN IF 
; --> SETQ THE FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND 'CL-PPCRE::*END-STRING-POS*
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :FLAGS (SB-C::DELETED)
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {100260BD43}> {100279B873}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN LET UNLESS IF WHEN IF 
; --> SETQ THE FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND 'CL-PPCRE::*END-STRING-POS*
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :FLAGS (SB-C::DELETED)
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {100260BD43}> {1002751553}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN LET UNLESS IF WHEN IF 
; --> SETQ THE FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (UNLESS (SETQ CL-PPCRE::POS #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;       (IF (<= (THE FIXNUM CL-PPCRE::POS) (THE FIXNUM CL-PPCRE::*END-STRING-POS*))
;           (RETURN-FROM CL-PPCRE::ADVANCE-FN CL-PPCRE::POS))
;       (UNLESS (SETQ CL-PPCRE::*END-STRING-POS* #)
;         (RETURN-FROM CL-PPCRE:SCAN NIL))
;       CL-PPCRE::POS))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND 'CL-PPCRE::*END-STRING-POS*
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :FLAGS (SB-C::DELETED)
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {100260BD43}> {10026FE953}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN LET UNLESS IF WHEN IF 
; --> SETQ THE FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND 'CL-PPCRE::*END-STRING-POS*
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :FLAGS (SB-C::DELETED)
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {100260BD43}> {10026A52D3}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

;     (SETQ CL-PPCRE::TRY-POS (1+ CL-PPCRE::*END-STRING-POS*))
; 
; note: doing signed word to integer coercion (cost 20) to TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) to TRY-POS

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET)
;                (FUNCTION CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN LET UNLESS IF WHEN IF 
; --> SETQ THE FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* 
; ==>
;   (SB-C::%SPECIAL-BIND 'CL-PPCRE::*END-STRING-POS*
;    #<SB-C::LAMBDA-VAR
;      :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;      :FLAGS (SB-C::DELETED)
;      :SPECVAR #<SB-C::GLOBAL-VAR
;                 :%SOURCE-NAME CL-PPCRE::*END-STRING-POS*
;                 :KIND :SPECIAL {100260BD43}> {100260BDA3}>)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of BIND

;     (FUNCALL CL-PPCRE::END-STRING-TEST CL-PPCRE::TRY-POS)
; --> SB-C::%FUNCALL 
; ==>
;   CL-PPCRE::TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS
; 
; note: doing signed word to integer coercion (cost 20) from TRY-POS

;     (CL-PPCRE::INSERT-ADVANCE-FN
;      (CL-PPCRE::ADVANCE-FN (CL-PPCRE::POS)
;       (DECLARE (FIXNUM CL-PPCRE::END-STRING-OFFSET CL-PPCRE::STARTS-WITH-LEN)
;                (FUNCTION CL-PPCRE::START-STRING-TEST CL-PPCRE::END-STRING-TEST))
;       (LOOP (UNLESS (SETQ #) (RETURN-FROM CL-PPCRE:SCAN NIL))
;             (LOCALLY
;              (DECLARE #)
;              (WHEN # #)
;              (LET #
;                #)))))
; --> LAMBDA FUNCTION BLOCK LET* LABELS WHEN IF PROGN LET UNLESS IF WHEN IF 
; --> SETQ THE FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::END-STRING-TEST)
;                   (1- CL-PPCRE::END-TEST-POS))
; 
; note: doing signed word to integer coercion (cost 20)


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/scanner-tmpOU81XRV0.fasl written
; compilation finished in 0:00:00.421
; compiling file "/<<PKGBUILDDIR>>/cl-ppcre/api.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CL-PPCRE)
; compiling (DEFGENERIC CREATE-SCANNER ...)
; compiling (DEFMETHOD CREATE-SCANNER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMETHOD CREATE-SCANNER (STRING)
;     (COPY-SEQ CL-PPCRE::QUOTED-REGEX-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; compiling (DEFMETHOD CREATE-SCANNER ...)
; compiling (DEFMETHOD CREATE-SCANNER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMETHOD CREATE-SCANNER (T)
;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (= 1 (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::END-STRING))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::END-STRING) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (PLUSP (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH))
; ==>
;   (> (CL-PPCRE::LEN CL-PPCRE::STARTS-WITH) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFGENERIC SCAN ...)
; compiling (DEFMETHOD SCAN ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMETHOD SCAN (STRING T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING)
;              (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;              CL-PPCRE::START CL-PPCRE::END)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (CL-PPCRE:CREATE-SCANNER CL-PPCRE::REGEX-STRING))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --> LET COND IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET COND IF THE COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; compiling (DEFMETHOD SCAN ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMETHOD SCAN #'T
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --> LET COND IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET COND IF THE COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; compiling (DEFMETHOD SCAN ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMETHOD SCAN (T T)
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE)
;              (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
;              CL-PPCRE::START CL-PPCRE::END)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (CL-PPCRE:CREATE-SCANNER CL-PPCRE::PARSE-TREE))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING CL-PPCRE::TARGET-STRING)
; --> LET COND IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET COND IF THE COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; compiling (DEFINE-COMPILER-MACRO SCAN ...)
; compiling (DEFUN SCAN-TO-STRINGS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN SCAN-TO-STRINGS
;     (MAP 'VECTOR
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (IF CL-PPCRE::REG-START
;                (FUNCALL CL-PPCRE::SUBSTR-FN CL-PPCRE::TARGET-STRING
;                         CL-PPCRE::REG-START CL-PPCRE::REG-END)
;                NIL))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> TRULY-THE SB-KERNEL:%MAP MAP-INTO MAKE-SEQUENCE MIN LET 
; ==>
;   (LENGTH #:G33)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> TRULY-THE SB-KERNEL:%MAP MAP-INTO MAKE-SEQUENCE MIN LET LET MIN LET 
; ==>
;   (LENGTH #:G34)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFINE-COMPILER-MACRO SCAN-TO-STRINGS ...)
; compiling (DEFMACRO REGISTER-GROUPS-BIND ...)
; compiling (DEFMACRO DO-SCANS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMACRO DO-SCANS
;     (DEFMACRO CL-PPCRE:DO-SCANS
;               (
;                (CL-PPCRE::MATCH-START
;                 CL-PPCRE::MATCH-END
;                 CL-PPCRE::REG-STARTS
;                 CL-PPCRE::REG-ENDS
;                 CL-PPCRE::REGEX
;                 CL-PPCRE::TARGET-STRING
;                 &OPTIONAL
;                 CL-PPCRE::RESULT-FORM
;                 &KEY
;                 CL-PPCRE::START
;                 CL-PPCRE::END)
;                &BODY CL-PPCRE::BODY &ENVIRONMENT CL-PPCRE::ENV)
;       #<(SIMPLE-ARRAY CHARACTER
;          (495)) Iterates over TARGET-STRING and tries to match REGEX as often as
;   possible evaluating BODY with MATCH-START, MATCH-END, REG-STARTS, and
;   REG-ENDS bound to the four return values of each match in turn.  ... {100271286F}>
;       (CL-PPCRE::WITH-REBINDING (CL-PPCRE::TARGET-STRING)
;         (CL-PPCRE::WITH-UNIQUE-NAMES (CL-PPCRE::%START CL-PPCRE::%END
;                                       CL-PPCRE::%REGEX CL-PPCRE::SCANNER)
;           (DECLARE (IGNORABLE CL-PPCRE::%REGEX CL-PPCRE::SCANNER))
;           `(BLOCK NIL
;              (LET* #
;                #
;                #)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (MATCH-START MATCH-END
;                                                      REG-STARTS REG-ENDS REGEX
;                                                      TARGET-STRING &OPTIONAL
;                                                      RESULT-FORM &KEY START END)

; compiling (DEFMACRO DO-MATCHES ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMACRO DO-MATCHES
;     (DEFMACRO CL-PPCRE:DO-MATCHES
;               (
;                (CL-PPCRE::MATCH-START
;                 CL-PPCRE::MATCH-END
;                 CL-PPCRE::REGEX
;                 CL-PPCRE::TARGET-STRING
;                 &OPTIONAL
;                 CL-PPCRE::RESULT-FORM
;                 &KEY
;                 CL-PPCRE::START
;                 CL-PPCRE::END)
;                &BODY CL-PPCRE::BODY)
;       #<(SIMPLE-ARRAY CHARACTER
;          (477)) Iterates over TARGET-STRING and tries to match REGEX as often as
;   possible evaluating BODY with MATCH-START and MATCH-END bound to the
;   start/end positions of each match in turn.  After the last match,
;   ... {1002BB2CCF}>
;       (CL-PPCRE::WITH-UNIQUE-NAMES (CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
;         `(CL-PPCRE:DO-SCANS (,CL-PPCRE::MATCH-START ,CL-PPCRE::MATCH-END
;                              ,CL-PPCRE::REG-STARTS ,CL-PPCRE::REG-ENDS
;                              ,CL-PPCRE::REGEX ,CL-PPCRE::TARGET-STRING
;                              ,CL-PPCRE::RESULT-FORM :START ,CL-PPCRE::START :END
;                              ,CL-PPCRE::END)
;            ,@CL-PPCRE::BODY)))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (MATCH-START MATCH-END REGEX
;                                                      TARGET-STRING &OPTIONAL
;                                                      RESULT-FORM &KEY START END)

; compiling (DEFMACRO DO-MATCHES-AS-STRINGS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMACRO DO-MATCHES-AS-STRINGS
;     (DEFMACRO CL-PPCRE:DO-MATCHES-AS-STRINGS
;               (
;                (CL-PPCRE::MATCH-VAR
;                 CL-PPCRE::REGEX
;                 CL-PPCRE::TARGET-STRING
;                 &OPTIONAL
;                 CL-PPCRE::RESULT-FORM
;                 &KEY
;                 CL-PPCRE::START
;                 CL-PPCRE::END
;                 CL-PPCRE::SHAREDP)
;                &BODY CL-PPCRE::BODY)
;       #<(SIMPLE-ARRAY CHARACTER
;          (569)) Iterates over TARGET-STRING and tries to match REGEX as often as
;   possible evaluating BODY with MATCH-VAR bound to the substring of
;   TARGET-STRING corresponding to each match in turn.  After the last
;   ma... {1002D5BFFF}>
;       (CL-PPCRE::WITH-REBINDING (CL-PPCRE::TARGET-STRING)
;         (CL-PPCRE::WITH-UNIQUE-NAMES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                                       CL-PPCRE::SUBSTR-FN)
;           `(LET (#)
;              (CL-PPCRE:DO-MATCHES #
;                #)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (MATCH-VAR REGEX
;                                                      TARGET-STRING &OPTIONAL
;                                                      RESULT-FORM &KEY START END
;                                                      SHAREDP)

; compiling (DEFMACRO DO-REGISTER-GROUPS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMACRO DO-REGISTER-GROUPS
;     (DEFMACRO CL-PPCRE:DO-REGISTER-GROUPS
;               (CL-PPCRE::VAR-LIST
;                (CL-PPCRE::REGEX
;                 CL-PPCRE::TARGET-STRING
;                 &OPTIONAL
;                 CL-PPCRE::RESULT-FORM
;                 &KEY
;                 CL-PPCRE::START
;                 CL-PPCRE::END
;                 CL-PPCRE::SHAREDP)
;                &BODY CL-PPCRE::BODY)
;       #<(SIMPLE-ARRAY CHARACTER
;          (820)) Iterates over TARGET-STRING and tries to match REGEX as often as
;   possible evaluating BODY with the variables in VAR-LIST bound to the
;   corresponding register groups for each match in turn, i.e. each
;   va... {1002F6451F}>
;       (CL-PPCRE::WITH-REBINDING (CL-PPCRE::TARGET-STRING)
;         (CL-PPCRE::WITH-UNIQUE-NAMES (CL-PPCRE::SUBSTR-FN CL-PPCRE::MATCH-START
;                                       CL-PPCRE::MATCH-END CL-PPCRE::REG-STARTS
;                                       CL-PPCRE::REG-ENDS CL-PPCRE::START-INDEX)
;           `(LET (#)
;              (CL-PPCRE:DO-SCANS #
;                #)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (REGEX TARGET-STRING
;                                                            &OPTIONAL RESULT-FORM
;                                                            &KEY START END SHAREDP)

; compiling (DEFUN ALL-MATCHES ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN ALL-MATCHES
;     (CL-PPCRE:DO-MATCHES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING
;                           (NREVERSE CL-PPCRE::RESULT-LIST) :START CL-PPCRE::START
;                           :END CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REGEX CL-PPCRE::TARGET-STRING
;                           (NREVERSE CL-PPCRE::RESULT-LIST) :START CL-PPCRE::START
;                           :END CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::RESULT-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::RESULT-LIST))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF 
; ==>
;   (LENGTH #:TARGET-STRING3)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF THE COERCE THE IF 
; --> REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF THE COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINE-COMPILER-MACRO ALL-MATCHES ...)
; compiling (DEFUN ALL-MATCHES-AS-STRINGS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN ALL-MATCHES-AS-STRINGS
;     (CL-PPCRE:DO-MATCHES-AS-STRINGS (CL-PPCRE::MATCH CL-PPCRE::REGEX
;                                      CL-PPCRE::TARGET-STRING
;                                      (NREVERSE CL-PPCRE::RESULT-LIST) :START
;                                      CL-PPCRE::START :END CL-PPCRE::END :SHAREDP
;                                      CL-PPCRE::SHAREDP)
;       (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --> TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --> IF 
; ==>
;   (= #:MATCH-START2 #:MATCH-END3)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --> TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --> IF 1+ 
; ==>
;   (+ #:MATCH-END3 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-MATCHES-AS-STRINGS (CL-PPCRE::MATCH CL-PPCRE::REGEX
;                                      CL-PPCRE::TARGET-STRING
;                                      (NREVERSE CL-PPCRE::RESULT-LIST) :START
;                                      CL-PPCRE::START :END CL-PPCRE::END :SHAREDP
;                                      CL-PPCRE::SHAREDP)
;       (PUSH CL-PPCRE::MATCH CL-PPCRE::RESULT-LIST))
; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* OR LET IF 
; ==>
;   (LENGTH #:TARGET-STRING7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF THE COERCE THE IF 
; --> REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF THE COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --> TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --> IF 
; ==>
;   (= #:MATCH-START2 #:MATCH-END3)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> LET LET CL-PPCRE:DO-MATCHES CL-PPCRE:DO-SCANS LET BLOCK LET* LOOP BLOCK 
; --> TAGBODY PROGN MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION SETQ THE 
; --> IF 1+ 
; ==>
;   (+ #:MATCH-END3 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINE-COMPILER-MACRO ALL-MATCHES-AS-STRINGS ...)
; compiling (DEFUN SPLIT ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN SPLIT
;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;           CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;           IF CL-PPCRE::REG-START
;           DO ...)
; --> BLOCK LET LET TAGBODY SB-LOOP::LOOP-DESETQ SETQ THE AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (> CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* OR LET IF 
; ==>
;   (LENGTH #:TARGET-STRING1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --> IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --> IF THE COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

;     (>= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST))
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (INCF CL-PPCRE::COUNTER)
; --> SETQ THE 
; ==>
;   (+ 1 CL-PPCRE::COUNTER)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

;     (>= (INCF CL-PPCRE::COUNTER) CL-PPCRE::LIMIT)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (> CL-PPCRE::THIS-END CL-PPCRE::THIS-START)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (UNLESS
;           (AND (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
;                (= CL-PPCRE::MATCH-START (CAR CL-PPCRE::POS-LIST)))
;         (WHEN (AND CL-PPCRE::LIMIT (>= # CL-PPCRE::LIMIT)) (RETURN))
;         (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;         (WHEN CL-PPCRE::WITH-REGISTERS-P
;           (LOOP CL-PPCRE::FOR CL-PPCRE::REG-START CL-PPCRE::ACROSS CL-PPCRE::REG-STARTS
;                 CL-PPCRE::FOR CL-PPCRE::REG-END CL-PPCRE::ACROSS CL-PPCRE::REG-ENDS
;                 IF CL-PPCRE::REG-START
;                 DO ...))
;         (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)))
; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINE-COMPILER-MACRO SPLIT ...)
; compiling (DEFUN STRING-CASE-MODIFIER ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN STRING-CASE-MODIFIER
;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::FROM))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CHAR CL-PPCRE::STR CL-PPCRE::FROM)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CHAR CL-PPCRE::STR CL-PPCRE::TO)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CHAR CL-PPCRE::STR (1- CL-PPCRE::TO))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CHAR CL-PPCRE::STR CL-PPCRE::INDEX)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

; compiling (DEFGENERIC BUILD-REPLACEMENT-TEMPLATE ...)
; compiling (LET* (# #) ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFMETHOD BUILD-REPLACEMENT-TEMPLATE (STRING)
;     (POSITION-IF #'CL-PPCRE::DIGIT-CHAR-P CL-PPCRE::REPLACEMENT-STRING :START
;                  CL-PPCRE::MATCH-START :END CL-PPCRE::MATCH-END)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (CHAR CL-PPCRE::REPLACEMENT-STRING (1+ CL-PPCRE::MATCH-START))
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (CL-PPCRE:DO-MATCHES (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                           CL-PPCRE::REG-SCANNER CL-PPCRE::REPLACEMENT-STRING)
;       (WHEN (< CL-PPCRE::FROM CL-PPCRE::MATCH-START)
;         (PUSH
;          (SUBSEQ CL-PPCRE::REPLACEMENT-STRING CL-PPCRE::FROM
;                  CL-PPCRE::MATCH-START)
;          CL-PPCRE::COLLECTOR))
;       (LET* ((CL-PPCRE::PARSE-START
;               (POSITION-IF #'CL-PPCRE::DIGIT-CHAR-P CL-PPCRE::REPLACEMENT-STRING
;                            :START CL-PPCRE::MATCH-START :END
;                            CL-PPCRE::MATCH-END))
;              (CL-PPCRE::TOKEN
;               (IF CL-PPCRE::PARSE-START
;                   #
;                   #)))
;         (WHEN (AND (NUMBERP CL-PPCRE::TOKEN) (< CL-PPCRE::TOKEN 0))
;           (CL-PPCRE::SIGNAL-INVOCATION-ERROR
;            "Illegal substring ~S in replacement string."
;            (SUBSEQ CL-PPCRE::REPLACEMENT-STRING CL-PPCRE::MATCH-START
;                    CL-PPCRE::MATCH-END)))
;         (PUSH CL-PPCRE::TOKEN CL-PPCRE::COLLECTOR))
;       (SETQ CL-PPCRE::FROM CL-PPCRE::MATCH-END))
; --> CL-PPCRE:DO-SCANS LET BLOCK LET* SETQ THE 
; --> CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND IF THE COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a STRING, not a SIMPLE-BASE-STRING.

;     (< CL-PPCRE::FROM CL-PPCRE::MATCH-START)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (1-
;      (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                     :JUNK-ALLOWED T))
; ==>
;   (-
;    (PARSE-INTEGER CL-PPCRE::REPLACEMENT-STRING :START CL-PPCRE::PARSE-START
;                   :JUNK-ALLOWED T)
;    1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< CL-PPCRE::TOKEN 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; compiling (DEFMETHOD BUILD-REPLACEMENT-TEMPLATE ...)
; compiling (DEFMETHOD BUILD-REPLACEMENT-TEMPLATE ...)
; compiling (DEFMETHOD BUILD-REPLACEMENT-TEMPLATE ...)
; compiling (DEFUN BUILD-REPLACEMENT ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN BUILD-REPLACEMENT
;     (ARRAY-DIMENSION CL-PPCRE::REG-STARTS 0)
; 
; note: unable to
;   optimize
; because:
;   The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --> BLOCK 
; ==>
;   (MAKE-ARRAY (- CL-PPCRE::END CL-PPCRE::START) :ELEMENT-TYPE
;               (ARRAY-ELEMENT-TYPE SEQUENCE) :DISPLACED-TO SEQUENCE
;               :DISPLACED-INDEX-OFFSET CL-PPCRE::START)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (MAP 'LIST
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (AND CL-PPCRE::REG-START
;                 (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                    CL-PPCRE::REG-END)))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G42 #:G43)
; 
; note: unable to open code because: can't determine sequence argument type

;     (APPLY CL-PPCRE::TOKEN
;            (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                               CL-PPCRE::MATCH-END)
;            (MAP 'LIST
;                 (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;                   (AND CL-PPCRE::REG-START
;                        (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING
;                                           CL-PPCRE::REG-START
;                                           CL-PPCRE::REG-END)))
;                 CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS))
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TOKEN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TOKEN is not known to be a function

;     (MAP 'LIST
;          (LAMBDA (CL-PPCRE::REG-START CL-PPCRE::REG-END)
;            (AND CL-PPCRE::REG-START
;                 (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                                    CL-PPCRE::REG-END)))
;          CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> TRULY-THE 
; ==>
;   (SB-KERNEL:%MAP SB-C::RESULT-TYPE-ARG SB-C::FUN #:G46 #:G47)
; 
; note: unable to open code because: can't determine sequence argument type

;     (FUNCALL CL-PPCRE::TOKEN CL-PPCRE::TARGET-STRING CL-PPCRE::START
;              CL-PPCRE::END CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;              CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CL-PPCRE::TOKEN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   TOKEN is not known to be a function

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --> BLOCK 
; ==>
;   (MAKE-ARRAY (- CL-PPCRE::END CL-PPCRE::START) :ELEMENT-TYPE
;               (ARRAY-ELEMENT-TYPE SEQUENCE) :DISPLACED-TO SEQUENCE
;               :DISPLACED-INDEX-OFFSET CL-PPCRE::START)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --> BLOCK 
; ==>
;   (MAKE-ARRAY (- CL-PPCRE::END CL-PPCRE::START) :ELEMENT-TYPE
;               (ARRAY-ELEMENT-TYPE SEQUENCE) :DISPLACED-TO SEQUENCE
;               :DISPLACED-INDEX-OFFSET CL-PPCRE::START)
; 
; note: unable to optimize because: ELEMENT-TYPE is not constant.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::REG-START
;                        CL-PPCRE::REG-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (>= CL-PPCRE::TOKEN CL-PPCRE::REG-BOUND)
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.

;     (1+ CL-PPCRE::TOKEN)
; ==>
;   (+ CL-PPCRE::TOKEN 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

;     (CL-PPCRE::NSUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::MATCH-START
;                        CL-PPCRE::MATCH-END)
; --> BLOCK MAKE-ARRAY 
; ==>
;   (- CL-PPCRE::END CL-PPCRE::START)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; compiling (DEFUN REPLACE-AUX ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN REPLACE-AUX
;     (FUNCALL
;      (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING CL-PPCRE::FROM
;       CL-PPCRE::TO CL-PPCRE::START CL-PPCRE::END)
;      CL-PPCRE::CURR-REPLACEMENT)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (CL-PPCRE::STRING-CASE-MODIFIER CL-PPCRE::TARGET-STRING CL-PPCRE::FROM
;     CL-PPCRE::TO CL-PPCRE::START CL-PPCRE::END))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; compiling (DEFUN REGEX-REPLACE ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN REGEX-REPLACE
;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; compiling (DEFINE-COMPILER-MACRO REGEX-REPLACE ...)
; compiling (DEFUN REGEX-REPLACE-ALL ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN REGEX-REPLACE-ALL
;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;       (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
;   The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (SUBSEQ CL-PPCRE::TARGET-STRING CL-PPCRE::START CL-PPCRE::END)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (LENGTH CL-PPCRE::TARGET-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (CL-PPCRE:DO-SCANS (CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END
;                         CL-PPCRE::REG-STARTS CL-PPCRE::REG-ENDS CL-PPCRE::REGEX
;                         CL-PPCRE::TARGET-STRING NIL :START CL-PPCRE::START :END
;                         CL-PPCRE::END)
;       (PUSH CL-PPCRE::MATCH-START CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::MATCH-END CL-PPCRE::POS-LIST)
;       (PUSH CL-PPCRE::REG-STARTS CL-PPCRE::REG-LIST)
;       (PUSH CL-PPCRE::REG-ENDS CL-PPCRE::REG-LIST))
; --> LET BLOCK LET* OR LET IF 
; ==>
;   (LENGTH #:TARGET-STRING1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --> IF THE COERCE THE IF REPLACE MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> LET BLOCK LET* SETQ THE CL-PPCRE::MAYBE-COERCE-TO-SIMPLE-STRING LET COND 
; --> IF THE COERCE THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 
; ==>
;   (= CL-PPCRE::MATCH-START CL-PPCRE::MATCH-END)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; --> LET BLOCK LET* LOOP BLOCK TAGBODY PROGN MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION SETQ THE IF 1+ 
; ==>
;   (+ CL-PPCRE::MATCH-END 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINE-COMPILER-MACRO REGEX-REPLACE-ALL ...)
; compiling (DEFMACRO REGEX-APROPOS-AUX ...)
; compiling (DEFUN REGEX-APROPOS-LIST ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN REGEX-APROPOS-LIST
;     (DEFUN CL-PPCRE:REGEX-APROPOS-LIST
;            (CL-PPCRE::REGEX
;             &OPTIONAL CL-PPCRE::PACKAGES
;             &KEY (CL-PPCRE::CASE-INSENSITIVE T))
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       #<(SIMPLE-ARRAY CHARACTER
;          (221)) Similar to the standard function APROPOS-LIST but returns a list of
;   all symbols which match the regular expression REGEX.  If
;   CASE-INSENSITIVE is true and REGEX isn't already a scanner, a
;   case-insensi... {10050FA20F}>
;       (LET ((CL-PPCRE::COLLECTOR 'NIL))
;         (CL-PPCRE::REGEX-APROPOS-AUX (CL-PPCRE::REGEX CL-PPCRE::PACKAGES
;                                                       CL-PPCRE::CASE-INSENSITIVE
;                                                       CL-PPCRE::COLLECTOR)
;           (PUSH SYMBOL CL-PPCRE::COLLECTOR))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA CL-PPCRE:REGEX-APROPOS-LIST
;         (CL-PPCRE::REGEX &OPTIONAL CL-PPCRE::PACKAGES &KEY
;                          (CL-PPCRE::CASE-INSENSITIVE T))
;       #<(SIMPLE-ARRAY CHARACTER
;          (221)) Similar to the standard function APROPOS-LIST but returns a list of
; all symbols which match the regular expression REGEX.  If
; CASE-INSENSITIVE is true and REGEX isn't already a scanner, a
; case-insensi... {10050FA20F}>
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       (BLOCK CL-PPCRE:REGEX-APROPOS-LIST
;         (LET ((CL-PPCRE::COLLECTOR 'NIL))
;           (CL-PPCRE::REGEX-APROPOS-AUX (CL-PPCRE::REGEX CL-PPCRE::PACKAGES
;                                                         CL-PPCRE::CASE-INSENSITIVE
;                                                         CL-PPCRE::COLLECTOR)
;             (PUSH SYMBOL CL-PPCRE::COLLECTOR)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (REGEX &OPTIONAL PACKAGES
;                                                            &KEY
;                                                            (CASE-INSENSITIVE T))

; compiling (DEFUN PRINT-SYMBOL-INFO ...)
; compiling (DEFUN REGEX-APROPOS ...)
; file: /<<PKGBUILDDIR>>/cl-ppcre/api.lisp
; in: DEFUN REGEX-APROPOS
;     (DEFUN CL-PPCRE:REGEX-APROPOS
;            (CL-PPCRE::REGEX
;             &OPTIONAL CL-PPCRE::PACKAGES
;             &KEY (CL-PPCRE::CASE-INSENSITIVE T))
;       #<(SIMPLE-ARRAY CHARACTER
;          (216)) Similar to the standard function APROPOS but returns a list of all
;   symbols which match the regular expression REGEX.  If CASE-INSENSITIVE
;   is true and REGEX isn't already a scanner, a case-insensitive ... {100564AC0F}>
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       (CL-PPCRE::REGEX-APROPOS-AUX (CL-PPCRE::REGEX CL-PPCRE::PACKAGES
;                                                     CL-PPCRE::CASE-INSENSITIVE)
;         (CL-PPCRE::PRINT-SYMBOL-INFO SYMBOL))
;       (VALUES))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA CL-PPCRE:REGEX-APROPOS
;         (CL-PPCRE::REGEX &OPTIONAL CL-PPCRE::PACKAGES &KEY
;                          (CL-PPCRE::CASE-INSENSITIVE T))
;       #<(SIMPLE-ARRAY CHARACTER
;          (216)) Similar to the standard function APROPOS but returns a list of all
; symbols which match the regular expression REGEX.  If CASE-INSENSITIVE
; is true and REGEX isn't already a scanner, a case-insensitive ... {100564AC0F}>
;       (DECLARE
;        (OPTIMIZE SPEED (SAFETY 0) (SPACE 0) (DEBUG 1) (COMPILATION-SPEED 0)))
;       (BLOCK CL-PPCRE:REGEX-APROPOS
;         (CL-PPCRE::REGEX-APROPOS-AUX (CL-PPCRE::REGEX CL-PPCRE::PACKAGES
;                                                       CL-PPCRE::CASE-INSENSITIVE)
;           (CL-PPCRE::PRINT-SYMBOL-INFO SYMBOL))
;         (VALUES)))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (REGEX &OPTIONAL PACKAGES
;                                                            &KEY
;                                                            (CASE-INSENSITIVE T))

; compiling (LET* (# #) ...)
; compiling (LET* (# # ...) ...)
; compiling (LET* (# # ...) ...)
; compiling (DEFUN PARSE-TREE-SYNONYM ...)
; compiling (DEFUN (SETF PARSE-TREE-SYNONYM) ...)
; compiling (DEFMACRO DEFINE-PARSE-TREE-SYNONYM ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/cl-ppcre/api-tmpY2ML9CFA.fasl written
; compilation finished in 0:00:00.249
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "cl-ppcre" "api">
; 
; compilation unit finished
;   caught 7 STYLE-WARNING conditions
;   printed 700 notes
STYLE-WARNING: using deprecated EVAL-WHEN situation names LOAD EVAL
WARNING: System definition file #P"/<<PKGBUILDDIR>>/sysdef.asd" contains definition for system "chaosx". Please only define "sysdef" and secondary systems with a name starting with "sysdef/" (e.g. "sysdef/test") in that file.
; compiling file "/<<PKGBUILDDIR>>/chaos-package.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (PUSHNEW :BIGPINK ...)
; compiling (REQUIRE :ASDF)
; compiling (DEFPACKAGE :CL-PPCRE-ASD ...)
; compiling (DEFPACKAGE :CL-PPCRE ...)
; compiling (DEFPACKAGE "CHAOS" ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos-package-tmpX2JYJDQE.fasl written
; compilation finished in 0:00:00.001
; compiling file "/<<PKGBUILDDIR>>/version.lisp" (written 07 FEB 2018 08:36:06 PM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DEFVAR CAFEOBJ-VERSION)
; compiling (DEFVAR CAFEOBJ-VERSION-MAJOR)
; compiling (DEFVAR CAFEOBJ-VERSION-MINOR)
; compiling (DEFVAR CAFEOBJ-VERSION-MEMO)
; compiling (DEFVAR PATCH-LEVEL ...)
; compiling (SETQ CAFEOBJ-VERSION-MAJOR ...)
; compiling (SETQ CAFEOBJ-VERSION-MEMO ...)
; compiling (SETQ PATCH-LEVEL ...)
; compiling (IF (NOT #) ...)
; compiling (SETQ CAFEOBJ-VERSION ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/version-tmpOPCILR65.fasl written
; compilation finished in 0:00:00.001
; compiling file "/<<PKGBUILDDIR>>/comlib/globals.lisp" (written 28 DEC 2015 06:25:53 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DECLAIM (SPECIAL *CURRENT-MODULE* ...))
; compiling (DEFVAR *TOP-LEVEL-DEFINITION-IN-PROGRESS* ...)
; compiling (DECLAIM (SPECIAL *OPEN-MODULE* ...))
; compiling (DEFVAR *CURRENT-MODULE* ...)
; compiling (DEFVAR *CURRENT-SORT-ORDER* ...)
; compiling (DEFVAR *CURRENT-OPINFO-TABLE* ...)
; compiling (DEFVAR *CURRENT-EXT-RULE-TABLE* ...)
; compiling (DEFVAR *OPEN-MODULE* ...)
; compiling (DEFVAR *LAST-BEFORE-OPEN* ...)
; compiling (DEFVAR *CHAOS-FEATURES* ...)
; compiling (DECLAIM (SPECIAL *CHAOS-VERBOSE* ...))
; compiling (DEFVAR *CHAOS-VERBOSE* ...)
; compiling (DEFVAR *CHAOS-QUIET* ...)
; compiling (DEFVAR *CHAOS-INPUT-SOURCE* ...)
; compiling (DECLAIM (SPECIAL *CHAOS-INPUT-LEVEL*) ...)
; compiling (DEFVAR *CHAOS-INPUT-LEVEL* ...)
; compiling (DEFVAR *CHAOS-INPUT-NESTING-LIMIT* ...)
; compiling (DECLAIM (SPECIAL *AUTO-CONTEXT-CHANGE*))
; compiling (DEFVAR *AUTO-CONTEXT-CHANGE* ...)
; compiling (DEFVAR *SYSTEM-PRELUDE-DIR* ...)
; compiling (DEFVAR *SYSTEM-LIB-DIR* ...)
; compiling (DEFVAR *SYSTEM-EX-DIR* ...)
; compiling (DECLAIM (SPECIAL *TRACE-LEVEL*))
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *TRACE-LEVEL* ...)
; compiling (DECLAIM (SPECIAL *SELF*))
; compiling (DEFVAR *SELF* ...)
; compiling (DEFVAR $$COND ...)
; compiling (DEFVAR $$TRACE-REWRITE ...)
; compiling (DEFVAR $$TRACE-REWRITE-WHOLE ...)
; compiling (DEFVAR $$TRACE-PROOF ...)
; compiling (DEFVAR *PROOF-TREE* ...)
; compiling (DEFVAR *NEXT-DEFAULT-PROOF-NODE* ...)
; compiling (DEFVAR *CITP-VERBOSE* ...)
; compiling (DEFVAR *CITP-NORMALIZE-INSTANCE* ...)
; compiling (DEFVAR *REWRITE-STEPPING* ...)
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *REWRITE-COUNT-LIMIT* ...)
; compiling (DEFVAR *REWRITE-STOP-PATTERN* ...)
; compiling (DEFVAR *STEPS-TO-BE-DONE* ...)
; compiling (DEFVAR $$MOD ...)
; compiling (DEFVAR *OLD-CONTEXT* ...)
; compiling (DECLAIM (SPECIAL *OLD-CONTEXT*))
; compiling (DECLAIM (SPECIAL *ALLOW-$$TERM*))
; compiling (DEFVAR *ALLOW-$$TERM* ...)
; compiling (DEFVAR $$TERM ...)
; compiling (DEFVAR $$SUBTERM ...)
; compiling (DEFVAR $$TERM-CONTEXT ...)
; compiling (DEFVAR $$SELECTION-STACK ...)
; compiling (DEFVAR $$ACTION-STACK ...)
; compiling (DEFVAR $$NORM ...)
; compiling (DEFVAR $$SHOW-RED ...)
; compiling (DEFVAR *PERFORM-ON-DEMAND-REDUCTION* ...)
; compiling (DECLAIM (SPECIAL *REWRITE-EXEC-MODE*))
; compiling (DEFVAR *REWRITE-EXEC-MODE* ...)
; compiling (DECLAIM (SPECIAL *CEXEC-TARGET*))
; compiling (DEFVAR *CEXEC-TARGET* ...)
; compiling (DECLAIM (SPECIAL *REWRITE-EXEC-CONDITION*))
; compiling (DEFVAR *REWRITE-EXEC-CONDITION* ...)
; compiling (DECLAIM (SPECIAL *REWRITE-SEMANTIC-REDUCE*) ...)
; compiling (DEFVAR *REWRITE-SEMANTIC-REDUCE* ...)
; compiling (DECLAIM (SPECIAL *BEH-REWRITE*) ...)
; compiling (DEFVAR *BEH-REWRITE* ...)
; compiling (DECLAIM (TYPE FIXNUM ...) ...)
; compiling (DEFVAR *RULE-COUNT* ...)
; compiling (DEFVAR *SHOW-STATS* ...)
; compiling (DEFVAR *TRY-TRY* ...)
; compiling (DEFVAR *REDUCE-CONDITIONS* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFVAR $$TRIALS ...)
; compiling (DECLAIM (TYPE FIXNUM ...) ...)
; compiling (DEFVAR $$MATCHES ...)
; compiling (DEFVAR *ON-REDUCTION* ...)
; compiling (DEFVAR *REDUCE-BUILTIN-EAGER* ...)
; compiling (DEFPARAMETER .CONDITION-TRIAL-LIMIT-DEFAULT. ...)
; compiling (DEFVAR *CONDITION-TRIAL-LIMIT* ...)
; compiling (DEFVAR *MEL-SORT* ...)
; compiling (DEFVAR *MEL-ALWAYS* ...)
; compiling (DEFVAR *M-PATTERN-SUBST* ...)
; compiling (DEFVAR *MEMO-REWRITE* ...)
; compiling (DEFVAR *CLEAN-MEMO-IN-NORMALIZE* ...)
; compiling (DEFVAR *ALWAYS-MEMO* ...)
; compiling (DECLAIM (SPECIAL *HASH-HIT*) ...)
; compiling (DEFVAR *TERM-MEMO-HASH-HIT* ...)
; compiling (DEFVAR *ALLOW-ILLEGAL-BEH-AXIOM* ...)
; compiling (DECLAIM (SPECIAL *REGULARIZE-SIGNATURE*))
; compiling (DEFVAR *REGULARIZE-SIGNATURE* ...)
; compiling (DEFVAR *CHECK-REGULARITY* ...)
; compiling (DECLAIM (SPECIAL *CHECK-COMPATIBILITY*))
; compiling (DEFVAR *CHECK-COMPATIBILITY* ...)
; compiling (DECLAIM (SPECIAL *CHECK-SENSIBLENESS*))
; compiling (DEFVAR *CHECK-SENSIBLENESS* ...)
; compiling (DECLAIM (SPECIAL *CHECK-RWL-COHERENCY*))
; compiling (DEFVAR *CHECK-RWL-COHERENCY* ...)
; compiling (DECLAIM (SPECIAL *BUILTIN-OVERLOADING-CHECK*))
; compiling (DEFVAR *BUILTIN-OVERLOADING-CHECK* ...)
; compiling (DECLAIM (SPECIAL *PRINT-INDENT*))
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *MODULE-ALL-RULES-EVERY* ...)
; compiling (DEFVAR *FANCY-PRINT* ...)
; compiling (DEFVAR *PRINT-TERM-STRUCT* ...)
; compiling (DEFVAR *PRINT-XMODE* ...)
; compiling (DEFVAR *SHOW-MODE* ...)
; compiling (DEFVAR *PRINT-INDENT* ...)
; compiling (DEFPARAMETER *PRINT-INDENT-INCREMENT* ...)
; compiling (DEFVAR *PRINT-EXPLICIT* ...)
; compiling (DEFVAR *PRINT-ABBREV-MOD* ...)
; compiling (DEFVAR *PRINT-ABBREV-NUM* ...)
; compiling (DEFVAR *PRINT-ABBREV-TABLE* ...)
; compiling (DEFVAR *PRINT-ABBREV-QUALS* ...)
; compiling (DEFVAR *PRINT-WITH-SORT* ...)
; compiling (DEFVAR *PRINT-OPERATOR-TABLE* ...)
; compiling (DEFVAR *PRINT-FLAG-MODULE-VALUES* ...)
; compiling (DEFVAR *PRINT-INDENT-CONTIN* ...)
; compiling (DEFVAR *PRINT-LINE-LIMIT* ...)
; compiling (DEFVAR *PRINT-MODE* ...)
; compiling (DEFVAR *PRINT-ALL-EQNS* ...)
; compiling (DEFVAR *PRINT-EXEC-RULE* ...)
; compiling (DEFVAR *PRINT-IGNORE-MODS* ...)
; compiling (DEFVAR *CHAOS-PRINT-LEVEL* ...)
; compiling (DEFVAR *CHAOS-PRINT-LENGTH* ...)
; compiling (DEFVAR *CHAOS-PRINT-ERRORS* ...)
; compiling (DEFVAR *CHAOS-INPUT-QUIET* ...)
; compiling (DEFVAR *PRINT-VARIABLES* ...)
; compiling (DEFVAR *GRIND-BOOL-TERM* ...)
; compiling (DECLAIM (SPECIAL .FILE-COL.) ...)
; compiling (DEFVAR .FILE-COL. ...)
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *TERM-PRINT-DEPTH* ...)
; compiling (DEFVAR *SHOW-TREE-HORIZONTAL* ...)
; compiling (DEFVAR *CAFEOBJ-INPUT-QUIET* ...)
; compiling (DEFVAR $)
; compiling (DEFVAR -CAFEOBJ-LOAD-TIME- ...)
; compiling (DEFVAR *CAFEOBJ-STANDARD-PRELUDE-PATH* ...)
; compiling (DEFCONSTANT $NAME-SORT ...)
; compiling (DEFCONSTANT $NAME-GEN-SORT ...)
; compiling (DEFCONSTANT $NAME-BI-SORT ...)
; compiling (DEFCONSTANT $NAME-IDENTIFIER ...)
; compiling (DEFCONSTANT $NAME-COSMOS ...)
; compiling (DEFCONSTANT $NAME-UNIVERSAL ...)
; compiling (DEFCONSTANT $NAME-HUNIVERSAL ...)
; compiling (DEFCONSTANT $NAME-TERM ...)
; compiling (DEFCONSTANT $NAME-BOTTOM ...)
; compiling (DEFCONSTANT $NAME-HBOTTOM ...)
; compiling (DEFCONSTANT $NAME-RECORD ...)
; compiling (DEFCONSTANT $NAME-CLASS ...)
; compiling (DEFCONSTANT $NAME-AND-SORT ...)
; compiling (DEFCONSTANT $NAME-OR-SORT ...)
; compiling (DEFCONSTANT $NAME-ERR-SORT ...)
; compiling (DEFCONSTANT $NAME-OPERATOR ...)
; compiling (DEFCONSTANT $NAME-OPTHEORY ...)
; compiling (DEFCONSTANT $NAME-MODULE ...)
; compiling (DEFCONSTANT $NAME-SIGNATURE ...)
; compiling (DEFCONSTANT $NAME-AXIOMSET ...)
; compiling (DEFCONSTANT $NAME-TRS ...)
; compiling (DEFCONSTANT $NAME-AXIOM ...)
; compiling (DEFCONSTANT $NAME-CHAOS-OBJECT ...)
; compiling (DEFCONSTANT $NAME-CHAOS-EXPR ...)
; compiling (DEFCONSTANT $NAME-TERM-TYPE ...)
; compiling (DEFCONSTANT $NAME-CHAOS-LIST ...)
; compiling (DEFCONSTANT $NAME-VOID ...)
; compiling (DEFCONSTANT $NAME-IMPORT ...)
; compiling (DEFCONSTANT $NAME-SUBST ...)
; compiling (DEFCONSTANT $NAME-PARAMETER ...)
; compiling (DEFVAR *COSMOS* ...)
; compiling (DEFVAR *CHAOS-OBJECT* ...)
; compiling (DEFVAR *CHAOS-EXPR-SORT* ...)
; compiling (DEFVAR *TERM-SORT* ...)
; compiling (DEFVAR *UNIVERSAL-SORT* ...)
; compiling (DEFVAR *HUNIVERSAL-SORT* ...)
; compiling (DEFVAR *BOTTOM-SORT* ...)
; compiling (DEFVAR *HBOTTOM-SORT* ...)
; compiling (DEFVAR *SORT-SORT* ...)
; compiling (DEFVAR *GENERAL-SORT* ...)
; compiling (DEFVAR *BUILTIN-SORT* ...)
; compiling (DEFVAR *IDENTIFIER-SORT* ...)
; compiling (DEFVAR *ID-SORT* ...)
; compiling (DEFVAR *QID-SORT* ...)
; compiling (DEFVAR *SYNTAX-ERR-SORT* ...)
; compiling (DEFVAR *TYPE-ERR-SORT* ...)
; compiling (DEFVAR *OP-ERR-SORT* ...)
; compiling (DEFVAR *AND-SORT* ...)
; compiling (DEFVAR *OR-SORT* ...)
; compiling (DEFVAR *ERR-SORT* ...)
; compiling (DEFVAR *SORT-ERROR* ...)
; compiling (DEFVAR *RECORD-SORT* ...)
; compiling (DEFVAR *CLASS-SORT* ...)
; compiling (DEFVAR *OPERATOR-SORT* ...)
; compiling (DEFVAR *OPTHEORY-SORT* ...)
; compiling (DEFVAR *MODULE-SORT* ...)
; compiling (DEFVAR *IMPORT-SORT* ...)
; compiling (DEFVAR *SIGNATURE-SORT* ...)
; compiling (DEFVAR *AXIOMSET-SORT* ...)
; compiling (DEFVAR *TRS-SORT* ...)
; compiling (DEFVAR *VARIABLE-SORT* ...)
; compiling (DEFVAR *APPL-FORM-SORT* ...)
; compiling (DEFVAR *PVARIABLE-SORT* ...)
; compiling (DEFVAR *LISP-TERM-SORT* ...)
; compiling (DEFVAR *SLISP-TERM-SORT* ...)
; compiling (DEFVAR *GLISP-TERM-SORT* ...)
; compiling (DEFVAR *BCONST-TERM-SORT* ...)
; compiling (DEFVAR *MODEXPR-SORT* ...)
; compiling (DEFVAR *CHAOS-LIST-SORT* ...)
; compiling (DEFVAR *CHAOS-VOID-SORT* ...)
; compiling (DEFVAR *BOOL-SORT* ...)
; compiling (DEFVAR *SORT-ID-SORT* ...)
; compiling (DEFVAR *STRING-SORT* ...)
; compiling (DEFVAR *CHAOS-VALUE-SORT* ...)
; compiling (DEFVAR *CHARACTER-SORT* ...)
; compiling (DEFVAR *AXIOM-SORT* ...)
; compiling (DEFVAR *OBJECT-IDENTIFIER-SORT* ...)
; compiling (DEFVAR *OBJECT-SORT* ...)
; compiling (DEFVAR *RECORD-INSTANCE-SORT* ...)
; compiling (DEFVAR *CLASS-ID-SORT* ...)
; compiling (DEFVAR *RECORD-ID-SORT* ...)
; compiling (DEFVAR *ATTRIBUTE-ID-SORT* ...)
; compiling (DEFVAR *ATTRIBUTE-SORT* ...)
; compiling (DEFVAR *ATTRIBUTE-LIST-SORT* ...)
; compiling (DEFVAR *ATTR-VALUE-SORT* ...)
; compiling (DEFVAR *MESSAGE-SORT* ...)
; compiling (DEFVAR *CONFIGURATION-SORT* ...)
; compiling (DEFVAR *ACZ-CONFIGURATION-SORT* ...)
; compiling (DEFVAR *SUBST-SORT* ...)
; compiling (DEFVAR *SORT_BUILTIN* ...)
; compiling (DEFVAR *PARAMETER-SORT* ...)
; compiling (DEFVAR *CONDITION-SORT* ...)
; compiling (DEFVAR SUP-UNIVERSAL-SORT-NAME ...)
; compiling (DEFVAR SUP-HUNIVERSAL-SORT-NAME ...)
; compiling (DEFVAR *SYSTEM-STANDARD-PRELUDE* ...)
; compiling (DEFVAR *SYSTEM-SOFT-WIRED* ...)
; compiling (DEFVAR *KERNEL-HARD-WIRED-BUILTIN-MODULES* ...)
; compiling (DEFVAR *SYSTEM-MODULE* ...)
; compiling (DEFVAR *CHAOS-META* ...)
; compiling (DEFVAR *CHAOS-MODULE* ...)
; compiling (DEFVAR *CHAOS-OBJECT-MODULE* ...)
; compiling (DEFVAR *BUILTIN-METALEVEL-SORT* ...)
; compiling (DEFVAR *STRING-NOT-FOUND* ...)
; compiling (DEFVAR *CHAOS-SORT-ORDER* ...)
; compiling (DEFVAR *PARSER-SORT-ORDER* ...)
; compiling (DEFVAR *SYSTEM-OBJECT-MODULE* ...)
; compiling (DEFVAR *IDENTIFIER-MODULE* ...)
; compiling (DEFVAR *UNIVERSAL-MODULE* ...)
; compiling (DEFVAR *PARSER-MODULE* ...)
; compiling (DEFVAR *QID-MODULE* ...)
; compiling (DEFVAR *ID-MODULE* ...)
; compiling (DEFVAR .INT-MODULE. ...)
; compiling (DEFVAR *BUILTIN-METHOD* ...)
; compiling (DEFVAR *BUILTIN-OP* ...)
; compiling (DEFVAR *PARTIAL-OP* ...)
; compiling (DEFVAR *VOID-OP* ...)
; compiling (DEFVAR *PARTIAL-METHOD* ...)
; compiling (DEFVAR *VOID-METHOD* ...)
; compiling (DEFVAR *TYPE-ERR-OP* ...)
; compiling (DEFVAR *TYPE-ERR-METHOD* ...)
; compiling (DEFVAR *OP-ERR-OP* ...)
; compiling (DEFVAR *OP-ERR-METHOD* ...)
; compiling (DEFVAR *OP-TERM* ...)
; compiling (DEFVAR *TRUTH-VALUE-MODULE* ...)
; compiling (DEFVAR *TRUTH-MODULE* ...)
; compiling (DEFVAR *BOOL-MODULE* ...)
; compiling (DEFVAR *IDENTICAL-MODULE* ...)
; compiling (DEFVAR *EQL-MODULE* ...)
; compiling (DEFVAR *BOOTSTRAPPING-BOOL* ...)
; compiling (DEFVAR *BOOL-TRUE* ...)
; compiling (DEFVAR *BOOL-TRUE-METH* ...)
; compiling (DEFVAR *BOOL-FALSE* ...)
; compiling (DEFVAR *BOOL-FALSE-METH* ...)
; compiling (DEFVAR *BOOL-AND* ...)
; compiling (DEFVAR *BOOL-OR* ...)
; compiling (DEFVAR *BOOL-NOT* ...)
; compiling (DEFVAR *SORT-MEMBERSHIP* ...)
; compiling (DEFVAR *BOOL-IF* ...)
; compiling (DEFVAR *BOOL-IMPLY* ...)
; compiling (DEFVAR *BOOL-XOR* ...)
; compiling (DEFVAR *BOOL-EQUAL* ...)
; compiling (DEFVAR *BOOL-MATCH* ...)
; compiling (DEFVAR *BEH-EQUAL* ...)
; compiling (DEFVAR *BOOL-NONEQUAL* ...)
; compiling (DEFVAR *BEH-EQ-PRED* ...)
; compiling (DEFVAR *BOOL-AND-ALSO* ...)
; compiling (DEFVAR *BOOL-OR-ELSE* ...)
; compiling (DEFVAR *BOOL-IFF* ...)
; compiling (DEFVAR *BOOL-COND-OP* ...)
; compiling (DEFVAR *EQL-OP* ...)
; compiling (DEFVAR *M-AND-OP* ...)
; compiling (DEFVAR *M-OR-OP* ...)
; compiling (DEFVAR *RWL-MODULE* ...)
; compiling (DEFVAR *RWL-NAT-STAR-SORT* ...)
; compiling (DEFVAR *RWL-PREDICATE* ...)
; compiling (DEFVAR *RWL-PREDICATE2* ...)
; compiling (DEFVAR .RWL-SCH-CONTEXT. ...)
; compiling (DEFVAR .RWL-CONTEXT-STACK. ...)
; compiling (DEFVAR .RWL-STATES-SO-FAR. ...)
; compiling (DEFVAR *RWL-SEARCH-NO-STATE-REPORT* ...)
; compiling (DEFVAR *IDENTICAL* ...)
; compiling (DEFVAR *NONIDENTICAL* ...)
; compiling (DEFVAR *ATTRIBUTE-CONSTRUCTOR* ...)
; compiling (DEFVAR *ATTRIBUTE-LIST-CONSTRUCTOR* ...)
; compiling (DEFVAR *ATTRIBUTE-LIST-AUX-VARIABLE* ...)
; compiling (DEFVAR *OBJECT-REFERENCE-METHOD* ...)
; compiling (DEFVAR *OBJECT-CONSTRUCTOR-METHOD* ...)
; compiling (DEFVAR *OBJECT-CONSTRUCTOR-OP* ...)
; compiling (DEFVAR *RECORD-CONSTRUCTOR-METHOD* ...)
; compiling (DEFVAR *RECORD-CONSTRUCTOR-OP* ...)
; compiling (DEFVAR *VOID-OBJECT* ...)
; compiling (DEFVAR *VOID-RECORD* ...)
; compiling (DECLAIM (SPECIAL *PARSE-VARIABLES* ...))
; compiling (DECLAIM (SPECIAL *READER-SCHEMA-ENV* ...))
; compiling (DECLAIM (SPECIAL *MACROEXPAND*))
; compiling (DEFVAR *FILL-RC-ATTRIBUTE* ...)
; compiling (DEFVAR *PARSING-AXIOM-LHS* ...)
; compiling (DEFVAR *PARSE-LHS-ATTR-VARS* ...)
; compiling (DEFVAR *LHS-ATTRID-VARS* ...)
; compiling (DEFPARAMETER .LISP-START-SYMBOL. ...)
; compiling (DEFVAR *PARSE-VARIABLES* ...)
; compiling (DEFCONSTANT PARSER-MIN-PRECEDENCE ...)
; compiling (DEFCONSTANT PARSER-MAX-PRECEDENCE ...)
; compiling (DEFVAR *READER-SCHEMA-ENV* ...)
; compiling (DEFVAR *READER-CURRENT-SCHEMA* ...)
; compiling (DEFVAR *READER-CURRENT-CONTEXT* ...)
; compiling (DEFVAR *READER-STARTING-POSITION* ...)
; compiling (DEFVAR *BUILTIN-AST-DICT* ...)
; compiling (DEFVAR *PARSE-NORMALIZE* ...)
; compiling (DEFVAR *MACROEXPAND* ...)
; compiling (DEFVAR *INCLUDE-BOOL* ...)
; compiling (DEFVAR *INCLUDE-BOOL-SAVE*)
; compiling (DEFVAR *INCLUDE-RWL* ...)
; compiling (DEFVAR *INCLUDE-FOPL* ...)
; compiling (DEFVAR *COMPILE-LISP-RHS* ...)
; compiling (DEFVAR *RUNNING-WITH-TK* ...)
; compiling (DEFVAR *SUB-PROMPT* ...)
; compiling (DEFVAR *NO-PROMPT* ...)
; compiling (DEFVAR *CONSIDER-OBJECT* ...)
; compiling (DEFVAR *AUTO-RECONSTRUCT* ...)
; compiling (DEFVAR *SAVE-DEFINITION* ...)
; compiling (DECLAIM (SPECIAL *MODMORPH-NEW-MODULE*))
; compiling (DEFVAR *MODMORPH-NEW-MODULE* ...)
; compiling (DEFVAR *TIME-ZONE* ...)
; compiling (DEFVAR *ALLOW-GENERAL-TERM-INPUT* ...)
; compiling (DEFVAR *CHAOS-LIBPATH* ...)
; compiling (DECLAIM (SPECIAL *BEH-PROOF-IN-PROGRESS*))
; compiling (DEFVAR *BEH-PROOF-IN-PROGRESS* ...)
; compiling (DEFVAR *USER-BOOL* ...)
; compiling (DEFVAR *TRAM-PATH* ...)
; compiling (DEFVAR *TRAM-OPTIONS* ...)
; compiling (DEFVAR *TRAM-BUILTIN-MODULES*)
; compiling (DEFVAR *TRAM-BOOL-MODULES*)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFVAR *CEXEC-LIMIT* ...)
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFVAR *CEXEC-TRACE* ...)
; compiling (DEFVAR *CEXEC-NORMALIZE* ...)
; compiling (DEFVAR *CEXEC-FIND-ALL-SOLUTIONS* ...)
; compiling (DEFVAR *COMPILE-BUILTIN-AXIOM* ...)
; compiling (DEFVAR *BI-UNIVERSAL-OPERATORS* ...)
; compiling (DEFVAR *ALLOW-UNIVERSAL-SORT* ...)
; compiling (DEFVAR *AUTOLOAD-ALIST* ...)
; compiling (DEFVAR *SELECT-AMBIG-TERM* ...)
; compiling (DEFVAR *ACCEPT-SYSTEM-PROOF* ...)
; compiling (DEFVAR *FIND-ALL-RULES* ...)
; compiling (DEFVAR *NO-ID-COMPLETION* ...)
; compiling (DEFVAR *REWRITE-DEBUG* ...)
; compiling (DEFVAR *ON-TERM-HASH-DEBUG* ...)
; compiling (DEFVAR *ON-AXIOM-DEBUG* ...)
; compiling (DEFVAR *BEH-DEBUG* ...)
; compiling (DEFVAR *GEN-RULE-DEBUG* ...)
; compiling (DEFVAR *ON-CHANGE-DEBUG* ...)
; compiling (DEFVAR *ON-OPERATOR-DEBUG* ...)
; compiling (DEFVAR *ON-SORT-DEBUG* ...)
; compiling (DEFVAR *ON-TRS-DEBUG* ...)
; compiling (DEFVAR *ON-IMPORT-DEBUG* ...)
; compiling (DEFVAR *ON-MODEXP-DEBUG* ...)
; compiling (DEFVAR *ON-VIEW-DEBUG* ...)
; compiling (DEFVAR *MATCH-DEBUG* ...)
; compiling (DEFVAR *MODULE-DEP-DEBUG* ...)
; compiling (DEFVAR *TERM-DEBUG* ...)
; compiling (DEFVAR *ON-PARSE-DEBUG* ...)
; compiling (DEFVAR *REGULARIZE-DEBUG* ...)
; compiling (DEFVAR *ON-TRAM-DEBUG* ...)
; compiling (DEFVAR *MEL-DEBUG* ...)
; compiling (DEFVAR *CHECK-IMPORT-MODE* ...)
; compiling (DEFVAR *CEXEC-DEBUG* ...)
; compiling (DEFVAR *DEBUG-META* ...)
; compiling (DEFVAR *DEBUG-CITP* ...)
; compiling (DEFVAR *DEBUG-PRINT* ...)
; compiling (DEFVAR *DEBUG-BTERM* ...)
; compiling (PROCLAIM (QUOTE #))
; compiling (DEFVAR *TOP-LEVEL-TAG* ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/globals-tmpRV9F8A9A.fasl written
; compilation finished in 0:00:00.015
; compiling file "/<<PKGBUILDDIR>>/comlib/macros.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFMACRO ONCE-ONLY ...)
; compiling (DEFMACRO MEMQ ...)
; compiling (DEFMACRO ASSQ ...)
; compiling (DEFMACRO POSQ ...)
; compiling (DEFMACRO MEMEQ ...)
; compiling (DEFMACRO ASSEQ ...)
; compiling (DEFMACRO POSEQ ...)
; compiling (DEFMACRO CASE-EQUAL ...)
; compiling (DEFMACRO DOTIMES-FIXNUM ...)
; compiling (DEFMACRO MSETQ ...)
; compiling (DEFMACRO MLET ...)
; compiling (DEFMACRO LET-IF ...)
; compiling (DEFMACRO WHEN-BIND ...)
; compiling (DEFMACRO WHILE ...)
; compiling (DEFMACRO WHILE-NOT ...)
; compiling (DEFMACRO DEF-SYNONYM ...)
; compiling (DEFMACRO FIXNUMP ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/macros-tmpK2ZAJT4I.fasl written
; compilation finished in 0:00:00.038
; compiling file "/<<PKGBUILDDIR>>/comlib/print-utils.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFUN FILECOL ...)
; compiling (DEFUN FILE-COLUMN ...)
; file: /<<PKGBUILDDIR>>/comlib/print-utils.lisp
; in: DEFUN FILE-COLUMN
;     (DEFUN CHAOS::FILE-COLUMN (CHAOS::STRM)
;       (DECLARE (INLINE CHAOS::FILECOL)
;                (VALUES FIXNUM))
;       (CHAOS::FILECOL CHAOS::STRM))
; --> PROGN 
; ==>
;   (SB-IMPL::%DEFUN 'CHAOS::FILE-COLUMN
;                    (SB-INT:NAMED-LAMBDA CHAOS::FILE-COLUMN
;                        (CHAOS::STRM)
;                      (DECLARE (INLINE CHAOS::FILECOL)
;                               (VALUES FIXNUM))
;                      (BLOCK CHAOS::FILE-COLUMN (CHAOS::FILECOL CHAOS::STRM))))
; 
; caught STYLE-WARNING:
;   Call to CHAOS::FILECOL could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.

; compiling (DEFUN PRINT-CHECK ...)
; file: /<<PKGBUILDDIR>>/comlib/print-utils.lisp
; in: DEFUN PRINT-CHECK
;     (<= CHAOS::*PRINT-LINE-LIMIT* (+ (CHAOS::FILE-COLUMN STREAM) CHAOS::FWD))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= (1+ CHAOS::INDENT) CHAOS::*PRINT-LINE-LIMIT*)
; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= CHAOS::*PRINT-LINE-LIMIT* (+ (CHAOS::FILE-COLUMN STREAM) CHAOS::FWD))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.

;     (>= (1+ CHAOS::INDENT) CHAOS::*PRINT-LINE-LIMIT*)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -4611686018427387903 4611686018427387904), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (<= CHAOS::*PRINT-LINE-LIMIT* (+ (CHAOS::FILE-COLUMN STREAM) CHAOS::FWD))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC-<

;     (>= (1+ CHAOS::INDENT) CHAOS::*PRINT-LINE-LIMIT*)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC->

; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC-=

;     (<= CHAOS::*PRINT-LINE-LIMIT* (+ (CHAOS::FILE-COLUMN STREAM) CHAOS::FWD))
; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC-=

; compiling (DEFUN PRINT-INDENT ...)
; compiling (DEFPARAMETER .TERMINAL-WIDTH. ...)
; compiling (DEFUN PRINT-CENTERING ...)
; file: /<<PKGBUILDDIR>>/comlib/print-utils.lisp
; in: DEFUN PRINT-CENTERING
;     (/ (- CHAOS::.TERMINAL-WIDTH. (LENGTH STRING)) 2.0)
; 
; note: unable to
;   convert to multiplication by reciprocal
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.

;     (TRUNCATE (+ (/ (- CHAOS::.TERMINAL-WIDTH. (LENGTH STRING)) 2.0) 0.5))
; --> TRUNCATE LET 
; ==>
;   (SB-KERNEL:%UNARY-TRUNCATE SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a REAL, not a DOUBLE-FLOAT.

;     (- CHAOS::.TERMINAL-WIDTH. (LENGTH STRING))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (/ (- CHAOS::.TERMINAL-WIDTH. (LENGTH STRING)) 2.0)
; 
; note: forced to do full call
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).

;     (+ (/ (- CHAOS::.TERMINAL-WIDTH. (LENGTH STRING)) 2.0) 0.5)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST
;                                                              T).

; compiling (DEFUN PRINT-TO-RIGHT ...)
; file: /<<PKGBUILDDIR>>/comlib/print-utils.lisp
; in: DEFUN PRINT-TO-RIGHT
;     (- CHAOS::.TERMINAL-WIDTH. 1 (CHAOS::FILECOL STREAM) CHAOS::*PRINT-INDENT*
;        (LENGTH STRING))
; --> - - - 
; ==>
;   (- CHAOS::.TERMINAL-WIDTH. 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> - - 
; ==>
;   (- (- CHAOS::.TERMINAL-WIDTH. 1) (CHAOS::FILECOL STREAM))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

; --> - 
; ==>
;   (- (- (- CHAOS::.TERMINAL-WIDTH. 1) (CHAOS::FILECOL STREAM))
;      CHAOS::*PRINT-INDENT*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

; ==>
;   (-
;    (- (- (- CHAOS::.TERMINAL-WIDTH. 1) (CHAOS::FILECOL STREAM))
;       CHAOS::*PRINT-INDENT*)
;    (LENGTH STRING))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (SIGNED-BYTE 64) &REST
;                                                          T).
;       etc.

;     (DOTIMES
;         (CHAOS::X
;          (- CHAOS::.TERMINAL-WIDTH. 1 (CHAOS::FILECOL STREAM)
;             CHAOS::*PRINT-INDENT* (LENGTH STRING)))
;       (DECLARE (TYPE FIXNUM CHAOS::X))
;       (PRINC CHAOS::FILL-CHAR STREAM))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN PRINT-TO-LEFT ...)
; file: /<<PKGBUILDDIR>>/comlib/print-utils.lisp
; in: DEFUN PRINT-TO-LEFT
;     (- CHAOS::*PRINT-LINE-LIMIT* 1 CHAOS::*PRINT-INDENT* (CHAOS::FILECOL STREAM)
;        (LENGTH STRING))
; --> - - - 
; ==>
;   (- CHAOS::*PRINT-LINE-LIMIT* 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> - - 
; ==>
;   (- (- CHAOS::*PRINT-LINE-LIMIT* 1) CHAOS::*PRINT-INDENT*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

; --> - 
; ==>
;   (- (- (- CHAOS::*PRINT-LINE-LIMIT* 1) CHAOS::*PRINT-INDENT*)
;      (CHAOS::FILECOL STREAM))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

; ==>
;   (-
;    (- (- (- CHAOS::*PRINT-LINE-LIMIT* 1) CHAOS::*PRINT-INDENT*)
;       (CHAOS::FILECOL STREAM))
;    (LENGTH STRING))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (SIGNED-BYTE 64) &REST
;                                                          T).
;       etc.

;     (DOTIMES
;         (CHAOS::X
;          (- CHAOS::*PRINT-LINE-LIMIT* 1 CHAOS::*PRINT-INDENT*
;             (CHAOS::FILECOL STREAM) (LENGTH STRING)))
;       (DECLARE (TYPE FIXNUM CHAOS::X))
;       (PRINC CHAOS::FILL-CHAR STREAM))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN PRINT-NEXT ...)
; compiling (DEFUN PRINT-NEXT-PREFIX ...)
; compiling (DEFUN PRINT-SIMPLE ...)
; compiling (DEFUN PRINT-SIMPLE-PRINC ...)
; compiling (DEFUN PRINT-SIMPLE-PRINC-OPEN ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/print-utils-tmpUX5S4ADN.fasl written
; compilation finished in 0:00:00.019
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "chaosx" "comlib" "print-utils">
; compiling file "/<<PKGBUILDDIR>>/comlib/message.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFUN FLUSH-ALL ...)
; compiling (DEFUN FRESH-ALL ...)
; compiling (DEFVAR *MESSAGE-DB* ...)
; compiling (DEFUN GET-MSG-TYPE ...)
; compiling (DEFUN GET-MSG-LEVEL ...)
; compiling (DEFUN GET-MSG-FMT ...)
; compiling (DEFUN GET-MSG-DESCRIPTION ...)
; compiling (DEFUN REGISTER-MESSAGE ...)
; compiling (DEFVAR *MSG-LVL* ...)
; compiling (DEFVAR *OLD-MSG-LVL* ...)
; compiling (DEFUN SET-VERBOSE-LVL ...)
; file: /<<PKGBUILDDIR>>/comlib/message.lisp
; in: DEFUN SET-VERBOSE-LVL
;     (<= CHAOS::LVL 3)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFUN SET-VERBOSE-ON ...)
; compiling (DEFUN SET-VERBOSE-OFF ...)
; file: /<<PKGBUILDDIR>>/comlib/message.lisp
; in: DEFUN SET-VERBOSE-OFF
;     (ZEROP CHAOS::*MSG-LVL*)
; ==>
;   (= CHAOS::*MSG-LVL* 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; compiling (DEFUN SET-EXPERT-ON ...)
; compiling (DEFUN SET-EXPORT-OFF ...)
; file: /<<PKGBUILDDIR>>/comlib/message.lisp
; in: DEFUN SET-EXPORT-OFF
;     (= CHAOS::*MSG-LVL* 2)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; compiling (DEFUN SET-QUIET-ON ...)
; compiling (DEFUN SET-QUIET-OFF ...)
; file: /<<PKGBUILDDIR>>/comlib/message.lisp
; in: DEFUN SET-QUIET-OFF
;     (= CHAOS::*MSG-LVL* 3)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a (OR (COMPLEX SINGLE-FLOAT)
;                                             (COMPLEX DOUBLE-FLOAT)).
; 
; note: unable to open code because: The operands might not be the same type.

; compiling (DEFUN OUTPUT-MSG ...)
; file: /<<PKGBUILDDIR>>/comlib/message.lisp
; in: DEFUN OUTPUT-MSG
;     (STRING CHAOS::ID)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (>= (CHAOS::GET-MSG-LEVEL CHAOS::ID) CHAOS::*MSG-LVL*)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFMACRO WITH-OUTPUT-CHAOS-ERROR-N ...)
; compiling (DEFMACRO WITH-OUTPUT-CHAOS-WARNING-N ...)
; compiling (DEFMACRO WITH-OUTPUT-PANIC-MESSAGE-N ...)
; compiling (DEFMACRO WITH-OUTPUT-MSG-N ...)
; compiling (DEFMACRO WITH-OUTPUT-SIMPLE-MSG-N ...)
; compiling (DEFMACRO WITH-OUTPUT-CHAOS-ERROR ...)
; compiling (DEFMACRO WITH-OUTPUT-CHAOS-WARNING ...)
; compiling (DEFMACRO WITH-OUTPUT-PANIC-MESSAGE ...)
; compiling (DEFMACRO WITH-OUTPUT-MSG ...)
; compiling (DEFMACRO WITH-OUTPUT-SIMPLE-MSG ...)
; compiling (DEFUN PRINT-IN-PROGRESS ...)
; compiling (DEFMACRO I-MISS-CURRENT-MODULE ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/message-tmp10401X32.fasl written
; compilation finished in 0:00:00.091
; compiling file "/<<PKGBUILDDIR>>/comlib/error.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DECLAIM (SPECIAL *SUPPRESS-ERR-HANDLER-MSG*))
; compiling (DEFVAR *SUPPRESS-ERR-HANDLER-MSG* ...)
; compiling (DEFUN CHAOS-ERROR ...)
; compiling (DEFUN GET-CHAOS-ERROR-PROC ...)
; compiling (DEFMACRO WITH-CHAOS-ERROR ...)
; compiling (DEFUN CHAOS-INDICATE-POSITION ...)
; compiling (DEFUN CHAOS-TO-TOP ...)
; compiling (DEFMACRO WITH-CHAOS-TOP-ERROR ...)
; compiling (DEFMACRO IGNORING-CHAOS-ERROR ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/error-tmpZ7CBRM0G.fasl written
; compilation finished in 0:00:00.014
; compiling file "/<<PKGBUILDDIR>>/comlib/misc.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFVAR *KEYWORD-PACKAGE* ...)
; compiling (DEFUN MAKE-KEYWORD ...)
; compiling (DEFUN EXTRACT-KEYWORD ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN EXTRACT-KEYWORD
;     (DEFUN CHAOS::EXTRACT-KEYWORD
;            (CHAOS::KEY CHAOS::ARGLIST
;             &OPTIONAL (CHAOS::DEFAULT NIL)
;             &KEY (CHAOS::NO-VALUE NIL))
;       (DECLARE (TYPE LIST CHAOS::ARGLIST)
;                (TYPE T CHAOS::DEFAULT)
;                (TYPE KEYWORD CHAOS::KEY)
;                (VALUES SYMBOL))
;       (LET ((CHAOS::BINDING (MEMBER CHAOS::KEY CHAOS::ARGLIST :TEST #'EQL)))
;         (COND ((AND # CHAOS::NO-VALUE) CHAOS::NO-VALUE)
;               ((CDR CHAOS::BINDING) (CADR CHAOS::BINDING)) (T CHAOS::DEFAULT))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA CHAOS::EXTRACT-KEYWORD
;         (CHAOS::KEY CHAOS::ARGLIST &OPTIONAL (CHAOS::DEFAULT NIL) &KEY
;          (CHAOS::NO-VALUE NIL))
;       (DECLARE (TYPE LIST CHAOS::ARGLIST)
;                (TYPE T CHAOS::DEFAULT)
;                (TYPE KEYWORD CHAOS::KEY)
;                (VALUES SYMBOL))
;       (BLOCK CHAOS::EXTRACT-KEYWORD
;         (LET ((CHAOS::BINDING #))
;           (COND (# CHAOS::NO-VALUE) (# #) (T CHAOS::DEFAULT)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (KEY ARGLIST &OPTIONAL
;                                                      (DEFAULT NIL) &KEY
;                                                      (NO-VALUE NIL))

; compiling (DEFMACRO ALLOC-SVEC ...)
; compiling (DEFMACRO ALLOC-SVEC-FIXNUM ...)
; compiling (DEFMACRO %SVREF ...)
; compiling (DECLAIM (INLINE SVREF ...))
; compiling (DEFUN AT-TOP-LEVEL ...)
; compiling (DEFUN GET-ENVIRONMENT-VARIABLE ...)
; compiling (DEFVAR *ON-DEBUG* ...)
; compiling (DEFVAR *DEBUG-LEVEL* ...)
; compiling (DEFMACRO DEBUG-MSG ...)
; compiling (DEFMACRO DEBUG-FORM ...)
; compiling (DEFUN ON-DEBUG ...)
; compiling (DEFUN OFF-DEBUG ...)
; compiling (DEFUN OB< ...)
; compiling (DEFUN OB-COMPARE ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN OB-COMPARE
;     (< (THE NUMBER CHAOS::X) (THE NUMBER CHAOS::Y))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (< (THE NUMBER CHAOS::Y) (THE NUMBER CHAOS::X))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.

;     (LENGTH (THE SEQUENCE CHAOS::X))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH (THE SEQUENCE CHAOS::Y))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ELT CHAOS::X CHAOS::I)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.

;     (ELT CHAOS::Y CHAOS::I)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.

;     (< (THE NUMBER CHAOS::X) (THE NUMBER CHAOS::Y))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (< (THE NUMBER CHAOS::Y) (THE NUMBER CHAOS::X))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (< (THE INTEGER CHAOS::X) (THE INTEGER CHAOS::Y))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (< (THE INTEGER CHAOS::Y) (THE INTEGER CHAOS::X))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN TOPO-SORT ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN TOPO-SORT
;     (FUNCALL CHAOS::PRED CHAOS::VALR CHAOS::VAL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::PRED)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   PRED is not known to be a function

; compiling (DEFVAR .32BIT. ...)
; compiling (DECLAIM (INLINE ADDR-OF))
; compiling (DEFUN ADDR-OF ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN ADDR-OF
;     (LOGAND CHAOS::.32BIT. (SB-KERNEL:GET-LISP-OBJ-ADDRESS CHAOS::X))
; ==>
;   (LOGAND 'SB-C::DUMMY 18446744073709551615)
; 
; note: forced to do LOGAND-WORD-MASK (cost 10)
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).
;       etc.

;     (DEFUN CHAOS::ADDR-OF (CHAOS::X)
;       (LOGAND CHAOS::.32BIT. (SB-KERNEL:GET-LISP-OBJ-ADDRESS CHAOS::X)))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA CHAOS::ADDR-OF
;         (CHAOS::X)
;       (BLOCK CHAOS::ADDR-OF
;         (LOGAND CHAOS::.32BIT. (SB-KERNEL:GET-LISP-OBJ-ADDRESS CHAOS::X))))
; 
; note: doing unsigned word to integer coercion (cost 20) to "<return value>"

; compiling (DEFUN PRINT-ADDR ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN PRINT-ADDR
;     (CHAOS::ADDR-OF CHAOS::X)
; --> BLOCK LOGAND 
; ==>
;   (LOGAND 'SB-C::DUMMY 18446744073709551615)
; 
; note: forced to do LOGAND-WORD-MASK (cost 10)
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).
;       etc.

;     (FORMAT T "0x~8,'0x" (CHAOS::ADDR-OF CHAOS::X))
; --> FORMAT SB-INT:NAMED-LAMBDA FUNCTION BLOCK LET 
; ==>
;   (SB-FORMAT::FORMAT-PRINT-INTEGER STREAM SB-FORMAT::FORMAT-ARG1 NIL NIL 16
;                                    #:FVAR1 #:FVAR2 #:FVAR3 #:FVAR4)
; 
; note: doing unsigned word to integer coercion (cost 20)

; compiling (DEFUN QUERY-INPUT ...)
; compiling (DEFUN INTERNAL-REAL-TIME-IN-SECONDS ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN INTERNAL-REAL-TIME-IN-SECONDS
;     (FLOAT (/ (GET-INTERNAL-REAL-TIME) INTERNAL-TIME-UNITS-PER-SECOND))
; --> IF 
; ==>
;   (SB-KERNEL:%SINGLE-FLOAT SB-C::N)
; 
; note: forced to do full call
;       unable to do inline float coercion (cost 5) because:
;       The first argument is a (RATIONAL 0 2305843009213693951/1000), not a (SIGNED-BYTE
;                                                                             64).

; compiling (DEFUN READ-CHAR-WAIT ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN READ-CHAR-WAIT
;     (+ CHAOS::START CHAOS::TIMEOUT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 3) because:
;       The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &REST T).

;     (< (+ CHAOS::START CHAOS::TIMEOUT) (CHAOS::INTERNAL-REAL-TIME-IN-SECONDS))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFVAR *USE-TIMEOUTS* ...)
; compiling (DEFVAR *CLEAR-INPUT-BEFORE-QUERY* ...)
; compiling (DEFUN Y-OR-N-P-WAIT ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN Y-OR-N-P-WAIT
;     (FIND CHAR '(#\Tab #\Newline #\Return))
; --> NTH-VALUE MULTIPLE-VALUE-BIND LET SB-KERNEL:%FIND-POSITION 
; --> SB-KERNEL:%FIND-POSITION-IF LET LAMBDA FUNCTION FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::TEST-FUN) SB-C::ITEM
;                   SB-C::I)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFSTRUCT (MULTISET # ...) ...)
; compiling (DEFMACRO MULTISET-NEW ...)
; compiling (DEFMACRO MULTISET-IS-EMPTY ...)
; compiling (DEFMACRO MULTISET-INSERT ...)
; compiling (DEFMACRO LIST-TO-MULTISET ...)
; compiling (DEFMACRO MULTISET-TO-SET ...)
; compiling (DEFMACRO MULTISET-DELETE ...)
; compiling (DEFMACRO MULTISET-MERGE ...)
; compiling (DEFMACRO MULTISET-INTERSECTIN ...)
; compiling (DEFMACRO MULTISET-DIFF ...)
; compiling (DEFMACRO MULTISET-COUNT ...)
; compiling (DEFMACRO MULTISET-COPY ...)
; compiling (DEFMACRO XOR ...)
; compiling (DEFMACRO NAND ...)
; compiling (DEFMACRO NOR ...)
; compiling (DEFUN GET-TIME-STRING ...)
; compiling (DEFUN ELAPSED-TIME-IN-SECONDS ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN ELAPSED-TIME-IN-SECONDS
;     (- CHAOS::NOW CHAOS::BASE)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (SIGNED-BYTE 64) &REST
;                                                          T).
;       etc.

;     (COERCE (/ (- CHAOS::NOW CHAOS::BASE) INTERNAL-TIME-UNITS-PER-SECOND)
;             'SINGLE-FLOAT)
; --> THE 
; ==>
;   (SB-KERNEL:%SINGLE-FLOAT SB-C::X)
; 
; note: forced to do full call
;       unable to do inline float coercion (cost 5) because:
;       The first argument is a RATIONAL, not a (SIGNED-BYTE 64).

; compiling (DEFUN TIME-IN-SECONDS ...)
; file: /<<PKGBUILDDIR>>/comlib/misc.lisp
; in: DEFUN TIME-IN-SECONDS
;     (COERCE (/ CHAOS::SUM INTERNAL-TIME-UNITS-PER-SECOND) 'SINGLE-FLOAT)
; --> THE 
; ==>
;   (SB-KERNEL:%SINGLE-FLOAT SB-C::X)
; 
; note: forced to do full call
;       unable to do inline float coercion (cost 5) because:
;       The first argument is a RATIONAL, not a (SIGNED-BYTE 64).

; compiling (DEFMACRO EVERY2LEN ...)
; compiling (DEFUN LIST2ARRAY ...)
; compiling (DEFUN MAKE-LIST-1-N ...)
; compiling (DEFUN MAKE-LIST-1-N-0 ...)
; compiling (DEFMACRO FIND-IN-ASSOC-TABLE ...)
; compiling (DEFMACRO GET-ENTRY-IN-ASSOC-TABLE ...)
; compiling (DEFMACRO DELETE-ENTRY-FROM-ASSOC-TABLE ...)
; compiling (DEFMACRO DELETE-OBJECT-FROM-ASSOC-TABLE ...)
; compiling (DEFMACRO ADD-TO-ASSOC-TABLE ...)
; compiling (DEFMACRO OBJECT-IS-IN-ASSOC-TABLE? ...)
; compiling (DEFMACRO TEST-AND ...)
; compiling (DEFMACRO MAKE-AND ...)
; compiling (DEFMACRO MAKE-OR ...)
; compiling (DEFMACRO MAKE-XOR ...)
; compiling (DEFMACRO EXPT-FIXNUM ...)
; compiling (DEFMACRO EXPT2 ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/misc-tmp9OZEQ0G2.fasl written
; compilation finished in 0:00:00.141
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "chaosx" "comlib" "misc">
; compiling file "/<<PKGBUILDDIR>>/comlib/string.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFUN STRING-SEARCH-CAR ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN STRING-SEARCH-CAR
;     (POSITION-IF
;      #'(LAMBDA (CHARACTER)
;          (DECLARE (TYPE CHARACTER CHARACTER))
;          (WHEN (FIND CHARACTER CHAOS::CHARACTER-BAG)
;            (SETQ CHAOS::DELIMITER CHARACTER)))
;      STRING)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

; compiling (DEFUN STRING-SEARCH-CDR ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN STRING-SEARCH-CDR
;     (POSITION-IF
;      #'(LAMBDA (CHARACTER)
;          (WHEN (FIND CHARACTER CHAOS::CHARACTER-BAG)
;            (SETQ CHAOS::DELIMITER CHARACTER)))
;      STRING)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (FIND CHARACTER CHAOS::CHARACTER-BAG)
; --> NTH-VALUE MULTIPLE-VALUE-BIND LET SB-KERNEL:%FIND-POSITION 
; --> SB-KERNEL:%FIND-POSITION-IF LET LAMBDA FUNCTION FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::TEST-FUN) SB-C::ITEM
;                   SB-C::I)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN PARSE-WITH-DELIMITER ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN PARSE-WITH-DELIMITER
;     (POSITION CHAOS::DELIM CHAOS::LINE)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION SB-C::ITEM SEQUENCE SB-C::FROM-END SB-C::START
;                             SB-C::END
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY)
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-TEST SB-C::TEST
;                                                                     SB-C::TEST-NOT))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a CHARACTER.

; compiling (DEFUN PARSE-WITH-DELIMITER2 ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN PARSE-WITH-DELIMITER2
;     (POSITION CHAOS::DELIM CHAOS::LINE)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION SB-C::ITEM SEQUENCE SB-C::FROM-END SB-C::START
;                             SB-C::END
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY)
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-TEST SB-C::TEST
;                                                                     SB-C::TEST-NOT))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a CHARACTER.

;     (STRING CHAOS::DELIM)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFUN PARSE-WITH-DELIMITERS ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN PARSE-WITH-DELIMITERS
;     (POSITION-IF #'(LAMBDA (CHARACTER) (FIND CHARACTER CHAOS::DELIMITERS))
;                  CHAOS::LINE)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (FIND CHARACTER CHAOS::DELIMITERS)
; --> NTH-VALUE MULTIPLE-VALUE-BIND LET SB-KERNEL:%FIND-POSITION 
; --> SB-KERNEL:%FIND-POSITION-IF LET LAMBDA FUNCTION FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::TEST-FUN) SB-C::ITEM
;                   SB-C::I)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN PARALLEL-SUBSTITUTE ...)
; compiling (DEFUN PARSE-WITH-STRING-DELIMITER ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN PARSE-WITH-STRING-DELIMITER
;     (VALUES NIL (+ CHAOS::START CHAOS::DLENGTH) NIL)
; 
; note: doing signed word to integer coercion (cost 20)

;     (VALUES (SUBSEQ STRING CHAOS::START CHAOS::DELIM-POS)
;             (+ CHAOS::DELIM-POS CHAOS::DLENGTH) NIL)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN PARSE-WITH-STRING-DELIMITER* ...)
; compiling (DEFUN SPLIT-STRING ...)
; compiling (DEFUN EXTRACT-STRINGS ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN EXTRACT-STRINGS
;     (POSITION-IF-NOT #'(LAMBDA (CHARACTER) (FIND CHARACTER CHAOS::DELIMITERS))
;                      STRING)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF-NOT
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (POSITION-IF #'(LAMBDA (CHARACTER) (FIND CHARACTER CHAOS::DELIMITERS)) STRING
;                  :START CHAOS::BEGIN)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to
;   expand inline
; because:
;   upgraded array element type not known at compile time

;     (FIND CHARACTER CHAOS::DELIMITERS)
; --> NTH-VALUE MULTIPLE-VALUE-BIND LET SB-KERNEL:%FIND-POSITION 
; --> SB-KERNEL:%FIND-POSITION-IF LET LAMBDA FUNCTION FUNCALL 
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::TEST-FUN) SB-C::ITEM
;                   SB-C::I)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN FORMAT-JUSTIFIED-STRING ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN FORMAT-JUSTIFIED-STRING
;     (LENGTH CHAOS::CONTENT)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (< (+ CHAOS::CURSOR CHAOS::CONTENT-LENGTH) CHAOS::WIDTH)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (LENGTH CHAOS::CONTENT)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (+ CHAOS::CURSOR CHAOS::CONTENT-LENGTH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (< (+ CHAOS::CURSOR CHAOS::CONTENT-LENGTH) CHAOS::WIDTH)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (INCF CHAOS::CURSOR CHAOS::CONTENT-LENGTH)
; --> SETQ THE 
; ==>
;   (+ CHAOS::CONTENT-LENGTH CHAOS::CURSOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (SETF CHAOS::CURSOR (+ CHAOS::PROMPT-LENGTH CHAOS::CONTENT-LENGTH))
; ==>
;   (SETQ CHAOS::CURSOR (+ CHAOS::PROMPT-LENGTH CHAOS::CONTENT-LENGTH))
; 
; note: doing signed word to integer coercion (cost 20) to CURSOR

; compiling (DEFUN NUMBER-TO-STRING ...)
; file: /<<PKGBUILDDIR>>/comlib/string.lisp
; in: DEFUN NUMBER-TO-STRING
;     (TRUNCATE (LOG NUMBER CHAOS::BASE))
; --> TRUNCATE LET 
; ==>
;   (SB-KERNEL:%UNARY-TRUNCATE SB-C::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a FLOAT, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a FLOAT, not a DOUBLE-FLOAT.

;     (1+ (TRUNCATE (LOG NUMBER CHAOS::BASE)))
; ==>
;   (+ (TRUNCATE (LOG NUMBER CHAOS::BASE)) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; compiling (DEFUN NULL-STRING ...)
; compiling (DEFUN READ-DELIMITED-STRING ...)
; compiling (DEFMACRO NUMERIC-CHAR-P ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/string-tmpB2JTL1W9.fasl written
; compilation finished in 0:00:00.056
; compiling file "/<<PKGBUILDDIR>>/comlib/list.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFUN FLATTEN-LIST ...)
; compiling (DEFUN FIRSTN ...)
; compiling (DEFUN IN-ORDER-UNION ...)
; compiling (DEFUN TRUE-LIST-P ...)
; compiling (DEFUN ROTATE-LIST ...)
; file: /<<PKGBUILDDIR>>/comlib/list.lisp
; in: DEFUN ROTATE-LIST
;     (LENGTH LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN DELETE-NTH ...)
; file: /<<PKGBUILDDIR>>/comlib/list.lisp
; in: DEFUN DELETE-NTH
;     (LENGTH CHAOS::LST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/list-tmpP3BI68WQ.fasl written
; compilation finished in 0:00:00.007
; compiling file "/<<PKGBUILDDIR>>/comlib/dag.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFSTRUCT DAG-NODE ...)
; compiling (DEFMACRO CREATE-DAG-NODE ...)
; compiling (DEFMACRO ADD-SUBNODES ...)
; compiling (DEFMACRO PUSH-SUB-NODE ...)
; compiling (DEFMACRO DAG-NODE-IS-MARKED? ...)
; compiling (DEFMACRO MARK-DAG-NODE ...)
; compiling (DEFMACRO UNMARK-DAG-NODE ...)
; compiling (DEFUN UNMARK-ALL-DAG-NODES ...)
; compiling (DEFUN DAG-DFS ...)
; file: /<<PKGBUILDDIR>>/comlib/dag.lisp
; in: DEFUN DAG-DFS
;     (FUNCALL FUNCTION CHAOS::D)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   FUNCTION is not known to be a function

; compiling (DEFUN DAG-WFS ...)
; file: /<<PKGBUILDDIR>>/comlib/dag.lisp
; in: DEFUN DAG-WFS
;     (FUNCALL FUNCTION CHAOS::D)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   FUNCTION is not known to be a function

; compiling (DEFSTRUCT (BDAG #) ...)
; compiling (DEFMACRO CREATE-BDAG-NODE ...)
; compiling (DEFMACRO ADD-BDAG-SUBNODES ...)
; compiling (DEFMACRO PUSH-BDAG-NODE ...)
; compiling (DEFUN GET-BDAG-PARENTS ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/dag-tmpQDARA81Z.fasl written
; compilation finished in 0:00:00.051
; compiling file "/<<PKGBUILDDIR>>/comlib/fsys.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (REQUIRE (QUOTE SB-POSIX))
; compiling (DEFUN LOAD-FILE ...)
; compiling (DECLAIM (FTYPE # ...))
; compiling (DEFUN EXPAND-FILE-NAME ...)
; compiling (DEFMACRO DOFILE ...)
; compiling (DEFUN IS-DIRECTORY? ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN IS-DIRECTORY?
;     (LENGTH (NAMESTRING CHAOS::P))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               NULL), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               NULL), not a VECTOR.

;     (SUBSEQ (NAMESTRING CHAOS::P) (1- (LENGTH (NAMESTRING CHAOS::P))))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               NULL), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               NULL), not a LIST.

; compiling (DEFUN IS-SIMPLE-FILE-NAME? ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN IS-SIMPLE-FILE-NAME?
;     (ERROR "is-simple-file-name? : given non string arg ~a" CHAOS::PATH)
; ==>
;   "is-simple-file-name? : given non string arg ~a"
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

; compiling (DEFUN IS-RELATIVE-FILE-NAME? ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN IS-RELATIVE-FILE-NAME?
;     (ERROR "is-relative-file-name? : given non string arg ~a" CHAOS::PATH)
; ==>
;   "is-relative-file-name? : given non string arg ~a"
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

; compiling (DEFUN SUPPLY-SUFFIXES ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN SUPPLY-SUFFIXES
;     (POSITION #\.
;               (IF (PATHNAMEP CHAOS::PATH)
;                   (PATHNAME-NAME CHAOS::PATH)
;                   CHAOS::PATH)
;               :FROM-END T)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION SB-C::ITEM SEQUENCE SB-C::FROM-END SB-C::START
;                             SB-C::END
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY)
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-TEST SB-C::TEST
;                                                                     SB-C::TEST-NOT))
; 
; note: unable to
;   expand inline
; due to type uncertainty:
;   The second argument is a (OR NULL (SIMPLE-ARRAY CHARACTER (*))
;                                (SIMPLE-ARRAY NIL (*))
;                                SIMPLE-BASE-STRING), not a LIST.
; 
; note: unable to
;   expand inline
; due to type uncertainty:
;   The second argument is a (OR NULL (SIMPLE-ARRAY CHARACTER (*))
;                                (SIMPLE-ARRAY NIL (*))
;                                SIMPLE-BASE-STRING), not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a (OR NULL (SIMPLE-ARRAY CHARACTER (*))
;                                (SIMPLE-ARRAY NIL (*))
;                                SIMPLE-BASE-STRING), not a STRING.

;     (MAPCAR #'PATHNAME
;             (MAPCAR
;              #'(LAMBDA (CHAOS::X)
;                  (CONCATENATE 'STRING (NAMESTRING CHAOS::PATH)
;                               (NAMESTRING CHAOS::X)))
;              CHAOS::SUFFIXES))
; --> LET LET SB-INT:DO-ANONYMOUS BLOCK LET TAGBODY TAGBODY SB-KERNEL:%RPLACD 
; --> SETQ THE CONS FUNCALL SB-C::%FUNCALL 
; ==>
;   (PATHNAME (CAR #:G1))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.

; compiling (DEFUN CHAOS-PROBE-FILE ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN CHAOS-PROBE-FILE
;     (PATHNAME CHAOS::LIBDIR)
; ==>
;   CHAOS::LIBDIR
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

; compiling (DEFUN BARE-CHAOS-PWD ...)
; compiling (DEFUN CHAOS-PWD ...)
; compiling (DEFUN CHAOS-RELATIVE-PATHNAME? ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN CHAOS-RELATIVE-PATHNAME?
;     (PATHNAME CHAOS::F-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.

; compiling (DEFUN CHAOS-GET-RELATIVE-PATH ...)
; compiling (DEFUN CHAOS-GET-DIRECTORY ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN CHAOS-GET-DIRECTORY
;     (PATHNAME CHAOS::FILE-PATH)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.

; compiling (DEFUN CHAOS-GET-RELATIVE-PATH* ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN CHAOS-GET-RELATIVE-PATH*
;     (PATHNAME CHAOS::F-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a PATHNAME.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               PATHNAME SYNONYM-STREAM
;                               FILE-STREAM), not a STRING.

; compiling (DEFUN CHAOS-LS ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN CHAOS-LS
;     (APPLY #'RUN-PROGRAM "/bin/sh" (LIST "-c" CHAOS::COMM) :INPUT NIL :OUTPUT
;            *TERMINAL-IO* NIL)
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-C::%FUNCALL #'RUN-PROGRAM #:G12 #:G13 #:G14 #:G15 #:G16 #:G17)
; 
; note: The third argument (in keyword position) is not a constant, weakening keyword
; argument checking.
; 
; note: The fifth argument (in keyword position) is not a constant, weakening keyword
; argument checking.

; compiling (DEFVAR *CHAOS-DIRECTORY-STACK* ...)
; compiling (DEFUN CHAOS-PRINT-DIRECTORY-STACK ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN CHAOS-PRINT-DIRECTORY-STACK
;     (FORMAT STREAM "~%~a" CHAOS::*CHAOS-DIRECTORY-STACK*)
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "~%~a"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL (TERPRI STREAM) (PRINC SB-FORMAT::FORMAT-ARG1 STREAM))
;             NIL)
;           #:G3)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (DEFUN FSYS-PARSE-NUMBER ...)
; compiling (DEFUN CHAOS-PUSHD ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN CHAOS-PUSHD
;     (LENGTH CHAOS::*CHAOS-DIRECTORY-STACK*)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN CHAOS-POPD ...)
; compiling (DEFUN CHAOS-CD ...)
; compiling (DEFPARAMETER *CHAOS-BINARY-MAGIC* ...)
; compiling (DEFUN CHAOS-BINARY-FILE? ...)
; compiling (DEFPARAMETER *CHAOS-BIN-SUFFIX* ...)
; compiling (DEFUN CHAOS-INPUT-FILE ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN CHAOS-INPUT-FILE
;     (APPLY CHAOS::PROC CHAOS::ARGS)
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::PROC)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (>= (FILE-WRITE-DATE CHAOS::BIN-FNAME) (FILE-WRITE-DATE CHAOS::FNAME))
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

; compiling (DEFUN SET-SEARCH-PATH ...)
; compiling (DEFUN SET-SEARCH-PATH-PLUS ...)
; compiling (DEFUN SET-SEARCH-PATH-MINUS ...)
; compiling (DEFUN PR-SEARCH-PATH ...)
; file: /<<PKGBUILDDIR>>/comlib/fsys.lisp
; in: DEFUN PR-SEARCH-PATH
;     (FORMAT STREAM "libpath = ~{~a~^:~}" CHAOS::*CHAOS-LIBPATH*)
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "libpath = ~{~a~^:~}"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "libpath = " STREAM)
;               (LET* (# #)
;                 (DECLARE #)
;                 (LOOP #
;                       #
;                       #
;                       #)))
;             NIL)
;           #:G3)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (DEFUN CHAOS-INITIALIZE-FSYS ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/fsys-tmpYEMMM7SE.fasl written
; compilation finished in 0:00:00.167
; compiling file "/<<PKGBUILDDIR>>/comlib/tree-display.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFPARAMETER TREE-SPACING ...)
; compiling (DEFPARAMETER LEAVES-AT-BOTTOM? ...)
; compiling (DECLAIM (SPECIAL LEAF? ...))
; compiling (DEFVAR LEAF? ...)
; compiling (DEFVAR LEAF-NAME ...)
; compiling (DEFVAR LEAF-INFO ...)
; compiling (DEFVAR INT-NODE-NAME ...)
; compiling (DEFVAR INT-NODE-CHILDREN ...)
; compiling (DEFUN MAKE-AUGM-LEAF ...)
; compiling (DEFUN MAKE-AUGM-PAD ...)
; compiling (DEFUN MAKE-AUGM-INT-NODE ...)
; compiling (DEFUN AUGM-TREE-INT-NODE? ...)
; compiling (DEFUN AUGM-TREE-PAD? ...)
; compiling (DEFUN AUGM-TREE-WIDTH ...)
; compiling (DEFUN AUGM-TREE-ROOT ...)
; compiling (DEFUN AUGM-TREE-NAME ...)
; compiling (DEFUN AUGM-LEAF-INFO ...)
; compiling (DEFUN AUGM-INT-NODE-LPAD ...)
; compiling (DEFUN AUGM-INT-NODE-RPAD ...)
; compiling (DEFUN AUGM-INT-NODE-CHILDREN ...)
; compiling (DEFUN PAD ...)
; compiling (DEFUN FIELD-WIDTH ...)
; compiling (DEFUN AUGMENT-TREE ...)
; file: /<<PKGBUILDDIR>>/comlib/tree-display.lisp
; in: DEFUN AUGMENT-TREE
;     (FUNCALL CHAOS::LEAF? CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::LEAF?)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (FUNCALL CHAOS::LEAF-NAME CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::LEAF-NAME)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (FUNCALL CHAOS::LEAF-INFO CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::LEAF-INFO)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (FUNCALL CHAOS::INT-NODE-CHILDREN CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::INT-NODE-CHILDREN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (FUNCALL CHAOS::INT-NODE-NAME CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::INT-NODE-NAME)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (* (- (THE FIXNUM (LENGTH (THE LIST CHAOS::CHILDREN))) 1) CHAOS::TREE-SPACING)
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (+ (* (- (THE FIXNUM (LENGTH #)) 1) CHAOS::TREE-SPACING)
;        (THE FIXNUM (APPLY #'+ (MAPCAR #'CHAOS::AUGM-TREE-WIDTH CHAOS::CHILDREN))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       etc.

;     (+ (- CHAOS::WIDTH (THE FIXNUM (CHAOS::AUGM-TREE-WIDTH CHAOS::LAST-CHILD)))
;        (+ (THE FIXNUM (CHAOS::AUGM-TREE-ROOT CHAOS::FIRST-CHILD))
;           (THE FIXNUM (CHAOS::AUGM-TREE-ROOT CHAOS::LAST-CHILD))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -18446744073709551615 18446744073709551613)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -18446744073709551615 18446744073709551613)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC-+
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC-+

;     (CHAOS::MAKE-AUGM-INT-NODE (+ CHAOS::MAX-LEFT CHAOS::MAX-RIGHT)
;      CHAOS::MAX-LEFT CHAOS::NAME (- CHAOS::MAX-LEFT CHAOS::LEFT)
;      (- CHAOS::MAX-RIGHT CHAOS::RIGHT) CHAOS::CHILDREN)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (TYPE HASH-TABLE ...) ...)
; compiling (DEFVAR _DUP-HASH_ ...)
; compiling (DEFVAR _REF-NUM-COUNTER_ ...)
; compiling (DEFVAR _DUP-INFOS_ ...)
; compiling (DEFUN AUGMENT-TREE-AS-GRAPH ...)
; compiling (DEFSTRUCT GRPH-INFO ...)
; compiling (DEFSTRUCT (GRPH-INT-NODE-INFO #))
; compiling (DEFSTRUCT (GRPH-LEAF-INFO #) ...)
; compiling (DEFUN TRAVERSE-TREE-CHECKING-DUPS ...)
; file: /<<PKGBUILDDIR>>/comlib/tree-display.lisp
; in: DEFUN TRAVERSE-TREE-CHECKING-DUPS
;     (FUNCALL CHAOS::LEAF? CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::LEAF?)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (FUNCALL CHAOS::LEAF-NAME CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::LEAF-NAME)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (FUNCALL CHAOS::LEAF-INFO CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::LEAF-INFO)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (FUNCALL CHAOS::INT-NODE-NAME CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::INT-NODE-NAME)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (FUNCALL CHAOS::INT-NODE-CHILDREN CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::INT-NODE-CHILDREN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; compiling (DEFUN AUGMENT-TREE-AS-GRAPH-AUX ...)
; file: /<<PKGBUILDDIR>>/comlib/tree-display.lisp
; in: DEFUN AUGMENT-TREE-AS-GRAPH-AUX
;     (FUNCALL CHAOS::INT-NODE-CHILDREN CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::INT-NODE-CHILDREN)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

;     (* (- (THE FIXNUM (LENGTH CHAOS::CHILDREN)) 1) CHAOS::TREE-SPACING)
; 
; note: unable to
;   convert x*2^k to shift
; due to type uncertainty:
;   The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (+ (* (- (THE FIXNUM (LENGTH CHAOS::CHILDREN)) 1) CHAOS::TREE-SPACING)
;        (THE FIXNUM (APPLY #'+ (MAPCAR #'CHAOS::AUGM-TREE-WIDTH CHAOS::CHILDREN))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       etc.

;     (+ (- CHAOS::WIDTH (THE FIXNUM (CHAOS::AUGM-TREE-WIDTH CHAOS::LAST-CHILD)))
;        (+ (THE FIXNUM (CHAOS::AUGM-TREE-ROOT CHAOS::FIRST-CHILD))
;           (THE FIXNUM (CHAOS::AUGM-TREE-ROOT CHAOS::LAST-CHILD))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808
;                                 9223372036854775806), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -18446744073709551615 18446744073709551613)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -18446744073709551615 18446744073709551613)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC-+
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC-+

;     (CHAOS::MAKE-AUGM-INT-NODE (+ CHAOS::MAX-LEFT CHAOS::MAX-RIGHT)
;      CHAOS::MAX-LEFT CHAOS::NAME (- CHAOS::MAX-LEFT CHAOS::LEFT)
;      (- CHAOS::MAX-RIGHT CHAOS::RIGHT) CHAOS::CHILDREN)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN ANY-INT-NODES? ...)
; compiling (DEFUN ALL-DONE? ...)
; compiling (DEFUN PRINT-SEQ ...)
; compiling (DEFUN PRINT-LOOP1 ...)
; file: /<<PKGBUILDDIR>>/comlib/tree-display.lisp
; in: DEFUN PRINT-LOOP1
;     (- CHAOS::TREE-WIDTH CHAOS::ROOT CHAOS::NAME-RIGHT)
; ==>
;   (- (- CHAOS::TREE-WIDTH CHAOS::ROOT) CHAOS::NAME-RIGHT)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

; compiling (DEFUN PRINT-LOOP2 ...)
; file: /<<PKGBUILDDIR>>/comlib/tree-display.lisp
; in: DEFUN PRINT-LOOP2
;     (+ CHAOS::ROOT 1)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (- CHAOS::TREE-WIDTH CHAOS::ROOT CHAOS::INFO-RIGHT)
; ==>
;   (- (- CHAOS::TREE-WIDTH CHAOS::ROOT) CHAOS::INFO-RIGHT)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The second argument is a (INTEGER -6917529027641081854
;                                 6917529027641081854), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -16140901064495857661 16140901064495857661)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -16140901064495857661 16140901064495857661)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (- CHAOS::TREE-WIDTH CHAOS::ROOT CHAOS::NAME-RIGHT)
; ==>
;   (- (- CHAOS::TREE-WIDTH CHAOS::ROOT) CHAOS::NAME-RIGHT)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775807 9223372036854775807), not a FIXNUM.
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The result is a (VALUES
;                        (INTEGER -13835058055282163710 13835058055282163711)
;                        &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ CHAOS::LPAD CHAOS::ROOT1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (+ CHAOS::ROOT CHAOS::TREE-SPACING CHAOS::RIGHT)
; --> + 
; ==>
;   (+ CHAOS::ROOT CHAOS::TREE-SPACING)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

; ==>
;   (+ (+ CHAOS::ROOT CHAOS::TREE-SPACING) CHAOS::RIGHT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (+ CHAOS::ROOT 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- CHAOS::WIDTH (+ CHAOS::ROOT 1))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
;                                                                &REST T).
;       etc.

;     (+ CHAOS::RIGHT CHAOS::RPAD)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &REST T).
;       etc.

;     (CHAOS::PRINT-LOOP3 (CDR CHAOS::CHILDREN)
;      (CONS CHAOS::CHILD1 (CHAOS::PAD CHAOS::LPAD 'NIL))
;      (- CHAOS::WIDTH1 (+ CHAOS::ROOT1 1)))
; 
; note: doing signed word to integer coercion (cost 20) to RIGHT

;     (- CHAOS::TREE-WIDTH CHAOS::ROOT CHAOS::NAME-RIGHT)
; ==>
;   (- (- CHAOS::TREE-WIDTH CHAOS::ROOT) CHAOS::NAME-RIGHT)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--

;     (- CHAOS::TREE-WIDTH CHAOS::ROOT CHAOS::INFO-RIGHT)
; ==>
;   (- (- CHAOS::TREE-WIDTH CHAOS::ROOT) CHAOS::INFO-RIGHT)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC--
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of GENERIC--

; compiling (DEFUN PRINT-TREES ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/tree-display-tmp73HU0RPK.fasl written
; compilation finished in 0:00:00.052
; compiling file "/<<PKGBUILDDIR>>/comlib/lex.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFVAR *BUILTIN-CATS* ...)
; compiling (DEFMACRO DEFINE-BUILTIN-TOKEN ...)
; compiling (DEFMACRO DECLARE-BI-TOKEN ...)
; compiling (DEFPARAMETER *LISP-ESCAPE-CHAR* ...)
; compiling (DEFPARAMETER .LISP-SIMPLE-SEXPR. ...)
; compiling (DEFPARAMETER .LISP-GENERAL-SEXPR. ...)
; compiling (DEFPARAMETER *CHAOS-ESCAPE-CHAR* ...)
; compiling (DEFPARAMETER .CHAOS-VALUE-SEXPR. ...)
; compiling (DEFPARAMETER .STRING-TOKEN. ...)
; compiling (DECLARE-BI-TOKEN (QUOTE %SLISP))
; compiling (DECLARE-BI-TOKEN (QUOTE %GLISP))
; compiling (DECLARE-BI-TOKEN (QUOTE |String|))
; compiling (DECLARE-BI-TOKEN (QUOTE |%Chaos|))
; compiling (DECLARE-BI-TOKEN (QUOTE |#\||))
; compiling (DECLARE-BI-TOKEN (QUOTE |\|#|))
; compiling (DECLAIM (TYPE # ...))
; compiling (DEFPARAMETER .READER-CHAR-CODE-LIMIT. ...)
; compiling (DECLAIM (TYPE SIMPLE-VECTOR ...))
; compiling (DEFVAR *READER-READ-TABLE*)
; compiling (SETF *READER-READ-TABLE* ...)
; compiling (DEFMACRO !SET-SYNTAX ...)
; compiling (DEFUN LEX-SHOW-DELIMITERS ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN LEX-SHOW-DELIMITERS
;     (FORMAT STREAM "~%~S : ~S" (CODE-CHAR CHAOS::X) CHAOS::SYNTAX)
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "~%~S : ~S"
;               (STREAM SB-FORMAT::FORMAT-ARG1 SB-FORMAT::FORMAT-ARG2 &REST
;                SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (TERPRI STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING " : " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG2 STREAM))
;             NIL)
;           #:G5 #:G6)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (DEFUN !INIT-READ-TABLE ...)
; compiling (DEFMACRO READER-GET-SYNTAX ...)
; compiling (DEFMACRO READER-VALID-CHAR-CODE ...)
; compiling (DEFUN !SET-SINGLE-READER ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN !SET-SINGLE-READER
;     (STRING CHAOS::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               CHARACTER), not a STRING.

; compiling (DEFUN !SET-READER ...)
; compiling (DEFVAR *READER-INPUT* ...)
; compiling (DEFPARAMETER *READER-VOID* ...)
; compiling (DEFVAR *TOKEN-BUF* ...)
; compiling (DEFVAR *LAST-TOKEN* ...)
; compiling (DEFPARAMETER *LEX-EOF* ...)
; compiling (DEFMACRO !READ-IN ...)
; compiling (DEFMACRO !READ-DISCARD ...)
; compiling (DEFUN !READ-SYM ...)
; compiling (DEFUN TEST-LEX ...)
; compiling (DEFPARAMETER NEWLINE-STRING ...)
; compiling (DEFPARAMETER LINE-CONTINUE-CHAR ...)
; compiling (DEFPARAMETER .READ-LINE-EOF. ...)
; compiling (DECLAIM (SPECIAL *LIVE-NEWLINE*))
; compiling (DEFVAR *LIVE-NEWLINE* ...)
; compiling (DEFMACRO ADD-NEW-LINE ...)
; compiling (DEFUN READ-LINES ...)
; compiling (DEFVAR .READER-CH. ...)
; compiling (DECLAIM (SPECIAL .ESCAPE-CHAR.))
; compiling (DEFVAR .DEFAULT-ESCAPE-CHAR. ...)
; compiling (DEFPARAMETER CONTROL-D ...)
; compiling (DEFPARAMETER CONTROL-D-STRING ...)
; compiling (DEFPARAMETER INPUT-ESCAPE ...)
; compiling (DEFPARAMETER INPUT-ESCAPE-STRING ...)
; compiling (DEFMACRO SEE-CTRL-D ...)
; compiling (DEFMACRO READER-IS-AT-EOF ...)
; compiling (DEFMACRO AT-EOF ...)
; compiling (DEFMACRO AT-EOF-OR-CONTROL-D ...)
; compiling (DEFMACRO SEE-INPUT-ESCAPE ...)
; compiling (DEFUN STR-MATCH? ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN STR-MATCH?
;     (STRING= (THE SIMPLE-STRING CHAOS::X)
;              (IF (STRINGP CHAOS::Y)
;                  (THE SIMPLE-STRING CHAOS::Y)
;                  (STRING-DOWNCASE (STRING (THE SYMBOL CHAOS::Y)))))
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SIMPLE-STRING, not a SIMPLE-BASE-STRING.
;   The second argument is a SIMPLE-STRING, not a SIMPLE-BASE-STRING.

; compiling (DEFUN LEX-STRING-MATCH ...)
; compiling (DECLAIM (SPECIAL .READER-ESCAPE.))
; compiling (DEFVAR .READER-ESCAPE. ...)
; compiling (DEFVAR .NEWLINE-COUNT. ...)
; compiling (DEFVAR *LAST-NEWLINE* ...)
; compiling (DEFPARAMETER EOF-CHAR ...)
; compiling (DEFUN READER-GET-CHAR ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN READER-GET-CHAR
;     (INCF CHAOS::.NEWLINE-COUNT.)
; --> SETQ THE 
; ==>
;   (+ 1 CHAOS::.NEWLINE-COUNT.)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (> CHAOS::.NEWLINE-COUNT. 2)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CHAOS::.NEWLINE-COUNT.)
; --> SETQ THE 
; ==>
;   (+ 1 CHAOS::.NEWLINE-COUNT.)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (> CHAOS::.NEWLINE-COUNT. 2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DECLAIM (TYPE SIMPLE-STRING ...))
; compiling (DEFVAR .READER-BUF. ...)
; compiling (DEFPARAMETER .CHAOS-SIMPLE-LISP-KEYWORD. ...)
; compiling (DEFPARAMETER .CHAOS-GENERAL-LISP-KEYWORD. ...)
; compiling (DEFPARAMETER .CHAOS-VALUE-KEYWORD. ...)
; compiling (DEFPARAMETER .ML-BEGIN-CHAR. ...)
; compiling (DEFPARAMETER .ML-END-CHAR. ...)
; compiling (DEFVAR .LEX-INNER-MULTI-COMMENT. ...)
; compiling (DEFUN READ-LEXICON ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN READ-LEXICON
;     (STRING CHAOS::.READER-CH.)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFUN LEX-CONSIDER-TOKEN ...)
; compiling (DEFUN READER-SUPPRESS-CH ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN READER-SUPPRESS-CH
;     (STRING CHAOS::.READER-CH.)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFUN READER-UNREAD ...)
; compiling (DEFUN SKIP-MULTI-COMMENT ...)
; compiling (DEFUN UNREAD-TOKEN ...)
; compiling (DEFUN READ-SYM ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN READ-SYM
;     (STRING CHAOS::.READER-CH.)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFUN LEX-READ-STRING ...)
; compiling (DEFUN LEX-READ-LISP-ESCAPE ...)
; compiling (DEFUN LEX-READ-CHAOS-VALUE ...)
; compiling (DEFUN LEX-READ-LIST ...)
; compiling (DEFUN LEX-READ-REST-OF-LIST ...)
; compiling (DEFUN BI-TOKEN? ...)
; compiling (DEFUN LEX-READ ...)
; compiling (DEFMACRO ALL-DIGIT? ...)
; compiling (DEFPARAMETER .DEFAULT-SPACE-CHARS. ...)
; compiling (DEFPARAMETER .DEFAULT-RETURN-CHARS. ...)
; compiling (DEFPARAMETER .DEFAULT-SINGLE-CHARS. ...)
; compiling (DEFUN !FORCE-SINGLE-READER ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN !FORCE-SINGLE-READER
;     (CHAR (THE STRING CHAOS::X) 0)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (STRING CHAOS::X)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFUN !UNSET-SINGLE-READER ...)
; file: /<<PKGBUILDDIR>>/comlib/lex.lisp
; in: DEFUN !UNSET-SINGLE-READER
;     (CHAR (THE STRING CHAOS::X) 0)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

;     (ASSOC CHAOS::CHR CHAOS::.DEFAULT-SINGLE-CHARS.)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

; compiling (DEFUN !LEX-READ-INIT ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/lex-tmpIO5N7K88.fasl written
; compilation finished in 0:00:00.119
; compiling file "/<<PKGBUILDDIR>>/comlib/reader.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFVAR *READER-SPECIAL-SCHEMA-PATTERNS* ...)
; compiling (DEFUN READER ...)
; compiling (DEFUN ABORT-GENERAL-READER ...)
; compiling (DEFUN GENERAL-READ-EOF-ERROR ...)
; compiling (DEFUN GENERAL-READ-ABORT ...)
; compiling (DEFUN STRING-MATCH ...)
; file: /<<PKGBUILDDIR>>/comlib/reader.lisp
; in: DEFUN STRING-MATCH
;     (STRING CHAOS::Y)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (STRING= (THE SIMPLE-STRING CHAOS::X)
;              (IF (STRINGP CHAOS::Y)
;                  (THE SIMPLE-STRING CHAOS::Y)
;                  (THE SIMPLE-STRING (STRING-DOWNCASE (STRING CHAOS::Y)))))
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SIMPLE-STRING, not a SIMPLE-BASE-STRING.
;   The second argument is a SIMPLE-STRING, not a SIMPLE-BASE-STRING.

; compiling (DEFUN GENERAL-READ-STRING-MATCHES ...)
; file: /<<PKGBUILDDIR>>/comlib/reader.lisp
; in: DEFUN GENERAL-READ-STRING-MATCHES
;     (FUNCALL (CADR CHAOS::Y) CHAOS::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (CADR CHAOS::Y))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; compiling (DEFUN GENERAL-READ-NUMBERP ...)
; compiling (DEFUN GENERAL-READ ...)
; compiling (DEFUN READ-NAMED ...)
; compiling (DEFUN READ-OPTIONAL ...)
; compiling (DEFUN READ-IF-PRESENT ...)
; compiling (DEFUN READ-ONE-OF ...)
; compiling (DEFUN READ-ONE-OF-DEFAULT ...)
; compiling (DEFUN READ-MANY-OF ...)
; compiling (DEFUN READ-SEQ-OF ...)
; compiling (DEFUN READ-ANY-ONE ...)
; compiling (DEFUN READ-CONTINUE ...)
; compiling (DEFUN READ-CONTINUE-APPEND ...)
; compiling (DEFUN GENERAL-READ-SHOW-CONTEXT ...)
; compiling (DEFUN GENERAL-READ-IS-SIMPLE-SCHEMA ...)
; compiling (DEFUN GENERAL-READ-DISPLAY-SCHEMA ...)
; compiling (DEFUN GENERAL-READ-PRINT-SCHEMA-1 ...)
; compiling (DEFUN GENERAL-READ-PRINT-SCHEMA ...)
; file: /<<PKGBUILDDIR>>/comlib/reader.lisp
; in: DEFUN GENERAL-READ-PRINT-SCHEMA
;     (< CHAOS::*PRINT-LINE-LIMIT* (CHAOS::FILECOL *STANDARD-OUTPUT*))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (EQL CHAOS::CONTROL-D CHAOS::I)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN READ-COMMENT-LINE ...)
; compiling (DEFUN GENERAL-READ-COMMENTLONG ...)
; compiling (DECLAIM (INLINE READ-TERM-FROM-STRING))
; compiling (DEFPARAMETER .TERM-DELIMITING-CHARS. ...)
; compiling (DEFUN !SET-TERM-DELIM-CHARS ...)
; compiling (DEFUN READ-TERM-FROM-STRING ...)
; compiling (DEFUN READ-SEQ-OF-TERM-FROM-STRING ...)
; compiling (DEFUN READ-TERM-AT-TOP ...)
; compiling (DEFUN READ-SEQ-OF-TERM-AT-TOP ...)
; compiling (DEFUN READ-TERM ...)
; compiling (DEFUN READ-SEQ-OF-TERM ...)
; compiling (DEFUN READ-ARGS ...)
; compiling (DEFPARAMETER .OP-NAME-DELIMITING-CHARS. ...)
; compiling (DEFUN READ-SEQ-OF-OPNAME ...)
; compiling (DEFUN READ-OPNAME ...)
; compiling (DEFUN READ-OPNAME-AT-TOP ...)
; compiling (DEFUN READ-SEQ-OF-OPNAME-AT-TOP ...)
; compiling (DEFUN READ-OPNAME-FROM-STRING ...)
; compiling (DEFUN READ-SEQ-OF-OPNAME-FROM-STRING ...)
; compiling (DEFUN READ-SORT ...)
; compiling (DEFUN READ-SORTS ...)
; compiling (DEFUN READ-CHARS ...)
; compiling (DEFUN READ-OPATTR ...)
; compiling (DEFUN READ-SUPER-EXP ...)
; compiling (DEFUN READ-SUPEREXP ...)
; compiling (DEFUN READ-SUPEREXPR-DELIMITED ...)
; compiling (DEFVAR *MODEXP-PARSE-INPUT* ...)
; compiling (DEFMACRO MODEXP-SKIP ...)
; compiling (DEFUN SCAN-PARENTHESIZED-UNIT ...)
; compiling (DEFUN GROUP-PAREN-UNITS ...)
; compiling (DEFUN CHECK-ENCLOSING-PARENS ...)
; compiling (DEFUN READ-MODULE-EXP ...)
; compiling (DEFUN READ-MODEXP ...)
; compiling (DEFUN READ-MODEXP-DELIMITED ...)
; compiling (DEFUN READ-MODEXP-FROM-STRING ...)
; compiling (DEFVAR *INTERACTIVE-SESSION* ...)
; compiling (DEFUN SET-INTERACTIVE ...)
; compiling (DEFUN OFF-INTERACTIVE ...)
; compiling (DEFUN WAIT-UNTIL-NON-WHITE ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/reader-tmpCM21U60Z.fasl written
; compilation finished in 0:00:00.082
; compiling file "/<<PKGBUILDDIR>>/comlib/let-over-lambda.lisp" (written 09 SEP 2015 05:53:34 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (IF (STRING-LESSP # ...) ...)
; compiling (DEFUN GROUP ...)
; compiling (DEFUN MKSTR ...)
; compiling (DEFUN SYMB ...)
; compiling (DEFUN FLATTEN ...)
; compiling (DEFUN G!-SYMBOL-P ...)
; compiling (DEFUN O!-SYMBOL-P ...)
; compiling (DEFUN O!-SYMBOL-TO-G!-SYMBOL ...)
; compiling (DEFMACRO DEFMACRO/G! ...)
; compiling (DEFMACRO DEFMACRO! ...)
; compiling (DEFUN |#"-reader| ...)
; compiling (SET-DISPATCH-MACRO-CHARACTER #\# ...)
; compiling (DEFUN |#>-reader| ...)
; compiling (SET-DISPATCH-MACRO-CHARACTER #\# ...)
; compiling (DEFUN SEGMENT-READER ...)
; compiling (DEFMACRO! MATCH-MODE-PPCRE-LAMBDA-FORM ...)
; compiling (DEFMACRO! SUBST-MODE-PPCRE-LAMBDA-FORM ...)
; compiling (DEFUN |#~-reader| ...)
; compiling (SET-DISPATCH-MACRO-CHARACTER #\# ...)
; compiling (DEFMACRO! DLAMBDA ...)
; compiling (DEFMACRO ALAMBDA ...)
; compiling (DEFMACRO AIF ...)
; compiling (DEFUN |#`-reader| ...)
; compiling (SET-DISPATCH-MACRO-CHARACTER #\# ...)
; compiling (DEFMACRO ALET% ...)
; compiling (DEFMACRO ALET ...)
; compiling (DEFUN LET-BINDING-TRANSFORM ...)
; compiling (DEFMACRO PANDORICLET ...)
; compiling (DEFUN PANDORICLET-GET ...)
; compiling (DEFUN PANDORICLET-SET ...)
; compiling (DECLAIM (INLINE GET-PANDORIC))
; compiling (DEFUN GET-PANDORIC ...)
; compiling (DEFSETF GET-PANDORIC ...)
; compiling (DEFMACRO WITH-PANDORIC ...)
; compiling (DEFUN PANDORIC-HOTPATCH ...)
; compiling (DEFMACRO PANDORIC-RECODE ...)
; compiling (DEFMACRO PLAMBDA ...)
; compiling (DEFVAR PANDORIC-EVAL-TUNNEL)
; compiling (DEFMACRO PANDORIC-EVAL ...)
; compiling (SET-DISPATCH-MACRO-CHARACTER #\# ...)
; compiling (DEFMACRO FAST-PROGN ...)
; compiling (DEFMACRO SAFE-PROGN ...)
; compiling (DEFUN FFORMAT ...)
; compiling (DEFINE-COMPILER-MACRO FFORMAT ...)
; compiling (DECLAIM (INLINE MAKE-TLIST ...))
; compiling (DEFUN MAKE-TLIST ...)
; compiling (DEFUN TLIST-LEFT ...)
; compiling (DEFUN TLIST-RIGHT ...)
; compiling (DEFUN TLIST-EMPTY-P ...)
; compiling (DECLAIM (INLINE TLIST-ADD-LEFT ...))
; compiling (DEFUN TLIST-ADD-LEFT ...)
; compiling (DEFUN TLIST-ADD-RIGHT ...)
; compiling (DECLAIM (INLINE TLIST-REM-LEFT))
; compiling (DEFUN TLIST-REM-LEFT ...)
; compiling (DECLAIM (INLINE TLIST-UPDATE))
; compiling (DEFUN TLIST-UPDATE ...)
; compiling (DEFUN BUILD-BATCHER-SN ...)
; compiling (DEFMACRO! SORTF ...)
; compiling (DEFUN DOLLAR-SYMBOL-P ...)
; compiling (DEFUN PRUNE-IF-MATCH-BODIES-FROM-SUB-LEXICAL-SCOPE ...)
; compiling (DEFMACRO! IF-MATCH ...)
; compiling (DEFMACRO WHEN-MATCH ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/comlib/let-over-lambda-tmp9DT7SEFG.fasl written
; compilation finished in 0:00:00.153
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/term2.lisp" (written 28 DEC 2015 06:25:53 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFTYPE TERM ...)
; compiling (DEFTYPE TERM-BODY ...)
; compiling (DEFMACRO TERMP ...)
; compiling (DEFUN IS-TERM? ...)
; compiling (DEFMACRO TERM-BODY ...)
; compiling (DEFMACRO CREATE-TERM ...)
; compiling (DEFMACRO NEW-TERM ...)
; compiling (DEFMACRO TERM-EQ ...)
; compiling (DEFMACRO TERM-EQUAL ...)
; compiling (DEFUN !TERM-EQ ...)
; compiling (DEFMACRO TERM-REPLACE ...)
; compiling (DEFCONSTANT VARIABLE-TYPE ...)
; compiling (DEFCONSTANT APPLICATION-FORM-TYPE ...)
; compiling (DEFCONSTANT SIMPLE-LISP-CODE-TYPE ...)
; compiling (DEFCONSTANT GENERAL-LISP-CODE-TYPE ...)
; compiling (DEFCONSTANT LISP-CODE-TYPE ...)
; compiling (DEFCONSTANT PSUEDO-CONSTANT-TYPE ...)
; compiling (DEFCONSTANT PURE-BUILTIN-CONSTANT-TYPE ...)
; compiling (DEFCONSTANT SYSTEM-OBJECT-TYPE ...)
; compiling (DEFCONSTANT BUILTIN-CONSTANT-TYPE ...)
; compiling (DEFCONSTANT PRE-ENCODE-BIT ...)
; compiling (DEFCONSTANT PRE-VARIABLE-TYPE ...)
; compiling (DEFCONSTANT PRE-APPLICATION-FORM-TYPE ...)
; compiling (DEFCONSTANT PRE-SIMPLE-LISP-CODE-TYPE ...)
; compiling (DEFCONSTANT PRE-GENERAL-LISP-CODE-TYPE ...)
; compiling (DEFCONSTANT PRE-LISP-CODE-TYPE ...)
; compiling (DEFCONSTANT PRE-PSUEDO-CONSTANT-TYPE ...)
; compiling (DEFCONSTANT PRE-BUILTIN-CONSTANT-TYPE ...)
; compiling (DEFCONSTANT PRE-PURE-BUILTIN-CONSTANT-TYPE ...)
; compiling (DEFCONSTANT PRE-SYSTEM-OBJECT-TYPE ...)
; compiling (DEFCONSTANT REDUCED-FLAG ...)
; compiling (DEFCONSTANT LOWEST-PARSED-FLAG ...)
; compiling (DEFCONSTANT ON-DEMAND-FLAG ...)
; compiling (DEFCONSTANT RED-FLAG ...)
; compiling (DEFMACRO BODY-1ST ...)
; compiling (DEFMACRO BODY-2ND ...)
; compiling (DEFMACRO BODY-3RD ...)
; compiling (DEFMACRO BODY-4TH ...)
; compiling (DEFMACRO TERM-1ST ...)
; compiling (DEFMACRO TERM-2ND ...)
; compiling (DEFMACRO TERM-3RD ...)
; compiling (DEFMACRO TERM-4TH ...)
; compiling (DEFMACRO TERM$CODE ...)
; compiling (DEFMACRO TERM-CODE ...)
; compiling (DEFCONSTANT TERM-TYPE-MASK ...)
; compiling (DEFMACRO TERM-TYPE-EQ ...)
; compiling (DEFUN TERM-TYPE ...)
; compiling (DEFMACRO TERM$SORT ...)
; compiling (DEFMACRO TERM$SORT-CODE ...)
; compiling (DEFMACRO TERM-SORT ...)
; compiling (DEFMACRO TERM-SORT-CODE ...)
; compiling (DEFMACRO VARIABLE$SORT ...)
; compiling (DEFMACRO VARIABLE-SORT ...)
; compiling (DEFMACRO TERM$OP-CODE ...)
; compiling (DEFMACRO TERM$METHOD ...)
; compiling (DEFMACRO TERM$HEAD ...)
; compiling (DEFMACRO TERM-OP-CODE ...)
; compiling (DEFMACRO TERM-METHOD ...)
; compiling (DEFMACRO TERM-HEAD ...)
; compiling (DEFMACRO CHANGE$HEAD-OPERATOR ...)
; compiling (DEFMACRO CHANGE-HEAD-OPERATOR ...)
; compiling (DEFMACRO TERM$VARIABLE-CODE ...)
; compiling (DEFMACRO VARIABLE$NAME ...)
; compiling (DEFMACRO VARIABLE$PRINT-NAME ...)
; compiling (DEFMACRO TERM-VARIABLE-CODE ...)
; compiling (DEFMACRO VARIABLE-NAME ...)
; compiling (DEFMACRO VARIABLE-PRINT-NAME ...)
; compiling (DEFMACRO TERM$BUILTIN-VALUE ...)
; compiling (DEFMACRO TERM-BUILTIN-VALUE ...)
; compiling (DEFMACRO CHAOS-FORM-EXPR ...)
; compiling (DEFMACRO CHAOS-ORIGINAL-EXPR ...)
; compiling (DEFMACRO TERM$PSUEDO-CONSTANT-CODE ...)
; compiling (DEFMACRO TERM$PSUEDO-CONSTANT-NAME ...)
; compiling (DEFMACRO PSUEDO-CONSTANT-CODE ...)
; compiling (DEFMACRO PSUEDO-CONSTANT-NAME ...)
; compiling (DEFMACRO TERM$LISP-FUNCTION ...)
; compiling (DEFMACRO TERM-LISP-FUNCTION ...)
; compiling (DEFMACRO LISP-FORM-FUNCTION ...)
; compiling (DEFMACRO TERM$SYSTEM-OBJECT ...)
; compiling (DEFMACRO TERM-SYSTEM-OBJECT ...)
; compiling (DEFMACRO TERM$LISP-CODE-ORIGINAL-FORM ...)
; compiling (DEFMACRO TERM$LISP-FORM-ORIGINAL-FORM ...)
; compiling (DEFMACRO LISP-CODE-ORIGINAL-FORM ...)
; compiling (DEFMACRO LISP-FORM-ORIGINAL-FORM ...)
; compiling (DEFMACRO TERM$SUBTERMS ...)
; compiling (DEFMACRO TERM-SUBTERMS ...)
; compiling (DEFMACRO TERM$ARG-1 ...)
; compiling (DEFMACRO TERM$ARG-2 ...)
; compiling (DEFMACRO TERM$ARG-3 ...)
; compiling (DEFMACRO TERM$ARG-4 ...)
; compiling (DEFMACRO TERM$ARG-N ...)
; compiling (DEFMACRO TERM-ARG-1 ...)
; compiling (DEFMACRO TERM-ARG-2 ...)
; compiling (DEFMACRO TERM-ARG-3 ...)
; compiling (DEFMACRO TERM-ARG-4 ...)
; compiling (DEFMACRO TERM-ARG-N ...)
; compiling (DEFMACRO TERM-CODE$IS-DECODED? ...)
; compiling (DEFMACRO TERM-CODE$IS-VARIABLE? ...)
; compiling (DEFMACRO TERM-CODE$IS-APPLICATION-FORM? ...)
; compiling (DEFMACRO TERM-CODE$IS-LISP-CODE? ...)
; compiling (DEFMACRO TERM-CODE$IS-SIMPLE-LISP-CODE? ...)
; compiling (DEFMACRO TERM-CODE$IS-GENERAL-LISP-CODE? ...)
; compiling (DEFMACRO TERM-CODE$IS-BUILTIN-CONSTANT? ...)
; compiling (DEFMACRO TERM-CODE$IS-PURE-BUILTIN-CONSTANT? ...)
; compiling (DEFMACRO TERM-CODE$IS-PSUEDO-CONSTANT? ...)
; compiling (DEFMACRO TERM-CODE$IS-SYSTEM-OBJECT? ...)
; compiling (DEFMACRO TERM$IS-VARIABLE? ...)
; compiling (DEFMACRO TERM$IS-APPLICATION-FORM? ...)
; compiling (DEFMACRO TERM$IS-APPLFORM? ...)
; compiling (DEFMACRO TERM$IS-LISP-CODE? ...)
; compiling (DEFMACRO TERM$IS-LISP-FORM? ...)
; compiling (DEFMACRO TERM$IS-SIMPLE-LISP-CODE? ...)
; compiling (DEFMACRO TERM$IS-SIMPLE-LISP-FORM? ...)
; compiling (DEFMACRO TERM$IS-GENERAL-LISP-CODE? ...)
; compiling (DEFMACRO TERM$IS-GENERAL-LISP-FORM? ...)
; compiling (DEFMACRO TERM$IS-PURE-BUILTIN-CONSTANT? ...)
; compiling (DEFMACRO TERM$IS-BUILTIN-CONSTANT? ...)
; compiling (DEFMACRO TERM$IS-PSUEDO-CONSTANT? ...)
; compiling (DEFMACRO TERM$IS-SYSTEM-OBJECT? ...)
; compiling (DEFMACRO TERM-IS-VARIABLE? ...)
; compiling (DEFMACRO TERM-IS-APPLICATION-FORM? ...)
; compiling (DEFMACRO TERM-IS-APPLFORM? ...)
; compiling (DEFMACRO TERM-IS-LISP-FORM? ...)
; compiling (DEFMACRO TERM-IS-SIMPLE-LISP-FORM? ...)
; compiling (DEFMACRO TERM-IS-GENERAL-LISP-FORM? ...)
; compiling (DEFMACRO TERM-IS-PURE-BUILTIN-CONSTANT? ...)
; compiling (DEFMACRO TERM-IS-BUILTIN-CONSTANT? ...)
; compiling (DEFMACRO TERM-IS-PSUEDO-CONSTANT? ...)
; compiling (DEFMACRO TERM-IS-SYSTEM-OBJECT? ...)
; compiling (DEFMACRO TERM-IS-CHAOS-EXPR? ...)
; compiling (DEFMACRO TERM$STATE-FLAG ...)
; compiling (DEFMACRO TERM-STATE-FLAG ...)
; compiling (DEFMACRO TERM$TEST-REDUCED-FLAG ...)
; compiling (DEFMACRO TERM-TEST-REDUCED-FLAG ...)
; compiling (DEFMACRO TERM-IS-REDUCED? ...)
; compiling (DEFMACRO TERM$TEST-RED-FLAG ...)
; compiling (DEFMACRO TERM-TEST-RED-FLAG ...)
; compiling (DEFMACRO TERM-IS-RED ...)
; compiling (DEFMACRO TERM$TEST-LOWEST-PARSED-FLAG ...)
; compiling (DEFMACRO TERM-TEST-LOWEST-PARSED-FLAG ...)
; compiling (DEFMACRO TERM-IS-LOWEST-PARSED? ...)
; compiling (DEFMACRO TERM$TEST-ON-DEMAND-FLAG ...)
; compiling (DEFMACRO TERM-TEST-ON-DEMAND-FLAG ...)
; compiling (DEFMACRO TERM-IS-ON-DEMAND? ...)
; compiling (DEFMACRO TERM$SET-REDUCED-FLAG ...)
; compiling (DEFMACRO TERM-SET-REDUCED-FLAG ...)
; compiling (DEFMACRO MARK-TERM-AS-REDUCED ...)
; compiling (DEFCONSTANT .NOT-REDUCED-BIT. ...)
; compiling (DEFMACRO TERM$UNSET-REDUCED-FLAG ...)
; compiling (DEFMACRO TERM-UNSET-REDUCED-FLAG ...)
; compiling (DEFMACRO MARK-TERM-AS-NOT-REDUCED ...)
; compiling (DEFMACRO TERM$SET-RED-FLAG ...)
; compiling (DEFMACRO TERM-SET-RED ...)
; compiling (DEFCONSTANT .GREEN-BIT. ...)
; compiling (DEFMACRO TERM$SET-GREEN ...)
; compiling (DEFMACRO TERM-SET-GREEN ...)
; compiling (DEFMACRO TERM$SET-LOWEST-PARSED-FLAG ...)
; compiling (DEFMACRO TERM-SET-LOWEST-PARSED-FLAG ...)
; compiling (DEFMACRO MARK-TERM-AS-LOWEST-PARSED ...)
; compiling (DEFCONSTANT .NOT-LOWEST-PARSED-BIT. ...)
; compiling (DEFMACRO TERM$UNSET-LOWEST-PARSED-FLAG ...)
; compiling (DEFMACRO TERM-UNSET-LOWEST-PARSED-FLAG ...)
; compiling (DEFMACRO MARK-TERM-AS-NOT-LOWEST-PARSED ...)
; compiling (DEFMACRO TERM$SET-ON-DEMAND-FLAG ...)
; compiling (DEFMACRO TERM-SET-ON-DEMAND-FLAG ...)
; compiling (DEFMACRO MARK-TERM-AS-ON-DEMAND ...)
; compiling (DEFCONSTANT .NOT-ON-DEMAND-BIT. ...)
; compiling (DEFMACRO TERM$UNSET-ON-DEMAND-FLAG ...)
; compiling (DEFMACRO TERM-UNSET-ON-DEMAND-FLAG ...)
; compiling (DEFMACRO MARK-TERM-AS-NOT-ON-DEMAND ...)
; compiling (DEFCONSTANT VAR-CONST-CODE ...)
; compiling (DEFCONSTANT PRE-VAR-CONST-CODE ...)
; compiling (DEFMACRO @CREATE-VARIABLE-TERM ...)
; compiling (DEFMACRO MAKE-VARIABLE-TERM ...)
; compiling (DEFMACRO VARIABLE-COPY ...)
; compiling (DEFMACRO VARIABLE-COPY-X ...)
; compiling (DEFMACRO CREATE-APPLICATION-FORM-TERM ...)
; compiling (DEFMACRO @CREATE-APPLICATION-FORM-TERM ...)
; compiling (DEFCONSTANT SIMPLE-LISP-CONST-CODE ...)
; compiling (DEFCONSTANT PRE-SIMPLE-LISP-CONST-CODE ...)
; compiling (DEFMACRO CREATE-SIMPLE-LISP-CODE-TERM ...)
; compiling (DEFMACRO MAKE-SIMPLE-LISP-FORM-TERM ...)
; compiling (DEFCONSTANT GENERAL-LISP-CONST-CODE ...)
; compiling (DEFCONSTANT PRE-GENERAL-LISP-CONST-CODE ...)
; compiling (DEFMACRO CREATE-GENERAL-LISP-CODE-TERM ...)
; compiling (DEFMACRO @CREATE-GENERAL-LISP-CODE-TERM ...)
; compiling (DEFMACRO MAKE-GENERAL-LISP-FORM-TERM ...)
; compiling (DEFCONSTANT BUILTIN-CONSTR-CODE ...)
; compiling (DEFCONSTANT PRE-BUILTIN-CONSTR-CODE ...)
; compiling (DEFMACRO MAKE-BCONST-TERM ...)
; compiling (DEFCONSTANT PSUEDO-CONSTANT-CONST-CODE ...)
; compiling (DEFCONSTANT PRE-PSUEDO-CONSTANT-CONST-CODE ...)
; compiling (DEFMACRO MAKE-PSUEDO-CONSTANT-TERM ...)
; compiling (DEFMACRO MAKE-PVARIABLE-TERM ...)
; compiling (DEFMACRO PVARIABLE-COPY ...)
; compiling (DEFCONSTANT SYSTEM-OBJECT-CONST-CODE ...)
; compiling (DEFCONSTANT PRE-SYSTEM-OBJECT-CONST-CODE ...)
; compiling (DEFMACRO MAKE-SYSTEM-OBJECT-TERM ...)
; compiling (DEFCONSTANT ALL-TERM-CODE ...)
; compiling (DEFMACRO TERM? ...)
; compiling (DEFMACRO TERM$BUILTIN-EQUAL ...)
; compiling (DEFMACRO TERM-BUILTIN-EQUAL ...)
; compiling (DEFCONSTANT PRIORI-CONSTANT-TYPE ...)
; compiling (DEFMACRO TERM$IS-CONSTANT? ...)
; compiling (DEFMACRO TERM-IS-CONSTANT? ...)
; compiling (DEFUN TERM-VARIABLES ...)
; compiling (DEFUN TERM-PVARIABLES ...)
; compiling (DECLAIM (INLINE VARIABLES-OCCUR-AT-TOP?))
; compiling (DEFUN VARIABLES-OCCUR-AT-TOP? ...)
; compiling (DEFCONSTANT APRIORI-GROUND-TYPE ...)
; compiling (DEFMACRO TERM$IS-GROUND? ...)
; compiling (DEFUN TERM-IS-GROUND? ...)
; compiling (DECLAIM (INLINE SIMPLE-COPY-TERM))
; compiling (DEFUN SIMPLE-COPY-TERM ...)
; compiling (DEFMACRO !TERM-VARIABLE-MATCH ...)
; compiling (DEFMACRO TERM-VARIABLE-MATCH ...)
; compiling (DEFMACRO !TERM-OPERATOR-EQ ...)
; compiling (DEFMACRO TERM-OPERATOR-EQ ...)
; compiling (DEFMACRO !TERM-OPERATOR-EQUAL ...)
; compiling (DEFMACRO TERM-OPERATOR-EQUAL ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/term2-tmp8065ESJT.fasl written
; compilation finished in 0:00:00.310
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/defterm.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFSTRUCT (%CHAOS-OBJECT #) ...)
; compiling (DEFUN CHAOS-PR-OBJECT ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/defterm.lisp
; in: DEFUN CHAOS-PR-OBJECT
;     (FORMAT STREAM "#<~a : ~x>" (CHAOS::%CHAOS-OBJECT--TYPE CHAOS::OBJ)
;             (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "#<~a : ~x>"
;               (STREAM SB-FORMAT::FORMAT-ARG1 SB-FORMAT::FORMAT-ARG2 &REST
;                SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "#<" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING " : " STREAM)
;               (LET (# #)
;                 (PRINC SB-FORMAT::FORMAT-ARG2 STREAM))
;               (WRITE-CHAR #\> STREAM))
;             NIL)
;           #:G7 #:G8)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

;     (CHAOS::ADDR-OF CHAOS::OBJ)
; --> BLOCK LOGAND 
; ==>
;   (LOGAND 'SB-C::DUMMY 18446744073709551615)
; 
; note: forced to do LOGAND-WORD-MASK (cost 10)
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).
;       etc.

;     (FORMAT STREAM "#<~a : ~x>" (CHAOS::%CHAOS-OBJECT--TYPE CHAOS::OBJ)
;             (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "#<~a : ~x>"
;               (STREAM SB-FORMAT::FORMAT-ARG1 SB-FORMAT::FORMAT-ARG2 &REST
;                SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "#<" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING " : " STREAM)
;               (LET (# #)
;                 (PRINC SB-FORMAT::FORMAT-ARG2 STREAM))
;               (WRITE-CHAR #\> STREAM))
;             NIL)
;           #:G7 #:G8)
; 
; note: doing unsigned word to integer coercion (cost 20)

; compiling (DEFSTRUCT (%CHAOS-STATIC-OBJECT) ...)
; compiling (DEFMACRO OBJECT-TYPE ...)
; compiling (DEFMACRO CHAOS-OBJECT? ...)
; compiling (DEFMACRO TYPE-P-CHAOS ...)
; compiling (DEFMACRO OBJECT-CATEGORY ...)
; compiling (DEFMACRO OBJECT-EVALUATOR ...)
; compiling (DEFMACRO OBJECT-PRINTER ...)
; compiling (DEFMACRO OBJECT-VISIBLE-SLOTS ...)
; compiling (DEFMACRO OBJECT-CONSTRUCTOR ...)
; compiling (DEFSTRUCT (%CHAOS-AST #) ...)
; compiling (DEFMACRO CHAOS-AST? ...)
; compiling (DEFMACRO AST-TYPE ...)
; compiling (DEFMACRO AST-CATEGORY ...)
; compiling (DEFMACRO AST-PRINTER ...)
; compiling (DEFMACRO AST-EVALUATOR ...)
; compiling (DEFUN %MAKE-KEYWORD ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/defterm.lisp
; in: DEFUN %MAKE-KEYWORD
;     (STRING CHAOS::SYMBOL-OR-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFMACRO DEFTERM ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/defterm.lisp
; in: DEFMACRO DEFTERM
;     (STRING CHAOS::CONC-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (STRING CHAOS::NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (STRING CHAOS::CONC-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (STRING CHAOS::NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (STRING CHAOS::CONC-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (STRING CHAOS::NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (STRING CHAOS::CONC-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (STRING CHAOS::NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFMACRO DEFKEY ...)
; compiling (DEFUN %IS-CHAOS-TERM? ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/defterm-tmp7S8Z6FGF.fasl written
; compilation finished in 0:00:00.265
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/bobject2.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFSTRUCT (OBJECT # ...) ...)
; compiling (DEFMACRO OBJECT-INFO ...)
; compiling (DEFUN SET-OBJECT-CONTEXT-MODULE ...)
; compiling (DEFSTRUCT (EX-INTERFACE #) ...)
; compiling (DEFSTRUCT (SYMBOL-TABLE) ...)
; compiling (DEFSTRUCT (STABLE) ...)
; compiling (DEFUN CANONICALIZE-OBJECT-NAME ...)
; compiling (DEFUN SYMBOL-TABLE-ADD ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bobject2.lisp
; in: DEFUN SYMBOL-TABLE-ADD
;     (PUSHNEW CHAOS::OBJ (CHAOS::STABLE-SORTS CHAOS::TBL))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

;     (PUSHNEW CHAOS::OBJ (CHAOS::STABLE-OPERATORS CHAOS::TBL))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

;     (PUSHNEW CHAOS::OBJ (CHAOS::STABLE-PARAMETERS CHAOS::TBL))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

;     (PUSHNEW CHAOS::OBJ (CHAOS::STABLE-SUBMODULES CHAOS::TBL))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

;     (PUSHNEW CHAOS::OBJ (CHAOS::STABLE-AXIOMS CHAOS::TBL))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

;     (PUSHNEW CHAOS::OBJ (CHAOS::STABLE-UNKNOWNS CHAOS::TBL))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

; compiling (DEFUN SYMBOL-TABLE-GET ...)
; compiling (DEFSTRUCT (TOP-OBJECT # ...) ...)
; compiling (DEFMACRO OBJECT-DEPEND-DAG ...)
; compiling (DEFUN OBJECT-PARAMETERS ...)
; compiling (DEFSETF OBJECT-PARAMETERS ...)
; compiling (DEFUN OBJECT-EXPORTING-OBJECTS ...)
; compiling (DEFSETF OBJECT-EXPORTING-OBJECTS ...)
; compiling (DEFUN OBJECT-DIRECT-SUB-OBJECTS ...)
; compiling (DEFUN OBJECT-ALL-SUB-OBJECTS ...)
; compiling (DEFUN GATHER-SUB-OBJECTS ...)
; compiling (DEFUN OBJECT-ALL-EXPORTING-OBJECTS ...)
; compiling (DEFUN GATHER-EXPORTING-OBJECTS ...)
; compiling (DEFUN INITIALIZE-DEPEND-DAG ...)
; compiling (DEFUN INITIALIZE-OBJECT-INTERFACE ...)
; compiling (DEFUN CLEAN-UP-EX-INTERFACE ...)
; compiling (DEFUN ADD-DEPEND-RELATION ...)
; compiling (DEFMACRO OBJECT-STATUS ...)
; compiling (DEFMACRO OBJECT-IS-INCONSISTENT ...)
; compiling (DEFMACRO MARK-OBJECT-AS-INCONSISTENT ...)
; compiling (DEFUN PROPAGATE-OBJECT-CHANGE ...)
; compiling (DEFMACRO OBJECT-DECL-FORM ...)
; compiling (DEFTERM SCRIPT ...)
; compiling (DEFUN SCRIPT? ...)
; compiling (DEFTERM AST ...)
; compiling (DEFUN AST? ...)
; compiling (DEFSTRUCT (PARSE-DICTIONARY #) ...)
; compiling (DEFSTRUCT (SIGNATURE-STRUCT # ...) ...)
; compiling (DEFUN PRINT-SIGNATURE ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bobject2.lisp
; in: DEFUN PRINT-SIGNATURE
;     (FORMAT STREAM "'[:signature \"~a\"]" (CHAOS::MAKE-MODULE-PRINT-NAME2 MOD))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "'[:signature \"~a\"]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "'[:signature \"" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING "\"]" STREAM))
;             NIL)
;           #:G7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (DEFSTRUCT (AXIOM-SET # ...) ...)
; compiling (DEFUN PRINT-AXIOM-SET ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bobject2.lisp
; in: DEFUN PRINT-AXIOM-SET
;     (FORMAT STREAM "':axset[\"~a\"]" (CHAOS::MODULE-PRINT-NAME MOD))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "':axset[\"~a\"]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "':axset[\"" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING "\"]" STREAM))
;             NIL)
;           #:G7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (LET (#) ...)
; compiling (DEFSTRUCT (TRS # ...) ...)
; compiling (DEFUN PRINT-TRS ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bobject2.lisp
; in: DEFUN PRINT-TRS
;     (FORMAT STREAM "'[:trs \"~a\"]" (CHAOS::MAKE-MODULE-PRINT-NAME2 MOD))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "'[:trs \"~a\"]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "'[:trs \"" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING "\"]" STREAM))
;             NIL)
;           #:G7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (DEFSTRUCT (MODULE-DYN-CONTEXT #) ...)
; compiling (DEFSTRUCT (MODULE # ...) ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bobject2.lisp
; in: DEFSTRUCT MODULE
;     (DEFSTRUCT
;         (CHAOS::MODULE (:INCLUDE CHAOS::TOP-OBJECT (CHAOS::-TYPE 'CHAOS::MODULE))
;          (:CONC-NAME "MODULE-") (:CONSTRUCTOR CHAOS::MAKE-MODULE)
;          (:CONSTRUCTOR CHAOS::MODULE* (CHAOS::NAME))
;          (:PRINT-FUNCTION CHAOS::PRINT-MODULE-OBJECT))
;       (CHAOS::PRINT-NAME "" :TYPE STRING)
;       (CHAOS::SIGNATURE NIL :TYPE (OR NULL CHAOS::SIGNATURE-STRUCT))
;       (CHAOS::AXIOM-SET NIL :TYPE (OR NULL CHAOS::AXIOM-SET))
;       (CHAOS::THEOREMS NIL :TYPE LIST)
;       (CHAOS::PARSE-DICTIONARY NIL :TYPE (OR NULL CHAOS::PARSE-DICTIONARY))
;       (CHAOS::TRS NIL :TYPE (OR NULL CHAOS::TRS))
;       (CHAOS::CONTEXT NIL :TYPE (OR NULL CHAOS::MODULE-DYN-CONTEXT))
;       (CHAOS::ALIAS NIL :TYPE LIST))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION CHAOS::MODULE {1003DB2533}>
;    '#(#<SB-KERNEL:LAYOUT for T {20300003}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {20300103}>
;       #<SB-KERNEL:LAYOUT for CHAOS::%CHAOS-OBJECT {204F1403}>
;       #<SB-KERNEL:LAYOUT for CHAOS::OBJECT {204F1E03}>
;       #<SB-KERNEL:LAYOUT for CHAOS::TOP-OBJECT {20501183}>))
; 
; caught STYLE-WARNING:
;   Previously compiled calls to CHAOS::MODULE-P, CHAOS::MODULE-NAME,
;   CHAOS::MODULE-SYMBOL-TABLE and CHAOS::MODULE-PRINT-NAME could not be inlined
;   because the structure definition for CHAOS::MODULE was not yet seen. To avoid
;   this warning, DEFSTRUCT should precede references to the affected functions, or
;   they must be declared locally notinline at each call site.

; compiling (DEFMACRO MODULE-KIND ...)
; compiling (DEFMACRO MODULE-IS-THEORY ...)
; compiling (DEFMACRO MODULE-IS-OBJECT ...)
; compiling (DEFMACRO MODULE-IS-FINAL ...)
; compiling (DEFMACRO MODULE-IS-LOOSE ...)
; compiling (DEFMACRO MODULE-IS-INITIAL ...)
; compiling (DEFUN PRINT-MODULE-OBJECT ...)
; compiling (DEFSTRUCT (VIEW-STRUCT # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFUN PRINT-VIEW-STRUCT-OBJECT ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bobject2.lisp
; in: DEFUN PRINT-VIEW-STRUCT-OBJECT
;     (FORMAT STREAM ":view[~a: ~s => ~s | ~s]"
;             (CHAOS::VIEW-STRUCT-NAME CHAOS::OBJ)
;             (CHAOS::VIEW-STRUCT-SRC CHAOS::OBJ)
;             (CHAOS::VIEW-STRUCT-TARGET CHAOS::OBJ) (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":view[~a: ~s => ~s | ~s]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 SB-FORMAT::FORMAT-ARG2
;                SB-FORMAT::FORMAT-ARG3 SB-FORMAT::FORMAT-ARG4 &REST
;                SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":view[" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING ": " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG2 STREAM)
;               (WRITE-STRING " => " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG3 STREAM)
;               (WRITE-STRING " | " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG4 STREAM)
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G7 #:G8 #:G9 #:G10)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

;     (CHAOS::ADDR-OF CHAOS::OBJ)
; --> BLOCK LOGAND 
; ==>
;   (LOGAND 'SB-C::DUMMY 18446744073709551615)
; 
; note: forced to do LOGAND-WORD-MASK (cost 10)
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).
;       etc.

;     (FORMAT STREAM ":view[~a: ~s => ~s | ~s]"
;             (CHAOS::VIEW-STRUCT-NAME CHAOS::OBJ)
;             (CHAOS::VIEW-STRUCT-SRC CHAOS::OBJ)
;             (CHAOS::VIEW-STRUCT-TARGET CHAOS::OBJ) (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":view[~a: ~s => ~s | ~s]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 SB-FORMAT::FORMAT-ARG2
;                SB-FORMAT::FORMAT-ARG3 SB-FORMAT::FORMAT-ARG4 &REST
;                SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":view[" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING ": " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG2 STREAM)
;               (WRITE-STRING " => " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG3 STREAM)
;               (WRITE-STRING " | " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG4 STREAM)
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G7 #:G8 #:G9 #:G10)
; 
; note: doing unsigned word to integer coercion (cost 20)


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/bobject2-tmpSIT3QPKP.fasl written
; compilation finished in 0:00:00.180
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "chaosx" "chaos" "primitives" "bobject2">
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/absntax.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFTERM SEQ ...)
; compiling (DEFTERM QUOTE ...)
; compiling (DEFTERM SORT-REF ...)
; compiling (DEFUN MAY-BE-ERROR-SORT-REF? ...)
; compiling (DEFTERM SORT-DECL ...)
; compiling (DEFTERM BSORT-DECL ...)
; compiling (DEFTERM SUBSORT-DECL ...)
; compiling (DEFTERM PSORT-DECL ...)
; compiling (DEFTERM ATTR-RENAME ...)
; compiling (DEFTERM SLOT ...)
; compiling (DEFTERM SUPER ...)
; compiling (DEFTERM RECORD-DECL ...)
; compiling (DEFTERM CLASS-DECL ...)
; compiling (DEFTERM OPREF ...)
; compiling (DEFTERM OPATTRS ...)
; compiling (DEFTERM OP-DECL ...)
; compiling (DEFTERM METH-REF ...)
; compiling (DEFTERM VAR-DECL ...)
; compiling (DEFTERM PVAR-DECL ...)
; compiling (DEFTERM LET ...)
; compiling (DEFTERM MACRO ...)
; compiling (DEFTERM AXIOM-DECL ...)
; compiling (DEFTERM AX-REF ...)
; compiling (DEFTERM EQ-REF ...)
; compiling (DEFTERM RL-REF ...)
; compiling (DEFTERM RRULE-REF ...)
; compiling (DEFTERM IMPORT ...)
; compiling (DEFTERM SIGNATURE ...)
; compiling (DEFTERM AXIOMS ...)
; compiling (DEFTERM MODULE-DECL ...)
; compiling (DEFTERM VIEW-DECL ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/absntax-tmpE0PA0714.fasl written
; compilation finished in 0:00:00.435
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/script.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFTERM EVAL ...)
; compiling (DEFTERM ERROR ...)
; compiling (DEFTERM LISP-EVAL ...)
; compiling (DEFTERM DYNA-COMMENT ...)
; compiling (DEFTERM REDUCE ...)
; compiling (DEFTERM TEST-REDUCE ...)
; compiling (DEFTERM PARSE ...)
; compiling (DEFTERM INPUT ...)
; compiling (DEFTERM TRACE ...)
; compiling (DEFTERM TRACE-WHOLE ...)
; compiling (DEFTERM STEP ...)
; compiling (DEFTERM DESCRIBE-MODULE ...)
; compiling (DEFTERM OPEN-MODULE ...)
; compiling (DEFTERM CLOSE-MODULE ...)
; compiling (DEFTERM SAVE ...)
; compiling (DEFTERM RESTORE ...)
; compiling (DEFTERM RESET ...)
; compiling (DEFTERM FULL-RESET ...)
; compiling (DEFTERM LOAD-PRELUDE ...)
; compiling (DEFTERM PROVIDE ...)
; compiling (DEFTERM REQUIRE ...)
; compiling (DEFTERM REWRITE-COUNT ...)
; compiling (DEFTERM STOP-AT ...)
; compiling (DEFTERM PROTECT ...)
; compiling (DEFTERM DRIBBLE ...)
; compiling (DEFTERM SAVE-CHAOS ...)
; compiling (DEFTERM LS ...)
; compiling (DEFTERM PWD ...)
; compiling (DEFTERM SHELL ...)
; compiling (DEFTERM CD ...)
; compiling (DEFTERM PUSHD ...)
; compiling (DEFTERM POPD ...)
; compiling (DEFTERM DIRS ...)
; compiling (DEFTERM SHOW ...)
; compiling (DEFTERM DESCRIBE ...)
; compiling (DEFTERM SELECT ...)
; compiling (DEFTERM SET ...)
; compiling (DEFTERM REGULARIZE ...)
; compiling (DEFTERM CHECK ...)
; compiling (DEFTERM TRAM ...)
; compiling (DEFTERM AUTOLOAD ...)
; compiling (DEFTERM NO-AUTOLOAD ...)
; compiling (DEFTERM CBRED ...)
; compiling (DEFTERM CHAOS ...)
; compiling (DEFTERM CONTINUE ...)
; compiling (DEFTERM WHAT-IS ...)
; compiling (DEFTERM INSPECT ...)
; compiling (DEFTERM LOOK-UP ...)
; compiling (DEFTERM DELIMITER ...)
; compiling (DEFTERM SCASE ...)
; compiling (DEFTERM GENDOC ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/script-tmpJRWHHVG0.fasl written
; compilation finished in 0:00:00.637
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/op-theory.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFTYPE OP-THEORY ...)
; compiling (DEFUN THEORY-MAKE ...)
; compiling (DEFMACRO THEORY-INFO ...)
; compiling (DEFMACRO THEORY-ZERO ...)
; compiling (DEFUN ZERO-RULE-ONLY ...)
; compiling (DEFTYPE THEORY-INFO ...)
; compiling (DEFMACRO THEORY-INFO-NAME ...)
; compiling (DEFMACRO THEORY-INFO-CODE ...)
; compiling (DEFMACRO THEORY-INFO-EMPTY-FOR-UNIFY ...)
; compiling (DEFMACRO THEORY-INFO-EMPTY-FOR-MATCHING ...)
; compiling (DEFMACRO THEORY-INFO-MATCH-EQUAL-FUN ...)
; compiling (DEFMACRO THEORY-INFO-MATCH-INIT-FUN ...)
; compiling (DEFMACRO THEORY-INFO-MATCH-NEXT-FUN ...)
; compiling (DEFMACRO THEORY-INFO-UNIFY-EQUAL-FUN ...)
; compiling (DEFMACRO THEORY-INFO-UNIFY-INIT-FUN ...)
; compiling (DEFMACRO THEORY-INFO-UNIFY-NEXT-FUN ...)
; compiling (DEFUN NEW-THEORY-INFO ...)
; compiling (DEFUN PR-THEORY-INFO ...)
; compiling (DEFUN PR-OPTHEORY-INTERNAL ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/op-theory.lisp
; in: DEFUN PR-OPTHEORY-INTERNAL
;     (FORMAT STREAM "#<Theory ~s : zero = ~s>"
;             (CHAOS::THEORY-INFO-NAME (CHAOS::THEORY-INFO CHAOS::OPTH))
;             (CHAOS::THEORY-ZERO CHAOS::OPTH))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "#<Theory ~s : zero = ~s>"
;               (STREAM SB-FORMAT::FORMAT-ARG1 SB-FORMAT::FORMAT-ARG2 &REST
;                SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "#<Theory " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING " : zero = " STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG2 STREAM)
;               (WRITE-CHAR #\> STREAM))
;             NIL)
;           #:G8 #:G9)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (DEFUN IS-OPERATOR-THEORY? ...)
; compiling (DEFMACRO THEORY-NAME ...)
; compiling (DEFMACRO THEORY-CODE ...)
; compiling (DEFMACRO THEORY-EMPTY-FOR-UNIFY ...)
; compiling (DEFMACRO THEORY-MATCH-EQUAL-FUN ...)
; compiling (DEFMACRO THEORY-MATCH-INIT-FUN ...)
; compiling (DEFMACRO THEORY-MATCH-NEXT-FUN ...)
; compiling (DEFMACRO THEORY-UNIFY-EQUAL-FUN ...)
; compiling (DEFMACRO THEORY-UNIFY-INIT-FUN ...)
; compiling (DEFMACRO THEORY-UNIFY-NEXT-FUN ...)
; compiling (DEFCONSTANT .E. ...)
; compiling (DEFCONSTANT .Z. ...)
; compiling (DEFCONSTANT .I. ...)
; compiling (DEFCONSTANT .C. ...)
; compiling (DEFCONSTANT .A. ...)
; compiling (DEFCONSTANT .AC. ...)
; compiling (DEFCONSTANT .AI. ...)
; compiling (DEFCONSTANT .AZ. ...)
; compiling (DEFCONSTANT .CZ. ...)
; compiling (DEFCONSTANT .CI. ...)
; compiling (DEFCONSTANT .IZ. ...)
; compiling (DEFCONSTANT .ACI. ...)
; compiling (DEFCONSTANT .ACZ. ...)
; compiling (DEFCONSTANT .CIZ. ...)
; compiling (DEFCONSTANT .AIZ. ...)
; compiling (DEFCONSTANT .ACIZ. ...)
; compiling (DEFMACRO TEST-THEORY ...)
; compiling (DEFMACRO UNSET-THEORY ...)
; compiling (DECLAIM (TYPE SIMPLE-VECTOR ...))
; compiling (DEFVAR *THEORY-INFO-ARRAY* ...)
; compiling (DEFMACRO THEORY-CODE-TO-INFO ...)
; compiling (DEFUN CREATE-THEORY ...)
; compiling (DECLAIM (SPECIAL THE-E-PROPERTY ...))
; compiling (DEFMACRO DEFINE-THEORY-INFO ...)
; compiling (DEFINE-THEORY-INFO THE-E-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-Z-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-I-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-IZ-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-C-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-CZ-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-CI-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-CIZ-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-A-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-AZ-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-AI-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-AIZ-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-AC-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-ACZ-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-ACI-PROPERTY ...)
; compiling (DEFINE-THEORY-INFO THE-ACIZ-PROPERTY ...)
; compiling (DEFVAR *THE-EMPTY-THEORY*)
; compiling (SETF *THE-EMPTY-THEORY* ...)
; compiling (DEFMACRO THEORY-INFO-IS-EMPTY-FOR-UNIFY ...)
; compiling (DEFMACRO THEORY-INFO-IS-EMPTY-FOR-MATCHING ...)
; compiling (DEFMACRO THEORY-IS-EMPTY-FOR-UNIFY ...)
; compiling (DEFMACRO THEORY-IS-EMPTY-FOR-MATCHING ...)
; compiling (DEFUN THEORY-INFO-IS-EMPTY-FOR-UNIFY-DIRECT ...)
; compiling (DEFMACRO THEORY-INFO-IS-EMPTY ...)
; compiling (DEFMACRO THEORY-INFO-IS-A ...)
; compiling (DEFMACRO THEORY-INFO-IS-C ...)
; compiling (DEFMACRO THEORY-INFO-IS-I ...)
; compiling (DEFMACRO THEORY-INFO-IS-Z ...)
; compiling (DEFMACRO THEORY-INFO-IS-AC ...)
; compiling (DEFMACRO THEORY-INFO-IS-AI ...)
; compiling (DEFMACRO THEORY-INFO-IS-AZ ...)
; compiling (DEFMACRO THEORY-INFO-IS-CI ...)
; compiling (DEFMACRO THEORY-INFO-IS-CZ ...)
; compiling (DEFMACRO THEORY-INFO-IS-IZ ...)
; compiling (DEFMACRO THEORY-INFO-IS-ACI ...)
; compiling (DEFMACRO THEORY-INFO-IS-ACZ ...)
; compiling (DEFMACRO THEORY-INFO-IS-AIZ ...)
; compiling (DEFMACRO THEORY-INFO-IS-CIZ ...)
; compiling (DEFMACRO THEORY-INFO-IS-ACIZ ...)
; compiling (DEFUN THEORY-INFO-IS-RESTRICTION-OF ...)
; compiling (DEFUN THEORY-INFO-IS-RESTRICTION-OF-IGNORING-ID ...)
; compiling (DEFMACRO E-EQUAL-IN-THEORY ...)
; compiling (DEFMACRO THEORY-CONTAINS-ASSOCIATIVITY ...)
; compiling (DEFUN THEORY-CONTAINS-ASSOCIATIVITY-DIRECT ...)
; compiling (DEFMACRO THEORY-CONTAINS-COMMUTATIVITY ...)
; compiling (DEFUN THEORY-CONTAINS-COMMUTATIVITY-DIRECT ...)
; compiling (DEFMACRO THEORY-CONTAINS-AC ...)
; compiling (DEFUN THEORY-CONTAINS-AC-DIRECT ...)
; compiling (DEFMACRO THEORY-CONTAINS-IDEMPOTENCY ...)
; compiling (DEFUN THEORY-CONTAINS-IDEMPOTENCY-DIRECT ...)
; compiling (DEFMACRO THEORY-CONTAINS-IDENTITY ...)
; compiling (DEFUN THEORY-CONTAINS-IDENTITY-DIRECT ...)
; compiling (DEFMACRO THEORY-CONTAINS-ACZ ...)
; compiling (DEFUN THEORY-CONTAINS-ACZ-DIRECT ...)
; compiling (DEFMACRO THEORY-CONTAINS-AZ ...)
; compiling (DEFUN THEORY-CONTAINS-AZ-DIRECT ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/op-theory-tmp4WZVROCX.fasl written
; compilation finished in 0:00:00.085
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/bmodexp.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFTYPE MODEXP ...)
; compiling (DEFPARAMETER .MODEXP-KEYWORDS. ...)
; compiling (DEFUN IS-MODEXP? ...)
; compiling (DEFTERM MODEXP ...)
; compiling (DEFTERM RMAP ...)
; compiling (DEFTERM REN-SORT ...)
; compiling (DEFTERM REN-HSORT ...)
; compiling (DEFTERM REN-OP ...)
; compiling (DEFTERM REN-BOP ...)
; compiling (DEFTERM VARS ...)
; compiling (DEFTERM REN-PARAM ...)
; compiling (DEFTERM + ...)
; compiling (DEFTERM * ...)
; compiling (DEFTERM ! ...)
; compiling (DEFTERM !ARG ...)
; compiling (DEFMACRO MAKE-?-NAME ...)
; compiling (DEFUN MODEXP-IS-?NAME? ...)
; compiling (DEFUN ?NAME-NAME ...)
; compiling (DEFUN MODEXP-IS-PARAMETER-THEORY ...)
; compiling (DEFTERM VIEW ...)
; compiling (DEFUN MODEXP-IS-ERROR ...)
; compiling (DEFUN MODEXP-IS-SIMPLE-NAME ...)
; compiling (DECLAIM (TYPE LIST ...))
; compiling (DEFVAR *MODEXP-VIEW-TABLE* ...)
; compiling (DEFUN FIND-VIEW-IN-ENV ...)
; compiling (DEFUN ADD-VIEW-DEFN ...)
; compiling (DEFSTRUCT (MODMORPH #) ...)
; compiling (DEFUN MODMORPH-IS-RENAME ...)
; compiling (DEFMACRO MODMORPH-ASSOC-IMAGE ...)
; compiling (DEFMACRO MODMORPH-ASSOC-IMAGES ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/bmodexp-tmpA0I3UKX8.fasl written
; compilation finished in 0:00:00.156
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/bmodule2.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFUN MODULE-IS-PARAMETER-THEORY ...)
; compiling (DEFMACRO MODULE-DAG ...)
; compiling (DEFMACRO MODULE-PARAMETERS ...)
; compiling (DEFMACRO MODULE-EXPORTING-MODULES ...)
; compiling (DEFMACRO MODULE-DAG-SUBMODULES ...)
; compiling (DEFUN MODULE-DIRECT-SUBMODULES ...)
; compiling (DEFUN MODULE-SUBMODULES ...)
; compiling (DEFUN INITIALIZE-MODULE-DAG ...)
; compiling (DEFUN MODULE-ALL-SUBMODULES ...)
; compiling (DEFUN GATHER-SUBMODULES ...)
; compiling (DEFUN GET-MODULE-DEPENDENCY ...)
; compiling (DEFUN GATHER-MODULE-DEPENDENCY ...)
; compiling (DEFUN GET-IMPORTING-PATH ...)
; compiling (DEFUN GET-REAL-IMPORTING-MODE ...)
; compiling (DEFMACRO MODULE-EXTENDS ...)
; compiling (DEFMACRO MODULE-PROTECTS ...)
; compiling (DEFMACRO MODULE-USING ...)
; compiling (DEFMACRO MODULE-INCLUDING ...)
; compiling (DEFMACRO IMPORTED-MODULES ...)
; compiling (DEFMACRO PARAMETER-ARG-NAME ...)
; compiling (DEFMACRO PARAMETER-THEORY-MODULE ...)
; compiling (DEFMACRO PARAMETER-IMPORTED-MODE ...)
; compiling (DEFMACRO PARAMETER-CONTEXT ...)
; compiling (DEFUN PARAMETER-THEORY-ARG-NAME ...)
; compiling (DEFUN PARAMETER-MODULE-THEORY ...)
; compiling (DEFUN PARAMETER-MODULE-CONTEXT ...)
; compiling (DEFUN MODULE-DIRECT-EXPORTING-MODULES ...)
; compiling (DEFUN MODULE-ALL-EXPORTING-MODULES ...)
; compiling (DEFUN GATHER-EXPORTING-MODULES ...)
; compiling (DEFUN INITIALIZE-MODULE-INTERFACE ...)
; compiling (DEFMACRO MODULE-SORTS ...)
; compiling (DEFMACRO MODULE-OWN-SORTS ...)
; compiling (DEFMACRO MODULE-SORT-RELATIONS ...)
; compiling (DEFMACRO MODULE-OPERATORS ...)
; compiling (DEFMACRO MODULE-OPATTRS ...)
; compiling (DEFMACRO MODULE-PRINCIPAL-SORT ...)
; compiling (DEFUN INITIALIZE-SIGNATURE ...)
; compiling (DEFUN CLEAN-UP-SIGNATURE ...)
; compiling (DEFMACRO MODULE-VARIABLES ...)
; compiling (DEFMACRO MODULE-EQUATIONS ...)
; compiling (DEFMACRO MODULE-RULES ...)
; compiling (DEFUN INITIALIZE-AXIOM-SET ...)
; compiling (DEFUN CLEAN-UP-AXIOM-SET ...)
; compiling (DEFMACRO MODULE-DICTIONARY-TABLE ...)
; compiling (DEFMACRO MODULE-DICTIONARY-BUILTINS ...)
; compiling (DEFMACRO MODULE-JUXTAPOSITION ...)
; compiling (DEFUN CLEAR-PARSE-DICT ...)
; compiling (DEFUN INITIALIZE-PARSE-DICTIONARY ...)
; compiling (DEFUN CLEAN-UP-PARSE-DICTIONARY ...)
; compiling (DEFMACRO MODULE-REWRITE-RULES ...)
; compiling (DEFMACRO MODULE-ALL-RULES ...)
; compiling (DEFMACRO MODULE-ALL-SORTS ...)
; compiling (DEFMACRO MODULE-ALL-OPERATORS ...)
; compiling (DEFMACRO MODULE-SORT-ORDER ...)
; compiling (DEFMACRO MODULE-OPINFO-TABLE ...)
; compiling (DEFMACRO MODULE-EXT-RULE-TABLE ...)
; compiling (DEFMACRO MODULE-TRS-SORT-NAME-MAP ...)
; compiling (DEFMACRO MODULE-TRS-OP-INFO-MAP ...)
; compiling (DEFMACRO MODULE-TRS-OP-REV-TABLE ...)
; compiling (DEFMACRO MODULE-TRS-SORT-GRAPH ...)
; compiling (DEFMACRO MODULE-TRS-ERR-SORTS ...)
; compiling (DEFMACRO MODULE-TRS-DUMMY-METHODS ...)
; compiling (DEFMACRO MODULE-TRS-SEM-RELATIONS ...)
; compiling (DEFMACRO MODULE-TRS-SEM-AXIOMS ...)
; compiling (DEFMACRO MODULE-TRS-TRAM ...)
; compiling (DEFUN INITIALIZE-TRS-EXT-INTERFACE ...)
; compiling (DEFUN INITIALIZE-TRS ...)
; compiling (DEFUN CLEAN-UP-TRS ...)
; compiling (DEFMACRO MODULE-BINDINGS ...)
; compiling (DEFMACRO MODULE-SPECIAL-BINDINGS ...)
; compiling (DEFMACRO MODULE-$$TERM ...)
; compiling (DEFMACRO MODULE-$$SUBTERM ...)
; compiling (DEFMACRO MODULE-$$ACTION-STACK ...)
; compiling (DEFMACRO MODULE-$$SELECTION-STACK ...)
; compiling (DEFUN INITIALIZE-MODULE-CONTEXT ...)
; compiling (DEFUN CLEAN-UP-CONTEXT ...)
; compiling (DEFUN MODULE-INFOS ...)
; compiling (DEFSETF MODULE-INFOS ...)
; compiling (DEFMACRO MODULE-PROTECTED-MODULES ...)
; compiling (DEFMACRO MODULE-TYPE ...)
; compiling (DEFMACRO MODULE-IS-HARD-WIRED ...)
; compiling (DEFMACRO MODULE-IS-SYSTEM-MODULE ...)
; compiling (DEFMACRO MODULE-IS-USER-MODULE ...)
; compiling (DEFMACRO MODULE-HIDDEN ...)
; compiling (DEFMACRO MODULE-IS-REGULAR ...)
; compiling (DEFUN ADD-MODULE-ALIAS ...)
; compiling (DEFUN ADD-IMPORTED-MODULE ...)
; compiling (DEFUN MODULE-INCLUDES-RWL ...)
; compiling (DEFMACRO MODULE-VOID-SORTS ...)
; compiling (DEFMACRO MODULE-VOID-METHODS ...)
; compiling (DEFMACRO MODULE-SORTS-FOR-REGULARITY ...)
; compiling (DEFMACRO MODULE-METHODS-FOR-REGULARITY ...)
; compiling (DEFMACRO MODULE-HAS-BEHAVIOURAL-AXIOMS ...)
; compiling (DEFMACRO MODULE-MACROS ...)
; compiling (DEFMACRO MODULE-SKOLEM-FUNCTIONS ...)
; compiling (DEFMACRO MODULE-INSTANCE-DB ...)
; compiling (DEFUN INITIALIZE-MODULE-INSTANCE-DB ...)
; compiling (DEFUN CLEAR-MODULE-INSTANCE-DB ...)
; compiling (DEFMACRO MODULE-PROTECTED-MODE ...)
; compiling (DEFMACRO MODULE-IS-WRITE-PROTECTED ...)
; compiling (DEFMACRO MODULE-CREATION-DATE ...)
; compiling (DEFMACRO MODULE-AXIOMS-TO-BE-FIXED ...)
; compiling (DEFMACRO MODULE-TERMS-TO-BE-FIXED ...)
; compiling (DEFMACRO MODULE-METHODS-WITH-RWL-AXIOM ...)
; compiling (DEFMACRO MODULE-RULES-WITH-RWL-AXIOM ...)
; compiling (DEFMACRO MODULE-BEH-STUFF ...)
; compiling (DEFMACRO MODULE-BEH-ATTRIBUTES ...)
; compiling (DEFMACRO MODULE-BEH-METHODS ...)
; compiling (DEFMACRO MODULE-NON-BEH-METHODS ...)
; compiling (DEFMACRO MODULE-NON-BEH-ATTRIBUTES ...)
; compiling (DEFMACRO MODULE-COBASIS ...)
; compiling (DEFMACRO MODULE-METHODS-WITH-BEH-AXIOM ...)
; compiling (DEFMACRO SORT-IS-FOR-REGULARITY? ...)
; compiling (DEFMACRO METHOD-IS-FOR-REGULARITY? ...)
; compiling (DEFMACRO MODULE-PSORT-DECLARATION ...)
; compiling (DEFMACRO MODULE-ERROR-OP-DECL ...)
; compiling (DEFMACRO MODULE-ERROR-SORTS ...)
; compiling (DEFMACRO MODULE-ERROR-METHODS ...)
; compiling (DEFMACRO MODULE-ERROR-VAR-DECL ...)
; compiling (DEFUN NEEDS-UPDATE-SORT-ORDER ...)
; compiling (DEFUN SET-NEEDS-UPDATE-SORT-ORDER ...)
; compiling (DEFUN UNSET-NEEDS-UPDATE-SORT-ORDER ...)
; compiling (DEFMACRO MODULE-AMBIG-SORTS ...)
; compiling (DEFMACRO MODULE-AMBIG-OPS ...)
; compiling (DEFPARAMETER MODULE-INITIAL ...)
; compiling (DEFPARAMETER MODULE-INCONSISTENT ...)
; compiling (DEFPARAMETER MODULE-REGULARIZED ...)
; compiling (DEFPARAMETER MODULE-READY-PARSING ...)
; compiling (DEFPARAMETER MODULE-READY-REWRITING ...)
; compiling (DEFUN MODULE-IS-INCONSISTENT ...)
; compiling (DEFUN MARK-MODULE-AS-INCONSISTENT ...)
; compiling (DEFMACRO NEED-PARSING-PREPARATION ...)
; compiling (DEFMACRO MODULE-IS-READY-FOR-PARSING ...)
; compiling (DEFMACRO MARK-MODULE-READY-FOR-PARSING ...)
; compiling (DEFMACRO MARK-NEED-PARSING-PREPARATION ...)
; compiling (DEFMACRO NEED-REWRITING-PREPARATION ...)
; compiling (DEFMACRO MODULE-IS-READY-FOR-REWRITING ...)
; compiling (DEFMACRO MARK-MODULE-AS-CONSISTENT ...)
; compiling (DEFMACRO MARK-MODULE-READY-FOR-REWRITING ...)
; compiling (DEFMACRO MARK-MODULE-NEED-REWRITING-PREPARATION ...)
; compiling (DEFMACRO SET-NEEDS-PARSE ...)
; compiling (DEFMACRO NEEDS-PARSE ...)
; compiling (DEFMACRO SET-NEEDS-RULE ...)
; compiling (DEFMACRO NEEDS-RULE ...)
; compiling (DEFMACRO WITH-IN-MODULE ...)
; compiling (DEFUN CHANGE-CURRENT-MODULE ...)
; compiling (DECLAIM (TYPE LIST ...))
; compiling (DEFVAR *MODULES-SO-FAR-TABLE* ...)
; compiling (DEFUN ADD-MODEXP-DEFN ...)
; compiling (DEFUN FIND-GLOBAL-MODULE ...)
; compiling (DEFUN EQUAL-TOP-LEVEL ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bmodule2.lisp
; in: DEFUN EQUAL-TOP-LEVEL
;     (EQL CHAOS::X CHAOS::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN FIND-EQUIVALENT-MODULE-IN-ENV ...)
; compiling (DEFUN MODEXP-UPDATE-NAME ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bmodule2.lisp
; in: DEFUN MODEXP-UPDATE-NAME
;     (RASSOC CHAOS::MODVAL CHAOS::*MODULES-SO-FAR-TABLE*)
; ==>
;   (SB-KERNEL:%RASSOC SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

; compiling (DECLAIM (TYPE LIST ...))
; compiling (DEFVAR *MODEXP-LOCAL-TABLE* ...)
; compiling (DEFUN ADD-MODEXP-LOCAL-DEFN ...)
; compiling (DEFUN GET-MODEXP-LOCAL ...)
; compiling (DECLAIM (TYPE LIST ...))
; compiling (DEFVAR *MODEXP-EVAL-TABLE* ...)
; compiling (DEFUN FIND-MODEXP-EVAL ...)
; compiling (DEFUN ADD-MODEXP-EVAL ...)
; compiling (DEFUN CLEAR-MODEXP-EVAL ...)
; compiling (DEFUN FIND-MODULE-IN-ENV ...)
; compiling (DEFUN FIND-MODULE-IN-ENV-EXT ...)
; compiling (DEFUN FIND-MODULE-IN-SUBLIST ...)
; compiling (DEFVAR .METHOD1. ...)
; compiling (DEFVAR .METHOD-TAB1. ...)
; compiling (DEFVAR .METHOD-VAL1. ...)
; compiling (DEFVAR .METHOD2. ...)
; compiling (DEFVAR .METHOD-TAB2. ...)
; compiling (DEFVAR .METHOD-VAL2. ...)
; compiling (DEFUN CLEAR-METHOD-INFO-HASH ...)
; compiling (DEFUN INITIALIZE-MODULE ...)
; compiling (DEFUN CLEAN-UP-MODULE ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/bmodule2-tmp267Y2N80.fasl written
; compilation finished in 0:00:00.191
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/bview2.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFMACRO VIEW-NAME ...)
; compiling (DEFMACRO VIEW-SRC ...)
; compiling (DEFMACRO VIEW-SOURCE ...)
; compiling (DEFMACRO VIEW-TARGET ...)
; compiling (DEFMACRO VIEW-SORT-MAPS ...)
; compiling (DEFMACRO VIEW-OP-MAPS ...)
; compiling (DEFMACRO VIEW-DECL-FORM ...)
; compiling (DEFMACRO VIEW-INTERFACE ...)
; compiling (DEFMACRO VIEW-EXPORTING-OBJECTS ...)
; compiling (DEFMACRO VIEW-STATUS ...)
; compiling (DEFUN VIEW-P ...)
; compiling (DEFUN MODEXP-IS-VIEW ...)
; compiling (DEFUN VIEW-IS-INCONSISTENT ...)
; compiling (DEFUN MARK-VIEW-AS-CONSISTENT ...)
; compiling (DEFUN COPY-VIEW ...)
; compiling (DEFUN INITIALIZE-VIEW ...)
; compiling (DEFUN CLEAN-UP-VIEW ...)
; compiling (DEFSTRUCT INT-INSTANTIATION ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bview2.lisp
; in: DEFSTRUCT INT-INSTANTIATION
;     (DEFSTRUCT CHAOS::INT-INSTANTIATION
;       (CHAOS::MODULE NIL :TYPE T)
;       (CHAOS::ARGS NIL :TYPE LIST))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION CHAOS::INT-INSTANTIATION {1007B693C3}>
;    '#(#<SB-KERNEL:LAYOUT for T {20300003}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {20300103}>))
; 
; caught STYLE-WARNING:
;   Previously compiled calls to CHAOS::INT-INSTANTIATION-P and
;   CHAOS::INT-INSTANTIATION-MODULE could not be inlined because the structure
;   definition for CHAOS::INT-INSTANTIATION was not yet seen. To avoid this
;   warning, DEFSTRUCT should precede references to the affected functions, or they
;   must be declared locally notinline at each call site.

; compiling (DEFSTRUCT INT-PLUS ...)
; compiling (DEFSTRUCT INT-RENAME ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bview2.lisp
; in: DEFSTRUCT INT-RENAME
;     (DEFSTRUCT CHAOS::INT-RENAME
;       (CHAOS::MODULE NIL :TYPE T)
;       (CHAOS::SORT-MAPS NIL :TYPE LIST)
;       (CHAOS::OP-MAPS NIL :TYPE LIST))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION CHAOS::INT-RENAME {1007D51583}>
;    '#(#<SB-KERNEL:LAYOUT for T {20300003}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {20300103}>))
; 
; caught STYLE-WARNING:
;   Previously compiled calls to CHAOS::INT-RENAME-P and CHAOS::INT-RENAME-MODULE
;   could not be inlined because the structure definition for CHAOS::INT-RENAME was
;   not yet seen. To avoid this warning, DEFSTRUCT should precede references to the
;   affected functions, or they must be declared locally notinline at each call
;   site.

; compiling (DEFUN MODULE-EQ ...)
; compiling (DEFMACRO SAME-RENAMED-MODULE ...)
; compiling (DEFMACRO SAME-VIEW-MAPPING ...)
; compiling (DEFUN OUTER-EQUAL ...)
; compiling (DEFUN SAME-TOP-LEVEL ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bview2.lisp
; in: DEFUN SAME-TOP-LEVEL
;     (EVERY #'EQL CHAOS::ME1 CHAOS::ME2)
; --> BLOCK SB-INT:DX-FLET FLET #:WRAPPER10 BLOCK LET FUNCALL SB-C::%FUNCALL 
; --> EQL IF 
; ==>
;   (EQL #:G7 #:G8)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMACRO GET-RENAME-INFO ...)
; compiling (DEFUN CREATE-DUMMY-MODULE ...)
; compiling (DEFUN CREATE-DUMMY-MODULE-THEN-MAP ...)
; compiling (DEFUN MODULE-IS-RENAME-DUMMY-FOR ...)
; compiling (DEFUN IS-DUMMY-MODULE ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/bview2-tmpOUPE5FSJ.fasl written
; compilation finished in 0:00:00.042
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "chaosx" "chaos" "primitives" "bview2">
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/parse-modexp.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFUN PARSE-MODEXP ...)
; compiling (DEFUN DO-PARSE-MODEXP ...)
; compiling (DEFUN PARSE-RENAME-OR-INST ...)
; compiling (DEFUN PARSE-MAP-BODY ...)
; compiling (DEFUN PARSE-MAP-ELT ...)
; compiling (DEFUN PARSE-INSTANTIATION ...)
; compiling (DECLAIM (SPECIAL *POSITIONAL-ARG-POS* ...))
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFVAR *POSITIONAL-ARG-POS* ...)
; compiling (DEFVAR *ARG-TYPE* ...)
; compiling (DEFUN MODEXP-PARSE-ARGS ...)
; compiling (DEFUN PARSE-INSTANTIATE-ARG-NAME ...)
; compiling (DEFUN MODEXP-PARSE-ARG ...)
; compiling (DEFUN PARSE-VIEW ...)
; compiling (DEFUN DO-PARSE-VIEW ...)
; compiling (DEFUN PARSE-VIEW-BODY ...)
; compiling (DEFUN PARSE-VIEW-ELT ...)
; compiling (DEFUN PARSE-SORT-REFERENCE ...)
; compiling (DEFUN DO-PARSE-SORT-REF ...)
; compiling (DEFUN PARSE-OPERATOR-REFERENCE ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/parse-modexp.lisp
; in: DEFUN PARSE-OPERATOR-REFERENCE
;     (LENGTH (CAR CHAOS::*MODEXP-PARSE-INPUT*))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (POSITION #\. CHAOS::MOD-REF)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

;     (LENGTH CHAOS::MOD-REF)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (SUBSEQ CHAOS::MOD-REF (1+ CHAOS::POS))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; compiling (DEFUN PARSE-OP-SIMPLE-NAME ...)
; compiling (DEFUN MODEXP-PARSE-PARAM-SPECN ...)
; compiling (DEFUN PARSE-BALANCED-CONTEXT ...)
; compiling (DEFUN PARSE-BALANCED-CONTEXT-ONE ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/parse-modexp-tmpIGHCU6ZA.fasl written
; compilation finished in 0:00:00.099
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/normodexp.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DECLAIM (TYPE LIST ...))
; compiling (DEFVAR *MODEXP-NORMALIZED-TABLE* ...)
; compiling (DEFUN FIND-NORMALIZED-MODEXP ...)
; compiling (DEFUN ADD-MODEXP-NORMALIZED ...)
; compiling (DEFUN NORMALIZE-MODEXP ...)
; compiling (DEFUN CANONICALIZE-SIMPLE-MODULE-NAME ...)
; compiling (DEFUN DO-NORMALIZE-MODEXP ...)
; compiling (DEFUN NORMALIZE-RENAME ...)
; compiling (DEFUN NORMALIZE-PLUS ...)
; compiling (DEFUN NORMALIZE-INSTANTIATION ...)
; compiling (DEFUN NORMALIZE-INSTANTIATION-ARGS ...)
; compiling (DEFUN REORDER-MAPS ...)
; compiling (DEFUN NORMALIZE-RENAME-MAP ...)
; compiling (DEFUN NORMALIZE-VIEW ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/normodexp-tmpBO0TUGLK.fasl written
; compilation finished in 0:00:00.016
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/bsort.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFSTRUCT (SORT-STRUCT # ...) ...)
; compiling (DEFMACRO SORT-MODULE ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFSTRUCT (SORT* # ...))
; file: /<<PKGBUILDDIR>>/chaos/primitives/bsort.lisp
; in: DEFSTRUCT SORT*
;     (DEFSTRUCT
;         (CHAOS::SORT* (:INCLUDE CHAOS::SORT-STRUCT (CHAOS::-TYPE 'SORT))
;          (:CONC-NAME "SORT-") (:COPIER NIL) (:CONSTRUCTOR CHAOS::MAKE-SORT)
;          (:CONSTRUCTOR CHAOS::SORT* (CHAOS::ID &OPTIONAL CHAOS::HIDDEN))
;          (:PREDICATE CHAOS::SORT-P) (:PRINT-FUNCTION CHAOS::PRINT-SORT-OBJECT)))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION CHAOS::SORT* {1003D21813}>
;    '#(#<SB-KERNEL:LAYOUT for T {20300003}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {20300103}>
;       #<SB-KERNEL:LAYOUT for CHAOS::%CHAOS-OBJECT {204F1403}>
;       #<SB-KERNEL:LAYOUT for CHAOS::OBJECT {204F1E03}>
;       #<SB-KERNEL:LAYOUT for CHAOS::SORT-STRUCT {204E0083}>))
; 
; caught STYLE-WARNING:
;   Previously compiled call to CHAOS::SORT-P could not be inlined because the
;   structure definition for CHAOS::SORT* was not yet seen. To avoid this warning,
;   DEFSTRUCT should precede references to the affected functions, or they must be
;   declared locally notinline at each call site.

; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFMACRO SORT-TYPE ...)
; compiling (DEFMACRO SORT-NAME ...)
; compiling (DEFMACRO SORT-IS-INHABITED ...)
; compiling (DEFMACRO SORT-IS-HIDDEN ...)
; compiling (DEFMACRO SORT-IS-VISIBLE ...)
; compiling (DEFMACRO SORT-VISIBLE-TYPE ...)
; compiling (DEFMACRO SORT-CONSTRUCTORS ...)
; compiling (DEFUN SORT-IS-DERIVED-FROM ...)
; compiling (DEFUN GET-ORIGINAL-SORT ...)
; compiling (DEFMACRO SORT-IS-USER-DEFINED? ...)
; compiling (DEFUN SORT-VISIBLE-TYPE-PRINT ...)
; compiling (DEFUN PRINT-SORT-OBJECT ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bsort.lisp
; in: DEFUN PRINT-SORT-OBJECT
;     (FORMAT STREAM ":hsort[~s]" CHAOS::NAME)
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":hsort[~s]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":hsort[" STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G58)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

;     (FORMAT STREAM ":sort[~s]" CHAOS::NAME)
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":sort[~s]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":sort[" STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G68)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (DEFUN NEW-GENERAL-SORT ...)
; compiling (DEFVAR *SORT-TABLE* ...)
; compiling (DEFUN GET-SORT-NAMED ...)
; compiling (DEFUN CLEAR-TMP-SORT-CACHE ...)
; compiling (DEFUN REGISTER-SORT-CACHE ...)
; compiling (DEFSTRUCT (CRSORT # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFUN PRINT-CR-SORT-OBJECT ...)
; compiling (DEFSTRUCT (CLASS-SORT # ...))
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFUN PRINT-CLASS-SORT-OBJECT ...)
; compiling (DEFSTRUCT (RECORD-SORT # ...))
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (DEFUN PRINT-RECORD-SORT-OBJECT ...)
; compiling (DEFMACRO CRSORT-CONSTR-METHOD ...)
; compiling (DEFMACRO CRSORT-ID-METHOD ...)
; compiling (DEFMACRO CRSORT-ID-VARIABLE ...)
; compiling (DEFMACRO CRSORT-MAKE-1 ...)
; compiling (DEFMACRO CRSORT-MAKE-2 ...)
; compiling (DEFMACRO CRSORT-IS-A-COPY ...)
; compiling (DEFMACRO CRSORT-MAKE-3 ...)
; compiling (DEFMACRO CRSORT-MAKE-4 ...)
; compiling (DEFUN CREATE-CR-SORT ...)
; compiling (DEFUN NEW-RECORD-SORT ...)
; compiling (DEFUN NEW-CLASS-SORT ...)
; compiling (DEFMACRO FIND-SLOT-INFO ...)
; compiling (DEFMACRO CR-SLOT-NAME ...)
; compiling (DEFMACRO CR-SLOT-SORT ...)
; compiling (DEFMACRO CR-SLOT-DEFAULT ...)
; compiling (DEFMACRO CR-SLOT-ATTRIBUTE-ID ...)
; compiling (DEFMACRO CR-SLOT-ATTRIBUTE-ID-METHOD ...)
; compiling (DEFMACRO CR-SLOT-ATTRIBUTE-ID-VARIABLE ...)
; compiling (DEFMACRO CR-SLOT-READER ...)
; compiling (DEFMACRO CR-SLOT-WRITER ...)
; compiling (DEFMACRO GET-SLOT-SORT ...)
; compiling (DEFMACRO GET-SLOT-DEFAULT ...)
; compiling (DEFMACRO GET-ATTRIBUTE-ID ...)
; compiling (DEFMACRO GET-ATTRIBUTE-ID-METHOD ...)
; compiling (DEFMACRO GET-ATTRIBUTE-ID-VARIABLE ...)
; compiling (DEFMACRO GET-SLOT-READER ...)
; compiling (DEFMACRO GET-SLOT-WRITER ...)
; compiling (DEFSTRUCT (BSORT # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFUN PRINT-BSORT-OBJECT ...)
; compiling (DEFUN NEW-BI-SORT ...)
; compiling (DEFMACRO SORT-IS-BUILTIN ...)
; compiling (DEFMACRO BSORT-TOKEN-PREDICATE ...)
; compiling (DEFMACRO BSORT-TERM-CREATOR ...)
; compiling (DEFMACRO BSORT-TERM-PRINTER ...)
; compiling (DEFMACRO BSORT-TERM-PREDICATE ...)
; compiling (DEFVAR *BUILTIN-SORT-TABLE* ...)
; compiling (DEFUN GET-BUILTIN-SORT-NAMED ...)
; compiling (DEFUN REGISTER-BUILTIN-SORT ...)
; compiling (DEFUN CLEAR-BUILTIN-SORTS ...)
; compiling (DEFSTRUCT (AND-SORT # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFUN PRINT-AND-SORT-OBJECT ...)
; compiling (DEFUN NEW-AND-SORT ...)
; compiling (DEFSTRUCT (OR-SORT # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (DEFUN PRINT-OR-SORT-OBJECT ...)
; compiling (DEFUN NEW-OR-SORT ...)
; compiling (DEFSTRUCT (ERR-SORT # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (DEFUN PRINT-ERR-SORT-OBJECT ...)
; compiling (DEFUN NEW-ERR-SORT ...)
; compiling (DEFMACRO SORT= ...)
; compiling (DEFUN SORT=* ...)
; compiling (DEFMACRO SORT-SET-EQUAL ...)
; compiling (DEFMACRO SORT-LIST= ...)
; compiling (DEFMACRO MAKE-SORT-RELATION ...)
; compiling (DEFMACRO COPY-SORT-RELATION ...)
; compiling (DEFMACRO SORT-RELATION-SORT ...)
; compiling (DEFMACRO _SUBSORTS ...)
; compiling (DEFMACRO _SUPERSORTS ...)
; compiling (DEFMACRO _ERR-SORT ...)
; compiling (DEFUN ELIM-SYS-SORTS-FROM-RELATION ...)
; compiling (DEFTYPE SORT-ORDER ...)
; compiling (DEFUN ALLOCATE-SORT-ORDER ...)
; compiling (DEFUN CLEAR-SORT-ORDER ...)
; compiling (DEFMACRO GET-SORT-RELATION ...)
; compiling (DEFUN COPY-SORT-ORDER ...)
; compiling (DEFUN GET-ALL-SORTS ...)
; compiling (DEFMACRO SUBSORTS ...)
; compiling (DEFMACRO SUB-OR-EQUAL-SORTS ...)
; compiling (DEFMACRO SUPERSORTS ...)
; compiling (DEFMACRO SUPERSORTS-NO-ERR ...)
; compiling (DEFMACRO SUPER-OR-EQUAL-SORTS ...)
; compiling (DEFUN THE-ERR-SORT ...)
; compiling (DEFSETF THE-ERR-SORT ...)
; compiling (DECLAIM (INLINE SORT<))
; compiling (DEFUN SORT< ...)
; compiling (DEFUN SORT<* ...)
; compiling (DEFMACRO SORT<= ...)
; compiling (DEFUN SORT<=* ...)
; compiling (DEFMACRO SORT-IS-IN ...)
; compiling (DEFUN SORT-LIST<= ...)
; compiling (DEFUN SORT-LIST<=-ANY ...)
; compiling (DEFUN SORT-LIST< ...)
; compiling (DEFUN ADD-SORT-TO-ORDER ...)
; compiling (DEFUN GATHER-CONNECTED-RELATIONS-FROM-ORDER ...)
; compiling (DEFUN ADD-RELATION-TO-ORDER ...)
; compiling (DEFUN MAX-MINORANTS ...)
; compiling (DEFUN MAXIMAL-SORTS ...)
; compiling (DEFUN MAXIMAL-SORTS-NO-ERROR ...)
; compiling (DEFUN MINIMAL-SORTS ...)
; compiling (DEFUN MEET-OF-SORTS ...)
; compiling (DEFUN MERGE-SORT-RELATIONS ...)
; compiling (DEFUN MERGE-SORT-ORDER ...)
; compiling (DEFUN MERGE-SORT-ORDER-NO-EXTRA ...)
; compiling (DEFUN IS-IN-SAME-CONNECTED-COMPONENT ...)
; compiling (DEFUN COMPONENT-TOP ...)
; compiling (DEFUN IS-IN-SAME-CONNECTED-COMPONENT* ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bsort.lisp
; in: DEFUN IS-IN-SAME-CONNECTED-COMPONENT*
;     (CHAOS::SUB-OR-EQUAL-SORTS CHAOS::S1 CHAOS::SO)
; --> LET IF CONS CHAOS::ERR-SORT-LOWERS TRULY-THE SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   CHAOS::S1
; 
; note: deleting unreachable code

;     (CHAOS::SUB-OR-EQUAL-SORTS CHAOS::S2 CHAOS::SO)
; --> LET IF CONS CHAOS::ERR-SORT-LOWERS TRULY-THE SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   CHAOS::S2
; 
; note: deleting unreachable code

; compiling (DEFUN HAVE-COMMON-SUBSORT ...)
; compiling (DEFUN ALL-SORTS-IN-ORDER ...)
; compiling (DEFUN TOP-COMPONENTS ...)
; compiling (DEFUN BOTTOM-COMPONENTS ...)
; compiling (DEFUN DIRECT-SUBSORTS ...)
; compiling (DEFUN DIRECT-SUPERSORTS ...)
; compiling (DEFUN DIRECT-SUPERSORTS-NO-ERR ...)
; compiling (DEFUN SORT-RELATIONS-TRANSITIVE-CLOSURE ...)
; compiling (DEFUN SORT-RELATIONS-TRANSITIVE-CLOSURE1 ...)
; compiling (DEFUN CHECK-CYCLIC-SORT-ORDER ...)
; compiling (DEFUN CLEAR-ERR-SORTS ...)
; compiling (DEFUN GET-KINDS ...)
; compiling (DEFUN GET-ERR-SORTS ...)
; compiling (DEFUN GET-FAMILY ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/bsort-tmpIIXPIQNW.fasl written
; compilation finished in 0:00:00.372
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "chaosx" "chaos" "primitives" "bsort">
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/boperator.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFSTRUCT OPSYNTAX ...)
; compiling (DEFSTRUCT (OPERATOR # ...) ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/boperator.lisp
; in: DEFSTRUCT OPERATOR
;     (DEFSTRUCT
;         (CHAOS::OPERATOR (:INCLUDE CHAOS::OBJECT (CHAOS::-TYPE 'CHAOS::OPERATOR))
;          (:CONSTRUCTOR CHAOS::MAKE-OPERATOR)
;          (:CONSTRUCTOR CHAOS::OPERATOR* (CHAOS::NAME)) (:COPIER NIL)
;          (:PRINT-FUNCTION CHAOS::PRINT-OPERATOR-OBJECT))
;       (CHAOS::NAME NIL :TYPE LIST)
;       (CHAOS::STRATEGY NIL :TYPE LIST)
;       (CHAOS::THEORY NIL :TYPE (OR NULL CHAOS::OP-THEORY))
;       (CHAOS::SYNTAX NIL :TYPE (OR NULL CHAOS::OPSYNTAX))
;       (CHAOS::PRINT-NAME NIL :TYPE T)
;       (CHAOS::HIDDEN NIL :TYPE (OR NULL T)))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION CHAOS::OPERATOR {1004239523}>
;    '#(#<SB-KERNEL:LAYOUT for T {20300003}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {20300103}>
;       #<SB-KERNEL:LAYOUT for CHAOS::%CHAOS-OBJECT {204F1403}>
;       #<SB-KERNEL:LAYOUT for CHAOS::OBJECT {204F1E03}>))
; 
; caught STYLE-WARNING:
;   Previously compiled call to CHAOS::OPERATOR-P could not be inlined because the
;   structure definition for CHAOS::OPERATOR was not yet seen. To avoid this
;   warning, DEFSTRUCT should precede references to the affected functions, or they
;   must be declared locally notinline at each call site.

; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFUN PRINT-OPERATOR-OBJECT ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/boperator.lisp
; in: DEFUN PRINT-OPERATOR-OBJECT
;     (FORMAT STREAM ":op[~s : ~x]" (CHAOS::OPERATOR-NAME CHAOS::OBJ)
;             (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":op[~s : ~x]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 SB-FORMAT::FORMAT-ARG2 &REST
;                SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":op[" STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING " : " STREAM)
;               (LET (# #)
;                 (PRINC SB-FORMAT::FORMAT-ARG2 STREAM))
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G7 #:G8)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

;     (CHAOS::ADDR-OF CHAOS::OBJ)
; --> BLOCK LOGAND 
; ==>
;   (LOGAND 'SB-C::DUMMY 18446744073709551615)
; 
; note: forced to do LOGAND-WORD-MASK (cost 10)
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).
;       etc.

;     (FORMAT STREAM ":op[~s : ~x]" (CHAOS::OPERATOR-NAME CHAOS::OBJ)
;             (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":op[~s : ~x]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 SB-FORMAT::FORMAT-ARG2 &REST
;                SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":op[" STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING " : " STREAM)
;               (LET (# #)
;                 (PRINC SB-FORMAT::FORMAT-ARG2 STREAM))
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G7 #:G8)
; 
; note: doing unsigned word to integer coercion (cost 20)

; compiling (DEFMACRO OPERATOR-MODULE ...)
; compiling (DEFMACRO OPERATOR-SYMBOL ...)
; compiling (DEFMACRO OPERATOR-NUM-ARGS ...)
; compiling (DEFMACRO OPERATOR-ID ...)
; compiling (DEFMACRO OPERATOR-MODULE-ID ...)
; compiling (DEFMACRO OPERATOR-REWRITE-STRATEGY ...)
; compiling (DEFUN EXPLODE-OPERATOR-NAME ...)
; compiling (DEFUN MAKE-OPERATOR-TOKEN-SEQ ...)
; compiling (DEFUN OPERATOR-SYNTACTIC-TYPE-FROM-NAME ...)
; compiling (DEFMACRO OPERATOR= ...)
; compiling (DEFMACRO OPERATOR-EQL ...)
; compiling (DEFMACRO OPERATOR-EQUAL ...)
; compiling (DEFMACRO OPERATOR-IS-BEHAVIOURAL ...)
; compiling (DEFVAR *OPNAME-TABLE* ...)
; compiling (DEFUN CANONICALIZE-OP-NAME ...)
; compiling (DEFUN ALLOCATE-OPERATOR ...)
; compiling (DEFUN NEW-OPERATOR ...)
; compiling (DEFMACRO OPERATOR-TOKEN-SEQUENCE ...)
; compiling (DEFMACRO OPERATOR-IS-MIXFIX ...)
; compiling (DEFMACRO OPERATOR-SYNTACTIC-TYPE ...)
; compiling (DEFMACRO OPERATOR-PRECEDENCE ...)
; compiling (DEFMACRO OPERATOR-COMPUTED-PRECEDENCE ...)
; compiling (DEFMACRO OPERATOR-ASSOCIATIVITY ...)
; compiling (DEFUN MAKE-PRINT-OPERATOR-ID ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/boperator.lisp
; in: DEFUN MAKE-PRINT-OPERATOR-ID
;     (STRING CHAOS::A)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               SYMBOL), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               SYMBOL), not a STRING.

;     (STRING CHAOS::B)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               SYMBOL), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY CHARACTER (*))
;                               (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING
;                               SYMBOL), not a STRING.

; compiling (DEFUN CMAKE-OPERATOR-PRINT-NAME ...)
; compiling (DEFUN MAKE-OPINFO ...)
; compiling (DEFUN OPINFO-P ...)
; compiling (DEFMACRO OPINFO-OPERATOR ...)
; compiling (DEFMACRO OPINFO-METHODS ...)
; compiling (DEFMACRO OPINFO-METHOD-TABLE ...)
; compiling (DEFMACRO GET-OPERATOR-INFO ...)
; compiling (DEFMACRO OPERATOR-METHODS ...)
; compiling (DEFMACRO OPERATOR-METHOD-TABLE ...)
; compiling (DEFMACRO OPERATOR-THEORY-INFO ...)
; compiling (DEFMACRO OPERATOR-IS-ASSOCIATIVE ...)
; compiling (DEFMACRO OPERATOR-IS-IDENTITY ...)
; compiling (DEFMACRO OPERATOR-IS-COMMUTATIVE ...)
; compiling (DEFSTRUCT (METHOD # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFUN PRINT-METHOD-OBJECT ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/boperator.lisp
; in: DEFUN PRINT-METHOD-OBJECT
;     (FORMAT STREAM ":op[~a]" (CHAOS::METHOD-NAME CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":op[~a]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":op[" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

; compiling (DEFMACRO CREATE-OPERATOR-METHOD ...)
; compiling (DEFMACRO OPERATOR-METHOD-P ...)
; compiling (DEFMACRO METHOD-MODULE ...)
; compiling (DEFMACRO METHOD-SYMBOL ...)
; compiling (DEFMACRO METHOD-IS-BEHAVIOURAL ...)
; compiling (DEFMACRO METHOD-IS-USER-DEFINED-ERROR-METHOD ...)
; compiling (DEFMACRO METHOD-IS-FOR-CR ...)
; compiling (DEFUN METHOD-IS-DERIVED-FROM ...)
; compiling (DEFMACRO METHOD-IS-CONSTRUCTOR? ...)
; compiling (DEFMACRO METHOD-IS-META-DEMOD ...)
; compiling (DEFUN ALLOCATE-OPERATOR-METHOD ...)
; compiling (DEFUN MAKE-METHOD-ID-SYMBOL ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/boperator.lisp
; in: DEFUN MAKE-METHOD-ID-SYMBOL
;     (STRING= CHAOS::X "_")
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (FIND-IF #'(LAMBDA (CHAOS::X) (STRING= CHAOS::X "_")) (CAR CHAOS::NAM))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

; compiling (DEFUN MAKE-OPERATOR-METHOD ...)
; compiling (DEFMACRO METHOD-EQUAL ...)
; compiling (DEFMACRO METHOD= ...)
; compiling (DEFUN METHOD-W= ...)
; compiling (DEFMACRO METHOD-HAS-SAME-NAME ...)
; compiling (DEFUN METHOD-IS-OF-SAME-OPERATOR ...)
; compiling (DEFMACRO METHOD-IS-OF-SAME-OPERATOR+ ...)
; compiling (DEFUN METHOD-IS-PREDICATE ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/boperator.lisp
; in: DEFUN METHOD-IS-PREDICATE
;     (MEMBER CHAOS::*BOOL-SORT* (CHAOS::METHOD-ARITY CHAOS::METHOD))
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM SINGLE-FLOAT
;                                                  (NOT NUMBER))

; compiling (DEFUN FIND-METHOD-IN-METHOD-LIST ...)
; compiling (DEFSTRUCT (!METHOD-INFO # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DECLAIM (INLINE GET-METHOD-INFO))
; compiling (DEFUN GET-METHOD-INFO ...)
; compiling (DEFSETF GET-METHOD-INFO ...)
; compiling (DEFMACRO METHOD-OPERATOR ...)
; compiling (DEFMACRO METHOD-THEORY ...)
; compiling (DEFMACRO METHOD-THEORY-INFO-FOR-MATCHING ...)
; compiling (DEFMACRO METHOD-LOWER-METHODS ...)
; compiling (DEFMACRO METHOD-OVERLOADED-METHODS ...)
; compiling (DEFMACRO METHOD-RULES-WITH-SAME-TOP ...)
; compiling (DEFMACRO METHOD-RULES-WITH-DIFFERENT-TOP ...)
; compiling (DEFMACRO METHOD-MACROS ...)
; compiling (DEFMACRO METHOD-RULES ...)
; compiling (DEFMACRO METHOD-STRICTLY-OVERLOADED ...)
; compiling (DEFMACRO METHOD-REW-STRATEGY ...)
; compiling (DEFMACRO METHOD-REWRITE-STRATEGY ...)
; compiling (DEFMACRO METHOD-HAS-TRANS-RULE ...)
; compiling (DEFMACRO METHOD-IS-COHERENT ...)
; compiling (DEFMACRO METHOD-COHERENT ...)
; compiling (DEFUN ALLOCATE-METHOD-INFO ...)
; compiling (DEFUN MAKE-METHOD-INFO ...)
; compiling (DEFUN COMPUTE-METHOD-THEORY-INFO-FOR-MATCHING ...)
; compiling (DEFUN GET-METHOD-PRECEDENCE ...)
; compiling (DEFPARAMETER .DEFAULT-PREC. ...)
; compiling (DEFPARAMETER .DEFAULT-UNARY-PREC. ...)
; compiling (DEFUN COMPUTE-OPERATOR-PRECEDENCE ...)
; compiling (DEFSTRUCT (RULE-RING #) ...)
; compiling (DEFUN CREATE-RULE-RING ...)
; compiling (DEFUN ADD-RULE-TO-RING ...)
; compiling (DECLAIM (INLINE INITIALIZE-RULE-RING))
; compiling (DEFUN INITIALIZE-RULE-RING ...)
; compiling (DECLAIM (INLINE RULE-RING-SET-MARK))
; compiling (DEFUN RULE-RING-SET-MARK ...)
; compiling (DECLAIM (INLINE RULE-RING-NEXT))
; compiling (DEFUN RULE-RING-NEXT ...)
; compiling (DECLAIM (INLINE END-OF-RULE-RING))
; compiling (DEFUN END-OF-RULE-RING ...)
; compiling (DECLAIM (INLINE RULE-RING-IS-EMPTY))
; compiling (DEFUN RULE-RING-IS-EMPTY ...)
; compiling (DECLAIM (INLINE RULE-RING-TO-LIST))
; compiling (DEFUN RULE-RING-TO-LIST ...)
; compiling (DEFUN COPY-RULE-RING ...)
; compiling (DEFUN METHOD-IS-ERROR-METHOD ...)
; compiling (DEFUN METHOD-IS-UNIVERSAL ...)
; compiling (DEFUN METHOD-IS-UNIVERSAL* ...)
; compiling (DEFUN METHOD-IS-ASSOCIATIVE ...)
; compiling (DEFUN METHOD-IS-IDENTITY ...)
; compiling (DEFUN METHOD-IS-COMMUTATIVE ...)
; compiling (DEFUN METHOD-IS-IDEMPOTENT ...)
; compiling (DEFUN METHOD-IS-OVERLOADED-WITH ...)
; compiling (DEFUN METHOD-IS-IN-SAME-COMPONENT ...)
; compiling (DEFUN METHOD-IS-INSTANCE-OF ...)
; compiling (DEFUN METHOD-IS-SAME-QUAL-METHOD ...)
; compiling (DEFUN METHOD<= ...)
; compiling (DEFUN METHOD-IS-RESTRICTION-OF ...)
; compiling (DECLAIM (INLINE METHOD-IS-ASSOCIATIVE-RESTRICTION-OF))
; compiling (DEFUN METHOD-IS-ASSOCIATIVE-RESTRICTION-OF ...)
; compiling (DECLAIM (INLINE METHOD-IS-AC-RESTRICTION-OF))
; compiling (DEFUN METHOD-IS-AC-RESTRICTION-OF ...)
; compiling (DECLAIM (INLINE METHOD-IS-COMMUTATIVE-RESTRICTION-OF))
; compiling (DEFUN METHOD-IS-COMMUTATIVE-RESTRICTION-OF ...)
; compiling (DEFUN METHOD-IS-OVERLOADED-WITH-AC-ATTRIBUTE ...)
; compiling (DEFUN GREATEST-AC-METHOD-LESS-THAN ...)
; compiling (DEFUN LIST-ASSOCIATIVE-METHOD-ABOVE ...)
; compiling (DEFUN HIGHEST-METHODS-BELOW ...)
; compiling (DEFUN GET-DEFAULT-METHODS ...)
; compiling (DEFUN LOWEST-METHOD-DIRECT ...)
; compiling (DEFUN HIGHEST-METHOD-DIRECT ...)
; compiling (DEFUN STRICT-LOWER-COARITIES-DIRECT ...)
; compiling (DEFUN CHOOSE-MOST-GENERAL-OP ...)
; compiling (DEFUN CHOOSE-LOWEST-OP ...)
; compiling (DEFUN LOWEST-METHOD ...)
; compiling (DEFUN LOWEST-METHOD! ...)
; compiling (DEFUN LOWEST-METHOD* ...)
; compiling (DEFUN HIGHEST-METHOD ...)
; compiling (DEFUN GET-STRICT-LOWER-COARITIES ...)
; compiling (DEFUN METHOD-ALL-RULES ...)
; compiling (DEFUN MAKE-OPERATOR-INTERNAL ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/boperator.lisp
; in: DEFUN MAKE-OPERATOR-INTERNAL
;     (> CHAOS::T-CNT 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (INCF CHAOS::T-CNT)
; --> SETQ THE 
; ==>
;   (+ 1 CHAOS::T-CNT)
; 
; note: unable to
;   associate +/(+ -) of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (> CHAOS::T-CNT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/boperator-tmpOHM494YR.fasl written
; compilation finished in 0:00:00.314
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "chaosx" "chaos" "primitives" "boperator">
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/baxioms.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFSTRUCT (REWRITE-RULE # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFUN PRINT-RULE-OBJECT ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/baxioms.lisp
; in: DEFUN PRINT-RULE-OBJECT
;     (FORMAT STREAM ":rule[~S: " (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":rule[~S: "
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":rule[" STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING ": " STREAM))
;             NIL)
;           #:G7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

;     (FORMAT STREAM "]")
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "]"
;               (STREAM &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL (WRITE-CHAR #\] STREAM))
;             NIL))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

;     (FORMAT STREAM ":rule[~a]" (CHAOS::REWRITE-RULE-TYPE CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":rule[~a]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":rule[" STREAM)
;               (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G25)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

;     (CHAOS::ADDR-OF CHAOS::OBJ)
; --> BLOCK LOGAND 
; ==>
;   (LOGAND 'SB-C::DUMMY 18446744073709551615)
; 
; note: forced to do LOGAND-WORD-MASK (cost 10)
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).
;       etc.

;     (FORMAT STREAM ":rule[~S: " (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":rule[~S: "
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":rule[" STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-STRING ": " STREAM))
;             NIL)
;           #:G7)
; 
; note: doing unsigned word to integer coercion (cost 20)

; compiling (DEFMACRO RULE-TYPE ...)
; compiling (DEFMACRO RULE-IS-RULE ...)
; compiling (DEFMACRO RULE-IS-EQUATION ...)
; compiling (DEFMACRO RULE-LHS ...)
; compiling (DEFMACRO RULE-RHS ...)
; compiling (DEFMACRO RULE-CONDITION ...)
; compiling (DEFMACRO RULE-ID-CONDITION ...)
; compiling (DEFMACRO RULE-FIRST-MATCH-METHOD ...)
; compiling (DEFMACRO RULE-NEXT-MATCH-METHOD ...)
; compiling (DEFMACRO RULE-LABELS ...)
; compiling (DEFMACRO RULE-IS-BEHAVIOURAL ...)
; compiling (DEFMACRO RULE-TRACE-FLAG ...)
; compiling (DEFMACRO RULE-NEED-COPY ...)
; compiling (DEFMACRO RULE-NON-EXEC ...)
; compiling (DEFMACRO RULE-META-AND-OR ...)
; compiling (DEFSTRUCT (EX-REWRITE-RULE # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (SETF (GET # ...) ...)
; compiling (DEFMACRO RULE-EXTENSIONS ...)
; compiling (DEFMACRO REWIRTE-RULE-P ...)
; compiling (DEFMACRO IS-REWRITE-RULE? ...)
; compiling (DEFMACRO CREATE-REWRITE-RULE ...)
; compiling (DEFSTRUCT (AXIOM # ...) ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/baxioms.lisp
; in: DEFSTRUCT AXIOM
;     (DEFSTRUCT
;         (CHAOS::AXIOM (:INCLUDE CHAOS::REWRITE-RULE (CHAOS::-TYPE 'CHAOS::AXIOM))
;          (:COPIER NIL) (:CONSTRUCTOR CHAOS::MAKE-AXIOM)
;          (:CONSTRUCTOR CHAOS::AXIOM*
;           (TYPE CHAOS::LHS CHAOS::RHS CONDITION CHAOS::BEHAVIOURAL))
;          (:PRINT-FUNCTION CHAOS::PRINT-AXIOM-OBJECT))
;       (CHAOS::KIND NIL :TYPE SYMBOL))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION CHAOS::AXIOM {1004849EA3}>
;    '#(#<SB-KERNEL:LAYOUT for T {20300003}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {20300103}>
;       #<SB-KERNEL:LAYOUT for CHAOS::%CHAOS-OBJECT {204F1403}>
;       #<SB-KERNEL:LAYOUT for CHAOS::OBJECT {204F1E03}>
;       #<SB-KERNEL:LAYOUT for CHAOS::REWRITE-RULE {20501C03}>))
; 
; caught STYLE-WARNING:
;   Previously compiled call to CHAOS::AXIOM-P could not be inlined because the
;   structure definition for CHAOS::AXIOM was not yet seen. To avoid this warning,
;   DEFSTRUCT should precede references to the affected functions, or they must be
;   declared locally notinline at each call site.

; compiling (SETF (GET # ...) ...)
; compiling (SETF (GET # ...) ...)
; compiling (SETF (SYMBOL-FUNCTION #) ...)
; compiling (DEFUN PRINT-AXIOM-OBJECT ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/baxioms.lisp
; in: DEFUN PRINT-AXIOM-OBJECT
;     (FORMAT STREAM ":axiom[~S]" (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":axiom[~S]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":axiom[" STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G7)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR BOOLEAN STREAM (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a NULL.

;     (CHAOS::ADDR-OF CHAOS::OBJ)
; --> BLOCK LOGAND 
; ==>
;   (LOGAND 'SB-C::DUMMY 18446744073709551615)
; 
; note: forced to do LOGAND-WORD-MASK (cost 10)
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).
;       etc.

;     (FORMAT STREAM ":axiom[~S]" (CHAOS::ADDR-OF CHAOS::OBJ))
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA ":axiom[~S]"
;               (STREAM SB-FORMAT::FORMAT-ARG1 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING ":axiom[" STREAM)
;               (PRIN1 SB-FORMAT::FORMAT-ARG1 STREAM)
;               (WRITE-CHAR #\] STREAM))
;             NIL)
;           #:G7)
; 
; note: doing unsigned word to integer coercion (cost 20)

; compiling (DEFMACRO IS-AXIOM? ...)
; compiling (DEFMACRO AXIOM-IS-BEHAVIOURAL ...)
; compiling (DEFMACRO AXIOM-IS-FOR-CR ...)
; compiling (DEFMACRO AXIOM-CONTAINS-MATCH-OP ...)
; compiling (DEFUN AXIOM-EXTENSIONS ...)
; compiling (DEFSETF AXIOM-EXTENSIONS ...)
; compiling (DEFMACRO AXIOM-AC-EXTENSION ...)
; compiling (DEFMACRO AXIOM-A-EXTENSIONS ...)
; compiling (DEFMACRO !AXIOM-AC-EXTENSION ...)
; compiling (DEFMACRO !AXIOM-A-EXTENSIONS ...)
; compiling (DEFUN CREATE-AXIOM ...)
; compiling (DEFMACRO RULE-IS-BUILTIN ...)
; compiling (DEFUN AXIOM-CONTAINS-ERROR-METHOD? ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/baxioms-tmpOVFB07XF.fasl written
; compilation finished in 0:00:00.106
WARNING:
   Lisp compilation had style-warnings while
   compiling #<CL-SOURCE-FILE "chaosx" "chaos" "primitives" "baxioms">
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/bmacro.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFSTRUCT (MACRO #) ...)
; compiling (DEFUN PRINT-MACRO ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/bmacro.lisp
; in: DEFUN PRINT-MACRO
;     (CHAOS::ADDR-OF CHAOS::MACRO)
; --> BLOCK LOGAND 
; ==>
;   (LOGAND 'SB-C::DUMMY 18446744073709551615)
; 
; note: forced to do LOGAND-WORD-MASK (cost 10)
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       unable to do inline (unsigned-byte 64) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).
;       etc.

;     (FORMAT T "#<MacroDecl: ~D>" (CHAOS::ADDR-OF CHAOS::MACRO))
; --> FORMAT SB-INT:NAMED-LAMBDA FUNCTION BLOCK LET 
; ==>
;   (PRINC SB-FORMAT::FORMAT-ARG1 STREAM)
; 
; note: doing unsigned word to integer coercion (cost 20)


; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/bmacro-tmpG6VFGMYP.fasl written
; compilation finished in 0:00:00.009
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/gen-eval.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DECLAIM (SPECIAL *DRIBBLE-AST* ...))
; compiling (DEFVAR *DRIBBLE-AST* ...)
; compiling (DEFVAR *DRIBBLE-STREAM* ...)
; compiling (DEFVAR *AST-LOG* ...)
; compiling (DEFVAR *NO-LOG-PARAMETER* ...)
; compiling (DECLAIM (SPECIAL *EVAL-AST*))
; compiling (DEFVAR *EVAL-AST* ...)
; compiling (DEFUN AST-TO-BE-DRIBBLED? ...)
; compiling (DEFUN EVAL-AST ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-eval.lisp
; in: DEFUN EVAL-AST
;     (STRING CHAOS::MODULE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (FUNCALL CHAOS::EVALUATOR CHAOS::AST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::EVALUATOR)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   EVALUATOR is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   EVALUATOR is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   EVALUATOR is not known to be a function

; compiling (DEFUN EVAL-SEQ ...)
; compiling (DEFUN EVAL-AST2 ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/gen-eval-tmp4QIPRMOF.fasl written
; compilation finished in 0:00:00.011
; compiling file "/<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp" (written 08 OCT 2015 01:43:01 AM):
; compiling (IN-PACKAGE :CHAOS)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DECLAIM (SPECIAL *CURRENT-TERM-DEPTH*) ...)
; compiling (DEFVAR *CURRENT-TERM-DEPTH* ...)
; compiling (DECLAIM (SPECIAL .PRINTED-VARS-SO-FAR.))
; compiling (DEFVAR .PRINTED-VARS-SO-FAR. ...)
; compiling (DECLAIM (SPECIAL **PRINT-VAR-SORT**))
; compiling (DEFVAR **PRINT-VAR-SORT** ...)
; compiling (DEFUN PRINT-VARIABLE ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN PRINT-VARIABLE
;     (STRING (CHAOS::VARIABLE$PRINT-NAME CHAOS::BODY))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFUN PRINT-AST-VD ...)
; compiling (DEFUN IS-AST ...)
; compiling (DEFVAR *PRINT-TERM-COLOR* ...)
; compiling (DEFUN VARIABLE-PRINT-STRING ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN VARIABLE-PRINT-STRING
;     (STRING (CHAOS::VARIABLE-PRINT-NAME CHAOS::TERM))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFUN BCONST-PRINT-STRING ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN BCONST-PRINT-STRING
;     (FUNCALL (CHAOS::BSORT-TERM-PRINTER (CHAOS::TERM-SORT CHAOS::TERM))
;              CHAOS::VAL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (CHAOS::BSORT-TERM-PRINTER (CHAOS::TERM-SORT CHAOS::TERM)))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; compiling (DEFUN TERM-TO-SEXPR ...)
; compiling (DEFUN IS-SELF-TERMINATING ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN IS-SELF-TERMINATING
;     (CHAR CHAOS::TOK 0)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a STRING, not a SIMPLE-ARRAY.

; compiling (DEFUN TERM-PRINT1 ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN TERM-PRINT1
;     (STRING CHAOS::I)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

; compiling (DEFUN TERM-PRINT2 ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN TERM-PRINT2
;     (LENGTH CHAOS::SUBS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (STRING CHAOS::I)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (<= CHAOS::PREC (CHAOS::GET-METHOD-PRECEDENCE CHAOS::HD))
; --> OR LET IF = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (* CHAOS::X 15)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a (INTEGER * 4611686018427387900), not a FIXNUM.
;       The result is a (VALUES (INTEGER * 69175290276410818500) &OPTIONAL), not a (VALUES
;                                                                                   FIXNUM
;                                                                                   &REST
;                                                                                   T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a (INTEGER * 4611686018427387900), not a (SIGNED-BYTE
;                                                                       64).
;       The result is a (VALUES (INTEGER * 69175290276410818500) &OPTIONAL), not a (VALUES
;                                                                                   (SIGNED-BYTE
;                                                                                    64)
;                                                                                   &REST
;                                                                                   T).
;       etc.

;     (1- CHAOS::X)
; ==>
;   (- CHAOS::X 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER * 4611686018427387900), not a FIXNUM.
;       The result is a (VALUES (INTEGER * 4611686018427387899) &OPTIONAL), not a (VALUES
;                                                                                  FIXNUM
;                                                                                  &REST
;                                                                                  T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER * 4611686018427387900), not a FIXNUM.
;       The result is a (VALUES (INTEGER * 4611686018427387899) &OPTIONAL), not a (VALUES
;                                                                                  FIXNUM
;                                                                                  &REST
;                                                                                  T).
;       etc.

; compiling (DEFUN TERM-PRINT ...)
; compiling (DEFUN TERM-PRINT-WITH-SORT ...)
; compiling (DEFUN TERM-PRINT-WITH-SORT-STRING ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN TERM-PRINT-WITH-SORT-STRING
;     (CHAOS::TERM-PRINT-WITH-SORT CHAOS::TERM CHAOS::STR)
; 
; note: deleting unreachable code

;     (LET ((CHAOS::STR
;            (MAKE-ARRAY '(0) :ELEMENT-TYPE 'BASE-CHAR :FILL-POINTER 0 :ADJUSTABLE
;                        T)))
;       (WITH-OUTPUT-TO-STRING (CHAOS::S CHAOS::STR)
;         (CHAOS::TERM-PRINT-WITH-SORT CHAOS::TERM CHAOS::STR))
;       CHAOS::STR)
; ==>
;   CHAOS::STR
; 
; note: deleting unreachable code

;     (CHAOS::TERM-PRINT-WITH-SORT CHAOS::TERM CHAOS::STR)
; 
; caught WARNING:
;   Derived type of STR is
;     (VALUES (AND BASE-STRING (NOT SIMPLE-ARRAY)) &OPTIONAL),
;   conflicting with its asserted type
;     STREAM.
;   See also:
;     The SBCL Manual, Node "Handling of Types"

; compiling (DEFUN PRINT-TERM-SEQ ...)
; compiling (DEFVAR *SHOW-SORT* ...)
; compiling (DEFUN PRINT-TERM-TREE ...)
; compiling (DEFUN PRINT-TERM-GRAPH ...)
; compiling (DEFUN !PRINT-TERM-TREE ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN !PRINT-TERM-TREE
;     (IF SORT
;         (CHAOS::SORT-ID SORT)
;         "unknown")
; ==>
;   "unknown"
; 
; note: deleting unreachable code

;     (STRING (CHAOS::VARIABLE-PRINT-NAME CHAOS::TERM))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING
;                               SYMBOL CHARACTER), not a STRING.

;     (FUNCALL CHAOS::LEAF-NAME CHAOS::TREE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::LEAF-NAME)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; compiling (DEFUN PRINT-AST ...)
; compiling (DEFUN PRINT-CHAOS-OBJECT ...)
; file: /<<PKGBUILDDIR>>/chaos/primitives/gen-print.lisp
; in: DEFUN PRINT-CHAOS-OBJECT
;     (FUNCALL CHAOS::PRINTER CHAOS::OBJECT STREAM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN CHAOS::PRINTER)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   PRINTER is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   PRINTER is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   PRINTER is not known to be a function
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   PRINTER is not known to be a function

;     (FORMAT STREAM "~%-- delcrations -------------------")
; ==>
;   (FORMAT SB-C::DEST
;           (SB-INT:NAMED-LAMBDA "~%-- delcrations -------------------"
;               (STREAM &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "
; -- delcrations -------------------"
;                             STREAM))
;             NIL))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR STREAM BOOLEAN), not a STREAM.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR STREAM BOOLEAN), not a (MEMBER T).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR STREAM BOOLEAN), not a NULL.

; compiling (DEFUN PRINT-OBJ-LIST ...)
; compiling (DEFUN PRINT-THEORY-BRIEF ...)
; compiling (DEFUN PRINT-THEORY ...)
; compiling (DEFUN PRINT-THEORY-INFO ...)
; compiling (DEFUN PRINT-SIMPLE-PRINC-FLAT ...)
; compiling (DEFUN DUMP-CHAOS-HASH ...)
; compiling (DEFUN DUMP-CHAOS-ASSOC-TABLE ...)
; compiling (DEFUN DUMP-MODEXP-LOCAL ...)
; compiling (DEFUN DUMP-MODULES-SO-FAR ...)
; compiling (DEFUN DUMP-MODEXP-EVAL ...)
; compiling (DEFUN DUMP-MODEXP-VIEW ...)

; /<<PKGBUILDDIR>>/tmpcache/common-lisp/sbcl-1.4.4.debian-linux-x64/<<PKGBUILDDIR>>/chaos/primitives/gen-print-tmpGW0QV22K.fasl written
; compilation finished in 0:00:00.101

debugger invoked on a UIOP/LISP-BUILD:COMPILE-FILE-ERROR in thread
#<THREAD "main thread" RUNNING {10005E85B3}>:
  COMPILE-FILE-ERROR while
  compiling #<CL-SOURCE-FILE "chaosx" "chaos" "primitives" "gen-print">

Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [RETRY                        ] Retry
                                     compiling #<CL-SOURCE-FILE "chaosx" "chaos" "primitives" "gen-print">.
  1: [ACCEPT                       ] Continue, treating
                                     compiling #<CL-SOURCE-FILE "chaosx" "chaos" "primitives" "gen-print">
                                     as having been successful.
  2:                                 Retry ASDF operation.
  3: [CLEAR-CONFIGURATION-AND-RETRY] Retry ASDF operation after resetting the
                                     configuration.
  4:                                 Retry ASDF operation.
  5:                                 Retry ASDF operation after resetting the
                                     configuration.
  6: [ABORT                        ] Exit debugger, returning to top level.

(UIOP/LISP-BUILD:CHECK-LISP-COMPILE-RESULTS NIL T T "~/asdf-action::format-action/" ((#<ASDF/LISP-ACTION:COMPILE-OP > . #<ASDF/LISP-ACTION:CL-SOURCE-FILE "chaosx" "chaos" "primitives" "gen-print">)))
   error finding frame source: Bogus form-number: the source file has probably
                               changed too much to cope with.
   source: NIL
0] ; 
; compilation unit aborted
;   caught 1 fatal ERROR condition
;   caught 1 WARNING condition
;   caught 8 STYLE-WARNING conditions
;   printed 366 notes

* chmod +x dumps/sbcl/cafeobj.sbcl
chmod: cannot access 'dumps/sbcl/cafeobj.sbcl': No such file or directory
Makefile:258: recipe for target 'dumps/sbcl/cafeobj.sbcl' failed
make[1]: *** [dumps/sbcl/cafeobj.sbcl] Error 1
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
debian/rules:23: recipe for target 'build-arch-stamp' failed
make: *** [build-arch-stamp] Error 2
dpkg-buildpackage: error: debian/rules build-arch subprocess returned exit status 2
--------------------------------------------------------------------------------
Build finished at 2018-02-07T20:36:12Z

Finished
--------


+------------------------------------------------------------------------------+
| Cleanup                                                                      |
+------------------------------------------------------------------------------+

Purging /<<BUILDDIR>>
Not cleaning session: cloned chroot in use
E: Build failure (dpkg-buildpackage died)

+------------------------------------------------------------------------------+
| Summary                                                                      |
+------------------------------------------------------------------------------+

Build Architecture: amd64
Build Type: any
Build-Space: 20996
Build-Time: 8
Distribution: unstable
Fail-Stage: build
Host Architecture: amd64
Install-Time: 42
Job: cafeobj_1.5.5-1
Machine Architecture: amd64
Package: cafeobj
Package-Time: 64
Source-Version: 1.5.5-1
Space: 20996
Status: attempted
Version: 1.5.5-1
--------------------------------------------------------------------------------
Finished at 2018-02-07T20:36:12Z
Build needed 00:01:04, 20996k disk space
E: Build failure (dpkg-buildpackage died)
DC-Status: Failed 65.745583558s
DC-Time-Estimation: 65.745583558 versus expected 191 (r/m: 1.9051381045466267 ; m: 65.745583558)
