DC-Build-Header: pearpc 0.5.dfsg-2 / Fri Jan 13 02:00:19 +0100 2012
Another build requested exclusive access to the build node
Another build requested exclusive access to the build node
sbuild (Debian sbuild) 0.62.2 (05 Apr 2011) on stremi-32.reims.grid5000.fr

╔══════════════════════════════════════════════════════════════════════════════╗
║ pearpc 0.5.dfsg-2 (amd64)                                  13 Jan 2012 02:01 ║
╚══════════════════════════════════════════════════════════════════════════════╝

Package: pearpc
Version: 0.5.dfsg-2
Source Version: 0.5.dfsg-2
Distribution: lsid64b
Architecture: amd64


┌──────────────────────────────────────────────────────────────────────────────┐
│ Update chroot                                                                │
└──────────────────────────────────────────────────────────────────────────────┘

Ign http://localhost sid InRelease
Get:1 http://localhost sid Release.gpg [836 B]
Get:2 http://localhost sid Release [188 kB]
Ign http://localhost sid/main Sources/DiffIndex
Ign http://localhost sid/main amd64 Packages/DiffIndex
Ign http://localhost sid/main TranslationIndex
Get:3 http://localhost sid/main Sources [7544 kB]
Get:4 http://localhost sid/main amd64 Packages [10.4 MB]
Ign http://localhost sid/main Translation-en
Fetched 18.2 MB in 3s (5393 kB/s)
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
The following packages have been kept back:
  clang cpp-4.6 g++-4.6 gcc-4.6 gcc-4.6-base libgcc1 libgomp1 libquadmath0
  libstdc++6 libstdc++6-4.6-dev
0 upgraded, 0 newly installed, 0 to remove and 10 not upgraded.

┌──────────────────────────────────────────────────────────────────────────────┐
│ Fetch source files                                                           │
└──────────────────────────────────────────────────────────────────────────────┘


Check APT
─────────

Checking available source versions...

Download source files with APT
──────────────────────────────

Reading package lists...
Building dependency tree...
Reading state information...
Need to get 815 kB of source archives.
Get:1 http://localhost/debian/ sid/main pearpc 0.5.dfsg-2 (dsc) [1346 B]
Get:2 http://localhost/debian/ sid/main pearpc 0.5.dfsg-2 (tar) [806 kB]
Get:3 http://localhost/debian/ sid/main pearpc 0.5.dfsg-2 (diff) [7706 B]
Fetched 815 kB in 0s (1298 kB/s)
Download complete and in download only mode

Check arch
──────────

Merged Build-Depends: build-essential, fakeroot
Filtered Build-Depends: build-essential, fakeroot
dpkg-deb: building package `sbuild-build-depends-core-dummy' in `/build/pearpc-ZxMcB4/resolver-x7J_m_/apt_archive/sbuild-build-depends-core-dummy.deb'.
OK
Reading package lists...

┌──────────────────────────────────────────────────────────────────────────────┐
│ Install core build dependencies (apt-based resolver)                         │
└──────────────────────────────────────────────────────────────────────────────┘

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following NEW packages will be installed:
  sbuild-build-depends-core-dummy
0 upgraded, 1 newly installed, 0 to remove and 10 not upgraded.
Need to get 0 B/702 B of archives.
After this operation, 0 B of additional disk space will be used.
WARNING: The following packages cannot be authenticated!
  sbuild-build-depends-core-dummy
Authentication warning overridden.
Selecting previously unselected package sbuild-build-depends-core-dummy.
(Reading database ... 10821 files and directories currently installed.)
Unpacking sbuild-build-depends-core-dummy (from .../sbuild-build-depends-core-dummy.deb) ...
Setting up sbuild-build-depends-core-dummy (0.invalid.0) ...
Cannot open /var/lib/schroot/mount/lsid64b-7f1150f4-c85f-41f4-9db6-a13b342e0207/etc/lsb-release: No such file or directory
Merged Build-Depends: base-files, base-passwd, bash, coreutils, dash, debianutils, diffutils, dpkg, e2fsprogs, findutils, grep, gzip, hostname, ncurses-base, ncurses-bin, perl-base, sed, login, sysvinit-utils, sysvinit, tar, bsdutils, mount, util-linux, libc6-dev | libc-dev, gcc (>= 4:4.4.3), g++ (>= 4:4.4.3), make, dpkg-dev (>= 1.13.5), debhelper (>= 7.0.50~), nasm, libaa1-dev, libgpmg1-dev, libsvga1-dev, libncurses5-dev, libxext-dev, libasound2-dev, libsdl1.2-dev, libx11-dev, autotools-dev
Filtered Build-Depends: base-files, base-passwd, bash, coreutils, dash, debianutils, diffutils, dpkg, e2fsprogs, findutils, grep, gzip, hostname, ncurses-base, ncurses-bin, perl-base, sed, login, sysvinit-utils, sysvinit, tar, bsdutils, mount, util-linux, libc6-dev, gcc (>= 4:4.4.3), g++ (>= 4:4.4.3), make, dpkg-dev (>= 1.13.5), debhelper (>= 7.0.50~), nasm, libaa1-dev, libgpmg1-dev, libsvga1-dev, libncurses5-dev, libxext-dev, libasound2-dev, libsdl1.2-dev, libx11-dev, autotools-dev
dpkg-deb: building package `sbuild-build-depends-pearpc-dummy' in `/build/pearpc-ZxMcB4/resolver-cUt73q/apt_archive/sbuild-build-depends-pearpc-dummy.deb'.
OK
Reading package lists...

┌──────────────────────────────────────────────────────────────────────────────┐
│ Install pearpc build dependencies (apt-based resolver)                       │
└──────────────────────────────────────────────────────────────────────────────┘

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following extra packages will be installed:
  autotools-dev bsdmainutils debhelper file gettext gettext-base groff-base
  html2text intltool-debian libaa1 libaa1-dev libasound2 libasound2-dev
  libasyncns0 libavahi-client-dev libavahi-client3 libavahi-common-data
  libavahi-common-dev libavahi-common3 libcaca-dev libcaca0 libcap2 libcroco3
  libdbus-1-3 libdbus-1-dev libdirectfb-1.2-9 libdirectfb-dev
  libdirectfb-extra libdrm2 libflac8 libfreetype6 libfreetype6-dev
  libgl1-mesa-dev libgl1-mesa-glx libglapi-mesa libglib2.0-0 libglib2.0-bin
  libglib2.0-data libglib2.0-dev libglu1-mesa libglu1-mesa-dev libgpm-dev
  libgpm2 libgpmg1-dev libice-dev libice6 libjpeg8 libjpeg8-dev libjson0
  libmagic1 libncurses5-dev libogg0 libpcre3 libpipeline1 libpng12-0
  libpng12-dev libpopt0 libpthread-stubs0 libpthread-stubs0-dev libpulse-dev
  libpulse-mainloop-glib0 libpulse0 libsdl1.2-dev libsdl1.2debian
  libslang2-dev libsm-dev libsm6 libsndfile1 libsvga1 libsvga1-dev
  libsysfs-dev libsysfs2 libtinfo-dev libts-0.0-0 libunistring0 libvorbis0a
  libvorbisenc2 libwrap0 libx11-6 libx11-data libx11-dev libx11-xcb1 libx86-1
  libxau-dev libxau6 libxcb1 libxcb1-dev libxdamage1 libxdmcp-dev libxdmcp6
  libxext-dev libxext6 libxfixes3 libxi6 libxml2 libxrandr2 libxrender1
  libxt-dev libxt6 libxtst6 libxxf86vm1 man-db mesa-common-dev nasm pkg-config
  po-debconf tsconf x11-common x11proto-core-dev x11proto-input-dev
  x11proto-kb-dev x11proto-xext-dev xorg-sgml-doctools xtrans-dev zlib1g-dev
Suggested packages:
  wamerican wordlist whois vacation dh-make gettext-doc groff
  libasound2-plugins libasound2-doc libglib2.0-doc gpm ncurses-doc pulseaudio
  www-browser libmail-box-perl
Recommended packages:
  curl wget lynx-cur autopoint dbus libgl1-mesa-dri shared-mime-info python
  tcpd libx11-doc xml-core libmail-sendmail-perl
The following NEW packages will be installed:
  autotools-dev bsdmainutils debhelper file gettext gettext-base groff-base
  html2text intltool-debian libaa1 libaa1-dev libasound2 libasound2-dev
  libasyncns0 libavahi-client-dev libavahi-client3 libavahi-common-data
  libavahi-common-dev libavahi-common3 libcaca-dev libcaca0 libcap2 libcroco3
  libdbus-1-3 libdbus-1-dev libdirectfb-1.2-9 libdirectfb-dev
  libdirectfb-extra libdrm2 libflac8 libfreetype6 libfreetype6-dev
  libgl1-mesa-dev libgl1-mesa-glx libglapi-mesa libglib2.0-0 libglib2.0-bin
  libglib2.0-data libglib2.0-dev libglu1-mesa libglu1-mesa-dev libgpm-dev
  libgpm2 libgpmg1-dev libice-dev libice6 libjpeg8 libjpeg8-dev libjson0
  libmagic1 libncurses5-dev libogg0 libpcre3 libpipeline1 libpng12-0
  libpng12-dev libpopt0 libpthread-stubs0 libpthread-stubs0-dev libpulse-dev
  libpulse-mainloop-glib0 libpulse0 libsdl1.2-dev libsdl1.2debian
  libslang2-dev libsm-dev libsm6 libsndfile1 libsvga1 libsvga1-dev
  libsysfs-dev libsysfs2 libtinfo-dev libts-0.0-0 libunistring0 libvorbis0a
  libvorbisenc2 libwrap0 libx11-6 libx11-data libx11-dev libx11-xcb1 libx86-1
  libxau-dev libxau6 libxcb1 libxcb1-dev libxdamage1 libxdmcp-dev libxdmcp6
  libxext-dev libxext6 libxfixes3 libxi6 libxml2 libxrandr2 libxrender1
  libxt-dev libxt6 libxtst6 libxxf86vm1 man-db mesa-common-dev nasm pkg-config
  po-debconf sbuild-build-depends-pearpc-dummy tsconf x11-common
  x11proto-core-dev x11proto-input-dev x11proto-kb-dev x11proto-xext-dev
  xorg-sgml-doctools xtrans-dev zlib1g-dev
0 upgraded, 116 newly installed, 0 to remove and 10 not upgraded.
Need to get 35.2 MB/35.2 MB of archives.
After this operation, 106 MB of additional disk space will be used.
WARNING: The following packages cannot be authenticated!
  libpipeline1 libpopt0 libgpm2 libpcre3 libwrap0 libasound2 libasyncns0
  libavahi-common-data libavahi-common3 libdbus-1-3 libavahi-client3
  libglib2.0-0 libxml2 libcroco3 libdrm2 libogg0 libflac8 libfreetype6
  libglapi-mesa libxau6 libxdmcp6 libxcb1 libx11-data libx11-6 libxfixes3
  libxdamage1 libxext6 libxxf86vm1 libgl1-mesa-glx libglu1-mesa x11-common
  libice6 libpng12-0 libcap2 libjson0 libsm6 libvorbis0a libvorbisenc2
  libsndfile1 libx11-xcb1 libxi6 libxtst6 libpulse0 libpulse-mainloop-glib0
  libcaca0 libsysfs2 tsconf libts-0.0-0 libdirectfb-1.2-9 libxrender1
  libxrandr2 libsdl1.2debian libunistring0 libxt6 bsdmainutils groff-base
  man-db libmagic1 file gettext-base autotools-dev html2text gettext
  intltool-debian po-debconf debhelper libaa1 xorg-sgml-doctools
  x11proto-core-dev libxau-dev libxdmcp-dev x11proto-input-dev x11proto-kb-dev
  xtrans-dev libpthread-stubs0 libpthread-stubs0-dev libxcb1-dev libx11-dev
  zlib1g-dev libpng12-dev libslang2-dev libtinfo-dev libncurses5-dev
  libaa1-dev libasound2-dev libavahi-common-dev pkg-config libdbus-1-dev
  libavahi-client-dev libcaca-dev libjpeg8 libdirectfb-extra libfreetype6-dev
  libjpeg8-dev x11proto-xext-dev libxext-dev libsysfs-dev libdirectfb-dev
  mesa-common-dev libgl1-mesa-dev libglib2.0-data libglib2.0-bin
  libglib2.0-dev libglu1-mesa-dev libgpm-dev libgpmg1-dev libice-dev
  libpulse-dev libsm-dev libxt-dev libsdl1.2-dev libx86-1 libsvga1
  libsvga1-dev nasm sbuild-build-depends-pearpc-dummy
Authentication warning overridden.
Get:1 http://localhost/debian/ sid/main libpipeline1 amd64 1.2.0-5 [38.2 kB]
Get:2 http://localhost/debian/ sid/main libpopt0 amd64 1.16-3 [55.2 kB]
Get:3 http://localhost/debian/ sid/main libgpm2 amd64 1.20.4-4 [35.6 kB]
Get:4 http://localhost/debian/ sid/main libpcre3 amd64 8.12-4 [225 kB]
Get:5 http://localhost/debian/ sid/main libwrap0 amd64 7.6.q-22 [62.2 kB]
Get:6 http://localhost/debian/ sid/main libasound2 amd64 1.0.24.1-4 [446 kB]
Get:7 http://localhost/debian/ sid/main libasyncns0 amd64 0.8-4 [13.6 kB]
Get:8 http://localhost/debian/ sid/main libavahi-common-data amd64 0.6.30-6 [133 kB]
Get:9 http://localhost/debian/ sid/main libavahi-common3 amd64 0.6.30-6 [54.2 kB]
Get:10 http://localhost/debian/ sid/main libdbus-1-3 amd64 1.4.16-1 [164 kB]
Get:11 http://localhost/debian/ sid/main libavahi-client3 amd64 0.6.30-6 [59.0 kB]
Get:12 http://localhost/debian/ sid/main libglib2.0-0 amd64 2.30.2-4 [1844 kB]
Get:13 http://localhost/debian/ sid/main libxml2 amd64 2.7.8.dfsg-5.1 [891 kB]
Get:14 http://localhost/debian/ sid/main libcroco3 amd64 0.6.2-2 [122 kB]
Get:15 http://localhost/debian/ sid/main libdrm2 amd64 2.4.30-1 [436 kB]
Get:16 http://localhost/debian/ sid/main libogg0 amd64 1.2.2~dfsg-1 [18.6 kB]
Get:17 http://localhost/debian/ sid/main libflac8 amd64 1.2.1-6 [154 kB]
Get:18 http://localhost/debian/ sid/main libfreetype6 amd64 2.4.8-1 [442 kB]
Get:19 http://localhost/debian/ sid/main libglapi-mesa amd64 7.11.2-1 [55.8 kB]
Get:20 http://localhost/debian/ sid/main libxau6 amd64 1:1.0.6-4 [17.1 kB]
Get:21 http://localhost/debian/ sid/main libxdmcp6 amd64 1:1.1.0-4 [22.9 kB]
Get:22 http://localhost/debian/ sid/main libxcb1 amd64 1.7-4 [43.7 kB]
Get:23 http://localhost/debian/ sid/main libx11-data all 2:1.4.4-4 [187 kB]
Get:24 http://localhost/debian/ sid/main libx11-6 amd64 2:1.4.4-4 [889 kB]
Get:25 http://localhost/debian/ sid/main libxfixes3 amd64 1:5.0-4 [21.5 kB]
Get:26 http://localhost/debian/ sid/main libxdamage1 amd64 1:1.1.3-2 [14.3 kB]
Get:27 http://localhost/debian/ sid/main libxext6 amd64 2:1.3.0-3 [52.3 kB]
Get:28 http://localhost/debian/ sid/main libxxf86vm1 amd64 1:1.1.1-2 [18.2 kB]
Get:29 http://localhost/debian/ sid/main libgl1-mesa-glx amd64 7.11.2-1 [156 kB]
Get:30 http://localhost/debian/ sid/main libglu1-mesa amd64 7.11.2-1 [220 kB]
Get:31 http://localhost/debian/ sid/main x11-common all 1:7.6+10 [281 kB]
Get:32 http://localhost/debian/ sid/main libice6 amd64 2:1.0.7-2 [56.5 kB]
Get:33 http://localhost/debian/ sid/main libpng12-0 amd64 1.2.46-4 [190 kB]
Get:34 http://localhost/debian/ sid/main libcap2 amd64 1:2.22-1 [13.3 kB]
Get:35 http://localhost/debian/ sid/main libjson0 amd64 0.9-1 [18.8 kB]
Get:36 http://localhost/debian/ sid/main libsm6 amd64 2:1.2.0-2 [29.8 kB]
Get:37 http://localhost/debian/ sid/main libvorbis0a amd64 1.3.2-1.1 [122 kB]
Get:38 http://localhost/debian/ sid/main libvorbisenc2 amd64 1.3.2-1.1 [146 kB]
Get:39 http://localhost/debian/ sid/main libsndfile1 amd64 1.0.25-4 [240 kB]
Get:40 http://localhost/debian/ sid/main libx11-xcb1 amd64 2:1.4.4-4 [125 kB]
Get:41 http://localhost/debian/ sid/main libxi6 amd64 2:1.4.5-1 [67.6 kB]
Get:42 http://localhost/debian/ sid/main libxtst6 amd64 2:1.2.0-4 [24.1 kB]
Get:43 http://localhost/debian/ sid/main libpulse0 amd64 1.1-2 [307 kB]
Get:44 http://localhost/debian/ sid/main libpulse-mainloop-glib0 amd64 1.1-2 [24.6 kB]
Get:45 http://localhost/debian/ sid/main libcaca0 amd64 0.99.beta17-2.1 [386 kB]
Get:46 http://localhost/debian/ sid/main libsysfs2 amd64 2.1.0+repack-1 [29.2 kB]
Get:47 http://localhost/debian/ sid/main tsconf all 1.0-9 [13.0 kB]
Get:48 http://localhost/debian/ sid/main libts-0.0-0 amd64 1.0-9 [30.0 kB]
Get:49 http://localhost/debian/ sid/main libdirectfb-1.2-9 amd64 1.2.10.0-4.3 [1201 kB]
Get:50 http://localhost/debian/ sid/main libxrender1 amd64 1:0.9.6-2 [31.5 kB]
Get:51 http://localhost/debian/ sid/main libxrandr2 amd64 2:1.3.2-2 [33.5 kB]
Get:52 http://localhost/debian/ sid/main libsdl1.2debian amd64 1.2.14-7 [222 kB]
Get:53 http://localhost/debian/ sid/main libunistring0 amd64 0.9.3-5 [434 kB]
Get:54 http://localhost/debian/ sid/main libxt6 amd64 1:1.1.1-2 [207 kB]
Get:55 http://localhost/debian/ sid/main bsdmainutils amd64 8.2.3 [208 kB]
Get:56 http://localhost/debian/ sid/main groff-base amd64 1.21-6 [1150 kB]
Get:57 http://localhost/debian/ sid/main man-db amd64 2.6.0.2-3 [1015 kB]
Get:58 http://localhost/debian/ sid/main libmagic1 amd64 5.09-2 [246 kB]
Get:59 http://localhost/debian/ sid/main file amd64 5.09-2 [52.0 kB]
Get:60 http://localhost/debian/ sid/main gettext-base amd64 0.18.1.1-5 [154 kB]
Get:61 http://localhost/debian/ sid/main autotools-dev all 20110511.1 [73.8 kB]
Get:62 http://localhost/debian/ sid/main html2text amd64 1.3.2a-15 [103 kB]
Get:63 http://localhost/debian/ sid/main gettext amd64 0.18.1.1-5 [2080 kB]
Get:64 http://localhost/debian/ sid/main intltool-debian all 0.35.0+20060710.1 [30.8 kB]
Get:65 http://localhost/debian/ sid/main po-debconf all 1.0.16+nmu2 [224 kB]
Get:66 http://localhost/debian/ sid/main debhelper all 8.9.14 [693 kB]
Get:67 http://localhost/debian/ sid/main libaa1 amd64 1.4p5-39 [63.2 kB]
Get:68 http://localhost/debian/ sid/main xorg-sgml-doctools all 1:1.10-1 [24.1 kB]
Get:69 http://localhost/debian/ sid/main x11proto-core-dev all 7.0.22-1 [323 kB]
Get:70 http://localhost/debian/ sid/main libxau-dev amd64 1:1.0.6-4 [20.6 kB]
Get:71 http://localhost/debian/ sid/main libxdmcp-dev amd64 1:1.1.0-4 [39.3 kB]
Get:72 http://localhost/debian/ sid/main x11proto-input-dev all 2.1-1 [145 kB]
Get:73 http://localhost/debian/ sid/main x11proto-kb-dev all 1.0.5-2 [27.5 kB]
Get:74 http://localhost/debian/ sid/main xtrans-dev all 1.2.6-2 [101 kB]
Get:75 http://localhost/debian/ sid/main libpthread-stubs0 amd64 0.3-3 [3228 B]
Get:76 http://localhost/debian/ sid/main libpthread-stubs0-dev amd64 0.3-3 [3998 B]
Get:77 http://localhost/debian/ sid/main libxcb1-dev amd64 1.7-4 [82.7 kB]
Get:78 http://localhost/debian/ sid/main libx11-dev amd64 2:1.4.4-4 [1027 kB]
Get:79 http://localhost/debian/ sid/main zlib1g-dev amd64 1:1.2.3.4.dfsg-3 [192 kB]
Get:80 http://localhost/debian/ sid/main libpng12-dev amd64 1.2.46-4 [266 kB]
Get:81 http://localhost/debian/ sid/main libslang2-dev amd64 2.2.4-5 [627 kB]
Get:82 http://localhost/debian/ sid/main libtinfo-dev amd64 5.9-4 [103 kB]
Get:83 http://localhost/debian/ sid/main libncurses5-dev amd64 5.9-4 [406 kB]
Get:84 http://localhost/debian/ sid/main libaa1-dev amd64 1.4p5-39 [146 kB]
Get:85 http://localhost/debian/ sid/main libasound2-dev amd64 1.0.24.1-4 [598 kB]
Get:86 http://localhost/debian/ sid/main libavahi-common-dev amd64 0.6.30-6 [71.9 kB]
Get:87 http://localhost/debian/ sid/main pkg-config amd64 0.26-1 [59.5 kB]
Get:88 http://localhost/debian/ sid/main libdbus-1-dev amd64 1.4.16-1 [243 kB]
Get:89 http://localhost/debian/ sid/main libavahi-client-dev amd64 0.6.30-6 [66.2 kB]
Get:90 http://localhost/debian/ sid/main libcaca-dev amd64 0.99.beta17-2.1 [1001 kB]
Get:91 http://localhost/debian/ sid/main libjpeg8 amd64 8c-2 [132 kB]
Get:92 http://localhost/debian/ sid/main libdirectfb-extra amd64 1.2.10.0-4.3 [36.4 kB]
Get:93 http://localhost/debian/ sid/main libfreetype6-dev amd64 2.4.8-1 [801 kB]
Get:94 http://localhost/debian/ sid/main libjpeg8-dev amd64 8c-2 [241 kB]
Get:95 http://localhost/debian/ sid/main x11proto-xext-dev all 7.2.0-3 [255 kB]
Get:96 http://localhost/debian/ sid/main libxext-dev amd64 2:1.3.0-3 [167 kB]
Get:97 http://localhost/debian/ sid/main libsysfs-dev amd64 2.1.0+repack-1 [47.3 kB]
Get:98 http://localhost/debian/ sid/main libdirectfb-dev amd64 1.2.10.0-4.3 [929 kB]
Get:99 http://localhost/debian/ sid/main mesa-common-dev amd64 7.11.2-1 [350 kB]
Get:100 http://localhost/debian/ sid/main libgl1-mesa-dev amd64 7.11.2-1 [31.8 kB]
Get:101 http://localhost/debian/ sid/main libglib2.0-data all 2.30.2-4 [2318 kB]
Get:102 http://localhost/debian/ sid/main libglib2.0-bin amd64 2.30.2-4 [639 kB]
Get:103 http://localhost/debian/ sid/main libglib2.0-dev amd64 2.30.2-4 [2382 kB]
Get:104 http://localhost/debian/ sid/main libglu1-mesa-dev amd64 7.11.2-1 [296 kB]
Get:105 http://localhost/debian/ sid/main libgpm-dev amd64 1.20.4-4 [39.8 kB]
Get:106 http://localhost/debian/ sid/main libgpmg1-dev all 1.20.4-4 [24.4 kB]
Get:107 http://localhost/debian/ sid/main libice-dev amd64 2:1.0.7-2 [143 kB]
Get:108 http://localhost/debian/ sid/main libpulse-dev amd64 1.1-2 [92.6 kB]
Get:109 http://localhost/debian/ sid/main libsm-dev amd64 2:1.2.0-2 [101 kB]
Get:110 http://localhost/debian/ sid/main libxt-dev amd64 1:1.1.1-2 [512 kB]
Get:111 http://localhost/debian/ sid/main libsdl1.2-dev amd64 1.2.14-7 [862 kB]
Get:112 http://localhost/debian/ sid/main libx86-1 amd64 1.1+ds1-7 [51.7 kB]
Get:113 http://localhost/debian/ sid/main libsvga1 amd64 1:1.4.3-31 [306 kB]
Get:114 http://localhost/debian/ sid/main libsvga1-dev amd64 1:1.4.3-31 [563 kB]
Get:115 http://localhost/debian/ sid/main nasm amd64 2.09.10-1 [1043 kB]
Extracting templates from packages: 25%Extracting templates from packages: 51%Extracting templates from packages: 77%Extracting templates from packages: 100%
Preconfiguring packages ...
Fetched 35.2 MB in 0s (41.5 MB/s)
Selecting previously unselected package libpipeline1.
(Reading database ... 10821 files and directories currently installed.)
Unpacking libpipeline1 (from .../libpipeline1_1.2.0-5_amd64.deb) ...
Selecting previously unselected package libpopt0.
Unpacking libpopt0 (from .../libpopt0_1.16-3_amd64.deb) ...
Selecting previously unselected package libgpm2.
Unpacking libgpm2 (from .../libgpm2_1.20.4-4_amd64.deb) ...
Selecting previously unselected package libpcre3.
Unpacking libpcre3 (from .../libpcre3_8.12-4_amd64.deb) ...
Selecting previously unselected package libwrap0.
Unpacking libwrap0 (from .../libwrap0_7.6.q-22_amd64.deb) ...
Selecting previously unselected package libasound2.
Unpacking libasound2 (from .../libasound2_1.0.24.1-4_amd64.deb) ...
Selecting previously unselected package libasyncns0.
Unpacking libasyncns0 (from .../libasyncns0_0.8-4_amd64.deb) ...
Selecting previously unselected package libavahi-common-data.
Unpacking libavahi-common-data (from .../libavahi-common-data_0.6.30-6_amd64.deb) ...
Selecting previously unselected package libavahi-common3.
Unpacking libavahi-common3 (from .../libavahi-common3_0.6.30-6_amd64.deb) ...
Selecting previously unselected package libdbus-1-3.
Unpacking libdbus-1-3 (from .../libdbus-1-3_1.4.16-1_amd64.deb) ...
Selecting previously unselected package libavahi-client3.
Unpacking libavahi-client3 (from .../libavahi-client3_0.6.30-6_amd64.deb) ...
Selecting previously unselected package libglib2.0-0.
Unpacking libglib2.0-0 (from .../libglib2.0-0_2.30.2-4_amd64.deb) ...
Selecting previously unselected package libxml2.
Unpacking libxml2 (from .../libxml2_2.7.8.dfsg-5.1_amd64.deb) ...
Selecting previously unselected package libcroco3.
Unpacking libcroco3 (from .../libcroco3_0.6.2-2_amd64.deb) ...
Selecting previously unselected package libdrm2.
Unpacking libdrm2 (from .../libdrm2_2.4.30-1_amd64.deb) ...
Selecting previously unselected package libogg0.
Unpacking libogg0 (from .../libogg0_1.2.2~dfsg-1_amd64.deb) ...
Selecting previously unselected package libflac8.
Unpacking libflac8 (from .../libflac8_1.2.1-6_amd64.deb) ...
Selecting previously unselected package libfreetype6.
Unpacking libfreetype6 (from .../libfreetype6_2.4.8-1_amd64.deb) ...
Selecting previously unselected package libglapi-mesa.
Unpacking libglapi-mesa (from .../libglapi-mesa_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libxau6.
Unpacking libxau6 (from .../libxau6_1%3a1.0.6-4_amd64.deb) ...
Selecting previously unselected package libxdmcp6.
Unpacking libxdmcp6 (from .../libxdmcp6_1%3a1.1.0-4_amd64.deb) ...
Selecting previously unselected package libxcb1.
Unpacking libxcb1 (from .../libxcb1_1.7-4_amd64.deb) ...
Selecting previously unselected package libx11-data.
Unpacking libx11-data (from .../libx11-data_2%3a1.4.4-4_all.deb) ...
Selecting previously unselected package libx11-6.
Unpacking libx11-6 (from .../libx11-6_2%3a1.4.4-4_amd64.deb) ...
Selecting previously unselected package libxfixes3.
Unpacking libxfixes3 (from .../libxfixes3_1%3a5.0-4_amd64.deb) ...
Selecting previously unselected package libxdamage1.
Unpacking libxdamage1 (from .../libxdamage1_1%3a1.1.3-2_amd64.deb) ...
Selecting previously unselected package libxext6.
Unpacking libxext6 (from .../libxext6_2%3a1.3.0-3_amd64.deb) ...
Selecting previously unselected package libxxf86vm1.
Unpacking libxxf86vm1 (from .../libxxf86vm1_1%3a1.1.1-2_amd64.deb) ...
Selecting previously unselected package libgl1-mesa-glx.
Unpacking libgl1-mesa-glx (from .../libgl1-mesa-glx_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libglu1-mesa.
Unpacking libglu1-mesa (from .../libglu1-mesa_7.11.2-1_amd64.deb) ...
Selecting previously unselected package x11-common.
Unpacking x11-common (from .../x11-common_1%3a7.6+10_all.deb) ...
Selecting previously unselected package libice6.
Unpacking libice6 (from .../libice6_2%3a1.0.7-2_amd64.deb) ...
Selecting previously unselected package libpng12-0.
Unpacking libpng12-0 (from .../libpng12-0_1.2.46-4_amd64.deb) ...
Selecting previously unselected package libcap2.
Unpacking libcap2 (from .../libcap2_1%3a2.22-1_amd64.deb) ...
Selecting previously unselected package libjson0.
Unpacking libjson0 (from .../libjson0_0.9-1_amd64.deb) ...
Selecting previously unselected package libsm6.
Unpacking libsm6 (from .../libsm6_2%3a1.2.0-2_amd64.deb) ...
Selecting previously unselected package libvorbis0a.
Unpacking libvorbis0a (from .../libvorbis0a_1.3.2-1.1_amd64.deb) ...
Selecting previously unselected package libvorbisenc2.
Unpacking libvorbisenc2 (from .../libvorbisenc2_1.3.2-1.1_amd64.deb) ...
Selecting previously unselected package libsndfile1.
Unpacking libsndfile1 (from .../libsndfile1_1.0.25-4_amd64.deb) ...
Selecting previously unselected package libx11-xcb1.
Unpacking libx11-xcb1 (from .../libx11-xcb1_2%3a1.4.4-4_amd64.deb) ...
Selecting previously unselected package libxi6.
Unpacking libxi6 (from .../libxi6_2%3a1.4.5-1_amd64.deb) ...
Selecting previously unselected package libxtst6.
Unpacking libxtst6 (from .../libxtst6_2%3a1.2.0-4_amd64.deb) ...
Selecting previously unselected package libpulse0.
Unpacking libpulse0 (from .../libpulse0_1.1-2_amd64.deb) ...
Selecting previously unselected package libpulse-mainloop-glib0.
Unpacking libpulse-mainloop-glib0 (from .../libpulse-mainloop-glib0_1.1-2_amd64.deb) ...
Selecting previously unselected package libcaca0.
Unpacking libcaca0 (from .../libcaca0_0.99.beta17-2.1_amd64.deb) ...
Selecting previously unselected package libsysfs2.
Unpacking libsysfs2 (from .../libsysfs2_2.1.0+repack-1_amd64.deb) ...
Selecting previously unselected package tsconf.
Unpacking tsconf (from .../archives/tsconf_1.0-9_all.deb) ...
Selecting previously unselected package libts-0.0-0.
Unpacking libts-0.0-0 (from .../libts-0.0-0_1.0-9_amd64.deb) ...
Selecting previously unselected package libdirectfb-1.2-9.
Unpacking libdirectfb-1.2-9 (from .../libdirectfb-1.2-9_1.2.10.0-4.3_amd64.deb) ...
Selecting previously unselected package libxrender1.
Unpacking libxrender1 (from .../libxrender1_1%3a0.9.6-2_amd64.deb) ...
Selecting previously unselected package libxrandr2.
Unpacking libxrandr2 (from .../libxrandr2_2%3a1.3.2-2_amd64.deb) ...
Selecting previously unselected package libsdl1.2debian.
Unpacking libsdl1.2debian (from .../libsdl1.2debian_1.2.14-7_amd64.deb) ...
Selecting previously unselected package libunistring0.
Unpacking libunistring0 (from .../libunistring0_0.9.3-5_amd64.deb) ...
Selecting previously unselected package libxt6.
Unpacking libxt6 (from .../libxt6_1%3a1.1.1-2_amd64.deb) ...
Selecting previously unselected package bsdmainutils.
Unpacking bsdmainutils (from .../bsdmainutils_8.2.3_amd64.deb) ...
Selecting previously unselected package groff-base.
Unpacking groff-base (from .../groff-base_1.21-6_amd64.deb) ...
Selecting previously unselected package man-db.
Unpacking man-db (from .../man-db_2.6.0.2-3_amd64.deb) ...
Selecting previously unselected package libmagic1.
Unpacking libmagic1 (from .../libmagic1_5.09-2_amd64.deb) ...
Selecting previously unselected package file.
Unpacking file (from .../archives/file_5.09-2_amd64.deb) ...
Selecting previously unselected package gettext-base.
Unpacking gettext-base (from .../gettext-base_0.18.1.1-5_amd64.deb) ...
Selecting previously unselected package autotools-dev.
Unpacking autotools-dev (from .../autotools-dev_20110511.1_all.deb) ...
Selecting previously unselected package html2text.
Unpacking html2text (from .../html2text_1.3.2a-15_amd64.deb) ...
Selecting previously unselected package gettext.
Unpacking gettext (from .../gettext_0.18.1.1-5_amd64.deb) ...
Selecting previously unselected package intltool-debian.
Unpacking intltool-debian (from .../intltool-debian_0.35.0+20060710.1_all.deb) ...
Selecting previously unselected package po-debconf.
Unpacking po-debconf (from .../po-debconf_1.0.16+nmu2_all.deb) ...
Selecting previously unselected package debhelper.
Unpacking debhelper (from .../debhelper_8.9.14_all.deb) ...
Selecting previously unselected package libaa1.
Unpacking libaa1 (from .../libaa1_1.4p5-39_amd64.deb) ...
Selecting previously unselected package xorg-sgml-doctools.
Unpacking xorg-sgml-doctools (from .../xorg-sgml-doctools_1%3a1.10-1_all.deb) ...
Selecting previously unselected package x11proto-core-dev.
Unpacking x11proto-core-dev (from .../x11proto-core-dev_7.0.22-1_all.deb) ...
Selecting previously unselected package libxau-dev.
Unpacking libxau-dev (from .../libxau-dev_1%3a1.0.6-4_amd64.deb) ...
Selecting previously unselected package libxdmcp-dev.
Unpacking libxdmcp-dev (from .../libxdmcp-dev_1%3a1.1.0-4_amd64.deb) ...
Selecting previously unselected package x11proto-input-dev.
Unpacking x11proto-input-dev (from .../x11proto-input-dev_2.1-1_all.deb) ...
Selecting previously unselected package x11proto-kb-dev.
Unpacking x11proto-kb-dev (from .../x11proto-kb-dev_1.0.5-2_all.deb) ...
Selecting previously unselected package xtrans-dev.
Unpacking xtrans-dev (from .../xtrans-dev_1.2.6-2_all.deb) ...
Selecting previously unselected package libpthread-stubs0.
Unpacking libpthread-stubs0 (from .../libpthread-stubs0_0.3-3_amd64.deb) ...
Selecting previously unselected package libpthread-stubs0-dev.
Unpacking libpthread-stubs0-dev (from .../libpthread-stubs0-dev_0.3-3_amd64.deb) ...
Selecting previously unselected package libxcb1-dev.
Unpacking libxcb1-dev (from .../libxcb1-dev_1.7-4_amd64.deb) ...
Selecting previously unselected package libx11-dev.
Unpacking libx11-dev (from .../libx11-dev_2%3a1.4.4-4_amd64.deb) ...
Selecting previously unselected package zlib1g-dev.
Unpacking zlib1g-dev (from .../zlib1g-dev_1%3a1.2.3.4.dfsg-3_amd64.deb) ...
Selecting previously unselected package libpng12-dev.
Unpacking libpng12-dev (from .../libpng12-dev_1.2.46-4_amd64.deb) ...
Selecting previously unselected package libslang2-dev.
Unpacking libslang2-dev (from .../libslang2-dev_2.2.4-5_amd64.deb) ...
Selecting previously unselected package libtinfo-dev.
Unpacking libtinfo-dev (from .../libtinfo-dev_5.9-4_amd64.deb) ...
Selecting previously unselected package libncurses5-dev.
Unpacking libncurses5-dev (from .../libncurses5-dev_5.9-4_amd64.deb) ...
Selecting previously unselected package libaa1-dev.
Unpacking libaa1-dev (from .../libaa1-dev_1.4p5-39_amd64.deb) ...
Selecting previously unselected package libasound2-dev.
Unpacking libasound2-dev (from .../libasound2-dev_1.0.24.1-4_amd64.deb) ...
Selecting previously unselected package libavahi-common-dev.
Unpacking libavahi-common-dev (from .../libavahi-common-dev_0.6.30-6_amd64.deb) ...
Selecting previously unselected package pkg-config.
Unpacking pkg-config (from .../pkg-config_0.26-1_amd64.deb) ...
Selecting previously unselected package libdbus-1-dev.
Unpacking libdbus-1-dev (from .../libdbus-1-dev_1.4.16-1_amd64.deb) ...
Selecting previously unselected package libavahi-client-dev.
Unpacking libavahi-client-dev (from .../libavahi-client-dev_0.6.30-6_amd64.deb) ...
Selecting previously unselected package libcaca-dev.
Unpacking libcaca-dev (from .../libcaca-dev_0.99.beta17-2.1_amd64.deb) ...
Selecting previously unselected package libjpeg8.
Unpacking libjpeg8 (from .../libjpeg8_8c-2_amd64.deb) ...
Selecting previously unselected package libdirectfb-extra.
Unpacking libdirectfb-extra (from .../libdirectfb-extra_1.2.10.0-4.3_amd64.deb) ...
Selecting previously unselected package libfreetype6-dev.
Unpacking libfreetype6-dev (from .../libfreetype6-dev_2.4.8-1_amd64.deb) ...
Selecting previously unselected package libjpeg8-dev.
Unpacking libjpeg8-dev (from .../libjpeg8-dev_8c-2_amd64.deb) ...
Selecting previously unselected package x11proto-xext-dev.
Unpacking x11proto-xext-dev (from .../x11proto-xext-dev_7.2.0-3_all.deb) ...
Selecting previously unselected package libxext-dev.
Unpacking libxext-dev (from .../libxext-dev_2%3a1.3.0-3_amd64.deb) ...
Selecting previously unselected package libsysfs-dev.
Unpacking libsysfs-dev (from .../libsysfs-dev_2.1.0+repack-1_amd64.deb) ...
Selecting previously unselected package libdirectfb-dev.
Unpacking libdirectfb-dev (from .../libdirectfb-dev_1.2.10.0-4.3_amd64.deb) ...
Selecting previously unselected package mesa-common-dev.
Unpacking mesa-common-dev (from .../mesa-common-dev_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libgl1-mesa-dev.
Unpacking libgl1-mesa-dev (from .../libgl1-mesa-dev_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libglib2.0-data.
Unpacking libglib2.0-data (from .../libglib2.0-data_2.30.2-4_all.deb) ...
Selecting previously unselected package libglib2.0-bin.
Unpacking libglib2.0-bin (from .../libglib2.0-bin_2.30.2-4_amd64.deb) ...
Selecting previously unselected package libglib2.0-dev.
Unpacking libglib2.0-dev (from .../libglib2.0-dev_2.30.2-4_amd64.deb) ...
Selecting previously unselected package libglu1-mesa-dev.
Unpacking libglu1-mesa-dev (from .../libglu1-mesa-dev_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libgpm-dev.
Unpacking libgpm-dev (from .../libgpm-dev_1.20.4-4_amd64.deb) ...
Selecting previously unselected package libgpmg1-dev.
Unpacking libgpmg1-dev (from .../libgpmg1-dev_1.20.4-4_all.deb) ...
Selecting previously unselected package libice-dev.
Unpacking libice-dev (from .../libice-dev_2%3a1.0.7-2_amd64.deb) ...
Selecting previously unselected package libpulse-dev.
Unpacking libpulse-dev (from .../libpulse-dev_1.1-2_amd64.deb) ...
Selecting previously unselected package libsm-dev.
Unpacking libsm-dev (from .../libsm-dev_2%3a1.2.0-2_amd64.deb) ...
Selecting previously unselected package libxt-dev.
Unpacking libxt-dev (from .../libxt-dev_1%3a1.1.1-2_amd64.deb) ...
Selecting previously unselected package libsdl1.2-dev.
Unpacking libsdl1.2-dev (from .../libsdl1.2-dev_1.2.14-7_amd64.deb) ...
Selecting previously unselected package libx86-1.
Unpacking libx86-1 (from .../libx86-1_1.1+ds1-7_amd64.deb) ...
Selecting previously unselected package libsvga1.
Unpacking libsvga1 (from .../libsvga1_1%3a1.4.3-31_amd64.deb) ...
Selecting previously unselected package libsvga1-dev.
Unpacking libsvga1-dev (from .../libsvga1-dev_1%3a1.4.3-31_amd64.deb) ...
Selecting previously unselected package nasm.
Unpacking nasm (from .../nasm_2.09.10-1_amd64.deb) ...
Selecting previously unselected package sbuild-build-depends-pearpc-dummy.
Unpacking sbuild-build-depends-pearpc-dummy (from .../sbuild-build-depends-pearpc-dummy.deb) ...
Processing triggers for install-info ...
Setting up libpipeline1 (1.2.0-5) ...
Setting up libpopt0 (1.16-3) ...
Setting up libgpm2 (1.20.4-4) ...
Setting up libpcre3 (8.12-4) ...
Setting up libwrap0 (7.6.q-22) ...
Setting up libasound2 (1.0.24.1-4) ...
Setting up libasyncns0 (0.8-4) ...
Setting up libavahi-common-data (0.6.30-6) ...
Setting up libavahi-common3 (0.6.30-6) ...
Setting up libdbus-1-3 (1.4.16-1) ...
Setting up libavahi-client3 (0.6.30-6) ...
Setting up libglib2.0-0 (2.30.2-4) ...
No schema files found: doing nothing.
Setting up libxml2 (2.7.8.dfsg-5.1) ...
Setting up libcroco3 (0.6.2-2) ...
Setting up libdrm2 (2.4.30-1) ...
Setting up libogg0 (1.2.2~dfsg-1) ...
Setting up libflac8 (1.2.1-6) ...
Setting up libfreetype6 (2.4.8-1) ...
Setting up libglapi-mesa (7.11.2-1) ...
Setting up libxau6 (1:1.0.6-4) ...
Setting up libxdmcp6 (1:1.1.0-4) ...
Setting up libxcb1 (1.7-4) ...
Setting up libx11-data (2:1.4.4-4) ...
Setting up libx11-6 (2:1.4.4-4) ...
Setting up libxfixes3 (1:5.0-4) ...
Setting up libxdamage1 (1:1.1.3-2) ...
Setting up libxext6 (2:1.3.0-3) ...
Setting up libxxf86vm1 (1:1.1.1-2) ...
Setting up libgl1-mesa-glx (7.11.2-1) ...
Setting up libglu1-mesa (7.11.2-1) ...
Setting up x11-common (1:7.6+10) ...
invoke-rc.d: policy-rc.d denied execution of start.
Setting up libice6 (2:1.0.7-2) ...
Setting up libpng12-0 (1.2.46-4) ...
Setting up libcap2 (1:2.22-1) ...
Setting up libjson0 (0.9-1) ...
Setting up libsm6 (2:1.2.0-2) ...
Setting up libvorbis0a (1.3.2-1.1) ...
Setting up libvorbisenc2 (1.3.2-1.1) ...
Setting up libsndfile1 (1.0.25-4) ...
Setting up libx11-xcb1 (2:1.4.4-4) ...
Setting up libxi6 (2:1.4.5-1) ...
Setting up libxtst6 (2:1.2.0-4) ...
Setting up libpulse0 (1.1-2) ...
Setting up libpulse-mainloop-glib0 (1.1-2) ...
Setting up libcaca0 (0.99.beta17-2.1) ...
Setting up libsysfs2 (2.1.0+repack-1) ...
Setting up tsconf (1.0-9) ...
Setting up libts-0.0-0 (1.0-9) ...
Setting up libdirectfb-1.2-9 (1.2.10.0-4.3) ...
Setting up libxrender1 (1:0.9.6-2) ...
Setting up libxrandr2 (2:1.3.2-2) ...
Setting up libsdl1.2debian (1.2.14-7) ...
Setting up libunistring0 (0.9.3-5) ...
Setting up libxt6 (1:1.1.1-2) ...
Setting up bsdmainutils (8.2.3) ...
update-alternatives: using /usr/bin/bsd-write to provide /usr/bin/write (write) in auto mode.
update-alternatives: using /usr/bin/bsd-from to provide /usr/bin/from (from) in auto mode.
Setting up groff-base (1.21-6) ...
Setting up man-db (2.6.0.2-3) ...
Building database of manual pages ...
Setting up libmagic1 (5.09-2) ...
Setting up file (5.09-2) ...
Setting up gettext-base (0.18.1.1-5) ...
Setting up autotools-dev (20110511.1) ...
Setting up html2text (1.3.2a-15) ...
Setting up gettext (0.18.1.1-5) ...
Setting up intltool-debian (0.35.0+20060710.1) ...
Setting up po-debconf (1.0.16+nmu2) ...
Setting up debhelper (8.9.14) ...
Setting up libaa1 (1.4p5-39) ...
Setting up xorg-sgml-doctools (1:1.10-1) ...
Setting up x11proto-core-dev (7.0.22-1) ...
Setting up libxau-dev (1:1.0.6-4) ...
Setting up libxdmcp-dev (1:1.1.0-4) ...
Setting up x11proto-input-dev (2.1-1) ...
Setting up x11proto-kb-dev (1.0.5-2) ...
Setting up xtrans-dev (1.2.6-2) ...
Setting up libpthread-stubs0 (0.3-3) ...
Setting up libpthread-stubs0-dev (0.3-3) ...
Setting up libxcb1-dev (1.7-4) ...
Setting up libx11-dev (2:1.4.4-4) ...
Setting up zlib1g-dev (1:1.2.3.4.dfsg-3) ...
Setting up libpng12-dev (1.2.46-4) ...
Setting up libslang2-dev (2.2.4-5) ...
Setting up libtinfo-dev (5.9-4) ...
Setting up libncurses5-dev (5.9-4) ...
Setting up libaa1-dev (1.4p5-39) ...
Setting up libasound2-dev (1.0.24.1-4) ...
Setting up libavahi-common-dev (0.6.30-6) ...
Setting up pkg-config (0.26-1) ...
Setting up libdbus-1-dev (1.4.16-1) ...
Setting up libavahi-client-dev (0.6.30-6) ...
Setting up libcaca-dev (0.99.beta17-2.1) ...
Setting up libjpeg8 (8c-2) ...
Setting up libdirectfb-extra (1.2.10.0-4.3) ...
Setting up libfreetype6-dev (2.4.8-1) ...
Setting up libjpeg8-dev (8c-2) ...
Setting up x11proto-xext-dev (7.2.0-3) ...
Setting up libxext-dev (2:1.3.0-3) ...
Setting up libsysfs-dev (2.1.0+repack-1) ...
Setting up libdirectfb-dev (1.2.10.0-4.3) ...
Setting up mesa-common-dev (7.11.2-1) ...
Setting up libgl1-mesa-dev (7.11.2-1) ...
Setting up libglib2.0-data (2.30.2-4) ...
Setting up libglib2.0-bin (2.30.2-4) ...
Setting up libglib2.0-dev (2.30.2-4) ...
Setting up libglu1-mesa-dev (7.11.2-1) ...
Setting up libgpm-dev (1.20.4-4) ...
Setting up libgpmg1-dev (1.20.4-4) ...
Setting up libice-dev (2:1.0.7-2) ...
Setting up libpulse-dev (1.1-2) ...
Setting up libsm-dev (2:1.2.0-2) ...
Setting up libxt-dev (1:1.1.1-2) ...
Setting up libsdl1.2-dev (1.2.14-7) ...
Setting up libx86-1 (1.1+ds1-7) ...
Setting up libsvga1 (1:1.4.3-31) ...
Setting up libsvga1-dev (1:1.4.3-31) ...
Setting up nasm (2.09.10-1) ...
Setting up sbuild-build-depends-pearpc-dummy (0.invalid.0) ...

┌──────────────────────────────────────────────────────────────────────────────┐
│ Build environment                                                            │
└──────────────────────────────────────────────────────────────────────────────┘

Kernel: Linux 2.6.32-5-amd64 amd64 (x86_64)
Toolchain package versions: binutils_2.22-4 dpkg-dev_1.16.1.2 g++-4.6_4.6.2-9 gcc-4.6_4.6.2-9 libc6-dev_2.13-24 libstdc++6_4.6.2-9 libstdc++6-4.6-dev_4.6.2-9 linux-libc-dev_3.1.8-2
Package versions: apt_0.8.15.9 apt-utils_0.8.15.9 autotools-dev_20110511.1 base-files_6.5 base-passwd_3.5.24 bash_4.2-1 binutils_2.22-4 bsdmainutils_8.2.3 bsdutils_1:2.20.1-1.1 build-essential_11.5 bzip2_1.0.6-1 clang_3.0-5 coreutils_8.13-3 cpp_4:4.6.2-4 cpp-4.6_4.6.2-9 dash_0.5.7-2 debconf_1.5.41 debfoster_2.7-1.1 debhelper_8.9.14 debian-archive-keyring_2010.08.28 debianutils_4.1 diffutils_1:3.2-1 dpkg_1.16.1.2 dpkg-dev_1.16.1.2 e2fslibs_1.42-1 e2fsprogs_1.42-1 fakeroot_1.18.2-1 file_5.09-2 findutils_4.4.2-4 g++_4:4.6.2-4 g++-4.6_4.6.2-9 gcc_4:4.6.2-4 gcc-4.6_4.6.2-9 gcc-4.6-base_4.6.2-9 gettext_0.18.1.1-5 gettext-base_0.18.1.1-5 gnupg_1.4.11-3 gpgv_1.4.11-3 grep_2.10-1 groff-base_1.21-6 gzip_1.4-2 hostname_3.09 html2text_1.3.2a-15 initscripts_2.88dsf-18 insserv_1.14.0-2.1 install-info_4.13a.dfsg.1-8 intltool-debian_0.35.0+20060710.1 less_444-1 libaa1_1.4p5-39 libaa1-dev_1.4p5-39 libacl1_2.2.51-5 libasound2_1.0.24.1-4 libasound2-dev_1.0.24.1-4 libasyncns0_0.8-4 libattr1_1:2.4.46-5 libavahi-client-dev_0.6.30-6 libavahi-client3_0.6.30-6 libavahi-common-data_0.6.30-6 libavahi-common-dev_0.6.30-6 libavahi-common3_0.6.30-6 libblkid1_2.20.1-1.1 libbz2-1.0_1.0.6-1 libc-bin_2.13-24 libc-dev-bin_2.13-24 libc6_2.13-24 libc6-dev_2.13-24 libcaca-dev_0.99.beta17-2.1 libcaca0_0.99.beta17-2.1 libcap2_1:2.22-1 libclang-common-dev_3.0-5 libclass-isa-perl_0.36-3 libcomerr2_1.42-1 libcroco3_0.6.2-2 libdb5.1_5.1.29-1 libdbus-1-3_1.4.16-1 libdbus-1-dev_1.4.16-1 libdirectfb-1.2-9_1.2.10.0-4.3 libdirectfb-dev_1.2.10.0-4.3 libdirectfb-extra_1.2.10.0-4.3 libdpkg-perl_1.16.1.2 libdrm2_2.4.30-1 libffi5_3.0.10-3 libflac8_1.2.1-6 libfreetype6_2.4.8-1 libfreetype6-dev_2.4.8-1 libgc1c2_1:7.1-8 libgcc1_1:4.6.2-9 libgdbm3_1.8.3-10 libgl1-mesa-dev_7.11.2-1 libgl1-mesa-glx_7.11.2-1 libglapi-mesa_7.11.2-1 libglib2.0-0_2.30.2-4 libglib2.0-bin_2.30.2-4 libglib2.0-data_2.30.2-4 libglib2.0-dev_2.30.2-4 libglu1-mesa_7.11.2-1 libglu1-mesa-dev_7.11.2-1 libgmp10_2:5.0.2+dfsg-2 libgomp1_4.6.2-9 libgpm-dev_1.20.4-4 libgpm2_1.20.4-4 libgpmg1-dev_1.20.4-4 libice-dev_2:1.0.7-2 libice6_2:1.0.7-2 libjpeg8_8c-2 libjpeg8-dev_8c-2 libjson0_0.9-1 libllvm3.0_3.0-5 liblzma2_5.1.1alpha+20110809-2 liblzma5_5.1.1alpha+20110809-3 libmagic1_5.09-2 libmount1_2.20.1-1.1 libmpc2_0.9-4 libmpfr4_3.1.0-3 libncurses5_5.9-4 libncurses5-dev_5.9-4 libncursesw5_5.9-4 libogg0_1.2.2~dfsg-1 libpam-modules_1.1.3-6 libpam-modules-bin_1.1.3-6 libpam-runtime_1.1.3-6 libpam0g_1.1.3-6 libpcre3_8.12-4 libpipeline1_1.2.0-5 libpng12-0_1.2.46-4 libpng12-dev_1.2.46-4 libpopt0_1.16-3 libpthread-stubs0_0.3-3 libpthread-stubs0-dev_0.3-3 libpulse-dev_1.1-2 libpulse-mainloop-glib0_1.1-2 libpulse0_1.1-2 libquadmath0_4.6.2-9 libreadline6_6.2-8 libsdl1.2-dev_1.2.14-7 libsdl1.2debian_1.2.14-7 libselinux1_2.1.0-4 libsepol1_2.1.0-1.2 libslang2_2.2.4-5 libslang2-dev_2.2.4-5 libsm-dev_2:1.2.0-2 libsm6_2:1.2.0-2 libsndfile1_1.0.25-4 libss2_1.42-1 libstdc++6_4.6.2-9 libstdc++6-4.6-dev_4.6.2-9 libsvga1_1:1.4.3-31 libsvga1-dev_1:1.4.3-31 libswitch-perl_2.16-2 libsysfs-dev_2.1.0+repack-1 libsysfs2_2.1.0+repack-1 libtimedate-perl_1.2000-1 libtinfo-dev_5.9-4 libtinfo5_5.9-4 libts-0.0-0_1.0-9 libunistring0_0.9.3-5 libusb-0.1-4_2:0.1.12-20 libuuid1_2.20.1-1.1 libvorbis0a_1.3.2-1.1 libvorbisenc2_1.3.2-1.1 libwrap0_7.6.q-22 libx11-6_2:1.4.4-4 libx11-data_2:1.4.4-4 libx11-dev_2:1.4.4-4 libx11-xcb1_2:1.4.4-4 libx86-1_1.1+ds1-7 libxau-dev_1:1.0.6-4 libxau6_1:1.0.6-4 libxcb1_1.7-4 libxcb1-dev_1.7-4 libxdamage1_1:1.1.3-2 libxdmcp-dev_1:1.1.0-4 libxdmcp6_1:1.1.0-4 libxext-dev_2:1.3.0-3 libxext6_2:1.3.0-3 libxfixes3_1:5.0-4 libxi6_2:1.4.5-1 libxml2_2.7.8.dfsg-5.1 libxrandr2_2:1.3.2-2 libxrender1_1:0.9.6-2 libxt-dev_1:1.1.1-2 libxt6_1:1.1.1-2 libxtst6_2:1.2.0-4 libxxf86vm1_1:1.1.1-2 linux-libc-dev_3.1.8-2 login_1:4.1.4.2+svn3283-3 lsb-base_3.2-28 make_3.81-8.1 man-db_2.6.0.2-3 mawk_1.3.3-16 mesa-common-dev_7.11.2-1 mount_2.20.1-1.1 multiarch-support_2.13-24 nasm_2.09.10-1 ncurses-base_5.9-4 ncurses-bin_5.9-4 nvi_1.81.6-8.2 passwd_1:4.1.4.2+svn3283-3 patch_2.6.1-2 perl_5.14.2-6 perl-base_5.14.2-6 perl-modules_5.14.2-6 pkg-config_0.26-1 po-debconf_1.0.16+nmu2 readline-common_6.2-8 sbuild-build-depends-core-dummy_0.invalid.0 sbuild-build-depends-pearpc-dummy_0.invalid.0 sed_4.2.1-9 sensible-utils_0.0.6 sysv-rc_2.88dsf-18 sysvinit_2.88dsf-18 sysvinit-utils_2.88dsf-18 tar_1.26-4 tsconf_1.0-9 tzdata_2011n-2 util-linux_2.20.1-1.1 x11-common_1:7.6+10 x11proto-core-dev_7.0.22-1 x11proto-input-dev_2.1-1 x11proto-kb-dev_1.0.5-2 x11proto-xext-dev_7.2.0-3 xorg-sgml-doctools_1:1.10-1 xtrans-dev_1.2.6-2 xz-utils_5.1.1alpha+20110809-3 zlib1g_1:1.2.3.4.dfsg-3 zlib1g-dev_1:1.2.3.4.dfsg-3

┌──────────────────────────────────────────────────────────────────────────────┐
│ Build                                                                        │
└──────────────────────────────────────────────────────────────────────────────┘


Unpack source
─────────────

gpgv: keyblock resource `/var/lib/sbuild/.gnupg/trustedkeys.gpg': file open error
gpgv: Signature made Sat Dec 10 00:59:41 2011 CET using DSA key ID 7ADF9466
gpgv: Can't check signature: public key not found
dpkg-source: warning: failed to verify signature on ./pearpc_0.5.dfsg-2.dsc
dpkg-source: info: extracting pearpc in pearpc-0.5.dfsg
dpkg-source: info: unpacking pearpc_0.5.dfsg.orig.tar.bz2
dpkg-source: info: unpacking pearpc_0.5.dfsg-2.debian.tar.gz
dpkg-source: info: applying fix_ftbfs_with_newer_gcc.patch

Check disc space
────────────────

Sufficient free space for build

dpkg-buildpackage
─────────────────

dpkg-buildpackage: source package pearpc
dpkg-buildpackage: source version 0.5.dfsg-2
 dpkg-source --before-build pearpc-0.5.dfsg
dpkg-buildpackage: host architecture amd64
 fakeroot debian/rules clean
dh clean
   dh_testdir
   dh_auto_clean
   dh_clean
 dpkg-source -b pearpc-0.5.dfsg
dpkg-source: info: using source format `3.0 (quilt)'
dpkg-source: info: building pearpc using existing ./pearpc_0.5.dfsg.orig.tar.bz2
dpkg-source: info: building pearpc in pearpc_0.5.dfsg-2.debian.tar.gz
dpkg-source: info: building pearpc in pearpc_0.5.dfsg-2.dsc
 debian/rules build
dh build
   dh_testdir
   debian/rules override_dh_auto_configure
make[1]: Entering directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg'
dh_auto_configure -- --enable-ui=sdl --program-suffix=.real
configure: WARNING: unrecognized options: --disable-maintainer-mode
checking build system type... x86_64-pc-linux-gnu
checking host system type... x86_64-pc-linux-gnu
checking target system type... x86_64-pc-linux-gnu
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... no
checking for mawk... mawk
checking whether make sets $(MAKE)... yes
*** GNU, building POSIX version. we need pthread and rt.
*** x86_64 target system
checking for ranlib... ranlib
checking for gmake... no
checking for make... /usr/bin/make
checking whether /usr/bin/make sets $(MAKE)... yes
checking for gcc... gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for gcc option to accept ISO C89... none needed
checking for style of include used by /usr/bin/make... GNU
checking dependency style of gcc... none
checking for g++... g++
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts -g... yes
checking dependency style of g++... none
checking how to run the C preprocessor... gcc -E
checking dependency style of gcc... none
checking for flex... no
checking for lex... no
checking for bison... no
checking for byacc... no
checking for ar... /usr/bin/ar
checking for gar... (cached) /usr/bin/ar
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for clock_settime in -lrt... yes
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking whether byte ordering is bigendian... no
checking for sdl-config... /usr/bin/sdl-config
checking for SDL - version >= 1.2.0... yes
checking for gettimeofday... yes
checking for memset... yes
checking for setenv... yes
checking for log2... yes
checking for exp2... yes
checking for ANSI C header files... (cached) yes
checking pthread.h usability... yes
checking pthread.h presence... yes
checking for pthread.h... yes
checking sys/socket.h usability... yes
checking sys/socket.h presence... yes
checking for sys/socket.h... yes
checking asm/types.h usability... yes
checking asm/types.h presence... yes
checking for asm/types.h... yes
checking for stdint.h... (cached) yes
checking for asm/types.h... (cached) yes
checking for linux/netlink.h... yes
checking for an ANSI C-conforming const... yes
checking size of char... 1
checking size of short... 2
checking size of int... 4
checking size of long int... 8
checking size of long long... 8
configure: creating ./config.status
config.status: creating Makefile
config.status: creating doc/Makefile
config.status: creating scripts/Makefile
config.status: creating src/Makefile
config.status: creating src/cpu/Makefile
config.status: creating src/cpu/cpu_generic/Makefile
config.status: creating src/cpu/cpu_jitc_x86/Makefile
config.status: creating src/cpu/cpu_jitc_x86_64/Makefile
config.status: creating src/debug/Makefile
config.status: creating src/io/Makefile
config.status: creating src/io/3c90x/Makefile
config.status: creating src/io/ide/Makefile
config.status: creating src/io/graphic/Makefile
config.status: creating src/io/rtl8139/Makefile
config.status: creating src/io/prom/Makefile
config.status: creating src/io/prom/fs/Makefile
config.status: creating src/io/prom/fs/hfs/Makefile
config.status: creating src/io/prom/fs/hfsplus/Makefile
config.status: creating src/io/cuda/Makefile
config.status: creating src/io/pci/Makefile
config.status: creating src/io/pic/Makefile
config.status: creating src/io/macio/Makefile
config.status: creating src/io/nvram/Makefile
config.status: creating src/io/usb/Makefile
config.status: creating src/io/serial/Makefile
config.status: creating src/system/Makefile
config.status: creating src/system/arch/Makefile
config.status: creating src/system/arch/x86/Makefile
config.status: creating src/system/arch/x86_64/Makefile
config.status: creating src/system/arch/generic/Makefile
config.status: creating src/system/osapi/Makefile
config.status: creating src/system/osapi/beos/Makefile
config.status: creating src/system/osapi/posix/Makefile
config.status: creating src/system/osapi/win32/Makefile
config.status: creating src/system/ui/Makefile
config.status: creating src/system/ui/beos/Makefile
config.status: creating src/system/ui/gtk/Makefile
config.status: creating src/system/ui/qt/Makefile
config.status: creating src/system/ui/sdl/Makefile
config.status: creating src/system/ui/win32/Makefile
config.status: creating src/system/ui/x11/Makefile
config.status: creating src/tools/Makefile
config.status: creating config.h
config.status: executing depfiles commands
configure: WARNING: unrecognized options: --disable-maintainer-mode

./configure successful.

================================================================================
                             Configuration summary
================================================================================

cpu emulation method:                cpu_jitc_x86_64
compiled for architecture:           x86_64
compiled for OS-API:                 posix
compiled for UI system:              sdl
enable debug:                        yes
enable profiling:                    no
make release build:                  yes
omit frame pointer:                  yes
final C compiler flags:               -Wundef -Wall -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT
final C++ compiler flags:             -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT
final linker flags:                   -L/usr/lib/x86_64-linux-gnu -lSDL
final linker add:                     -lpthread -lrt -lrt -L/usr/lib/x86_64-linux-gnu -lSDL

================================================================================
make[1]: Leaving directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg'
   dh_auto_build
make[1]: Entering directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg'
/usr/bin/make  all-recursive
make[2]: Entering directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg'
Making all in doc
make[3]: Entering directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg/doc'
make[3]: Nothing to be done for `all'.
make[3]: Leaving directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg/doc'
Making all in src
make[3]: Entering directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg/src'
Making all in cpu
make[4]: Entering directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg/src/cpu'
Making all in cpu_jitc_x86_64
make[5]: Entering directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg/src/cpu/cpu_jitc_x86_64'
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_alu.o ppc_alu.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_cpu.o ppc_cpu.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_dec.o ppc_dec.cc
ppc_dec.cc:1120:15: warning: unused variable 'last_instr' [-Wunused-variable]
static uint32 last_instr = 0, instr_report = 0, instr_count = 0;
              ^
ppc_dec.cc:1120:31: warning: unused variable 'instr_report' [-Wunused-variable]
static uint32 last_instr = 0, instr_report = 0, instr_count = 0;
                              ^
ppc_dec.cc:1120:49: warning: unused variable 'instr_count' [-Wunused-variable]
static uint32 last_instr = 0, instr_report = 0, instr_count = 0;
                                                ^
3 warnings generated.
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_esc.o ppc_esc.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_exc.o ppc_exc.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_fpu.o ppc_fpu.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_mmu.o ppc_mmu.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_opc.o ppc_opc.cc
ppc_opc.cc:1191:15: warning: unused variable 'ppc_to_x86_roundmode' [-Wunused-variable]
static uint32 ppc_to_x86_roundmode[] = {
              ^
1 warning generated.
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_vec.o ppc_vec.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o jitc.o jitc.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o jitc_debug.o jitc_debug.cc
gcc -DHAVE_CONFIG_H -I. -I../../.. -I ../..     -c -o jitc_mmu.o jitc_mmu.S
jitc_mmu.S:280:17: warning: '/*' within block comment [-Wcomment]
/*      add     %rsp, 8;        /* hash1, no longer needed */                  \
                                ^
1 warning generated.
jitc_mmu.S:36:1: warning: ignoring directive for now
.intel_syntax prefix
^
./jitc_common.h:3:1: warning: ignoring directive for now
.struct 0 #PPC_CPU_State
^
./jitc_common.h:4:8: warning: ignoring directive for now
 jitc:;.struct jitc+8
       ^
./jitc_common.h:5:7: warning: ignoring directive for now
 gpr:;.struct gpr+32*4
      ^
./jitc_common.h:6:7: warning: ignoring directive for now
 fpr:;.struct fpr+32*8
      ^
./jitc_common.h:7:6: warning: ignoring directive for now
 cr:;.struct cr+4
     ^
./jitc_common.h:8:9: warning: ignoring directive for now
 fpscr:;.struct fpscr+4
        ^
./jitc_common.h:9:7: warning: ignoring directive for now
 xer:;.struct xer+4
      ^
./jitc_common.h:10:10: warning: ignoring directive for now
 xer_ca:;.struct xer_ca+4
         ^
./jitc_common.h:11:9: warning: ignoring directive for now
 ltreg:;.struct ltreg+4
        ^
./jitc_common.h:12:7: warning: ignoring directive for now
 ctr:;.struct ctr+4
      ^
./jitc_common.h:14:7: warning: ignoring directive for now
 msr:;.struct msr+4
      ^
./jitc_common.h:15:7: warning: ignoring directive for now
 pvr:;.struct pvr+4
      ^
./jitc_common.h:17:9: warning: ignoring directive for now
 ibatu:;.struct ibatu+4*4
        ^
./jitc_common.h:18:9: warning: ignoring directive for now
 ibatl:;.struct ibatl+4*4
        ^
./jitc_common.h:19:11: warning: ignoring directive for now
 ibat_bl:;.struct ibat_bl+4*4
          ^
./jitc_common.h:20:12: warning: ignoring directive for now
 ibat_nbl:;.struct ibat_nbl+4*4
           ^
./jitc_common.h:21:13: warning: ignoring directive for now
 ibat_bepi:;.struct ibat_bepi+4*4
            ^
./jitc_common.h:22:13: warning: ignoring directive for now
 ibat_brpn:;.struct ibat_brpn+4*4
            ^
./jitc_common.h:24:9: warning: ignoring directive for now
 dbatu:;.struct dbatu+4*4
        ^
./jitc_common.h:25:9: warning: ignoring directive for now
 dbatl:;.struct dbatl+4*4
        ^
./jitc_common.h:26:11: warning: ignoring directive for now
 dbat_bl:;.struct dbat_bl+4*4
          ^
./jitc_common.h:27:12: warning: ignoring directive for now
 dbat_nbl:;.struct dbat_nbl+4*4
           ^
./jitc_common.h:28:13: warning: ignoring directive for now
 dbat_bepi:;.struct dbat_bepi+4*4
            ^
./jitc_common.h:29:13: warning: ignoring directive for now
 dbat_brpn:;.struct dbat_brpn+4*4
            ^
./jitc_common.h:31:8: warning: ignoring directive for now
 sdr1:;.struct sdr1+4
       ^
./jitc_common.h:33:6: warning: ignoring directive for now
 sr:;.struct sr+16*4
     ^
./jitc_common.h:35:7: warning: ignoring directive for now
 dar:;.struct dar+4
      ^
./jitc_common.h:36:9: warning: ignoring directive for now
 dsisr:;.struct dsisr+4
        ^
./jitc_common.h:37:8: warning: ignoring directive for now
 sprg:;.struct sprg+4*4
       ^
./jitc_common.h:38:8: warning: ignoring directive for now
 srr0:;.struct srr0+4
       ^
./jitc_common.h:39:8: warning: ignoring directive for now
 srr1:;.struct srr1+4
       ^
./jitc_common.h:41:8: warning: ignoring directive for now
 decr:;.struct decr+4
       ^
./jitc_common.h:42:7: warning: ignoring directive for now
 ear:;.struct ear+4
      ^
./jitc_common.h:43:7: warning: ignoring directive for now
 pir:;.struct pir+4
      ^
./jitc_common.h:44:6: warning: ignoring directive for now
 tb:;.struct tb+8
     ^
./jitc_common.h:46:7: warning: ignoring directive for now
 hid:;.struct hid+16*4
      ^
./jitc_common.h:48:6: warning: ignoring directive for now
 pc:;.struct pc+4
     ^
./jitc_common.h:49:7: warning: ignoring directive for now
 npc:;.struct npc+4
      ^
./jitc_common.h:50:15: warning: ignoring directive for now
 current_opc:;.struct current_opc+4
              ^
./jitc_common.h:52:21: warning: ignoring directive for now
 exception_pending:;.struct exception_pending+1
                    ^
./jitc_common.h:53:17: warning: ignoring directive for now
 dec_exception:;.struct dec_exception+1
                ^
./jitc_common.h:54:17: warning: ignoring directive for now
 ext_exception:;.struct ext_exception+1
                ^
./jitc_common.h:55:18: warning: ignoring directive for now
 stop_exception:;.struct stop_exception+1
                 ^
./jitc_common.h:56:21: warning: ignoring directive for now
 singlestep_ignore:;.struct singlestep_ignore+1
                    ^
./jitc_common.h:57:10: warning: ignoring directive for now
 align1:;.struct align1+1
         ^
./jitc_common.h:58:10: warning: ignoring directive for now
 align2:;.struct align2+1
         ^
./jitc_common.h:59:10: warning: ignoring directive for now
 align3:;.struct align3+1
         ^
./jitc_common.h:61:18: warning: ignoring directive for now
 pagetable_base:;.struct pagetable_base+4
                 ^
./jitc_common.h:62:22: warning: ignoring directive for now
 pagetable_hashmask:;.struct pagetable_hashmask+4
                     ^
./jitc_common.h:63:11: warning: ignoring directive for now
 reserve:;.struct reserve+4
          ^
./jitc_common.h:64:20: warning: ignoring directive for now
 have_reservation:;.struct have_reservation+4
                   ^
./jitc_common.h:66:12: warning: ignoring directive for now
 tlb_last:;.struct tlb_last+4
           ^
./jitc_common.h:67:10: warning: ignoring directive for now
 tlb_pa:;.struct tlb_pa+4*4
         ^
./jitc_common.h:68:10: warning: ignoring directive for now
 tlb_va:;.struct tlb_va+4*4
         ^
./jitc_common.h:69:8: warning: ignoring directive for now
 pdec:;.struct pdec+8
       ^
./jitc_common.h:70:7: warning: ignoring directive for now
 ptb:;.struct ptb+8
      ^
./jitc_common.h:72:8: warning: ignoring directive for now
 temp:;.struct temp+4
       ^
./jitc_common.h:73:9: warning: ignoring directive for now
 temp2:;.struct temp2+4
        ^
./jitc_common.h:74:9: warning: ignoring directive for now
 x87cw:;.struct x87cw+4
        ^
./jitc_common.h:75:10: warning: ignoring directive for now
 pc_ofs:;.struct pc_ofs+4
         ^
./jitc_common.h:76:21: warning: ignoring directive for now
 current_code_base:;.struct current_code_base+4
                    ^
./jitc_common.h:78:18: warning: ignoring directive for now
 tlb_code_0_eff:;.struct tlb_code_0_eff+32*4
                 ^
./jitc_common.h:79:18: warning: ignoring directive for now
 tlb_data_0_eff:;.struct tlb_data_0_eff+32*4
                 ^
./jitc_common.h:80:18: warning: ignoring directive for now
 tlb_data_8_eff:;.struct tlb_data_8_eff+32*4
                 ^
./jitc_common.h:81:19: warning: ignoring directive for now
 tlb_code_0_phys:;.struct tlb_code_0_phys+32*4
                  ^
./jitc_common.h:82:19: warning: ignoring directive for now
 tlb_data_0_phys:;.struct tlb_data_0_phys+32*4
                  ^
./jitc_common.h:83:19: warning: ignoring directive for now
 tlb_data_8_phys:;.struct tlb_data_8_phys+32*4
                  ^
./jitc_common.h:85:1: warning: ignoring directive for now
.struct 0 #JITC
^
./jitc_common.h:86:15: warning: ignoring directive for now
 clientPages:;.struct clientPages+8
              ^
./jitc_common.h:88:1: warning: ignoring directive for now
.struct 0 #ClientPage
^
./jitc_common.h:89:15: warning: ignoring directive for now
 entrypoints:;.struct entrypoints+1024*8
              ^
./jitc_common.h:90:15: warning: ignoring directive for now
 tcf_current:;.struct tcf_current+8
              ^
./jitc_common.h:91:15: warning: ignoring directive for now
 baseaddress:;.struct baseaddress+4
              ^
./jitc_common.h:92:13: warning: ignoring directive for now
 bytesLeft:;.struct bytesLeft+4
            ^
./jitc_common.h:93:7: warning: ignoring directive for now
 tcp:;.struct tcp+8
      ^
./jitc_common.h:94:10: warning: ignoring directive for now
 moreRU:;.struct moreRU+8
         ^
./jitc_common.h:95:10: warning: ignoring directive for now
 lessRU:;.struct lessRU+8
         ^
jitc_mmu.S:122:2: error: unknown use of instruction mnemonic without a size suffix
 shr %eax, 12
 ^
jitc_mmu.S:124:7: error: unknown token in expression
 mov [%rdi+tlb_code_0_eff + %rax*4], %ecx
      ^
jitc_mmu.S:125:7: error: unknown token in expression
 mov [%rdi+tlb_data_0_eff + %rax*4], %ecx
      ^
jitc_mmu.S:126:7: error: unknown token in expression
 mov [%rdi+tlb_data_8_eff + %rax*4], %ecx
      ^
jitc_mmu.S:385:2: error: unknown use of instruction mnemonic without a size suffix
 shr %edx, 12
 ^
jitc_mmu.S:388:7: error: unknown token in expression
 mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx
      ^
jitc_mmu.S:389:12: error: unexpected token in argument list
 mov dword ptr [%rdi+tlb_code_0_phys + %rdx*4], 0
           ^
jitc_mmu.S:390:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:401:34: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_code_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_code_0_phys + %rdx*4]; clc; ret 8; 1:
                                 ^
jitc_mmu.S:401:98: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_code_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_code_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                 ^
jitc_mmu.S:401:148: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_code_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_code_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                   ^
jitc_mmu.S:401:185: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_code_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_code_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                                                        ^
jitc_mmu.S:403:12: error: unexpected token in argument list
 test byte ptr [%rdi+msr], (1<<5) # MSR_IR
           ^
jitc_mmu.S:406:13: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:406:45: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:406:117: error: unexpected token in argument list
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:406:171: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:406:269: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:406:301: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:406:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:406:391: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:406:489: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:406:531: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:406:573: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:406:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:406:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:407:13: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:407:45: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:407:117: error: unexpected token in argument list
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:407:171: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:407:269: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:407:301: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:407:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:407:391: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:407:489: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:407:531: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:407:573: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:407:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:407:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:408:13: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:408:45: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:408:117: error: unexpected token in argument list
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:408:171: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:408:269: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:408:301: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:408:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:408:391: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:408:489: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:408:531: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:408:573: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:408:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:408:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:409:13: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:409:45: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:409:117: error: unexpected token in argument list
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:409:171: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:409:269: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:409:301: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:409:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:409:391: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:409:489: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:409:531: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:409:573: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:409:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:409:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:412:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 28 # SR
 ^
jitc_mmu.S:413:13: error: unknown token in expression
 mov %edx, [%rdi+sr+4*%rbx]
            ^
jitc_mmu.S:423:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 12
 ^
jitc_mmu.S:426:2: error: unknown use of instruction mnemonic without a size suffix
 shr %r8d, 22
 ^
jitc_mmu.S:449:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:450:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:451:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:456:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:456:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:456:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:456:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:456:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:456:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:456:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:456:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:456:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:456:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:456:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:456:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:456:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:456:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:456:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:457:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:457:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:457:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:457:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:457:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:457:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:457:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:457:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:457:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:457:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:457:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:457:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:457:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:457:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:457:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:458:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:458:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:458:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:458:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:458:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:458:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:458:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:458:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:458:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:458:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:458:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:458:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:458:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:458:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:458:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:459:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:459:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:459:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:459:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:459:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:459:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:459:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:459:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:459:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:459:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:459:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:459:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:459:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:459:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:459:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:460:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:460:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:460:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:460:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:460:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:460:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:460:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:460:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:460:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:460:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:460:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:460:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:460:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:460:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:460:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:461:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:461:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:461:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:461:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:461:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:461:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:461:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:461:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:461:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:461:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:461:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:461:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:461:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:461:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:461:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:462:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:462:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:462:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:462:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:462:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:462:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:462:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:462:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:462:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:462:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:462:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:462:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:462:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:462:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:462:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:463:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:463:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:463:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:463:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:463:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:463:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:463:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:463:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:463:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:463:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:463:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:463:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:463:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:463:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:463:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:469:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:470:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:471:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:473:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:473:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:473:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:473:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:473:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:473:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:473:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:473:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:473:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:473:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:473:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:473:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:473:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:473:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:473:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:474:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:474:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:474:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:474:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:474:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:474:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:474:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:474:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:474:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:474:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:474:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:474:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:474:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:474:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:474:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:475:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:475:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:475:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:475:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:475:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:475:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:475:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:475:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:475:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:475:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:475:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:475:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:475:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:475:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:475:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:476:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:476:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:476:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:476:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:476:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:476:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:476:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:476:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:476:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:476:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:476:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:476:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:476:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:476:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:476:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:477:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:477:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:477:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:477:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:477:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:477:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:477:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:477:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:477:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:477:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:477:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:477:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:477:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:477:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:477:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:478:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:478:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:478:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:478:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:478:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:478:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:478:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:478:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:478:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:478:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:478:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:478:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:478:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:478:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:478:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:479:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:479:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:479:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:479:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:479:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:479:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:479:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:479:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:479:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:479:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:479:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:479:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:479:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:479:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:479:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:480:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:480:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:480:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:480:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:480:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:480:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:480:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:480:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:480:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:480:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:480:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:480:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:480:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:480:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:480:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:506:2: error: unknown use of instruction mnemonic without a size suffix
 shr %edx, 12
 ^
jitc_mmu.S:512:7: error: unknown token in expression
 mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx
      ^
jitc_mmu.S:513:12: error: unexpected token in argument list
 mov dword ptr [%rdi+tlb_data_0_phys + %rdx*4], %ebx
           ^
jitc_mmu.S:516:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:518:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:529:34: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_0_phys + %rdx*4]; clc; ret 8; 1:
                                 ^
jitc_mmu.S:529:98: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                 ^
jitc_mmu.S:529:148: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                   ^
jitc_mmu.S:529:185: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                                                        ^
jitc_mmu.S:531:12: error: unexpected token in argument list
 test byte ptr [%rdi+msr], (1<<4) # MSR_DR
           ^
jitc_mmu.S:534:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:534:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:534:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:534:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:534:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:534:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:534:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:534:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:534:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:534:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:534:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:534:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:534:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:535:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:535:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:535:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:535:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:535:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:535:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:535:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:535:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:535:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:535:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:535:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:535:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:535:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:536:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:536:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:536:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:536:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:536:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:536:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:536:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:536:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:536:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:536:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:536:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:536:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:536:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:537:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:537:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:537:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:537:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:537:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:537:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:537:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:537:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:537:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:537:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:537:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:537:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:537:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:540:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 28 # SR
 ^
jitc_mmu.S:541:13: error: unknown token in expression
 mov %edx, [%rdi+sr+4*%rbx]
            ^
jitc_mmu.S:548:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 12
 ^
jitc_mmu.S:551:2: error: unknown use of instruction mnemonic without a size suffix
 shr %r8d, 22
 ^
jitc_mmu.S:574:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:575:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:576:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:581:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:581:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:581:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:581:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:581:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:581:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:581:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:581:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:581:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:581:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:581:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:581:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:581:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:581:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:581:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:582:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:582:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:582:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:582:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:582:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:582:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:582:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:582:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:582:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:582:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:582:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:582:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:582:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:582:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:582:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:583:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:583:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:583:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:583:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:583:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:583:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:583:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:583:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:583:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:583:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:583:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:583:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:583:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:583:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:583:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:584:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:584:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:584:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:584:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:584:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:584:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:584:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:584:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:584:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:584:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:584:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:584:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:584:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:584:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:584:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:585:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:585:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:585:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:585:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:585:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:585:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:585:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:585:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:585:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:585:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:585:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:585:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:585:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:585:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:585:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:586:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:586:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:586:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:586:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:586:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:586:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:586:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:586:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:586:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:586:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:586:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:586:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:586:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:586:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:586:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:587:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:587:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:587:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:587:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:587:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:587:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:587:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:587:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:587:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:587:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:587:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:587:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:587:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:587:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:587:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:588:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:588:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:588:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:588:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:588:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:588:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:588:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:588:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:588:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:588:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:588:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:588:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:588:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:588:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:588:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:594:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:595:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:596:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:598:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:598:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:598:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:598:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:598:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:598:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:598:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:598:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:598:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:598:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:598:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:598:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:598:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:598:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:598:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:599:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:599:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:599:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:599:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:599:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:599:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:599:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:599:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:599:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:599:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:599:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:599:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:599:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:599:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:599:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:600:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:600:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:600:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:600:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:600:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:600:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:600:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:600:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:600:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:600:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:600:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:600:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:600:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:600:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:600:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:601:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:601:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:601:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:601:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:601:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:601:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:601:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:601:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:601:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:601:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:601:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:601:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:601:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:601:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:601:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:602:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:602:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:602:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:602:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:602:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:602:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:602:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:602:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:602:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:602:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:602:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:602:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:602:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:602:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:602:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:603:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:603:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:603:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:603:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:603:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:603:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:603:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:603:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:603:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:603:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:603:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:603:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:603:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:603:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:603:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:604:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:604:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:604:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:604:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:604:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:604:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:604:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:604:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:604:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:604:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:604:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:604:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:604:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:604:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:604:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:605:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:605:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:605:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:605:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:605:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:605:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:605:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:605:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:605:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:605:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:605:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:605:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:605:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:605:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:605:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:622:2: error: unknown use of instruction mnemonic without a size suffix
 shr %edx, 12
 ^
jitc_mmu.S:628:7: error: unknown token in expression
 mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx
      ^
jitc_mmu.S:629:12: error: unexpected token in argument list
 mov dword ptr [%rdi+tlb_data_8_phys + %rdx*4], %ebx
           ^
jitc_mmu.S:632:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:634:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:645:34: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_8_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_8_phys + %rdx*4]; clc; ret 8; 1:
                                 ^
jitc_mmu.S:645:98: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_8_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_8_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                 ^
jitc_mmu.S:645:148: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_8_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_8_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                   ^
jitc_mmu.S:645:185: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_8_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_8_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                                                        ^
jitc_mmu.S:647:12: error: unexpected token in argument list
 test byte ptr [%rdi+msr], (1<<4) # MSR_DR
           ^
jitc_mmu.S:650:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:650:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:650:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:650:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:650:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:650:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:650:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:650:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:650:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:650:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:650:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:650:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:650:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:651:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:651:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:651:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:651:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:651:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:651:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:651:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:651:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:651:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:651:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:651:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:651:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:651:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:652:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:652:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:652:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:652:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:652:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:652:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:652:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:652:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:652:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:652:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:652:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:652:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:652:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:653:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:653:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:653:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:653:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:653:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:653:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:653:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:653:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:653:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:653:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:653:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:653:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:653:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:656:2: error: unknown use of instruction mnemonic without a size suffix
 shr %eax, 28 # SR
 ^
jitc_mmu.S:657:13: error: unknown token in expression
 mov %edx, [%rdi+sr+4*%rax]
            ^
jitc_mmu.S:665:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 12
 ^
jitc_mmu.S:667:2: error: unknown use of instruction mnemonic without a size suffix
 shr %r8d, 22
 ^
jitc_mmu.S:690:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:691:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:692:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:697:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:697:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:697:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:697:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:697:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:697:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:697:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:697:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:697:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:697:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:697:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:697:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:697:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:697:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:697:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:698:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:698:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:698:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:698:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:698:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:698:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:698:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:698:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:698:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:698:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:698:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:698:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:698:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:698:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:698:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:699:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:699:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:699:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:699:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:699:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:699:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:699:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:699:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:699:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:699:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:699:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:699:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:699:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:699:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:699:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:700:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:700:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:700:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:700:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:700:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:700:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:700:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:700:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:700:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:700:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:700:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:700:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:700:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:700:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:700:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:701:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:701:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:701:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:701:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:701:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:701:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:701:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:701:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:701:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:701:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:701:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:701:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:701:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:701:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:701:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:702:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:702:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:702:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:702:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:702:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:702:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:702:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:702:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:702:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:702:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:702:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:702:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:702:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:702:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:702:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:703:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:703:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:703:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:703:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:703:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:703:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:703:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:703:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:703:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:703:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:703:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:703:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:703:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:703:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:703:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:704:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:704:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:704:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:704:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:704:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:704:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:704:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:704:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:704:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:704:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:704:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:704:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:704:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:704:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:704:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:708:13: error: unknown token in expression
 mov %ebx, [%rsp]
            ^
jitc_mmu.S:711:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:712:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:713:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:715:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:715:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:715:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:715:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:715:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:715:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:715:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:715:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:715:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:715:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:715:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:715:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:715:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:715:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:715:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:716:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:716:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:716:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:716:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:716:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:716:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:716:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:716:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:716:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:716:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:716:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:716:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:716:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:716:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:716:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:717:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:717:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:717:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:717:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:717:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:717:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:717:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:717:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:717:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:717:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:717:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:717:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:717:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:717:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:717:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:718:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:718:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:718:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:718:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:718:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:718:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:718:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:718:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:718:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:718:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:718:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:718:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:718:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:718:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:718:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:719:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:719:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:719:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:719:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:719:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:719:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:719:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:719:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:719:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:719:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:719:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:719:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:719:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:719:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:719:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:720:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:720:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:720:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:720:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:720:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:720:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:720:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:720:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:720:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:720:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:720:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:720:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:720:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:720:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:720:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:721:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:721:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:721:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:721:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:721:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:721:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:721:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:721:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:721:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:721:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:721:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:721:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:721:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:721:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:721:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:722:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:722:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:722:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:722:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:722:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:722:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:722:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:722:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:722:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:722:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:722:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:722:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:722:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:722:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:722:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:746:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:746:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:753:7: error: unknown token in expression
 mov [%rax], %dl
      ^
jitc_mmu.S:757:8: error: invalid operand for instruction
 movzx %esi, %dl
       ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:772:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:772:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:783:7: error: unknown token in expression
 mov [%rax], %dh
      ^
jitc_mmu.S:784:7: error: unknown token in expression
 mov [%rax+1], %dl
      ^
jitc_mmu.S:787:2: error: unknown use of instruction mnemonic without a size suffix
 rol %dx, 8
 ^
jitc_mmu.S:789:8: error: invalid operand for instruction
 movzx %esi, %dx
       ^
jitc_mmu.S:798:13: error: unknown token in expression
 mov %edx, [%rsp+8]
            ^
jitc_mmu.S:800:7: error: unknown token in expression
 mov [%rax], %dh
      ^
jitc_mmu.S:808:7: error: unknown token in expression
 mov [%rax], %dl
      ^
jitc_mmu.S:812:8: error: invalid operand for instruction
 movzx %esi, %dh
       ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
jitc_mmu.S:816:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:819:8: error: invalid operand for instruction
 movzx %esi, %dl
       ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:835:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:835:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:848:7: error: unknown token in expression
 mov [%rax], %edx
      ^
jitc_mmu.S:862:13: error: unknown token in expression
 mov %edx, [%rsp+8]
            ^
jitc_mmu.S:863:13: error: unknown token in expression
 mov %ebx, [%rsp]
            ^
jitc_mmu.S:869:3: error: unknown use of instruction mnemonic without a size suffix
  rol %edx, 8
  ^
jitc_mmu.S:870:8: error: unknown token in expression
  mov [%rax], %dl
       ^
jitc_mmu.S:875:7: error: unknown token in expression
 mov [%rsp+8], %edx
      ^
jitc_mmu.S:876:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:887:3: error: unknown use of instruction mnemonic without a size suffix
  rol %edx, 8
  ^
jitc_mmu.S:888:8: error: unknown token in expression
  mov [%rax], %dl
       ^
jitc_mmu.S:898:3: error: unknown use of instruction mnemonic without a size suffix
  rol %edx, 8
  ^
jitc_mmu.S:902:9: error: invalid operand for instruction
  movzx %esi, %dl
        ^
jitc_mmu.S:918:3: error: unknown use of instruction mnemonic without a size suffix
  rol %edx, 8
  ^
jitc_mmu.S:922:9: error: invalid operand for instruction
  movzx %esi, %dl
        ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:942:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:942:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:955:7: error: unknown token in expression
 mov [%rax], %rdx
      ^
jitc_mmu.S:967:13: error: unknown token in expression
 mov %rdx, [%rsp+8]
            ^
jitc_mmu.S:968:13: error: unknown token in expression
 mov %ebx, [%rsp]
            ^
jitc_mmu.S:974:3: error: unknown use of instruction mnemonic without a size suffix
  rol %rdx, 8
  ^
jitc_mmu.S:975:8: error: unknown token in expression
  mov [%rax], %dl
       ^
jitc_mmu.S:980:7: error: unknown token in expression
 mov [%rsp+8], %rdx
      ^
jitc_mmu.S:981:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:992:3: error: unknown use of instruction mnemonic without a size suffix
  rol %rdx, 8
  ^
jitc_mmu.S:993:8: error: unknown token in expression
  mov [%rax], %dl
       ^
jitc_mmu.S:1003:3: error: unknown use of instruction mnemonic without a size suffix
  rol %rdx, 8
  ^
jitc_mmu.S:1007:9: error: invalid operand for instruction
  movzx %esi, %dl
        ^
jitc_mmu.S:1023:3: error: unknown use of instruction mnemonic without a size suffix
  rol %rdx, 8
  ^
jitc_mmu.S:1027:9: error: invalid operand for instruction
  movzx %esi, %dl
        ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1048:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1048:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1057:13: error: unknown token in expression
 mov %rbx, [%rdx]
            ^
jitc_mmu.S:1058:13: error: unknown token in expression
 mov %rsi, [%rdx+8]
            ^
jitc_mmu.S:1063:7: error: unknown token in expression
 mov [%rax+8], %rbx
      ^
jitc_mmu.S:1064:7: error: unknown token in expression
 mov [%rax], %rsi
      ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1072:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1072:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1081:10: error: unknown token in expression
 movaps [%rax], %xmm0
         ^
jitc_mmu.S:1084:10: error: unknown token in expression
 movaps [%rdx], %xmm0
         ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1101:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1101:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1106:19: error: unexpected token in argument list
 movzx %edx, byte ptr [%rax]
                  ^
jitc_mmu.S:1112:8: error: invalid operand for instruction
 movzx %edx, %al
       ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1127:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1127:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1136:19: error: unexpected token in argument list
 movzx %edx, word ptr [%rax]
                  ^
jitc_mmu.S:1137:2: error: unknown use of instruction mnemonic without a size suffix
 rol %dx, 8
 ^
jitc_mmu.S:1143:2: error: unknown use of instruction mnemonic without a size suffix
 rol %ax, 8
 ^
jitc_mmu.S:1144:8: error: invalid operand for instruction
 movzx %edx, %ax
       ^
jitc_mmu.S:1153:12: error: unknown token in expression
 mov %dh, [%rax]
           ^
jitc_mmu.S:1155:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:1156:7: error: unknown token in expression
 mov [%rsp], %edx
      ^
jitc_mmu.S:1162:12: error: unknown token in expression
 mov %dl, [%rax]
           ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1195:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1195:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1204:12: error: unknown token in expression
 mov %cx, [%rax]
           ^
jitc_mmu.S:1205:2: error: unknown use of instruction mnemonic without a size suffix
 rol %cx, 8
 ^
jitc_mmu.S:1206:14: error: invalid operand for instruction
 movsx %edx, %cx
             ^
jitc_mmu.S:1212:2: error: unknown use of instruction mnemonic without a size suffix
 rol %ax, 8
 ^
jitc_mmu.S:1213:14: error: invalid operand for instruction
 movsx %edx, %ax
             ^
jitc_mmu.S:1222:12: error: unknown token in expression
 mov %ch, [%rax]
           ^
jitc_mmu.S:1224:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:1225:7: error: unknown token in expression
 mov [%rsp], %ecx
      ^
jitc_mmu.S:1231:12: error: unknown token in expression
 mov %cl, [%rax]
           ^
jitc_mmu.S:1232:14: error: invalid operand for instruction
 movsx %edx, %cx
             ^
jitc_mmu.S:1251:14: error: invalid operand for instruction
 movsx %edx, %cx
             ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1266:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1266:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1275:13: error: unknown token in expression
 mov %edx, [%rax]
            ^
jitc_mmu.S:1295:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1296:13: error: unknown token in expression
  mov %dl, [%rax]
            ^
jitc_mmu.S:1301:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:1302:7: error: unknown token in expression
 mov [%rsp], %edx
      ^
jitc_mmu.S:1313:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1314:13: error: unknown token in expression
  mov %dl, [%rax]
            ^
jitc_mmu.S:1324:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1343:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1368:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1368:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1377:13: error: unknown token in expression
 mov %rdx, [%rax]
            ^
jitc_mmu.S:1397:3: error: unknown use of instruction mnemonic without a size suffix
  shl %rdx, 8
  ^
jitc_mmu.S:1398:13: error: unknown token in expression
  mov %dl, [%rax]
            ^
jitc_mmu.S:1415:3: error: unknown use of instruction mnemonic without a size suffix
  shl %rdx, 8
  ^
jitc_mmu.S:1416:13: error: unknown token in expression
  mov %dl, [%rax]
            ^
jitc_mmu.S:1426:3: error: unknown use of instruction mnemonic without a size suffix
  shl %rdx, 8
  ^
jitc_mmu.S:1443:3: error: unknown use of instruction mnemonic without a size suffix
  shl %rdx, 8
  ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1468:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1468:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1477:13: error: unknown token in expression
 mov %rbx, [%rax]
            ^
jitc_mmu.S:1478:13: error: unknown token in expression
 mov %rsi, [%rax+8]
            ^
jitc_mmu.S:1483:7: error: unknown token in expression
 mov [%rdx+8], %rbx
      ^
jitc_mmu.S:1484:7: error: unknown token in expression
 mov [%rdx], %rsi
      ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1492:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1492:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1501:17: error: unknown token in expression
 movaps %xmm0, [%rax]
                ^
jitc_mmu.S:1503:13: error: unknown token in expression
 mov %rbx, [%rax]
            ^
jitc_mmu.S:1504:13: error: unknown token in expression
 mov %rsi, [%rax+8]
            ^
jitc_mmu.S:1509:7: error: unknown token in expression
 mov [%rdx+8], %rbx
      ^
jitc_mmu.S:1510:7: error: unknown token in expression
 mov [%rdx], %rsi
      ^
jitc_mmu.S:1520:17: error: unknown token in expression
 movaps %xmm0, [%rdx]
                ^
jitc_mmu.S:1522:13: error: unknown token in expression
 mov %rax, [%rdx]
            ^
jitc_mmu.S:1523:13: error: unknown token in expression
 mov %rsi, [%rdx+8]
            ^
jitc_mmu.S:1528:7: error: unknown token in expression
 mov [%rdx+8], %rsi
      ^
jitc_mmu.S:1529:7: error: unknown token in expression
 mov [%rdx], %rax
      ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1544:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1544:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1550:15: error: unknown token in expression
   mov %edx, [%rdi+gpr+4*%rbx]
              ^
jitc_mmu.S:1566:3: error: unknown use of instruction mnemonic without a size suffix
  shr %ecx, 24
  ^
jitc_mmu.S:1567:8: error: unknown token in expression
  mov [%rax], %cl
       ^
jitc_mmu.S:1574:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1583:2: error: unknown use of instruction mnemonic without a size suffix
 shr %edx, 24
 ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1601:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1601:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1606:9: error: unknown token in expression
   mov [%rdi+gpr+4*%rbx], %edx
        ^
jitc_mmu.S:1623:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1624:17: error: unexpected token in argument list
  mov %dl, byte ptr [%rax]
                ^
jitc_mmu.S:1640:4: error: unknown use of instruction mnemonic without a size suffix
   shl %edx, 8
   ^
jitc_mmu.S:1645:7: error: unknown token in expression
 mov [%rdi+gpr+4*%rbx], %edx
      ^
jitc_mmu.S:1654:2: error: unknown use of instruction mnemonic without a size suffix
 shl %edx, 8
 ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1664:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1664:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1672:13: error: unknown token in expression
 mov %rdi, [%rdi+jitc]
            ^
jitc_mmu.S:1673:13: error: unknown token in expression
 mov %rcx, [%rdi+clientPages]
            ^
jitc_mmu.S:1674:2: error: unknown use of instruction mnemonic without a size suffix
 shr %eax, 12
 ^
jitc_mmu.S:1675:12: error: unexpected token in argument list
 cmp qword ptr [%rcx+%rax*8], 0
           ^
jitc_mmu.S:1681:13: error: unknown token in expression
 mov %rsi, [%rcx+%rax*8]
            ^
make[5]: *** [jitc_mmu.o] Error 1
make[5]: Leaving directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg/src/cpu/cpu_jitc_x86_64'
make[4]: *** [all-recursive] Error 1
make[4]: Leaving directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg/src/cpu'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg/src'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg'
make[1]: *** [all] Error 2
make[1]: Leaving directory `/build/pearpc-ZxMcB4/pearpc-0.5.dfsg'
dh_auto_build: make -j1 returned exit code 2
make: *** [build] Error 2
dpkg-buildpackage: error: debian/rules build gave error exit status 2
────────────────────────────────────────────────────────────────────────────────
Build finished at 20120113-0201

Finished
────────

E: Build failure (dpkg-buildpackage died)

┌──────────────────────────────────────────────────────────────────────────────┐
│ Cleanup                                                                      │
└──────────────────────────────────────────────────────────────────────────────┘

Purging /var/lib/schroot/mount/lsid64b-7f1150f4-c85f-41f4-9db6-a13b342e0207/build/pearpc-ZxMcB4
Not cleaning session: cloned chroot in use

┌──────────────────────────────────────────────────────────────────────────────┐
│ Summary                                                                      │
└──────────────────────────────────────────────────────────────────────────────┘

Architecture: amd64
Build-Space: 8380
Build-Time: 14
Distribution: lsid64b
Fail-Stage: build
Install-Time: 11
Job: pearpc_0.5.dfsg-2
Package: pearpc
Package-Time: 38
Source-Version: 0.5.dfsg-2
Space: 8380
Status: attempted
Version: 0.5.dfsg-2
────────────────────────────────────────────────────────────────────────────────
Finished at 20120113-0201
Build needed 00:00:38, 8380k disc space
DC-Message: Failed, but took only 99.576242. Retrying, you never know.
Another build requested exclusive access to the build node
Another build requested exclusive access to the build node
Another build requested exclusive access to the build node
Another build requested exclusive access to the build node
Requested exclusive mode, but other builds running.
Requested exclusive mode, but other builds running.
Requested exclusive mode, but other builds running.
sbuild (Debian sbuild) 0.62.2 (05 Apr 2011) on stremi-32.reims.grid5000.fr

╔══════════════════════════════════════════════════════════════════════════════╗
║ pearpc 0.5.dfsg-2 (amd64)                                  13 Jan 2012 02:05 ║
╚══════════════════════════════════════════════════════════════════════════════╝

Package: pearpc
Version: 0.5.dfsg-2
Source Version: 0.5.dfsg-2
Distribution: lsid64b
Architecture: amd64


┌──────────────────────────────────────────────────────────────────────────────┐
│ Update chroot                                                                │
└──────────────────────────────────────────────────────────────────────────────┘

Ign http://localhost sid InRelease
Get:1 http://localhost sid Release.gpg [836 B]
Get:2 http://localhost sid Release [188 kB]
Ign http://localhost sid/main Sources/DiffIndex
Ign http://localhost sid/main amd64 Packages/DiffIndex
Ign http://localhost sid/main TranslationIndex
Get:3 http://localhost sid/main Sources [7544 kB]
Get:4 http://localhost sid/main amd64 Packages [10.4 MB]
Ign http://localhost sid/main Translation-en
Fetched 18.2 MB in 3s (5232 kB/s)
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
The following packages have been kept back:
  clang cpp-4.6 g++-4.6 gcc-4.6 gcc-4.6-base libgcc1 libgomp1 libquadmath0
  libstdc++6 libstdc++6-4.6-dev
0 upgraded, 0 newly installed, 0 to remove and 10 not upgraded.

┌──────────────────────────────────────────────────────────────────────────────┐
│ Fetch source files                                                           │
└──────────────────────────────────────────────────────────────────────────────┘


Check APT
─────────

Checking available source versions...

Download source files with APT
──────────────────────────────

Reading package lists...
Building dependency tree...
Reading state information...
Need to get 815 kB of source archives.
Get:1 http://localhost/debian/ sid/main pearpc 0.5.dfsg-2 (dsc) [1346 B]
Get:2 http://localhost/debian/ sid/main pearpc 0.5.dfsg-2 (tar) [806 kB]
Get:3 http://localhost/debian/ sid/main pearpc 0.5.dfsg-2 (diff) [7706 B]
Fetched 815 kB in 0s (28.3 MB/s)
Download complete and in download only mode

Check arch
──────────

Merged Build-Depends: build-essential, fakeroot
Filtered Build-Depends: build-essential, fakeroot
dpkg-deb: building package `sbuild-build-depends-core-dummy' in `/build/pearpc-OoHa2E/resolver-oJCBW0/apt_archive/sbuild-build-depends-core-dummy.deb'.
OK
Reading package lists...

┌──────────────────────────────────────────────────────────────────────────────┐
│ Install core build dependencies (apt-based resolver)                         │
└──────────────────────────────────────────────────────────────────────────────┘

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following NEW packages will be installed:
  sbuild-build-depends-core-dummy
0 upgraded, 1 newly installed, 0 to remove and 10 not upgraded.
Need to get 0 B/704 B of archives.
After this operation, 0 B of additional disk space will be used.
WARNING: The following packages cannot be authenticated!
  sbuild-build-depends-core-dummy
Authentication warning overridden.
Selecting previously unselected package sbuild-build-depends-core-dummy.
(Reading database ... 10821 files and directories currently installed.)
Unpacking sbuild-build-depends-core-dummy (from .../sbuild-build-depends-core-dummy.deb) ...
Setting up sbuild-build-depends-core-dummy (0.invalid.0) ...
Cannot open /var/lib/schroot/mount/lsid64b-61f62d1d-09a0-4b72-b85e-920c858fe189/etc/lsb-release: No such file or directory
Merged Build-Depends: base-files, base-passwd, bash, coreutils, dash, debianutils, diffutils, dpkg, e2fsprogs, findutils, grep, gzip, hostname, ncurses-base, ncurses-bin, perl-base, sed, login, sysvinit-utils, sysvinit, tar, bsdutils, mount, util-linux, libc6-dev | libc-dev, gcc (>= 4:4.4.3), g++ (>= 4:4.4.3), make, dpkg-dev (>= 1.13.5), debhelper (>= 7.0.50~), nasm, libaa1-dev, libgpmg1-dev, libsvga1-dev, libncurses5-dev, libxext-dev, libasound2-dev, libsdl1.2-dev, libx11-dev, autotools-dev
Filtered Build-Depends: base-files, base-passwd, bash, coreutils, dash, debianutils, diffutils, dpkg, e2fsprogs, findutils, grep, gzip, hostname, ncurses-base, ncurses-bin, perl-base, sed, login, sysvinit-utils, sysvinit, tar, bsdutils, mount, util-linux, libc6-dev, gcc (>= 4:4.4.3), g++ (>= 4:4.4.3), make, dpkg-dev (>= 1.13.5), debhelper (>= 7.0.50~), nasm, libaa1-dev, libgpmg1-dev, libsvga1-dev, libncurses5-dev, libxext-dev, libasound2-dev, libsdl1.2-dev, libx11-dev, autotools-dev
dpkg-deb: building package `sbuild-build-depends-pearpc-dummy' in `/build/pearpc-OoHa2E/resolver-U2y63u/apt_archive/sbuild-build-depends-pearpc-dummy.deb'.
OK
Reading package lists...

┌──────────────────────────────────────────────────────────────────────────────┐
│ Install pearpc build dependencies (apt-based resolver)                       │
└──────────────────────────────────────────────────────────────────────────────┘

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following extra packages will be installed:
  autotools-dev bsdmainutils debhelper file gettext gettext-base groff-base
  html2text intltool-debian libaa1 libaa1-dev libasound2 libasound2-dev
  libasyncns0 libavahi-client-dev libavahi-client3 libavahi-common-data
  libavahi-common-dev libavahi-common3 libcaca-dev libcaca0 libcap2 libcroco3
  libdbus-1-3 libdbus-1-dev libdirectfb-1.2-9 libdirectfb-dev
  libdirectfb-extra libdrm2 libflac8 libfreetype6 libfreetype6-dev
  libgl1-mesa-dev libgl1-mesa-glx libglapi-mesa libglib2.0-0 libglib2.0-bin
  libglib2.0-data libglib2.0-dev libglu1-mesa libglu1-mesa-dev libgpm-dev
  libgpm2 libgpmg1-dev libice-dev libice6 libjpeg8 libjpeg8-dev libjson0
  libmagic1 libncurses5-dev libogg0 libpcre3 libpipeline1 libpng12-0
  libpng12-dev libpopt0 libpthread-stubs0 libpthread-stubs0-dev libpulse-dev
  libpulse-mainloop-glib0 libpulse0 libsdl1.2-dev libsdl1.2debian
  libslang2-dev libsm-dev libsm6 libsndfile1 libsvga1 libsvga1-dev
  libsysfs-dev libsysfs2 libtinfo-dev libts-0.0-0 libunistring0 libvorbis0a
  libvorbisenc2 libwrap0 libx11-6 libx11-data libx11-dev libx11-xcb1 libx86-1
  libxau-dev libxau6 libxcb1 libxcb1-dev libxdamage1 libxdmcp-dev libxdmcp6
  libxext-dev libxext6 libxfixes3 libxi6 libxml2 libxrandr2 libxrender1
  libxt-dev libxt6 libxtst6 libxxf86vm1 man-db mesa-common-dev nasm pkg-config
  po-debconf tsconf x11-common x11proto-core-dev x11proto-input-dev
  x11proto-kb-dev x11proto-xext-dev xorg-sgml-doctools xtrans-dev zlib1g-dev
Suggested packages:
  wamerican wordlist whois vacation dh-make gettext-doc groff
  libasound2-plugins libasound2-doc libglib2.0-doc gpm ncurses-doc pulseaudio
  www-browser libmail-box-perl
Recommended packages:
  curl wget lynx-cur autopoint dbus libgl1-mesa-dri shared-mime-info python
  tcpd libx11-doc xml-core libmail-sendmail-perl
The following NEW packages will be installed:
  autotools-dev bsdmainutils debhelper file gettext gettext-base groff-base
  html2text intltool-debian libaa1 libaa1-dev libasound2 libasound2-dev
  libasyncns0 libavahi-client-dev libavahi-client3 libavahi-common-data
  libavahi-common-dev libavahi-common3 libcaca-dev libcaca0 libcap2 libcroco3
  libdbus-1-3 libdbus-1-dev libdirectfb-1.2-9 libdirectfb-dev
  libdirectfb-extra libdrm2 libflac8 libfreetype6 libfreetype6-dev
  libgl1-mesa-dev libgl1-mesa-glx libglapi-mesa libglib2.0-0 libglib2.0-bin
  libglib2.0-data libglib2.0-dev libglu1-mesa libglu1-mesa-dev libgpm-dev
  libgpm2 libgpmg1-dev libice-dev libice6 libjpeg8 libjpeg8-dev libjson0
  libmagic1 libncurses5-dev libogg0 libpcre3 libpipeline1 libpng12-0
  libpng12-dev libpopt0 libpthread-stubs0 libpthread-stubs0-dev libpulse-dev
  libpulse-mainloop-glib0 libpulse0 libsdl1.2-dev libsdl1.2debian
  libslang2-dev libsm-dev libsm6 libsndfile1 libsvga1 libsvga1-dev
  libsysfs-dev libsysfs2 libtinfo-dev libts-0.0-0 libunistring0 libvorbis0a
  libvorbisenc2 libwrap0 libx11-6 libx11-data libx11-dev libx11-xcb1 libx86-1
  libxau-dev libxau6 libxcb1 libxcb1-dev libxdamage1 libxdmcp-dev libxdmcp6
  libxext-dev libxext6 libxfixes3 libxi6 libxml2 libxrandr2 libxrender1
  libxt-dev libxt6 libxtst6 libxxf86vm1 man-db mesa-common-dev nasm pkg-config
  po-debconf sbuild-build-depends-pearpc-dummy tsconf x11-common
  x11proto-core-dev x11proto-input-dev x11proto-kb-dev x11proto-xext-dev
  xorg-sgml-doctools xtrans-dev zlib1g-dev
0 upgraded, 116 newly installed, 0 to remove and 10 not upgraded.
Need to get 35.2 MB/35.2 MB of archives.
After this operation, 106 MB of additional disk space will be used.
WARNING: The following packages cannot be authenticated!
  libpipeline1 libpopt0 libgpm2 libpcre3 libwrap0 libasound2 libasyncns0
  libavahi-common-data libavahi-common3 libdbus-1-3 libavahi-client3
  libglib2.0-0 libxml2 libcroco3 libdrm2 libogg0 libflac8 libfreetype6
  libglapi-mesa libxau6 libxdmcp6 libxcb1 libx11-data libx11-6 libxfixes3
  libxdamage1 libxext6 libxxf86vm1 libgl1-mesa-glx libglu1-mesa x11-common
  libice6 libpng12-0 libcap2 libjson0 libsm6 libvorbis0a libvorbisenc2
  libsndfile1 libx11-xcb1 libxi6 libxtst6 libpulse0 libpulse-mainloop-glib0
  libcaca0 libsysfs2 tsconf libts-0.0-0 libdirectfb-1.2-9 libxrender1
  libxrandr2 libsdl1.2debian libunistring0 libxt6 bsdmainutils groff-base
  man-db libmagic1 file gettext-base autotools-dev html2text gettext
  intltool-debian po-debconf debhelper libaa1 xorg-sgml-doctools
  x11proto-core-dev libxau-dev libxdmcp-dev x11proto-input-dev x11proto-kb-dev
  xtrans-dev libpthread-stubs0 libpthread-stubs0-dev libxcb1-dev libx11-dev
  zlib1g-dev libpng12-dev libslang2-dev libtinfo-dev libncurses5-dev
  libaa1-dev libasound2-dev libavahi-common-dev pkg-config libdbus-1-dev
  libavahi-client-dev libcaca-dev libjpeg8 libdirectfb-extra libfreetype6-dev
  libjpeg8-dev x11proto-xext-dev libxext-dev libsysfs-dev libdirectfb-dev
  mesa-common-dev libgl1-mesa-dev libglib2.0-data libglib2.0-bin
  libglib2.0-dev libglu1-mesa-dev libgpm-dev libgpmg1-dev libice-dev
  libpulse-dev libsm-dev libxt-dev libsdl1.2-dev libx86-1 libsvga1
  libsvga1-dev nasm sbuild-build-depends-pearpc-dummy
Authentication warning overridden.
Get:1 http://localhost/debian/ sid/main libpipeline1 amd64 1.2.0-5 [38.2 kB]
Get:2 http://localhost/debian/ sid/main libpopt0 amd64 1.16-3 [55.2 kB]
Get:3 http://localhost/debian/ sid/main libgpm2 amd64 1.20.4-4 [35.6 kB]
Get:4 http://localhost/debian/ sid/main libpcre3 amd64 8.12-4 [225 kB]
Get:5 http://localhost/debian/ sid/main libwrap0 amd64 7.6.q-22 [62.2 kB]
Get:6 http://localhost/debian/ sid/main libasound2 amd64 1.0.24.1-4 [446 kB]
Get:7 http://localhost/debian/ sid/main libasyncns0 amd64 0.8-4 [13.6 kB]
Get:8 http://localhost/debian/ sid/main libavahi-common-data amd64 0.6.30-6 [133 kB]
Get:9 http://localhost/debian/ sid/main libavahi-common3 amd64 0.6.30-6 [54.2 kB]
Get:10 http://localhost/debian/ sid/main libdbus-1-3 amd64 1.4.16-1 [164 kB]
Get:11 http://localhost/debian/ sid/main libavahi-client3 amd64 0.6.30-6 [59.0 kB]
Get:12 http://localhost/debian/ sid/main libglib2.0-0 amd64 2.30.2-4 [1844 kB]
Get:13 http://localhost/debian/ sid/main libxml2 amd64 2.7.8.dfsg-5.1 [891 kB]
Get:14 http://localhost/debian/ sid/main libcroco3 amd64 0.6.2-2 [122 kB]
Get:15 http://localhost/debian/ sid/main libdrm2 amd64 2.4.30-1 [436 kB]
Get:16 http://localhost/debian/ sid/main libogg0 amd64 1.2.2~dfsg-1 [18.6 kB]
Get:17 http://localhost/debian/ sid/main libflac8 amd64 1.2.1-6 [154 kB]
Get:18 http://localhost/debian/ sid/main libfreetype6 amd64 2.4.8-1 [442 kB]
Get:19 http://localhost/debian/ sid/main libglapi-mesa amd64 7.11.2-1 [55.8 kB]
Get:20 http://localhost/debian/ sid/main libxau6 amd64 1:1.0.6-4 [17.1 kB]
Get:21 http://localhost/debian/ sid/main libxdmcp6 amd64 1:1.1.0-4 [22.9 kB]
Get:22 http://localhost/debian/ sid/main libxcb1 amd64 1.7-4 [43.7 kB]
Get:23 http://localhost/debian/ sid/main libx11-data all 2:1.4.4-4 [187 kB]
Get:24 http://localhost/debian/ sid/main libx11-6 amd64 2:1.4.4-4 [889 kB]
Get:25 http://localhost/debian/ sid/main libxfixes3 amd64 1:5.0-4 [21.5 kB]
Get:26 http://localhost/debian/ sid/main libxdamage1 amd64 1:1.1.3-2 [14.3 kB]
Get:27 http://localhost/debian/ sid/main libxext6 amd64 2:1.3.0-3 [52.3 kB]
Get:28 http://localhost/debian/ sid/main libxxf86vm1 amd64 1:1.1.1-2 [18.2 kB]
Get:29 http://localhost/debian/ sid/main libgl1-mesa-glx amd64 7.11.2-1 [156 kB]
Get:30 http://localhost/debian/ sid/main libglu1-mesa amd64 7.11.2-1 [220 kB]
Get:31 http://localhost/debian/ sid/main x11-common all 1:7.6+10 [281 kB]
Get:32 http://localhost/debian/ sid/main libice6 amd64 2:1.0.7-2 [56.5 kB]
Get:33 http://localhost/debian/ sid/main libpng12-0 amd64 1.2.46-4 [190 kB]
Get:34 http://localhost/debian/ sid/main libcap2 amd64 1:2.22-1 [13.3 kB]
Get:35 http://localhost/debian/ sid/main libjson0 amd64 0.9-1 [18.8 kB]
Get:36 http://localhost/debian/ sid/main libsm6 amd64 2:1.2.0-2 [29.8 kB]
Get:37 http://localhost/debian/ sid/main libvorbis0a amd64 1.3.2-1.1 [122 kB]
Get:38 http://localhost/debian/ sid/main libvorbisenc2 amd64 1.3.2-1.1 [146 kB]
Get:39 http://localhost/debian/ sid/main libsndfile1 amd64 1.0.25-4 [240 kB]
Get:40 http://localhost/debian/ sid/main libx11-xcb1 amd64 2:1.4.4-4 [125 kB]
Get:41 http://localhost/debian/ sid/main libxi6 amd64 2:1.4.5-1 [67.6 kB]
Get:42 http://localhost/debian/ sid/main libxtst6 amd64 2:1.2.0-4 [24.1 kB]
Get:43 http://localhost/debian/ sid/main libpulse0 amd64 1.1-2 [307 kB]
Get:44 http://localhost/debian/ sid/main libpulse-mainloop-glib0 amd64 1.1-2 [24.6 kB]
Get:45 http://localhost/debian/ sid/main libcaca0 amd64 0.99.beta17-2.1 [386 kB]
Get:46 http://localhost/debian/ sid/main libsysfs2 amd64 2.1.0+repack-1 [29.2 kB]
Get:47 http://localhost/debian/ sid/main tsconf all 1.0-9 [13.0 kB]
Get:48 http://localhost/debian/ sid/main libts-0.0-0 amd64 1.0-9 [30.0 kB]
Get:49 http://localhost/debian/ sid/main libdirectfb-1.2-9 amd64 1.2.10.0-4.3 [1201 kB]
Get:50 http://localhost/debian/ sid/main libxrender1 amd64 1:0.9.6-2 [31.5 kB]
Get:51 http://localhost/debian/ sid/main libxrandr2 amd64 2:1.3.2-2 [33.5 kB]
Get:52 http://localhost/debian/ sid/main libsdl1.2debian amd64 1.2.14-7 [222 kB]
Get:53 http://localhost/debian/ sid/main libunistring0 amd64 0.9.3-5 [434 kB]
Get:54 http://localhost/debian/ sid/main libxt6 amd64 1:1.1.1-2 [207 kB]
Get:55 http://localhost/debian/ sid/main bsdmainutils amd64 8.2.3 [208 kB]
Get:56 http://localhost/debian/ sid/main groff-base amd64 1.21-6 [1150 kB]
Get:57 http://localhost/debian/ sid/main man-db amd64 2.6.0.2-3 [1015 kB]
Get:58 http://localhost/debian/ sid/main libmagic1 amd64 5.09-2 [246 kB]
Get:59 http://localhost/debian/ sid/main file amd64 5.09-2 [52.0 kB]
Get:60 http://localhost/debian/ sid/main gettext-base amd64 0.18.1.1-5 [154 kB]
Get:61 http://localhost/debian/ sid/main autotools-dev all 20110511.1 [73.8 kB]
Get:62 http://localhost/debian/ sid/main html2text amd64 1.3.2a-15 [103 kB]
Get:63 http://localhost/debian/ sid/main gettext amd64 0.18.1.1-5 [2080 kB]
Get:64 http://localhost/debian/ sid/main intltool-debian all 0.35.0+20060710.1 [30.8 kB]
Get:65 http://localhost/debian/ sid/main po-debconf all 1.0.16+nmu2 [224 kB]
Get:66 http://localhost/debian/ sid/main debhelper all 8.9.14 [693 kB]
Get:67 http://localhost/debian/ sid/main libaa1 amd64 1.4p5-39 [63.2 kB]
Get:68 http://localhost/debian/ sid/main xorg-sgml-doctools all 1:1.10-1 [24.1 kB]
Get:69 http://localhost/debian/ sid/main x11proto-core-dev all 7.0.22-1 [323 kB]
Get:70 http://localhost/debian/ sid/main libxau-dev amd64 1:1.0.6-4 [20.6 kB]
Get:71 http://localhost/debian/ sid/main libxdmcp-dev amd64 1:1.1.0-4 [39.3 kB]
Get:72 http://localhost/debian/ sid/main x11proto-input-dev all 2.1-1 [145 kB]
Get:73 http://localhost/debian/ sid/main x11proto-kb-dev all 1.0.5-2 [27.5 kB]
Get:74 http://localhost/debian/ sid/main xtrans-dev all 1.2.6-2 [101 kB]
Get:75 http://localhost/debian/ sid/main libpthread-stubs0 amd64 0.3-3 [3228 B]
Get:76 http://localhost/debian/ sid/main libpthread-stubs0-dev amd64 0.3-3 [3998 B]
Get:77 http://localhost/debian/ sid/main libxcb1-dev amd64 1.7-4 [82.7 kB]
Get:78 http://localhost/debian/ sid/main libx11-dev amd64 2:1.4.4-4 [1027 kB]
Get:79 http://localhost/debian/ sid/main zlib1g-dev amd64 1:1.2.3.4.dfsg-3 [192 kB]
Get:80 http://localhost/debian/ sid/main libpng12-dev amd64 1.2.46-4 [266 kB]
Get:81 http://localhost/debian/ sid/main libslang2-dev amd64 2.2.4-5 [627 kB]
Get:82 http://localhost/debian/ sid/main libtinfo-dev amd64 5.9-4 [103 kB]
Get:83 http://localhost/debian/ sid/main libncurses5-dev amd64 5.9-4 [406 kB]
Get:84 http://localhost/debian/ sid/main libaa1-dev amd64 1.4p5-39 [146 kB]
Get:85 http://localhost/debian/ sid/main libasound2-dev amd64 1.0.24.1-4 [598 kB]
Get:86 http://localhost/debian/ sid/main libavahi-common-dev amd64 0.6.30-6 [71.9 kB]
Get:87 http://localhost/debian/ sid/main pkg-config amd64 0.26-1 [59.5 kB]
Get:88 http://localhost/debian/ sid/main libdbus-1-dev amd64 1.4.16-1 [243 kB]
Get:89 http://localhost/debian/ sid/main libavahi-client-dev amd64 0.6.30-6 [66.2 kB]
Get:90 http://localhost/debian/ sid/main libcaca-dev amd64 0.99.beta17-2.1 [1001 kB]
Get:91 http://localhost/debian/ sid/main libjpeg8 amd64 8c-2 [132 kB]
Get:92 http://localhost/debian/ sid/main libdirectfb-extra amd64 1.2.10.0-4.3 [36.4 kB]
Get:93 http://localhost/debian/ sid/main libfreetype6-dev amd64 2.4.8-1 [801 kB]
Get:94 http://localhost/debian/ sid/main libjpeg8-dev amd64 8c-2 [241 kB]
Get:95 http://localhost/debian/ sid/main x11proto-xext-dev all 7.2.0-3 [255 kB]
Get:96 http://localhost/debian/ sid/main libxext-dev amd64 2:1.3.0-3 [167 kB]
Get:97 http://localhost/debian/ sid/main libsysfs-dev amd64 2.1.0+repack-1 [47.3 kB]
Get:98 http://localhost/debian/ sid/main libdirectfb-dev amd64 1.2.10.0-4.3 [929 kB]
Get:99 http://localhost/debian/ sid/main mesa-common-dev amd64 7.11.2-1 [350 kB]
Get:100 http://localhost/debian/ sid/main libgl1-mesa-dev amd64 7.11.2-1 [31.8 kB]
Get:101 http://localhost/debian/ sid/main libglib2.0-data all 2.30.2-4 [2318 kB]
Get:102 http://localhost/debian/ sid/main libglib2.0-bin amd64 2.30.2-4 [639 kB]
Get:103 http://localhost/debian/ sid/main libglib2.0-dev amd64 2.30.2-4 [2382 kB]
Get:104 http://localhost/debian/ sid/main libglu1-mesa-dev amd64 7.11.2-1 [296 kB]
Get:105 http://localhost/debian/ sid/main libgpm-dev amd64 1.20.4-4 [39.8 kB]
Get:106 http://localhost/debian/ sid/main libgpmg1-dev all 1.20.4-4 [24.4 kB]
Get:107 http://localhost/debian/ sid/main libice-dev amd64 2:1.0.7-2 [143 kB]
Get:108 http://localhost/debian/ sid/main libpulse-dev amd64 1.1-2 [92.6 kB]
Get:109 http://localhost/debian/ sid/main libsm-dev amd64 2:1.2.0-2 [101 kB]
Get:110 http://localhost/debian/ sid/main libxt-dev amd64 1:1.1.1-2 [512 kB]
Get:111 http://localhost/debian/ sid/main libsdl1.2-dev amd64 1.2.14-7 [862 kB]
Get:112 http://localhost/debian/ sid/main libx86-1 amd64 1.1+ds1-7 [51.7 kB]
Get:113 http://localhost/debian/ sid/main libsvga1 amd64 1:1.4.3-31 [306 kB]
Get:114 http://localhost/debian/ sid/main libsvga1-dev amd64 1:1.4.3-31 [563 kB]
Get:115 http://localhost/debian/ sid/main nasm amd64 2.09.10-1 [1043 kB]
Extracting templates from packages: 25%Extracting templates from packages: 51%Extracting templates from packages: 77%Extracting templates from packages: 100%
Preconfiguring packages ...
Fetched 35.2 MB in 0s (42.5 MB/s)
Selecting previously unselected package libpipeline1.
(Reading database ... 10821 files and directories currently installed.)
Unpacking libpipeline1 (from .../libpipeline1_1.2.0-5_amd64.deb) ...
Selecting previously unselected package libpopt0.
Unpacking libpopt0 (from .../libpopt0_1.16-3_amd64.deb) ...
Selecting previously unselected package libgpm2.
Unpacking libgpm2 (from .../libgpm2_1.20.4-4_amd64.deb) ...
Selecting previously unselected package libpcre3.
Unpacking libpcre3 (from .../libpcre3_8.12-4_amd64.deb) ...
Selecting previously unselected package libwrap0.
Unpacking libwrap0 (from .../libwrap0_7.6.q-22_amd64.deb) ...
Selecting previously unselected package libasound2.
Unpacking libasound2 (from .../libasound2_1.0.24.1-4_amd64.deb) ...
Selecting previously unselected package libasyncns0.
Unpacking libasyncns0 (from .../libasyncns0_0.8-4_amd64.deb) ...
Selecting previously unselected package libavahi-common-data.
Unpacking libavahi-common-data (from .../libavahi-common-data_0.6.30-6_amd64.deb) ...
Selecting previously unselected package libavahi-common3.
Unpacking libavahi-common3 (from .../libavahi-common3_0.6.30-6_amd64.deb) ...
Selecting previously unselected package libdbus-1-3.
Unpacking libdbus-1-3 (from .../libdbus-1-3_1.4.16-1_amd64.deb) ...
Selecting previously unselected package libavahi-client3.
Unpacking libavahi-client3 (from .../libavahi-client3_0.6.30-6_amd64.deb) ...
Selecting previously unselected package libglib2.0-0.
Unpacking libglib2.0-0 (from .../libglib2.0-0_2.30.2-4_amd64.deb) ...
Selecting previously unselected package libxml2.
Unpacking libxml2 (from .../libxml2_2.7.8.dfsg-5.1_amd64.deb) ...
Selecting previously unselected package libcroco3.
Unpacking libcroco3 (from .../libcroco3_0.6.2-2_amd64.deb) ...
Selecting previously unselected package libdrm2.
Unpacking libdrm2 (from .../libdrm2_2.4.30-1_amd64.deb) ...
Selecting previously unselected package libogg0.
Unpacking libogg0 (from .../libogg0_1.2.2~dfsg-1_amd64.deb) ...
Selecting previously unselected package libflac8.
Unpacking libflac8 (from .../libflac8_1.2.1-6_amd64.deb) ...
Selecting previously unselected package libfreetype6.
Unpacking libfreetype6 (from .../libfreetype6_2.4.8-1_amd64.deb) ...
Selecting previously unselected package libglapi-mesa.
Unpacking libglapi-mesa (from .../libglapi-mesa_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libxau6.
Unpacking libxau6 (from .../libxau6_1%3a1.0.6-4_amd64.deb) ...
Selecting previously unselected package libxdmcp6.
Unpacking libxdmcp6 (from .../libxdmcp6_1%3a1.1.0-4_amd64.deb) ...
Selecting previously unselected package libxcb1.
Unpacking libxcb1 (from .../libxcb1_1.7-4_amd64.deb) ...
Selecting previously unselected package libx11-data.
Unpacking libx11-data (from .../libx11-data_2%3a1.4.4-4_all.deb) ...
Selecting previously unselected package libx11-6.
Unpacking libx11-6 (from .../libx11-6_2%3a1.4.4-4_amd64.deb) ...
Selecting previously unselected package libxfixes3.
Unpacking libxfixes3 (from .../libxfixes3_1%3a5.0-4_amd64.deb) ...
Selecting previously unselected package libxdamage1.
Unpacking libxdamage1 (from .../libxdamage1_1%3a1.1.3-2_amd64.deb) ...
Selecting previously unselected package libxext6.
Unpacking libxext6 (from .../libxext6_2%3a1.3.0-3_amd64.deb) ...
Selecting previously unselected package libxxf86vm1.
Unpacking libxxf86vm1 (from .../libxxf86vm1_1%3a1.1.1-2_amd64.deb) ...
Selecting previously unselected package libgl1-mesa-glx.
Unpacking libgl1-mesa-glx (from .../libgl1-mesa-glx_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libglu1-mesa.
Unpacking libglu1-mesa (from .../libglu1-mesa_7.11.2-1_amd64.deb) ...
Selecting previously unselected package x11-common.
Unpacking x11-common (from .../x11-common_1%3a7.6+10_all.deb) ...
Selecting previously unselected package libice6.
Unpacking libice6 (from .../libice6_2%3a1.0.7-2_amd64.deb) ...
Selecting previously unselected package libpng12-0.
Unpacking libpng12-0 (from .../libpng12-0_1.2.46-4_amd64.deb) ...
Selecting previously unselected package libcap2.
Unpacking libcap2 (from .../libcap2_1%3a2.22-1_amd64.deb) ...
Selecting previously unselected package libjson0.
Unpacking libjson0 (from .../libjson0_0.9-1_amd64.deb) ...
Selecting previously unselected package libsm6.
Unpacking libsm6 (from .../libsm6_2%3a1.2.0-2_amd64.deb) ...
Selecting previously unselected package libvorbis0a.
Unpacking libvorbis0a (from .../libvorbis0a_1.3.2-1.1_amd64.deb) ...
Selecting previously unselected package libvorbisenc2.
Unpacking libvorbisenc2 (from .../libvorbisenc2_1.3.2-1.1_amd64.deb) ...
Selecting previously unselected package libsndfile1.
Unpacking libsndfile1 (from .../libsndfile1_1.0.25-4_amd64.deb) ...
Selecting previously unselected package libx11-xcb1.
Unpacking libx11-xcb1 (from .../libx11-xcb1_2%3a1.4.4-4_amd64.deb) ...
Selecting previously unselected package libxi6.
Unpacking libxi6 (from .../libxi6_2%3a1.4.5-1_amd64.deb) ...
Selecting previously unselected package libxtst6.
Unpacking libxtst6 (from .../libxtst6_2%3a1.2.0-4_amd64.deb) ...
Selecting previously unselected package libpulse0.
Unpacking libpulse0 (from .../libpulse0_1.1-2_amd64.deb) ...
Selecting previously unselected package libpulse-mainloop-glib0.
Unpacking libpulse-mainloop-glib0 (from .../libpulse-mainloop-glib0_1.1-2_amd64.deb) ...
Selecting previously unselected package libcaca0.
Unpacking libcaca0 (from .../libcaca0_0.99.beta17-2.1_amd64.deb) ...
Selecting previously unselected package libsysfs2.
Unpacking libsysfs2 (from .../libsysfs2_2.1.0+repack-1_amd64.deb) ...
Selecting previously unselected package tsconf.
Unpacking tsconf (from .../archives/tsconf_1.0-9_all.deb) ...
Selecting previously unselected package libts-0.0-0.
Unpacking libts-0.0-0 (from .../libts-0.0-0_1.0-9_amd64.deb) ...
Selecting previously unselected package libdirectfb-1.2-9.
Unpacking libdirectfb-1.2-9 (from .../libdirectfb-1.2-9_1.2.10.0-4.3_amd64.deb) ...
Selecting previously unselected package libxrender1.
Unpacking libxrender1 (from .../libxrender1_1%3a0.9.6-2_amd64.deb) ...
Selecting previously unselected package libxrandr2.
Unpacking libxrandr2 (from .../libxrandr2_2%3a1.3.2-2_amd64.deb) ...
Selecting previously unselected package libsdl1.2debian.
Unpacking libsdl1.2debian (from .../libsdl1.2debian_1.2.14-7_amd64.deb) ...
Selecting previously unselected package libunistring0.
Unpacking libunistring0 (from .../libunistring0_0.9.3-5_amd64.deb) ...
Selecting previously unselected package libxt6.
Unpacking libxt6 (from .../libxt6_1%3a1.1.1-2_amd64.deb) ...
Selecting previously unselected package bsdmainutils.
Unpacking bsdmainutils (from .../bsdmainutils_8.2.3_amd64.deb) ...
Selecting previously unselected package groff-base.
Unpacking groff-base (from .../groff-base_1.21-6_amd64.deb) ...
Selecting previously unselected package man-db.
Unpacking man-db (from .../man-db_2.6.0.2-3_amd64.deb) ...
Selecting previously unselected package libmagic1.
Unpacking libmagic1 (from .../libmagic1_5.09-2_amd64.deb) ...
Selecting previously unselected package file.
Unpacking file (from .../archives/file_5.09-2_amd64.deb) ...
Selecting previously unselected package gettext-base.
Unpacking gettext-base (from .../gettext-base_0.18.1.1-5_amd64.deb) ...
Selecting previously unselected package autotools-dev.
Unpacking autotools-dev (from .../autotools-dev_20110511.1_all.deb) ...
Selecting previously unselected package html2text.
Unpacking html2text (from .../html2text_1.3.2a-15_amd64.deb) ...
Selecting previously unselected package gettext.
Unpacking gettext (from .../gettext_0.18.1.1-5_amd64.deb) ...
Selecting previously unselected package intltool-debian.
Unpacking intltool-debian (from .../intltool-debian_0.35.0+20060710.1_all.deb) ...
Selecting previously unselected package po-debconf.
Unpacking po-debconf (from .../po-debconf_1.0.16+nmu2_all.deb) ...
Selecting previously unselected package debhelper.
Unpacking debhelper (from .../debhelper_8.9.14_all.deb) ...
Selecting previously unselected package libaa1.
Unpacking libaa1 (from .../libaa1_1.4p5-39_amd64.deb) ...
Selecting previously unselected package xorg-sgml-doctools.
Unpacking xorg-sgml-doctools (from .../xorg-sgml-doctools_1%3a1.10-1_all.deb) ...
Selecting previously unselected package x11proto-core-dev.
Unpacking x11proto-core-dev (from .../x11proto-core-dev_7.0.22-1_all.deb) ...
Selecting previously unselected package libxau-dev.
Unpacking libxau-dev (from .../libxau-dev_1%3a1.0.6-4_amd64.deb) ...
Selecting previously unselected package libxdmcp-dev.
Unpacking libxdmcp-dev (from .../libxdmcp-dev_1%3a1.1.0-4_amd64.deb) ...
Selecting previously unselected package x11proto-input-dev.
Unpacking x11proto-input-dev (from .../x11proto-input-dev_2.1-1_all.deb) ...
Selecting previously unselected package x11proto-kb-dev.
Unpacking x11proto-kb-dev (from .../x11proto-kb-dev_1.0.5-2_all.deb) ...
Selecting previously unselected package xtrans-dev.
Unpacking xtrans-dev (from .../xtrans-dev_1.2.6-2_all.deb) ...
Selecting previously unselected package libpthread-stubs0.
Unpacking libpthread-stubs0 (from .../libpthread-stubs0_0.3-3_amd64.deb) ...
Selecting previously unselected package libpthread-stubs0-dev.
Unpacking libpthread-stubs0-dev (from .../libpthread-stubs0-dev_0.3-3_amd64.deb) ...
Selecting previously unselected package libxcb1-dev.
Unpacking libxcb1-dev (from .../libxcb1-dev_1.7-4_amd64.deb) ...
Selecting previously unselected package libx11-dev.
Unpacking libx11-dev (from .../libx11-dev_2%3a1.4.4-4_amd64.deb) ...
Selecting previously unselected package zlib1g-dev.
Unpacking zlib1g-dev (from .../zlib1g-dev_1%3a1.2.3.4.dfsg-3_amd64.deb) ...
Selecting previously unselected package libpng12-dev.
Unpacking libpng12-dev (from .../libpng12-dev_1.2.46-4_amd64.deb) ...
Selecting previously unselected package libslang2-dev.
Unpacking libslang2-dev (from .../libslang2-dev_2.2.4-5_amd64.deb) ...
Selecting previously unselected package libtinfo-dev.
Unpacking libtinfo-dev (from .../libtinfo-dev_5.9-4_amd64.deb) ...
Selecting previously unselected package libncurses5-dev.
Unpacking libncurses5-dev (from .../libncurses5-dev_5.9-4_amd64.deb) ...
Selecting previously unselected package libaa1-dev.
Unpacking libaa1-dev (from .../libaa1-dev_1.4p5-39_amd64.deb) ...
Selecting previously unselected package libasound2-dev.
Unpacking libasound2-dev (from .../libasound2-dev_1.0.24.1-4_amd64.deb) ...
Selecting previously unselected package libavahi-common-dev.
Unpacking libavahi-common-dev (from .../libavahi-common-dev_0.6.30-6_amd64.deb) ...
Selecting previously unselected package pkg-config.
Unpacking pkg-config (from .../pkg-config_0.26-1_amd64.deb) ...
Selecting previously unselected package libdbus-1-dev.
Unpacking libdbus-1-dev (from .../libdbus-1-dev_1.4.16-1_amd64.deb) ...
Selecting previously unselected package libavahi-client-dev.
Unpacking libavahi-client-dev (from .../libavahi-client-dev_0.6.30-6_amd64.deb) ...
Selecting previously unselected package libcaca-dev.
Unpacking libcaca-dev (from .../libcaca-dev_0.99.beta17-2.1_amd64.deb) ...
Selecting previously unselected package libjpeg8.
Unpacking libjpeg8 (from .../libjpeg8_8c-2_amd64.deb) ...
Selecting previously unselected package libdirectfb-extra.
Unpacking libdirectfb-extra (from .../libdirectfb-extra_1.2.10.0-4.3_amd64.deb) ...
Selecting previously unselected package libfreetype6-dev.
Unpacking libfreetype6-dev (from .../libfreetype6-dev_2.4.8-1_amd64.deb) ...
Selecting previously unselected package libjpeg8-dev.
Unpacking libjpeg8-dev (from .../libjpeg8-dev_8c-2_amd64.deb) ...
Selecting previously unselected package x11proto-xext-dev.
Unpacking x11proto-xext-dev (from .../x11proto-xext-dev_7.2.0-3_all.deb) ...
Selecting previously unselected package libxext-dev.
Unpacking libxext-dev (from .../libxext-dev_2%3a1.3.0-3_amd64.deb) ...
Selecting previously unselected package libsysfs-dev.
Unpacking libsysfs-dev (from .../libsysfs-dev_2.1.0+repack-1_amd64.deb) ...
Selecting previously unselected package libdirectfb-dev.
Unpacking libdirectfb-dev (from .../libdirectfb-dev_1.2.10.0-4.3_amd64.deb) ...
Selecting previously unselected package mesa-common-dev.
Unpacking mesa-common-dev (from .../mesa-common-dev_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libgl1-mesa-dev.
Unpacking libgl1-mesa-dev (from .../libgl1-mesa-dev_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libglib2.0-data.
Unpacking libglib2.0-data (from .../libglib2.0-data_2.30.2-4_all.deb) ...
Selecting previously unselected package libglib2.0-bin.
Unpacking libglib2.0-bin (from .../libglib2.0-bin_2.30.2-4_amd64.deb) ...
Selecting previously unselected package libglib2.0-dev.
Unpacking libglib2.0-dev (from .../libglib2.0-dev_2.30.2-4_amd64.deb) ...
Selecting previously unselected package libglu1-mesa-dev.
Unpacking libglu1-mesa-dev (from .../libglu1-mesa-dev_7.11.2-1_amd64.deb) ...
Selecting previously unselected package libgpm-dev.
Unpacking libgpm-dev (from .../libgpm-dev_1.20.4-4_amd64.deb) ...
Selecting previously unselected package libgpmg1-dev.
Unpacking libgpmg1-dev (from .../libgpmg1-dev_1.20.4-4_all.deb) ...
Selecting previously unselected package libice-dev.
Unpacking libice-dev (from .../libice-dev_2%3a1.0.7-2_amd64.deb) ...
Selecting previously unselected package libpulse-dev.
Unpacking libpulse-dev (from .../libpulse-dev_1.1-2_amd64.deb) ...
Selecting previously unselected package libsm-dev.
Unpacking libsm-dev (from .../libsm-dev_2%3a1.2.0-2_amd64.deb) ...
Selecting previously unselected package libxt-dev.
Unpacking libxt-dev (from .../libxt-dev_1%3a1.1.1-2_amd64.deb) ...
Selecting previously unselected package libsdl1.2-dev.
Unpacking libsdl1.2-dev (from .../libsdl1.2-dev_1.2.14-7_amd64.deb) ...
Selecting previously unselected package libx86-1.
Unpacking libx86-1 (from .../libx86-1_1.1+ds1-7_amd64.deb) ...
Selecting previously unselected package libsvga1.
Unpacking libsvga1 (from .../libsvga1_1%3a1.4.3-31_amd64.deb) ...
Selecting previously unselected package libsvga1-dev.
Unpacking libsvga1-dev (from .../libsvga1-dev_1%3a1.4.3-31_amd64.deb) ...
Selecting previously unselected package nasm.
Unpacking nasm (from .../nasm_2.09.10-1_amd64.deb) ...
Selecting previously unselected package sbuild-build-depends-pearpc-dummy.
Unpacking sbuild-build-depends-pearpc-dummy (from .../sbuild-build-depends-pearpc-dummy.deb) ...
Processing triggers for install-info ...
Setting up libpipeline1 (1.2.0-5) ...
Setting up libpopt0 (1.16-3) ...
Setting up libgpm2 (1.20.4-4) ...
Setting up libpcre3 (8.12-4) ...
Setting up libwrap0 (7.6.q-22) ...
Setting up libasound2 (1.0.24.1-4) ...
Setting up libasyncns0 (0.8-4) ...
Setting up libavahi-common-data (0.6.30-6) ...
Setting up libavahi-common3 (0.6.30-6) ...
Setting up libdbus-1-3 (1.4.16-1) ...
Setting up libavahi-client3 (0.6.30-6) ...
Setting up libglib2.0-0 (2.30.2-4) ...
No schema files found: doing nothing.
Setting up libxml2 (2.7.8.dfsg-5.1) ...
Setting up libcroco3 (0.6.2-2) ...
Setting up libdrm2 (2.4.30-1) ...
Setting up libogg0 (1.2.2~dfsg-1) ...
Setting up libflac8 (1.2.1-6) ...
Setting up libfreetype6 (2.4.8-1) ...
Setting up libglapi-mesa (7.11.2-1) ...
Setting up libxau6 (1:1.0.6-4) ...
Setting up libxdmcp6 (1:1.1.0-4) ...
Setting up libxcb1 (1.7-4) ...
Setting up libx11-data (2:1.4.4-4) ...
Setting up libx11-6 (2:1.4.4-4) ...
Setting up libxfixes3 (1:5.0-4) ...
Setting up libxdamage1 (1:1.1.3-2) ...
Setting up libxext6 (2:1.3.0-3) ...
Setting up libxxf86vm1 (1:1.1.1-2) ...
Setting up libgl1-mesa-glx (7.11.2-1) ...
Setting up libglu1-mesa (7.11.2-1) ...
Setting up x11-common (1:7.6+10) ...
invoke-rc.d: policy-rc.d denied execution of start.
Setting up libice6 (2:1.0.7-2) ...
Setting up libpng12-0 (1.2.46-4) ...
Setting up libcap2 (1:2.22-1) ...
Setting up libjson0 (0.9-1) ...
Setting up libsm6 (2:1.2.0-2) ...
Setting up libvorbis0a (1.3.2-1.1) ...
Setting up libvorbisenc2 (1.3.2-1.1) ...
Setting up libsndfile1 (1.0.25-4) ...
Setting up libx11-xcb1 (2:1.4.4-4) ...
Setting up libxi6 (2:1.4.5-1) ...
Setting up libxtst6 (2:1.2.0-4) ...
Setting up libpulse0 (1.1-2) ...
Setting up libpulse-mainloop-glib0 (1.1-2) ...
Setting up libcaca0 (0.99.beta17-2.1) ...
Setting up libsysfs2 (2.1.0+repack-1) ...
Setting up tsconf (1.0-9) ...
Setting up libts-0.0-0 (1.0-9) ...
Setting up libdirectfb-1.2-9 (1.2.10.0-4.3) ...
Setting up libxrender1 (1:0.9.6-2) ...
Setting up libxrandr2 (2:1.3.2-2) ...
Setting up libsdl1.2debian (1.2.14-7) ...
Setting up libunistring0 (0.9.3-5) ...
Setting up libxt6 (1:1.1.1-2) ...
Setting up bsdmainutils (8.2.3) ...
update-alternatives: using /usr/bin/bsd-write to provide /usr/bin/write (write) in auto mode.
update-alternatives: using /usr/bin/bsd-from to provide /usr/bin/from (from) in auto mode.
Setting up groff-base (1.21-6) ...
Setting up man-db (2.6.0.2-3) ...
Building database of manual pages ...
Setting up libmagic1 (5.09-2) ...
Setting up file (5.09-2) ...
Setting up gettext-base (0.18.1.1-5) ...
Setting up autotools-dev (20110511.1) ...
Setting up html2text (1.3.2a-15) ...
Setting up gettext (0.18.1.1-5) ...
Setting up intltool-debian (0.35.0+20060710.1) ...
Setting up po-debconf (1.0.16+nmu2) ...
Setting up debhelper (8.9.14) ...
Setting up libaa1 (1.4p5-39) ...
Setting up xorg-sgml-doctools (1:1.10-1) ...
Setting up x11proto-core-dev (7.0.22-1) ...
Setting up libxau-dev (1:1.0.6-4) ...
Setting up libxdmcp-dev (1:1.1.0-4) ...
Setting up x11proto-input-dev (2.1-1) ...
Setting up x11proto-kb-dev (1.0.5-2) ...
Setting up xtrans-dev (1.2.6-2) ...
Setting up libpthread-stubs0 (0.3-3) ...
Setting up libpthread-stubs0-dev (0.3-3) ...
Setting up libxcb1-dev (1.7-4) ...
Setting up libx11-dev (2:1.4.4-4) ...
Setting up zlib1g-dev (1:1.2.3.4.dfsg-3) ...
Setting up libpng12-dev (1.2.46-4) ...
Setting up libslang2-dev (2.2.4-5) ...
Setting up libtinfo-dev (5.9-4) ...
Setting up libncurses5-dev (5.9-4) ...
Setting up libaa1-dev (1.4p5-39) ...
Setting up libasound2-dev (1.0.24.1-4) ...
Setting up libavahi-common-dev (0.6.30-6) ...
Setting up pkg-config (0.26-1) ...
Setting up libdbus-1-dev (1.4.16-1) ...
Setting up libavahi-client-dev (0.6.30-6) ...
Setting up libcaca-dev (0.99.beta17-2.1) ...
Setting up libjpeg8 (8c-2) ...
Setting up libdirectfb-extra (1.2.10.0-4.3) ...
Setting up libfreetype6-dev (2.4.8-1) ...
Setting up libjpeg8-dev (8c-2) ...
Setting up x11proto-xext-dev (7.2.0-3) ...
Setting up libxext-dev (2:1.3.0-3) ...
Setting up libsysfs-dev (2.1.0+repack-1) ...
Setting up libdirectfb-dev (1.2.10.0-4.3) ...
Setting up mesa-common-dev (7.11.2-1) ...
Setting up libgl1-mesa-dev (7.11.2-1) ...
Setting up libglib2.0-data (2.30.2-4) ...
Setting up libglib2.0-bin (2.30.2-4) ...
Setting up libglib2.0-dev (2.30.2-4) ...
Setting up libglu1-mesa-dev (7.11.2-1) ...
Setting up libgpm-dev (1.20.4-4) ...
Setting up libgpmg1-dev (1.20.4-4) ...
Setting up libice-dev (2:1.0.7-2) ...
Setting up libpulse-dev (1.1-2) ...
Setting up libsm-dev (2:1.2.0-2) ...
Setting up libxt-dev (1:1.1.1-2) ...
Setting up libsdl1.2-dev (1.2.14-7) ...
Setting up libx86-1 (1.1+ds1-7) ...
Setting up libsvga1 (1:1.4.3-31) ...
Setting up libsvga1-dev (1:1.4.3-31) ...
Setting up nasm (2.09.10-1) ...
Setting up sbuild-build-depends-pearpc-dummy (0.invalid.0) ...

┌──────────────────────────────────────────────────────────────────────────────┐
│ Build environment                                                            │
└──────────────────────────────────────────────────────────────────────────────┘

Kernel: Linux 2.6.32-5-amd64 amd64 (x86_64)
Toolchain package versions: binutils_2.22-4 dpkg-dev_1.16.1.2 g++-4.6_4.6.2-9 gcc-4.6_4.6.2-9 libc6-dev_2.13-24 libstdc++6_4.6.2-9 libstdc++6-4.6-dev_4.6.2-9 linux-libc-dev_3.1.8-2
Package versions: apt_0.8.15.9 apt-utils_0.8.15.9 autotools-dev_20110511.1 base-files_6.5 base-passwd_3.5.24 bash_4.2-1 binutils_2.22-4 bsdmainutils_8.2.3 bsdutils_1:2.20.1-1.1 build-essential_11.5 bzip2_1.0.6-1 clang_3.0-5 coreutils_8.13-3 cpp_4:4.6.2-4 cpp-4.6_4.6.2-9 dash_0.5.7-2 debconf_1.5.41 debfoster_2.7-1.1 debhelper_8.9.14 debian-archive-keyring_2010.08.28 debianutils_4.1 diffutils_1:3.2-1 dpkg_1.16.1.2 dpkg-dev_1.16.1.2 e2fslibs_1.42-1 e2fsprogs_1.42-1 fakeroot_1.18.2-1 file_5.09-2 findutils_4.4.2-4 g++_4:4.6.2-4 g++-4.6_4.6.2-9 gcc_4:4.6.2-4 gcc-4.6_4.6.2-9 gcc-4.6-base_4.6.2-9 gettext_0.18.1.1-5 gettext-base_0.18.1.1-5 gnupg_1.4.11-3 gpgv_1.4.11-3 grep_2.10-1 groff-base_1.21-6 gzip_1.4-2 hostname_3.09 html2text_1.3.2a-15 initscripts_2.88dsf-18 insserv_1.14.0-2.1 install-info_4.13a.dfsg.1-8 intltool-debian_0.35.0+20060710.1 less_444-1 libaa1_1.4p5-39 libaa1-dev_1.4p5-39 libacl1_2.2.51-5 libasound2_1.0.24.1-4 libasound2-dev_1.0.24.1-4 libasyncns0_0.8-4 libattr1_1:2.4.46-5 libavahi-client-dev_0.6.30-6 libavahi-client3_0.6.30-6 libavahi-common-data_0.6.30-6 libavahi-common-dev_0.6.30-6 libavahi-common3_0.6.30-6 libblkid1_2.20.1-1.1 libbz2-1.0_1.0.6-1 libc-bin_2.13-24 libc-dev-bin_2.13-24 libc6_2.13-24 libc6-dev_2.13-24 libcaca-dev_0.99.beta17-2.1 libcaca0_0.99.beta17-2.1 libcap2_1:2.22-1 libclang-common-dev_3.0-5 libclass-isa-perl_0.36-3 libcomerr2_1.42-1 libcroco3_0.6.2-2 libdb5.1_5.1.29-1 libdbus-1-3_1.4.16-1 libdbus-1-dev_1.4.16-1 libdirectfb-1.2-9_1.2.10.0-4.3 libdirectfb-dev_1.2.10.0-4.3 libdirectfb-extra_1.2.10.0-4.3 libdpkg-perl_1.16.1.2 libdrm2_2.4.30-1 libffi5_3.0.10-3 libflac8_1.2.1-6 libfreetype6_2.4.8-1 libfreetype6-dev_2.4.8-1 libgc1c2_1:7.1-8 libgcc1_1:4.6.2-9 libgdbm3_1.8.3-10 libgl1-mesa-dev_7.11.2-1 libgl1-mesa-glx_7.11.2-1 libglapi-mesa_7.11.2-1 libglib2.0-0_2.30.2-4 libglib2.0-bin_2.30.2-4 libglib2.0-data_2.30.2-4 libglib2.0-dev_2.30.2-4 libglu1-mesa_7.11.2-1 libglu1-mesa-dev_7.11.2-1 libgmp10_2:5.0.2+dfsg-2 libgomp1_4.6.2-9 libgpm-dev_1.20.4-4 libgpm2_1.20.4-4 libgpmg1-dev_1.20.4-4 libice-dev_2:1.0.7-2 libice6_2:1.0.7-2 libjpeg8_8c-2 libjpeg8-dev_8c-2 libjson0_0.9-1 libllvm3.0_3.0-5 liblzma2_5.1.1alpha+20110809-2 liblzma5_5.1.1alpha+20110809-3 libmagic1_5.09-2 libmount1_2.20.1-1.1 libmpc2_0.9-4 libmpfr4_3.1.0-3 libncurses5_5.9-4 libncurses5-dev_5.9-4 libncursesw5_5.9-4 libogg0_1.2.2~dfsg-1 libpam-modules_1.1.3-6 libpam-modules-bin_1.1.3-6 libpam-runtime_1.1.3-6 libpam0g_1.1.3-6 libpcre3_8.12-4 libpipeline1_1.2.0-5 libpng12-0_1.2.46-4 libpng12-dev_1.2.46-4 libpopt0_1.16-3 libpthread-stubs0_0.3-3 libpthread-stubs0-dev_0.3-3 libpulse-dev_1.1-2 libpulse-mainloop-glib0_1.1-2 libpulse0_1.1-2 libquadmath0_4.6.2-9 libreadline6_6.2-8 libsdl1.2-dev_1.2.14-7 libsdl1.2debian_1.2.14-7 libselinux1_2.1.0-4 libsepol1_2.1.0-1.2 libslang2_2.2.4-5 libslang2-dev_2.2.4-5 libsm-dev_2:1.2.0-2 libsm6_2:1.2.0-2 libsndfile1_1.0.25-4 libss2_1.42-1 libstdc++6_4.6.2-9 libstdc++6-4.6-dev_4.6.2-9 libsvga1_1:1.4.3-31 libsvga1-dev_1:1.4.3-31 libswitch-perl_2.16-2 libsysfs-dev_2.1.0+repack-1 libsysfs2_2.1.0+repack-1 libtimedate-perl_1.2000-1 libtinfo-dev_5.9-4 libtinfo5_5.9-4 libts-0.0-0_1.0-9 libunistring0_0.9.3-5 libusb-0.1-4_2:0.1.12-20 libuuid1_2.20.1-1.1 libvorbis0a_1.3.2-1.1 libvorbisenc2_1.3.2-1.1 libwrap0_7.6.q-22 libx11-6_2:1.4.4-4 libx11-data_2:1.4.4-4 libx11-dev_2:1.4.4-4 libx11-xcb1_2:1.4.4-4 libx86-1_1.1+ds1-7 libxau-dev_1:1.0.6-4 libxau6_1:1.0.6-4 libxcb1_1.7-4 libxcb1-dev_1.7-4 libxdamage1_1:1.1.3-2 libxdmcp-dev_1:1.1.0-4 libxdmcp6_1:1.1.0-4 libxext-dev_2:1.3.0-3 libxext6_2:1.3.0-3 libxfixes3_1:5.0-4 libxi6_2:1.4.5-1 libxml2_2.7.8.dfsg-5.1 libxrandr2_2:1.3.2-2 libxrender1_1:0.9.6-2 libxt-dev_1:1.1.1-2 libxt6_1:1.1.1-2 libxtst6_2:1.2.0-4 libxxf86vm1_1:1.1.1-2 linux-libc-dev_3.1.8-2 login_1:4.1.4.2+svn3283-3 lsb-base_3.2-28 make_3.81-8.1 man-db_2.6.0.2-3 mawk_1.3.3-16 mesa-common-dev_7.11.2-1 mount_2.20.1-1.1 multiarch-support_2.13-24 nasm_2.09.10-1 ncurses-base_5.9-4 ncurses-bin_5.9-4 nvi_1.81.6-8.2 passwd_1:4.1.4.2+svn3283-3 patch_2.6.1-2 perl_5.14.2-6 perl-base_5.14.2-6 perl-modules_5.14.2-6 pkg-config_0.26-1 po-debconf_1.0.16+nmu2 readline-common_6.2-8 sbuild-build-depends-core-dummy_0.invalid.0 sbuild-build-depends-pearpc-dummy_0.invalid.0 sed_4.2.1-9 sensible-utils_0.0.6 sysv-rc_2.88dsf-18 sysvinit_2.88dsf-18 sysvinit-utils_2.88dsf-18 tar_1.26-4 tsconf_1.0-9 tzdata_2011n-2 util-linux_2.20.1-1.1 x11-common_1:7.6+10 x11proto-core-dev_7.0.22-1 x11proto-input-dev_2.1-1 x11proto-kb-dev_1.0.5-2 x11proto-xext-dev_7.2.0-3 xorg-sgml-doctools_1:1.10-1 xtrans-dev_1.2.6-2 xz-utils_5.1.1alpha+20110809-3 zlib1g_1:1.2.3.4.dfsg-3 zlib1g-dev_1:1.2.3.4.dfsg-3

┌──────────────────────────────────────────────────────────────────────────────┐
│ Build                                                                        │
└──────────────────────────────────────────────────────────────────────────────┘


Unpack source
─────────────

gpgv: keyblock resource `/var/lib/sbuild/.gnupg/trustedkeys.gpg': file open error
gpgv: Signature made Sat Dec 10 00:59:41 2011 CET using DSA key ID 7ADF9466
gpgv: Can't check signature: public key not found
dpkg-source: warning: failed to verify signature on ./pearpc_0.5.dfsg-2.dsc
dpkg-source: info: extracting pearpc in pearpc-0.5.dfsg
dpkg-source: info: unpacking pearpc_0.5.dfsg.orig.tar.bz2
dpkg-source: info: unpacking pearpc_0.5.dfsg-2.debian.tar.gz
dpkg-source: info: applying fix_ftbfs_with_newer_gcc.patch

Check disc space
────────────────

Sufficient free space for build

dpkg-buildpackage
─────────────────

dpkg-buildpackage: source package pearpc
dpkg-buildpackage: source version 0.5.dfsg-2
 dpkg-source --before-build pearpc-0.5.dfsg
dpkg-buildpackage: host architecture amd64
 fakeroot debian/rules clean
dh clean
   dh_testdir
   dh_auto_clean
   dh_clean
 dpkg-source -b pearpc-0.5.dfsg
dpkg-source: info: using source format `3.0 (quilt)'
dpkg-source: info: building pearpc using existing ./pearpc_0.5.dfsg.orig.tar.bz2
dpkg-source: info: building pearpc in pearpc_0.5.dfsg-2.debian.tar.gz
dpkg-source: info: building pearpc in pearpc_0.5.dfsg-2.dsc
 debian/rules build
dh build
   dh_testdir
   debian/rules override_dh_auto_configure
make[1]: Entering directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg'
dh_auto_configure -- --enable-ui=sdl --program-suffix=.real
configure: WARNING: unrecognized options: --disable-maintainer-mode
checking build system type... x86_64-pc-linux-gnu
checking host system type... x86_64-pc-linux-gnu
checking target system type... x86_64-pc-linux-gnu
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... no
checking for mawk... mawk
checking whether make sets $(MAKE)... yes
*** GNU, building POSIX version. we need pthread and rt.
*** x86_64 target system
checking for ranlib... ranlib
checking for gmake... no
checking for make... /usr/bin/make
checking whether /usr/bin/make sets $(MAKE)... yes
checking for gcc... gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for gcc option to accept ISO C89... none needed
checking for style of include used by /usr/bin/make... GNU
checking dependency style of gcc... none
checking for g++... g++
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts -g... yes
checking dependency style of g++... none
checking how to run the C preprocessor... gcc -E
checking dependency style of gcc... none
checking for flex... no
checking for lex... no
checking for bison... no
checking for byacc... no
checking for ar... /usr/bin/ar
checking for gar... (cached) /usr/bin/ar
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for clock_settime in -lrt... yes
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking whether byte ordering is bigendian... no
checking for sdl-config... /usr/bin/sdl-config
checking for SDL - version >= 1.2.0... yes
checking for gettimeofday... yes
checking for memset... yes
checking for setenv... yes
checking for log2... yes
checking for exp2... yes
checking for ANSI C header files... (cached) yes
checking pthread.h usability... yes
checking pthread.h presence... yes
checking for pthread.h... yes
checking sys/socket.h usability... yes
checking sys/socket.h presence... yes
checking for sys/socket.h... yes
checking asm/types.h usability... yes
checking asm/types.h presence... yes
checking for asm/types.h... yes
checking for stdint.h... (cached) yes
checking for asm/types.h... (cached) yes
checking for linux/netlink.h... yes
checking for an ANSI C-conforming const... yes
checking size of char... 1
checking size of short... 2
checking size of int... 4
checking size of long int... 8
checking size of long long... 8
configure: creating ./config.status
config.status: creating Makefile
config.status: creating doc/Makefile
config.status: creating scripts/Makefile
config.status: creating src/Makefile
config.status: creating src/cpu/Makefile
config.status: creating src/cpu/cpu_generic/Makefile
config.status: creating src/cpu/cpu_jitc_x86/Makefile
config.status: creating src/cpu/cpu_jitc_x86_64/Makefile
config.status: creating src/debug/Makefile
config.status: creating src/io/Makefile
config.status: creating src/io/3c90x/Makefile
config.status: creating src/io/ide/Makefile
config.status: creating src/io/graphic/Makefile
config.status: creating src/io/rtl8139/Makefile
config.status: creating src/io/prom/Makefile
config.status: creating src/io/prom/fs/Makefile
config.status: creating src/io/prom/fs/hfs/Makefile
config.status: creating src/io/prom/fs/hfsplus/Makefile
config.status: creating src/io/cuda/Makefile
config.status: creating src/io/pci/Makefile
config.status: creating src/io/pic/Makefile
config.status: creating src/io/macio/Makefile
config.status: creating src/io/nvram/Makefile
config.status: creating src/io/usb/Makefile
config.status: creating src/io/serial/Makefile
config.status: creating src/system/Makefile
config.status: creating src/system/arch/Makefile
config.status: creating src/system/arch/x86/Makefile
config.status: creating src/system/arch/x86_64/Makefile
config.status: creating src/system/arch/generic/Makefile
config.status: creating src/system/osapi/Makefile
config.status: creating src/system/osapi/beos/Makefile
config.status: creating src/system/osapi/posix/Makefile
config.status: creating src/system/osapi/win32/Makefile
config.status: creating src/system/ui/Makefile
config.status: creating src/system/ui/beos/Makefile
config.status: creating src/system/ui/gtk/Makefile
config.status: creating src/system/ui/qt/Makefile
config.status: creating src/system/ui/sdl/Makefile
config.status: creating src/system/ui/win32/Makefile
config.status: creating src/system/ui/x11/Makefile
config.status: creating src/tools/Makefile
config.status: creating config.h
config.status: executing depfiles commands
configure: WARNING: unrecognized options: --disable-maintainer-mode

./configure successful.

================================================================================
                             Configuration summary
================================================================================

cpu emulation method:                cpu_jitc_x86_64
compiled for architecture:           x86_64
compiled for OS-API:                 posix
compiled for UI system:              sdl
enable debug:                        yes
enable profiling:                    no
make release build:                  yes
omit frame pointer:                  yes
final C compiler flags:               -Wundef -Wall -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT
final C++ compiler flags:             -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT
final linker flags:                   -L/usr/lib/x86_64-linux-gnu -lSDL
final linker add:                     -lpthread -lrt -lrt -L/usr/lib/x86_64-linux-gnu -lSDL

================================================================================
make[1]: Leaving directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg'
   dh_auto_build
make[1]: Entering directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg'
/usr/bin/make  all-recursive
make[2]: Entering directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg'
Making all in doc
make[3]: Entering directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg/doc'
make[3]: Nothing to be done for `all'.
make[3]: Leaving directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg/doc'
Making all in src
make[3]: Entering directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg/src'
Making all in cpu
make[4]: Entering directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg/src/cpu'
Making all in cpu_jitc_x86_64
make[5]: Entering directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg/src/cpu/cpu_jitc_x86_64'
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_alu.o ppc_alu.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_cpu.o ppc_cpu.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_dec.o ppc_dec.cc
ppc_dec.cc:1120:15: warning: unused variable 'last_instr' [-Wunused-variable]
static uint32 last_instr = 0, instr_report = 0, instr_count = 0;
              ^
ppc_dec.cc:1120:31: warning: unused variable 'instr_report' [-Wunused-variable]
static uint32 last_instr = 0, instr_report = 0, instr_count = 0;
                              ^
ppc_dec.cc:1120:49: warning: unused variable 'instr_count' [-Wunused-variable]
static uint32 last_instr = 0, instr_report = 0, instr_count = 0;
                                                ^
3 warnings generated.
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_esc.o ppc_esc.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_exc.o ppc_exc.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_fpu.o ppc_fpu.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_mmu.o ppc_mmu.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_opc.o ppc_opc.cc
ppc_opc.cc:1191:15: warning: unused variable 'ppc_to_x86_roundmode' [-Wunused-variable]
static uint32 ppc_to_x86_roundmode[] = {
              ^
1 warning generated.
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o ppc_vec.o ppc_vec.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o jitc.o jitc.cc
g++ -DHAVE_CONFIG_H -I. -I../../.. -I ../..    -Wundef -Wall -Woverloaded-virtual -fsigned-char -O3 -fomit-frame-pointer -g -fno-inline -pthread -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -pipe -I/usr/include/SDL -D_GNU_SOURCE=1 -D_REENTRANT -c -o jitc_debug.o jitc_debug.cc
gcc -DHAVE_CONFIG_H -I. -I../../.. -I ../..     -c -o jitc_mmu.o jitc_mmu.S
jitc_mmu.S:280:17: warning: '/*' within block comment [-Wcomment]
/*      add     %rsp, 8;        /* hash1, no longer needed */                  \
                                ^
1 warning generated.
jitc_mmu.S:36:1: warning: ignoring directive for now
.intel_syntax prefix
^
./jitc_common.h:3:1: warning: ignoring directive for now
.struct 0 #PPC_CPU_State
^
./jitc_common.h:4:8: warning: ignoring directive for now
 jitc:;.struct jitc+8
       ^
./jitc_common.h:5:7: warning: ignoring directive for now
 gpr:;.struct gpr+32*4
      ^
./jitc_common.h:6:7: warning: ignoring directive for now
 fpr:;.struct fpr+32*8
      ^
./jitc_common.h:7:6: warning: ignoring directive for now
 cr:;.struct cr+4
     ^
./jitc_common.h:8:9: warning: ignoring directive for now
 fpscr:;.struct fpscr+4
        ^
./jitc_common.h:9:7: warning: ignoring directive for now
 xer:;.struct xer+4
      ^
./jitc_common.h:10:10: warning: ignoring directive for now
 xer_ca:;.struct xer_ca+4
         ^
./jitc_common.h:11:9: warning: ignoring directive for now
 ltreg:;.struct ltreg+4
        ^
./jitc_common.h:12:7: warning: ignoring directive for now
 ctr:;.struct ctr+4
      ^
./jitc_common.h:14:7: warning: ignoring directive for now
 msr:;.struct msr+4
      ^
./jitc_common.h:15:7: warning: ignoring directive for now
 pvr:;.struct pvr+4
      ^
./jitc_common.h:17:9: warning: ignoring directive for now
 ibatu:;.struct ibatu+4*4
        ^
./jitc_common.h:18:9: warning: ignoring directive for now
 ibatl:;.struct ibatl+4*4
        ^
./jitc_common.h:19:11: warning: ignoring directive for now
 ibat_bl:;.struct ibat_bl+4*4
          ^
./jitc_common.h:20:12: warning: ignoring directive for now
 ibat_nbl:;.struct ibat_nbl+4*4
           ^
./jitc_common.h:21:13: warning: ignoring directive for now
 ibat_bepi:;.struct ibat_bepi+4*4
            ^
./jitc_common.h:22:13: warning: ignoring directive for now
 ibat_brpn:;.struct ibat_brpn+4*4
            ^
./jitc_common.h:24:9: warning: ignoring directive for now
 dbatu:;.struct dbatu+4*4
        ^
./jitc_common.h:25:9: warning: ignoring directive for now
 dbatl:;.struct dbatl+4*4
        ^
./jitc_common.h:26:11: warning: ignoring directive for now
 dbat_bl:;.struct dbat_bl+4*4
          ^
./jitc_common.h:27:12: warning: ignoring directive for now
 dbat_nbl:;.struct dbat_nbl+4*4
           ^
./jitc_common.h:28:13: warning: ignoring directive for now
 dbat_bepi:;.struct dbat_bepi+4*4
            ^
./jitc_common.h:29:13: warning: ignoring directive for now
 dbat_brpn:;.struct dbat_brpn+4*4
            ^
./jitc_common.h:31:8: warning: ignoring directive for now
 sdr1:;.struct sdr1+4
       ^
./jitc_common.h:33:6: warning: ignoring directive for now
 sr:;.struct sr+16*4
     ^
./jitc_common.h:35:7: warning: ignoring directive for now
 dar:;.struct dar+4
      ^
./jitc_common.h:36:9: warning: ignoring directive for now
 dsisr:;.struct dsisr+4
        ^
./jitc_common.h:37:8: warning: ignoring directive for now
 sprg:;.struct sprg+4*4
       ^
./jitc_common.h:38:8: warning: ignoring directive for now
 srr0:;.struct srr0+4
       ^
./jitc_common.h:39:8: warning: ignoring directive for now
 srr1:;.struct srr1+4
       ^
./jitc_common.h:41:8: warning: ignoring directive for now
 decr:;.struct decr+4
       ^
./jitc_common.h:42:7: warning: ignoring directive for now
 ear:;.struct ear+4
      ^
./jitc_common.h:43:7: warning: ignoring directive for now
 pir:;.struct pir+4
      ^
./jitc_common.h:44:6: warning: ignoring directive for now
 tb:;.struct tb+8
     ^
./jitc_common.h:46:7: warning: ignoring directive for now
 hid:;.struct hid+16*4
      ^
./jitc_common.h:48:6: warning: ignoring directive for now
 pc:;.struct pc+4
     ^
./jitc_common.h:49:7: warning: ignoring directive for now
 npc:;.struct npc+4
      ^
./jitc_common.h:50:15: warning: ignoring directive for now
 current_opc:;.struct current_opc+4
              ^
./jitc_common.h:52:21: warning: ignoring directive for now
 exception_pending:;.struct exception_pending+1
                    ^
./jitc_common.h:53:17: warning: ignoring directive for now
 dec_exception:;.struct dec_exception+1
                ^
./jitc_common.h:54:17: warning: ignoring directive for now
 ext_exception:;.struct ext_exception+1
                ^
./jitc_common.h:55:18: warning: ignoring directive for now
 stop_exception:;.struct stop_exception+1
                 ^
./jitc_common.h:56:21: warning: ignoring directive for now
 singlestep_ignore:;.struct singlestep_ignore+1
                    ^
./jitc_common.h:57:10: warning: ignoring directive for now
 align1:;.struct align1+1
         ^
./jitc_common.h:58:10: warning: ignoring directive for now
 align2:;.struct align2+1
         ^
./jitc_common.h:59:10: warning: ignoring directive for now
 align3:;.struct align3+1
         ^
./jitc_common.h:61:18: warning: ignoring directive for now
 pagetable_base:;.struct pagetable_base+4
                 ^
./jitc_common.h:62:22: warning: ignoring directive for now
 pagetable_hashmask:;.struct pagetable_hashmask+4
                     ^
./jitc_common.h:63:11: warning: ignoring directive for now
 reserve:;.struct reserve+4
          ^
./jitc_common.h:64:20: warning: ignoring directive for now
 have_reservation:;.struct have_reservation+4
                   ^
./jitc_common.h:66:12: warning: ignoring directive for now
 tlb_last:;.struct tlb_last+4
           ^
./jitc_common.h:67:10: warning: ignoring directive for now
 tlb_pa:;.struct tlb_pa+4*4
         ^
./jitc_common.h:68:10: warning: ignoring directive for now
 tlb_va:;.struct tlb_va+4*4
         ^
./jitc_common.h:69:8: warning: ignoring directive for now
 pdec:;.struct pdec+8
       ^
./jitc_common.h:70:7: warning: ignoring directive for now
 ptb:;.struct ptb+8
      ^
./jitc_common.h:72:8: warning: ignoring directive for now
 temp:;.struct temp+4
       ^
./jitc_common.h:73:9: warning: ignoring directive for now
 temp2:;.struct temp2+4
        ^
./jitc_common.h:74:9: warning: ignoring directive for now
 x87cw:;.struct x87cw+4
        ^
./jitc_common.h:75:10: warning: ignoring directive for now
 pc_ofs:;.struct pc_ofs+4
         ^
./jitc_common.h:76:21: warning: ignoring directive for now
 current_code_base:;.struct current_code_base+4
                    ^
./jitc_common.h:78:18: warning: ignoring directive for now
 tlb_code_0_eff:;.struct tlb_code_0_eff+32*4
                 ^
./jitc_common.h:79:18: warning: ignoring directive for now
 tlb_data_0_eff:;.struct tlb_data_0_eff+32*4
                 ^
./jitc_common.h:80:18: warning: ignoring directive for now
 tlb_data_8_eff:;.struct tlb_data_8_eff+32*4
                 ^
./jitc_common.h:81:19: warning: ignoring directive for now
 tlb_code_0_phys:;.struct tlb_code_0_phys+32*4
                  ^
./jitc_common.h:82:19: warning: ignoring directive for now
 tlb_data_0_phys:;.struct tlb_data_0_phys+32*4
                  ^
./jitc_common.h:83:19: warning: ignoring directive for now
 tlb_data_8_phys:;.struct tlb_data_8_phys+32*4
                  ^
./jitc_common.h:85:1: warning: ignoring directive for now
.struct 0 #JITC
^
./jitc_common.h:86:15: warning: ignoring directive for now
 clientPages:;.struct clientPages+8
              ^
./jitc_common.h:88:1: warning: ignoring directive for now
.struct 0 #ClientPage
^
./jitc_common.h:89:15: warning: ignoring directive for now
 entrypoints:;.struct entrypoints+1024*8
              ^
./jitc_common.h:90:15: warning: ignoring directive for now
 tcf_current:;.struct tcf_current+8
              ^
./jitc_common.h:91:15: warning: ignoring directive for now
 baseaddress:;.struct baseaddress+4
              ^
./jitc_common.h:92:13: warning: ignoring directive for now
 bytesLeft:;.struct bytesLeft+4
            ^
./jitc_common.h:93:7: warning: ignoring directive for now
 tcp:;.struct tcp+8
      ^
./jitc_common.h:94:10: warning: ignoring directive for now
 moreRU:;.struct moreRU+8
         ^
./jitc_common.h:95:10: warning: ignoring directive for now
 lessRU:;.struct lessRU+8
         ^
jitc_mmu.S:122:2: error: unknown use of instruction mnemonic without a size suffix
 shr %eax, 12
 ^
jitc_mmu.S:124:7: error: unknown token in expression
 mov [%rdi+tlb_code_0_eff + %rax*4], %ecx
      ^
jitc_mmu.S:125:7: error: unknown token in expression
 mov [%rdi+tlb_data_0_eff + %rax*4], %ecx
      ^
jitc_mmu.S:126:7: error: unknown token in expression
 mov [%rdi+tlb_data_8_eff + %rax*4], %ecx
      ^
jitc_mmu.S:385:2: error: unknown use of instruction mnemonic without a size suffix
 shr %edx, 12
 ^
jitc_mmu.S:388:7: error: unknown token in expression
 mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx
      ^
jitc_mmu.S:389:12: error: unexpected token in argument list
 mov dword ptr [%rdi+tlb_code_0_phys + %rdx*4], 0
           ^
jitc_mmu.S:390:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:401:34: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_code_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_code_0_phys + %rdx*4]; clc; ret 8; 1:
                                 ^
jitc_mmu.S:401:98: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_code_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_code_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                 ^
jitc_mmu.S:401:148: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_code_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_code_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                   ^
jitc_mmu.S:401:185: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_code_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_code_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                                                        ^
jitc_mmu.S:403:12: error: unexpected token in argument list
 test byte ptr [%rdi+msr], (1<<5) # MSR_IR
           ^
jitc_mmu.S:406:13: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:406:45: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:406:117: error: unexpected token in argument list
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:406:171: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:406:269: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:406:301: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:406:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:406:391: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:406:489: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:406:531: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:406:573: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:406:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:406:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 0*4]; mov %ebx, [%rdi+ibat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 0*4]; or %eax, [%rdi+ibat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:407:13: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:407:45: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:407:117: error: unexpected token in argument list
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:407:171: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:407:269: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:407:301: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:407:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:407:391: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:407:489: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:407:531: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:407:573: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:407:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:407:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 1*4]; mov %ebx, [%rdi+ibat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 1*4]; or %eax, [%rdi+ibat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:408:13: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:408:45: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:408:117: error: unexpected token in argument list
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:408:171: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:408:269: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:408:301: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:408:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:408:391: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:408:489: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:408:531: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:408:573: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:408:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:408:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 2*4]; mov %ebx, [%rdi+ibat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 2*4]; or %eax, [%rdi+ibat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:409:13: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:409:45: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:409:117: error: unexpected token in argument list
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:409:171: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:409:269: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:409:301: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:409:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:409:391: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:409:489: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:409:531: error: unknown token in expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:409:573: error: expected absolute expression
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:409:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:409:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+ibat_bl + 3*4]; mov %ebx, [%rdi+ibat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+ibatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+ibat_nbl + 3*4]; or %eax, [%rdi+ibat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if code==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_code_0_eff + %rcx*4], %esi; mov [%rdi+tlb_code_0_phys + %rcx*4], %edx; .if code==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:412:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 28 # SR
 ^
jitc_mmu.S:413:13: error: unknown token in expression
 mov %edx, [%rdi+sr+4*%rbx]
            ^
jitc_mmu.S:423:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 12
 ^
jitc_mmu.S:426:2: error: unknown use of instruction mnemonic without a size suffix
 shr %r8d, 22
 ^
jitc_mmu.S:449:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:450:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:451:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:456:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:456:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:456:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:456:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:456:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:456:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:456:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:456:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:456:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:456:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:456:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:456:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:456:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:456:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:456:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:457:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:457:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:457:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:457:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:457:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:457:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:457:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:457:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:457:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:457:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:457:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:457:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:457:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:457:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:457:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:458:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:458:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:458:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:458:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:458:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:458:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:458:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:458:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:458:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:458:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:458:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:458:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:458:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:458:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:458:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:459:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:459:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:459:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:459:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:459:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:459:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:459:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:459:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:459:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:459:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:459:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:459:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:459:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:459:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:459:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:460:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:460:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:460:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:460:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:460:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:460:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:460:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:460:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:460:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:460:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:460:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:460:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:460:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:460:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:460:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:461:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:461:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:461:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:461:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:461:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:461:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:461:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:461:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:461:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:461:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:461:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:461:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:461:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:461:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:461:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:462:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:462:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:462:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:462:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:462:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:462:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:462:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:462:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:462:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:462:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:462:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:462:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:462:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:462:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:462:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:463:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:463:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:463:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:463:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:463:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:463:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:463:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:463:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:463:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:463:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:463:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:463:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:463:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:463:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:463:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:469:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:470:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:471:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:473:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:473:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:473:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:473:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:473:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:473:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:473:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:473:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:473:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:473:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:473:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:473:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:473:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:473:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:473:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:474:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:474:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:474:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:474:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:474:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:474:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:474:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:474:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:474:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:474:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:474:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:474:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:474:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:474:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:474:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:475:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:475:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:475:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:475:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:475:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:475:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:475:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:475:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:475:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:475:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:475:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:475:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:475:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:475:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:475:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:476:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:476:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:476:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:476:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:476:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:476:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:476:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:476:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:476:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:476:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:476:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:476:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:476:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:476:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:476:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:477:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:477:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:477:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:477:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:477:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:477:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:477:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:477:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:477:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:477:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:477:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:477:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:477:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:477:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:477:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:478:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:478:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:478:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:478:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:478:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:478:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:478:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:478:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:478:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:478:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:478:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:478:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:478:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:478:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:478:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:479:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:479:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:479:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:479:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:479:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:479:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:479:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:479:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:479:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:479:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:479:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:479:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:479:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:479:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:479:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:480:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:480:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:480:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:480:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:480:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:480:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:480:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:480:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:480:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:480:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:480:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:480:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:480:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:480:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:480:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_code; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if code==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_code_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_code_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if code==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:506:2: error: unknown use of instruction mnemonic without a size suffix
 shr %edx, 12
 ^
jitc_mmu.S:512:7: error: unknown token in expression
 mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx
      ^
jitc_mmu.S:513:12: error: unexpected token in argument list
 mov dword ptr [%rdi+tlb_data_0_phys + %rdx*4], %ebx
           ^
jitc_mmu.S:516:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:518:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:529:34: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_0_phys + %rdx*4]; clc; ret 8; 1:
                                 ^
jitc_mmu.S:529:98: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                 ^
jitc_mmu.S:529:148: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                   ^
jitc_mmu.S:529:185: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_0_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_0_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                                                        ^
jitc_mmu.S:531:12: error: unexpected token in argument list
 test byte ptr [%rdi+msr], (1<<4) # MSR_DR
           ^
jitc_mmu.S:534:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:534:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:534:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:534:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:534:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:534:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:534:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:534:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:534:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:534:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:534:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:534:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:534:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:535:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:535:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:535:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:535:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:535:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:535:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:535:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:535:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:535:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:535:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:535:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:535:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:535:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:536:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:536:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:536:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:536:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:536:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:536:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:536:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:536:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:536:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:536:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:536:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:536:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:536:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:537:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:537:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:537:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:537:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:537:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:537:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:537:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:537:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:537:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:537:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:537:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:537:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:537:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_0_eff + %rcx*4], %esi; mov [%rdi+tlb_data_0_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:540:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 28 # SR
 ^
jitc_mmu.S:541:13: error: unknown token in expression
 mov %edx, [%rdi+sr+4*%rbx]
            ^
jitc_mmu.S:548:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 12
 ^
jitc_mmu.S:551:2: error: unknown use of instruction mnemonic without a size suffix
 shr %r8d, 22
 ^
jitc_mmu.S:574:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:575:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:576:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:581:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:581:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:581:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:581:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:581:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:581:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:581:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:581:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:581:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:581:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:581:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:581:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:581:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:581:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:581:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:582:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:582:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:582:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:582:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:582:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:582:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:582:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:582:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:582:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:582:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:582:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:582:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:582:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:582:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:582:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:583:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:583:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:583:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:583:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:583:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:583:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:583:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:583:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:583:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:583:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:583:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:583:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:583:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:583:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:583:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:584:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:584:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:584:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:584:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:584:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:584:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:584:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:584:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:584:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:584:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:584:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:584:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:584:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:584:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:584:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:585:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:585:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:585:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:585:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:585:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:585:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:585:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:585:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:585:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:585:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:585:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:585:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:585:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:585:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:585:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:586:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:586:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:586:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:586:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:586:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:586:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:586:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:586:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:586:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:586:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:586:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:586:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:586:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:586:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:586:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:587:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:587:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:587:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:587:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:587:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:587:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:587:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:587:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:587:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:587:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:587:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:587:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:587:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:587:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:587:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:588:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:588:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:588:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:588:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:588:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:588:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:588:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:588:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:588:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:588:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:588:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:588:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:588:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:588:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:588:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:594:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:595:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:596:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:598:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:598:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:598:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:598:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:598:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:598:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:598:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:598:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:598:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:598:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:598:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:598:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:598:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:598:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:598:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:599:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:599:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:599:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:599:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:599:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:599:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:599:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:599:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:599:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:599:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:599:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:599:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:599:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:599:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:599:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:600:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:600:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:600:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:600:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:600:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:600:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:600:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:600:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:600:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:600:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:600:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:600:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:600:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:600:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:600:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:601:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:601:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:601:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:601:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:601:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:601:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:601:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:601:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:601:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:601:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:601:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:601:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:601:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:601:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:601:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:602:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:602:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:602:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:602:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:602:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:602:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:602:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:602:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:602:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:602:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:602:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:602:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:602:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:602:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:602:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:603:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:603:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:603:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:603:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:603:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:603:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:603:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:603:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:603:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:603:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:603:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:603:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:603:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:603:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:603:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:604:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:604:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:604:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:604:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:604:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:604:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:604:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:604:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:604:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:604:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:604:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:604:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:604:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:604:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:604:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:605:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:605:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:605:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:605:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:605:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:605:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:605:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:605:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:605:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:605:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:605:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:605:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:605:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:605:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:605:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (0) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_0_data; mov %edx, %esi; .if 0==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_0_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_0_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:622:2: error: unknown use of instruction mnemonic without a size suffix
 shr %edx, 12
 ^
jitc_mmu.S:628:7: error: unknown token in expression
 mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx
      ^
jitc_mmu.S:629:12: error: unexpected token in argument list
 mov dword ptr [%rdi+tlb_data_8_phys + %rdx*4], %ebx
           ^
jitc_mmu.S:632:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:634:2: error: unknown use of instruction mnemonic without a size suffix
 ret 8
 ^
jitc_mmu.S:645:34: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_8_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_8_phys + %rdx*4]; clc; ret 8; 1:
                                 ^
jitc_mmu.S:645:98: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_8_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_8_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                 ^
jitc_mmu.S:645:148: error: unknown token in expression
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_8_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_8_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                   ^
jitc_mmu.S:645:185: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; cmp %ecx, [%rdi+tlb_data_8_eff + %rdx*4]; jne 1f; add %eax, [%rdi+tlb_data_8_phys + %rdx*4]; clc; ret 8; 1:
                                                                                                                                                                                        ^
jitc_mmu.S:647:12: error: unexpected token in argument list
 test byte ptr [%rdi+msr], (1<<4) # MSR_DR
           ^
jitc_mmu.S:650:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:650:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:650:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:650:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:650:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:650:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:650:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:650:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:650:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:650:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:650:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:650:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:650:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 0*4]; mov %ebx, [%rdi+dbat_bepi + 0*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 0*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 0*4]; or %eax, [%rdi+dbat_brpn + 0*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:651:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:651:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:651:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:651:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:651:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:651:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:651:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:651:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:651:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:651:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:651:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:651:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:651:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 1*4]; mov %ebx, [%rdi+dbat_bepi + 1*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 1*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 1*4]; or %eax, [%rdi+dbat_brpn + 1*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:652:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:652:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:652:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:652:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:652:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:652:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:652:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:652:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:652:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:652:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:652:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:652:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:652:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 2*4]; mov %ebx, [%rdi+dbat_bepi + 2*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 2*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 2*4]; or %eax, [%rdi+dbat_brpn + 2*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:653:13: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
            ^
jitc_mmu.S:653:45: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                            ^
jitc_mmu.S:653:117: error: unexpected token in argument list
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                    ^
jitc_mmu.S:653:171: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                          ^
jitc_mmu.S:653:269: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:653:301: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:653:324: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:653:391: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:653:489: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:653:531: error: unknown token in expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:653:573: error: expected absolute expression
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:653:611: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:653:752: error: unknown use of instruction mnemonic without a size suffix
 mov %edx, [%rdi+dbat_bl + 3*4]; mov %ebx, [%rdi+dbat_bepi + 3*4]; and %edx, %eax; cmp %ebx, %edx; jne 3f; bt dword ptr [%rdi+msr], 14; mov %r12d, 2; sbb %r12d, 0; test [%rdi+dbatu + 3*4], %r12d; jz 3f; mov %esi, %eax; mov %ecx, %eax; mov %edx, 0xfffff000; and %eax, [%rdi+dbat_nbl + 3*4]; or %eax, [%rdi+dbat_brpn + 3*4]; shr %ecx, 12; and %esi, %edx; and %edx, %eax; and %ecx, 32 -1; .if data==data; cmp %edx, [gMemorySize]; ja 4f; add %edx, [gMemory]; 6:; .endif; sub %edx, %esi; mov [%rdi+tlb_data_8_eff + %rcx*4], %esi; mov [%rdi+tlb_data_8_phys + %rcx*4], %edx; .if data==data; add %eax, [gMemory]; clc; ret 8; 4: cmp %edx, 0x84000000; jmp 5f; cmp %edx, 0x85000000; ja 5f; sub %edx, 0x84000000; add %edx, [gFrameBuffer]; jmp 6b; 5: stc; .endif; ret 8; 3:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:656:2: error: unknown use of instruction mnemonic without a size suffix
 shr %eax, 28 # SR
 ^
jitc_mmu.S:657:13: error: unknown token in expression
 mov %edx, [%rdi+sr+4*%rax]
            ^
jitc_mmu.S:665:2: error: unknown use of instruction mnemonic without a size suffix
 shr %ebx, 12
 ^
jitc_mmu.S:667:2: error: unknown use of instruction mnemonic without a size suffix
 shr %r8d, 22
 ^
jitc_mmu.S:690:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:691:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:692:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:697:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:697:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:697:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:697:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:697:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:697:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:697:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:697:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:697:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:697:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:697:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:697:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:697:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:697:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:697:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:698:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:698:157: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                            ^
jitc_mmu.S:698:287: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:698:332: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:698:386: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:698:435: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:698:484: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:698:724: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:698:796: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:698:885: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:698:967: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:698:1009: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:698:1068: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:698:1079: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:698:1257: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:699:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:699:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:699:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:699:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:699:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:699:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:699:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:699:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:699:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:699:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:699:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:699:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:699:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:699:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:699:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:700:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:700:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:700:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:700:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:700:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:700:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:700:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:700:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:700:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:700:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:700:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:700:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:700:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:700:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:700:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:701:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:701:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:701:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:701:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:701:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:701:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:701:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:701:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:701:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:701:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:701:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:701:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:701:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:701:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:701:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:702:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:702:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:702:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:702:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:702:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:702:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:702:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:702:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:702:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:702:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:702:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:702:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:702:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:702:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:702:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:703:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:703:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:703:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:703:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:703:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:703:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:703:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:703:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:703:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:703:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:703:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:703:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:703:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:703:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:703:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:704:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:704:158: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                             ^
jitc_mmu.S:704:288: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:704:334: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:704:388: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:704:437: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:704:486: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:704:726: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:704:799: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:704:888: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:704:970: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:704:1012: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
jitc_mmu.S:704:1071: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:704:1082: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:704:1260: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (0) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 0==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:708:13: error: unknown token in expression
 mov %ebx, [%rsp]
            ^
jitc_mmu.S:711:13: error: unknown token in expression
 and %ebx, [%rdi+pagetable_hashmask]
            ^
jitc_mmu.S:712:2: error: unknown use of instruction mnemonic without a size suffix
 shl %ebx, 6
 ^
jitc_mmu.S:713:12: error: unknown token in expression
 or %ebx, [%rdi+pagetable_base]
           ^
jitc_mmu.S:715:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:715:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:715:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:715:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:715:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:715:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:715:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:715:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:715:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:715:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:715:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:715:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:715:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:715:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:715:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 0]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 0]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +0], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:716:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:716:160: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                               ^
jitc_mmu.S:716:290: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:716:335: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:716:389: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:716:438: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
jitc_mmu.S:716:487: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:716:730: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:716:802: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:716:891: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
jitc_mmu.S:716:973: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:716:1015: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:716:1074: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:716:1085: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^
jitc_mmu.S:716:1263: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 8]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 8]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +8], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
jitc_mmu.S:717:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:717:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:717:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:717:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:717:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:717:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:717:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:717:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:717:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:717:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:717:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:717:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:717:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:717:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:717:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 16]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 16]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +16], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:718:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:718:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:718:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:718:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:718:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:718:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:718:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:718:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:718:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:718:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:718:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:718:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:718:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:718:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:718:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 24]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 24]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +24], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:719:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:719:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:719:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:719:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:719:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:719:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:719:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:719:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:719:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:719:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:719:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:719:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:719:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:719:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:719:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 32]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 32]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +32], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:720:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:720:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:720:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:720:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:720:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:720:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:720:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:720:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:720:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:720:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:720:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:720:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:720:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:720:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:720:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 40]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 40]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +40], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:721:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:721:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:721:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:721:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:721:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:721:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:721:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:721:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:721:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:721:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:721:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:721:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:721:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:721:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:721:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 48]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 48]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +48], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
jitc_mmu.S:722:34: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                 ^
jitc_mmu.S:722:161: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                ^
jitc_mmu.S:722:291: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                  ^
jitc_mmu.S:722:337: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                ^
jitc_mmu.S:722:391: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                      ^
jitc_mmu.S:722:440: error: invalid operand for instruction
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
jitc_mmu.S:722:489: error: unexpected token in argument list
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
jitc_mmu.S:722:732: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
jitc_mmu.S:722:805: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:722:894: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
jitc_mmu.S:722:976: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:722:1018: error: unknown token in expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
jitc_mmu.S:722:1077: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
jitc_mmu.S:722:1088: error: expected absolute expression
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^
jitc_mmu.S:722:1266: error: unknown use of instruction mnemonic without a size suffix
 mov %rax, [gMemory]; mov %eax, [%rax + %rbx + 56]; bswap %eax; mov %ecx, %eax; and %eax, (1<<6) | (1<<31); cmp %eax, (1<<6) | (1<<31); jne 1f; mov %eax, %ecx; shr %ecx, 7; and %ecx, 0xffffff; cmp %ecx, %r12d; jne 1f; and %eax, 0x3f; cmp %eax, %r8d; jne 1f; mov %rsi, [gMemory]; mov %esi, [%rsi + %rbx + 4 + 56]; bswap %esi; test dword ptr [%rdi+msr], (1<<14); mov %eax, (1<<29); setz %cl; shl %eax, %cl; test %edx, %eax; setnz %al; movzx %eax, %al; mov %ecx, %esi; and %ecx, 3; cmp byte ptr [ppc_pte_protection + (8) + 4*%rax + %rcx], 1; .if 1<<6==0; pop %rdx; .endif; pop %rax; jne protection_fault_8_data; mov %edx, %esi; .if 8==0; or %edx, (1<<8); .else; or %edx, (1<<8) | (1<<7); .endif; bswap %edx; add %rbx, [gMemory]; mov [%rbx+4 +56], %edx; and %esi, 0xfffff000; mov %edx, %eax; mov %ecx, %eax; shr %edx, 12; and %ecx, 0xfffff000; and %edx, 32 -1; mov %ebx, %esi; sub %esi, %ecx; .if data==data; cmp %ebx, [gMemorySize]; ja 4f; add %esi, [gMemory]; 6:; .endif; mov [%rdi+tlb_data_8_eff + %rdx*4], %ecx; mov [%rdi+tlb_data_8_phys + %rdx*4], %esi; add %eax, %esi; clc; ret 8; .if data==data; 4: cmp %ebx, 0x84000000; jmp 5f; cmp %ebx, 0x85000000; ja 5f; call damageframebuffer; add %esi, [gFrameBuffer]; sub %esi, 0x84000000; jmp 6b; 5: add %eax, %esi; stc; ret 8; .endif; 1:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:746:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:746:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:753:7: error: unknown token in expression
 mov [%rax], %dl
      ^
jitc_mmu.S:757:8: error: invalid operand for instruction
 movzx %esi, %dl
       ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:772:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:772:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:783:7: error: unknown token in expression
 mov [%rax], %dh
      ^
jitc_mmu.S:784:7: error: unknown token in expression
 mov [%rax+1], %dl
      ^
jitc_mmu.S:787:2: error: unknown use of instruction mnemonic without a size suffix
 rol %dx, 8
 ^
jitc_mmu.S:789:8: error: invalid operand for instruction
 movzx %esi, %dx
       ^
jitc_mmu.S:798:13: error: unknown token in expression
 mov %edx, [%rsp+8]
            ^
jitc_mmu.S:800:7: error: unknown token in expression
 mov [%rax], %dh
      ^
jitc_mmu.S:808:7: error: unknown token in expression
 mov [%rax], %dl
      ^
jitc_mmu.S:812:8: error: invalid operand for instruction
 movzx %esi, %dh
       ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
jitc_mmu.S:816:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:819:8: error: invalid operand for instruction
 movzx %esi, %dl
       ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:835:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:835:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:848:7: error: unknown token in expression
 mov [%rax], %edx
      ^
jitc_mmu.S:862:13: error: unknown token in expression
 mov %edx, [%rsp+8]
            ^
jitc_mmu.S:863:13: error: unknown token in expression
 mov %ebx, [%rsp]
            ^
jitc_mmu.S:869:3: error: unknown use of instruction mnemonic without a size suffix
  rol %edx, 8
  ^
jitc_mmu.S:870:8: error: unknown token in expression
  mov [%rax], %dl
       ^
jitc_mmu.S:875:7: error: unknown token in expression
 mov [%rsp+8], %edx
      ^
jitc_mmu.S:876:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:887:3: error: unknown use of instruction mnemonic without a size suffix
  rol %edx, 8
  ^
jitc_mmu.S:888:8: error: unknown token in expression
  mov [%rax], %dl
       ^
jitc_mmu.S:898:3: error: unknown use of instruction mnemonic without a size suffix
  rol %edx, 8
  ^
jitc_mmu.S:902:9: error: invalid operand for instruction
  movzx %esi, %dl
        ^
jitc_mmu.S:918:3: error: unknown use of instruction mnemonic without a size suffix
  rol %edx, 8
  ^
jitc_mmu.S:922:9: error: invalid operand for instruction
  movzx %esi, %dl
        ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:942:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:942:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:955:7: error: unknown token in expression
 mov [%rax], %rdx
      ^
jitc_mmu.S:967:13: error: unknown token in expression
 mov %rdx, [%rsp+8]
            ^
jitc_mmu.S:968:13: error: unknown token in expression
 mov %ebx, [%rsp]
            ^
jitc_mmu.S:974:3: error: unknown use of instruction mnemonic without a size suffix
  rol %rdx, 8
  ^
jitc_mmu.S:975:8: error: unknown token in expression
  mov [%rax], %dl
       ^
jitc_mmu.S:980:7: error: unknown token in expression
 mov [%rsp+8], %rdx
      ^
jitc_mmu.S:981:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:992:3: error: unknown use of instruction mnemonic without a size suffix
  rol %rdx, 8
  ^
jitc_mmu.S:993:8: error: unknown token in expression
  mov [%rax], %dl
       ^
jitc_mmu.S:1003:3: error: unknown use of instruction mnemonic without a size suffix
  rol %rdx, 8
  ^
jitc_mmu.S:1007:9: error: invalid operand for instruction
  movzx %esi, %dl
        ^
jitc_mmu.S:1023:3: error: unknown use of instruction mnemonic without a size suffix
  rol %rdx, 8
  ^
jitc_mmu.S:1027:9: error: invalid operand for instruction
  movzx %esi, %dl
        ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1048:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1048:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1057:13: error: unknown token in expression
 mov %rbx, [%rdx]
            ^
jitc_mmu.S:1058:13: error: unknown token in expression
 mov %rsi, [%rdx+8]
            ^
jitc_mmu.S:1063:7: error: unknown token in expression
 mov [%rax+8], %rbx
      ^
jitc_mmu.S:1064:7: error: unknown token in expression
 mov [%rax], %rsi
      ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1072:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1072:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1081:10: error: unknown token in expression
 movaps [%rax], %xmm0
         ^
jitc_mmu.S:1084:10: error: unknown token in expression
 movaps [%rdx], %xmm0
         ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1101:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1101:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1106:19: error: unexpected token in argument list
 movzx %edx, byte ptr [%rax]
                  ^
jitc_mmu.S:1112:8: error: invalid operand for instruction
 movzx %edx, %al
       ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1127:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1127:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1136:19: error: unexpected token in argument list
 movzx %edx, word ptr [%rax]
                  ^
jitc_mmu.S:1137:2: error: unknown use of instruction mnemonic without a size suffix
 rol %dx, 8
 ^
jitc_mmu.S:1143:2: error: unknown use of instruction mnemonic without a size suffix
 rol %ax, 8
 ^
jitc_mmu.S:1144:8: error: invalid operand for instruction
 movzx %edx, %ax
       ^
jitc_mmu.S:1153:12: error: unknown token in expression
 mov %dh, [%rax]
           ^
jitc_mmu.S:1155:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:1156:7: error: unknown token in expression
 mov [%rsp], %edx
      ^
jitc_mmu.S:1162:12: error: unknown token in expression
 mov %dl, [%rax]
           ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1195:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1195:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1204:12: error: unknown token in expression
 mov %cx, [%rax]
           ^
jitc_mmu.S:1205:2: error: unknown use of instruction mnemonic without a size suffix
 rol %cx, 8
 ^
jitc_mmu.S:1206:14: error: invalid operand for instruction
 movsx %edx, %cx
             ^
jitc_mmu.S:1212:2: error: unknown use of instruction mnemonic without a size suffix
 rol %ax, 8
 ^
jitc_mmu.S:1213:14: error: invalid operand for instruction
 movsx %edx, %ax
             ^
jitc_mmu.S:1222:12: error: unknown token in expression
 mov %ch, [%rax]
           ^
jitc_mmu.S:1224:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:1225:7: error: unknown token in expression
 mov [%rsp], %ecx
      ^
jitc_mmu.S:1231:12: error: unknown token in expression
 mov %cl, [%rax]
           ^
jitc_mmu.S:1232:14: error: invalid operand for instruction
 movsx %edx, %cx
             ^
jitc_mmu.S:1251:14: error: invalid operand for instruction
 movsx %edx, %cx
             ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1266:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1266:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1275:13: error: unknown token in expression
 mov %edx, [%rax]
            ^
jitc_mmu.S:1295:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1296:13: error: unknown token in expression
  mov %dl, [%rax]
            ^
jitc_mmu.S:1301:13: error: unknown token in expression
 mov %eax, [%rsp]
            ^
jitc_mmu.S:1302:7: error: unknown token in expression
 mov [%rsp], %edx
      ^
jitc_mmu.S:1313:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1314:13: error: unknown token in expression
  mov %dl, [%rax]
            ^
jitc_mmu.S:1324:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1343:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1368:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1368:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1377:13: error: unknown token in expression
 mov %rdx, [%rax]
            ^
jitc_mmu.S:1397:3: error: unknown use of instruction mnemonic without a size suffix
  shl %rdx, 8
  ^
jitc_mmu.S:1398:13: error: unknown token in expression
  mov %dl, [%rax]
            ^
jitc_mmu.S:1415:3: error: unknown use of instruction mnemonic without a size suffix
  shl %rdx, 8
  ^
jitc_mmu.S:1416:13: error: unknown token in expression
  mov %dl, [%rax]
            ^
jitc_mmu.S:1426:3: error: unknown use of instruction mnemonic without a size suffix
  shl %rdx, 8
  ^
jitc_mmu.S:1443:3: error: unknown use of instruction mnemonic without a size suffix
  shl %rdx, 8
  ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1468:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1468:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1477:13: error: unknown token in expression
 mov %rbx, [%rax]
            ^
jitc_mmu.S:1478:13: error: unknown token in expression
 mov %rsi, [%rax+8]
            ^
jitc_mmu.S:1483:7: error: unknown token in expression
 mov [%rdx+8], %rbx
      ^
jitc_mmu.S:1484:7: error: unknown token in expression
 mov [%rdx], %rsi
      ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1492:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1492:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1501:17: error: unknown token in expression
 movaps %xmm0, [%rax]
                ^
jitc_mmu.S:1503:13: error: unknown token in expression
 mov %rbx, [%rax]
            ^
jitc_mmu.S:1504:13: error: unknown token in expression
 mov %rsi, [%rax+8]
            ^
jitc_mmu.S:1509:7: error: unknown token in expression
 mov [%rdx+8], %rbx
      ^
jitc_mmu.S:1510:7: error: unknown token in expression
 mov [%rdx], %rsi
      ^
jitc_mmu.S:1520:17: error: unknown token in expression
 movaps %xmm0, [%rdx]
                ^
jitc_mmu.S:1522:13: error: unknown token in expression
 mov %rax, [%rdx]
            ^
jitc_mmu.S:1523:13: error: unknown token in expression
 mov %rsi, [%rdx+8]
            ^
jitc_mmu.S:1528:7: error: unknown token in expression
 mov [%rdx+8], %rsi
      ^
jitc_mmu.S:1529:7: error: unknown token in expression
 mov [%rdx], %rax
      ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1544:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1544:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1550:15: error: unknown token in expression
   mov %edx, [%rdi+gpr+4*%rbx]
              ^
jitc_mmu.S:1566:3: error: unknown use of instruction mnemonic without a size suffix
  shr %ecx, 24
  ^
jitc_mmu.S:1567:8: error: unknown token in expression
  mov [%rax], %cl
       ^
jitc_mmu.S:1574:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1583:2: error: unknown use of instruction mnemonic without a size suffix
 shr %edx, 24
 ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1601:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1601:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1606:9: error: unknown token in expression
   mov [%rdi+gpr+4*%rbx], %edx
        ^
jitc_mmu.S:1623:3: error: unknown use of instruction mnemonic without a size suffix
  shl %edx, 8
  ^
jitc_mmu.S:1624:17: error: unexpected token in argument list
  mov %dl, byte ptr [%rax]
                ^
jitc_mmu.S:1640:4: error: unknown use of instruction mnemonic without a size suffix
   shl %edx, 8
   ^
jitc_mmu.S:1645:7: error: unknown token in expression
 mov [%rdi+gpr+4*%rbx], %edx
      ^
jitc_mmu.S:1654:2: error: unknown use of instruction mnemonic without a size suffix
 shl %edx, 8
 ^
<instantiation>:1:12: error: unknown token in expression
lea %rdi, [%rsp+(8 +8*1)]
           ^
<instantiation>:5:2: note: while in macro instantiation
 getCurCPU 1
 ^
jitc_mmu.S:1664:2: note: while in macro instantiation
 mmu_prologue
 ^
<instantiation>:6:7: error: unknown token in expression
 mov [%rdi+pc_ofs], %esi
      ^
jitc_mmu.S:1664:2: note: while in macro instantiation
 mmu_prologue
 ^
jitc_mmu.S:1672:13: error: unknown token in expression
 mov %rdi, [%rdi+jitc]
            ^
jitc_mmu.S:1673:13: error: unknown token in expression
 mov %rcx, [%rdi+clientPages]
            ^
jitc_mmu.S:1674:2: error: unknown use of instruction mnemonic without a size suffix
 shr %eax, 12
 ^
jitc_mmu.S:1675:12: error: unexpected token in argument list
 cmp qword ptr [%rcx+%rax*8], 0
           ^
jitc_mmu.S:1681:13: error: unknown token in expression
 mov %rsi, [%rcx+%rax*8]
            ^
make[5]: *** [jitc_mmu.o] Error 1
make[5]: Leaving directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg/src/cpu/cpu_jitc_x86_64'
make[4]: *** [all-recursive] Error 1
make[4]: Leaving directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg/src/cpu'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg/src'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg'
make[1]: *** [all] Error 2
make[1]: Leaving directory `/build/pearpc-OoHa2E/pearpc-0.5.dfsg'
dh_auto_build: make -j1 returned exit code 2
make: *** [build] Error 2
dpkg-buildpackage: error: debian/rules build gave error exit status 2
────────────────────────────────────────────────────────────────────────────────
Build finished at 20120113-0206

Finished
────────

E: Build failure (dpkg-buildpackage died)

┌──────────────────────────────────────────────────────────────────────────────┐
│ Cleanup                                                                      │
└──────────────────────────────────────────────────────────────────────────────┘

Purging /var/lib/schroot/mount/lsid64b-61f62d1d-09a0-4b72-b85e-920c858fe189/build/pearpc-OoHa2E
Not cleaning session: cloned chroot in use

┌──────────────────────────────────────────────────────────────────────────────┐
│ Summary                                                                      │
└──────────────────────────────────────────────────────────────────────────────┘

Architecture: amd64
Build-Space: 8380
Build-Time: 12
Distribution: lsid64b
Fail-Stage: build
Install-Time: 10
Job: pearpc_0.5.dfsg-2
Package: pearpc
Package-Time: 35
Source-Version: 0.5.dfsg-2
Space: 8380
Status: attempted
Version: 0.5.dfsg-2
────────────────────────────────────────────────────────────────────────────────
Finished at 20120113-0206
Build needed 00:00:35, 8380k disc space
DC-Build-Status: Failed 347.045399s
### Content of /var/log/daemon.log ###
Jan 12 21:02:50 stremi-32 approx: Concurrent download of debian/dists/sid/Release.gpg is taking too long
Jan 12 21:03:05 stremi-32 approx: Concurrent download of debian/dists/sid/Release.gpg is taking too long
Jan 12 21:03:57 stremi-32 approx: Concurrent download of debian/dists/sid/main/i18n/Index is taking too long
Jan 12 21:04:10 stremi-32 approx: Concurrent download of debian/dists/sid/Release.gpg is taking too long
Jan 12 21:04:21 stremi-32 approx: Concurrent download of debian/dists/sid/Release.gpg is taking too long
Jan 12 21:04:32 stremi-32 approx: Concurrent download of debian/dists/sid/Release.gpg is taking too long
Jan 12 21:04:48 stremi-32 approx: Concurrent download of debian/dists/sid/Release.gpg is taking too long
Jan 12 21:05:20 stremi-32 approx: Concurrent download of debian/dists/sid/Release is taking too long
Jan 12 21:05:33 stremi-32 approx: Concurrent download of debian/dists/sid/main/i18n/Index is taking too long
### End of content of /var/log/daemon.log ###
DC-Time-Estimation: 347.045399 versus expected 49 (r/m: 6.08255916326531 ; m: 49.0)
DC-Build-Network: USED. See /tmp/rulesafter.gWTF6s !
************************************************************
# Generated by iptables-save v1.4.8 on Fri Jan 13 02:06:06 2012
*filter
:INPUT ACCEPT [3310781:17421722043]
:FORWARD ACCEPT [0:0]
:OUTPUT DROP [0:0]
:LD - [0:0]
[1285408:14440495234] -A OUTPUT -o lo -j ACCEPT 
[0:0] -A OUTPUT -d 129.88.0.0/16 -j ACCEPT 
[0:0] -A OUTPUT -d 10.0.0.0/8 -j ACCEPT 
[0:0] -A OUTPUT -d 192.168.133.0/24 -j ACCEPT 
[0:0] -A OUTPUT -d 192.168.159.0/24 -j ACCEPT 
[0:0] -A OUTPUT -d 192.168.160.0/24 -j ACCEPT 
[0:0] -A OUTPUT -d 10.69.0.0/17 -j ACCEPT 
[0:0] -A OUTPUT -d 172.28.52.0/22 -j ACCEPT 
[0:0] -A OUTPUT -d 172.24.0.0/16 -j ACCEPT 
[0:0] -A OUTPUT -d 131.254.202.0/23 -j ACCEPT 
[0:0] -A OUTPUT -d 138.96.20.0/22 -j ACCEPT 
[0:0] -A OUTPUT -d 192.168.22.0/24 -j ACCEPT 
[290684:88222746] -A OUTPUT -d 172.16.0.0/16 -j ACCEPT 
[0:0] -A OUTPUT -d 192.168.67.0/24 -j ACCEPT 
[36863:4887036] -A OUTPUT -d 224.0.0.0/4 -p udp -j ACCEPT 
[232:13920] -A OUTPUT -j LD 
[232:13920] -A LD -j LOG 
[232:13920] -A LD -j REJECT --reject-with icmp-port-unreachable 
COMMIT
# Completed on Fri Jan 13 02:06:06 2012
************************************************************
--- /tmp/rulesbefore.LkxBUo	2012-01-13 02:00:19.937174554 +0100
+++ /tmp/rulesafter.gWTF6s	2012-01-13 02:06:06.990007283 +0100
@@ -1,10 +1,10 @@
-# Generated by iptables-save v1.4.8 on Fri Jan 13 02:00:19 2012
+# Generated by iptables-save v1.4.8 on Fri Jan 13 02:06:06 2012
 *filter
-:INPUT ACCEPT [3138348:15814164000]
+:INPUT ACCEPT [3310781:17421722043]
 :FORWARD ACCEPT [0:0]
 :OUTPUT DROP [0:0]
 :LD - [0:0]
-[1163817:12920395455] -A OUTPUT -o lo -j ACCEPT 
+[1285408:14440495234] -A OUTPUT -o lo -j ACCEPT 
 [0:0] -A OUTPUT -d 129.88.0.0/16 -j ACCEPT 
 [0:0] -A OUTPUT -d 10.0.0.0/8 -j ACCEPT 
 [0:0] -A OUTPUT -d 192.168.133.0/24 -j ACCEPT 
@@ -16,11 +16,11 @@
 [0:0] -A OUTPUT -d 131.254.202.0/23 -j ACCEPT 
 [0:0] -A OUTPUT -d 138.96.20.0/22 -j ACCEPT 
 [0:0] -A OUTPUT -d 192.168.22.0/24 -j ACCEPT 
-[276699:83618056] -A OUTPUT -d 172.16.0.0/16 -j ACCEPT 
+[290684:88222746] -A OUTPUT -d 172.16.0.0/16 -j ACCEPT 
 [0:0] -A OUTPUT -d 192.168.67.0/24 -j ACCEPT 
-[36045:4780080] -A OUTPUT -d 224.0.0.0/4 -p udp -j ACCEPT 
+[36863:4887036] -A OUTPUT -d 224.0.0.0/4 -p udp -j ACCEPT 
 [232:13920] -A OUTPUT -j LD 
 [232:13920] -A LD -j LOG 
 [232:13920] -A LD -j REJECT --reject-with icmp-port-unreachable 
 COMMIT
-# Completed on Fri Jan 13 02:00:19 2012
+# Completed on Fri Jan 13 02:06:06 2012
************************************************************
[10446.003401]  [<ffffffff812feb96>] ? do_page_fault+0x2e0/0x2fc
[10446.009879]  [<ffffffff812fca35>] ? page_fault+0x25/0x30
[10446.015871] INFO: task bash:12582 blocked for more than 120 seconds.
[10446.023027] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
[10446.031863] bash          D 0000000000000000     0 12582   9752 0x00000000
[10446.039637]  ffff88033e561c40 0000000000000082 0000000000000000 ffff88064ac15780
[10446.048044]  ffff88033e582a60 ffffffff812fb320 000000000000f9e0 ffff8808a1e45fd8
[10446.056445]  0000000000015780 0000000000015780 ffff8808fb213170 ffff8808fb213468
[10446.064843] Call Trace:
[10446.067622]  [<ffffffff812fb320>] ? thread_return+0x79/0xe0
[10446.073896]  [<ffffffff8117f3bd>] ? get_request+0x7e/0x2ba
[10446.080077]  [<ffffffff812fb3fa>] ? io_schedule+0x73/0xb7
[10446.086166]  [<ffffffff8117f6e9>] ? get_request_wait+0xf0/0x188
[10446.092834]  [<ffffffff81064f92>] ? autoremove_wake_function+0x0/0x2e
[10446.100085]  [<ffffffff8117fa78>] ? __make_request+0x2f7/0x428
[10446.106661]  [<ffffffff8117e247>] ? generic_make_request+0x299/0x2f9
[10446.113820]  [<ffffffff8117e37d>] ? submit_bio+0xd6/0xf2
[10446.119810]  [<ffffffff810d8c58>] ? end_swap_bio_read+0x0/0x60
[10446.126382]  [<ffffffff81111741>] ? bio_alloc+0x10/0x1f
[10446.132270]  [<ffffffff810d8aaa>] ? get_swap_bio+0x4a/0x9a
[10446.138452]  [<ffffffff810d8b49>] ? swap_readpage+0x4f/0x53
[10446.144728]  [<ffffffff810d8e56>] ? read_swap_cache_async+0xb3/0xf3
[10446.151790]  [<ffffffff810d8eed>] ? swapin_readahead+0x57/0x98
[10446.158365]  [<ffffffff810ccdfd>] ? handle_mm_fault+0x47f/0x80f
[10446.165038]  [<ffffffff812feb96>] ? do_page_fault+0x2e0/0x2fc
[10446.171502]  [<ffffffff812fca35>] ? page_fault+0x25/0x30
[10446.177486] INFO: task gcc:12660 blocked for more than 120 seconds.
[10446.184546] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
[10446.193380] gcc           D 0000000000000000     0 12660  12646 0x00000000
[10446.201140]  ffff88063e45f100 0000000000000082 0000000000000000 ffff880c35deca80
[10446.209549]  ffff88063d42b400 ffffffff8118b96e 000000000000f9e0 ffff880b75f2ffd8
[10446.217977]  0000000000015780 0000000000015780 ffff880be1c88000 ffff880be1c882f8
[10446.226387] Call Trace:
[10446.229152]  [<ffffffff8118b96e>] ? cfq_dispatch_requests+0x106/0x420
[10446.236411]  [<ffffffff8117f3bd>] ? get_request+0x7e/0x2ba
[10446.242598]  [<ffffffff812fb3fa>] ? io_schedule+0x73/0xb7
[10446.248685]  [<ffffffff8117f6e9>] ? get_request_wait+0xf0/0x188
[10446.255348]  [<ffffffff81064f92>] ? autoremove_wake_function+0x0/0x2e
[10446.262601]  [<ffffffff8117fa78>] ? __make_request+0x2f7/0x428
[10446.269176]  [<ffffffff8117e247>] ? generic_make_request+0x299/0x2f9
[10446.276331]  [<ffffffff8117e37d>] ? submit_bio+0xd6/0xf2
[10446.282314]  [<ffffffff810d8c58>] ? end_swap_bio_read+0x0/0x60
[10446.288885]  [<ffffffff81111741>] ? bio_alloc+0x10/0x1f
[10446.294778]  [<ffffffff810d8aaa>] ? get_swap_bio+0x4a/0x9a
[10446.300962]  [<ffffffff810d8b49>] ? swap_readpage+0x4f/0x53
[10446.307236]  [<ffffffff810d8e56>] ? read_swap_cache_async+0xb3/0xf3
[10446.314298]  [<ffffffff810d8eed>] ? swapin_readahead+0x57/0x98
[10446.320874]  [<ffffffff810ccdfd>] ? handle_mm_fault+0x47f/0x80f
[10446.327547]  [<ffffffff812feb96>] ? do_page_fault+0x2e0/0x2fc
[10446.334025]  [<ffffffff812fca35>] ? page_fault+0x25/0x30
************************************************************
